/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sequelize";
exports.ids = ["vendor-chunks/sequelize"];
exports.modules = {

/***/ "(action-browser)/../node_modules/sequelize/lib/associations/base.js":
/*!**********************************************************!*\
  !*** ../node_modules/sequelize/lib/associations/base.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { AssociationError } = __webpack_require__(/*! ./../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nclass Association {\n  constructor(source, target, options = {}) {\n    this.source = source;\n    this.target = target;\n    this.options = options;\n    this.scope = options.scope;\n    this.isSelfAssociation = this.source === this.target;\n    this.as = options.as;\n    this.associationType = \"\";\n    if (source.hasAlias(options.as)) {\n      throw new AssociationError(`You have used the alias ${options.as} in two separate associations. Aliased associations must have unique aliases.`);\n    }\n  }\n  toInstanceArray(input) {\n    if (!Array.isArray(input)) {\n      input = [input];\n    }\n    return input.map((element) => {\n      if (element instanceof this.target)\n        return element;\n      const tmpInstance = {};\n      tmpInstance[this.target.primaryKeyAttribute] = element;\n      return this.target.build(tmpInstance, { isNewRecord: false });\n    });\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.as;\n  }\n}\nmodule.exports = Association;\n//# sourceMappingURL=base.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyxtRkFBYTtBQUNsRDtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxvQkFBb0I7QUFDbEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Fzc29jaWF0aW9ucy9iYXNlLmpzP2YwNDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB7IEFzc29jaWF0aW9uRXJyb3IgfSA9IHJlcXVpcmUoXCIuLy4uL2Vycm9yc1wiKTtcbmNsYXNzIEFzc29jaWF0aW9uIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCB0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zY29wZSA9IG9wdGlvbnMuc2NvcGU7XG4gICAgdGhpcy5pc1NlbGZBc3NvY2lhdGlvbiA9IHRoaXMuc291cmNlID09PSB0aGlzLnRhcmdldDtcbiAgICB0aGlzLmFzID0gb3B0aW9ucy5hcztcbiAgICB0aGlzLmFzc29jaWF0aW9uVHlwZSA9IFwiXCI7XG4gICAgaWYgKHNvdXJjZS5oYXNBbGlhcyhvcHRpb25zLmFzKSkge1xuICAgICAgdGhyb3cgbmV3IEFzc29jaWF0aW9uRXJyb3IoYFlvdSBoYXZlIHVzZWQgdGhlIGFsaWFzICR7b3B0aW9ucy5hc30gaW4gdHdvIHNlcGFyYXRlIGFzc29jaWF0aW9ucy4gQWxpYXNlZCBhc3NvY2lhdGlvbnMgbXVzdCBoYXZlIHVuaXF1ZSBhbGlhc2VzLmApO1xuICAgIH1cbiAgfVxuICB0b0luc3RhbmNlQXJyYXkoaW5wdXQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICBpbnB1dCA9IFtpbnB1dF07XG4gICAgfVxuICAgIHJldHVybiBpbnB1dC5tYXAoKGVsZW1lbnQpID0+IHtcbiAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgdGhpcy50YXJnZXQpXG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgY29uc3QgdG1wSW5zdGFuY2UgPSB7fTtcbiAgICAgIHRtcEluc3RhbmNlW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdID0gZWxlbWVudDtcbiAgICAgIHJldHVybiB0aGlzLnRhcmdldC5idWlsZCh0bXBJbnN0YW5jZSwgeyBpc05ld1JlY29yZDogZmFsc2UgfSk7XG4gICAgfSk7XG4gIH1cbiAgW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV0oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXM7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gQXNzb2NpYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/associations/base.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/associations/belongs-to-many.js":
/*!*********************************************************************!*\
  !*** ../node_modules/sequelize/lib/associations/belongs-to-many.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst Utils = __webpack_require__(/*! ./../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst Helpers = __webpack_require__(/*! ./helpers */ \"(action-browser)/../node_modules/sequelize/lib/associations/helpers.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst Association = __webpack_require__(/*! ./base */ \"(action-browser)/../node_modules/sequelize/lib/associations/base.js\");\nconst BelongsTo = __webpack_require__(/*! ./belongs-to */ \"(action-browser)/../node_modules/sequelize/lib/associations/belongs-to.js\");\nconst HasMany = __webpack_require__(/*! ./has-many */ \"(action-browser)/../node_modules/sequelize/lib/associations/has-many.js\");\nconst HasOne = __webpack_require__(/*! ./has-one */ \"(action-browser)/../node_modules/sequelize/lib/associations/has-one.js\");\nconst AssociationError = (__webpack_require__(/*! ../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\").AssociationError);\nconst EmptyResultError = (__webpack_require__(/*! ../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\").EmptyResultError);\nconst Op = __webpack_require__(/*! ../operators */ \"(action-browser)/../node_modules/sequelize/lib/operators.js\");\nclass BelongsToMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    if (this.options.through === void 0 || this.options.through === true || this.options.through === null) {\n      throw new AssociationError(`${source.name}.belongsToMany(${target.name}) requires through option, pass either a string or a model`);\n    }\n    if (!this.options.through.model) {\n      this.options.through = {\n        model: options.through\n      };\n    }\n    this.associationType = \"BelongsToMany\";\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.through = __spreadValues({}, this.options.through);\n    this.isMultiAssociation = true;\n    this.doubleLinked = false;\n    if (!this.as && this.isSelfAssociation) {\n      throw new AssociationError(\"'as' must be defined for many-to-many self-associations\");\n    }\n    if (this.as) {\n      this.isAliased = true;\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n    this.combinedTableName = Utils.combineTableNames(this.source.tableName, this.isSelfAssociation ? this.as || this.target.tableName : this.target.tableName);\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n    _.each(this.target.associations, (association) => {\n      if (association.associationType !== \"BelongsToMany\")\n        return;\n      if (association.target !== this.source)\n        return;\n      if (this.options.through.model === association.options.through.model) {\n        this.paired = association;\n        association.paired = this;\n      }\n    });\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    if (this.options.targetKey) {\n      this.targetKey = this.options.targetKey;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    } else {\n      this.targetKeyDefault = true;\n      this.targetKey = this.target.primaryKeyAttribute;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    }\n    this._createForeignAndOtherKeys();\n    if (typeof this.through.model === \"string\") {\n      if (!this.sequelize.isDefined(this.through.model)) {\n        this.through.model = this.sequelize.define(this.through.model, {}, Object.assign(this.options, {\n          tableName: this.through.model,\n          indexes: [],\n          paranoid: this.through.paranoid ? this.through.paranoid : false,\n          validate: {}\n        }));\n      } else {\n        this.through.model = this.sequelize.model(this.through.model);\n      }\n    }\n    Object.assign(this.options, _.pick(this.through.model.options, [\n      \"timestamps\",\n      \"createdAt\",\n      \"updatedAt\",\n      \"deletedAt\",\n      \"paranoid\"\n    ]));\n    if (this.paired) {\n      let needInjectPaired = false;\n      if (this.targetKeyDefault) {\n        this.targetKey = this.paired.sourceKey;\n        this.targetKeyField = this.paired.sourceKeyField;\n        this._createForeignAndOtherKeys();\n      }\n      if (this.paired.targetKeyDefault) {\n        if (this.paired.targetKey !== this.sourceKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.targetKey = this.sourceKey;\n          this.paired.targetKeyField = this.sourceKeyField;\n          this.paired._createForeignAndOtherKeys();\n          needInjectPaired = true;\n        }\n      }\n      if (this.otherKeyDefault) {\n        this.otherKey = this.paired.foreignKey;\n      }\n      if (this.paired.otherKeyDefault) {\n        if (this.paired.otherKey !== this.foreignKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.otherKey = this.foreignKey;\n          needInjectPaired = true;\n        }\n      }\n      if (needInjectPaired) {\n        this.paired._injectAttributes();\n      }\n    }\n    if (this.through) {\n      this.throughModel = this.through.model;\n    }\n    this.options.tableName = this.combinedName = this.through.model === Object(this.through.model) ? this.through.model.tableName : this.through.model;\n    this.associationAccessor = this.as;\n    const plural = _.upperFirst(this.options.name.plural);\n    const singular = _.upperFirst(this.options.name.singular);\n    this.accessors = {\n      get: `get${plural}`,\n      set: `set${plural}`,\n      addMultiple: `add${plural}`,\n      add: `add${singular}`,\n      create: `create${singular}`,\n      remove: `remove${singular}`,\n      removeMultiple: `remove${plural}`,\n      hasSingle: `has${singular}`,\n      hasAll: `has${plural}`,\n      count: `count${plural}`\n    };\n  }\n  _createForeignAndOtherKeys() {\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else {\n      this.foreignKeyAttribute = {};\n      this.foreignKey = this.options.foreignKey || Utils.camelize([\n        this.source.options.name.singular,\n        this.sourceKey\n      ].join(\"_\"));\n    }\n    if (_.isObject(this.options.otherKey)) {\n      this.otherKeyAttribute = this.options.otherKey;\n      this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;\n    } else {\n      if (!this.options.otherKey) {\n        this.otherKeyDefault = true;\n      }\n      this.otherKeyAttribute = {};\n      this.otherKey = this.options.otherKey || Utils.camelize([\n        this.isSelfAssociation ? Utils.singularize(this.as) : this.target.options.name.singular,\n        this.targetKey\n      ].join(\"_\"));\n    }\n  }\n  _injectAttributes() {\n    this.identifier = this.foreignKey;\n    this.foreignIdentifier = this.otherKey;\n    _.each(this.through.model.rawAttributes, (attribute, attributeName) => {\n      if (attribute.primaryKey === true && attribute._autoGenerated === true) {\n        if ([this.foreignKey, this.otherKey].includes(attributeName)) {\n          attribute.primaryKey = false;\n        } else {\n          delete this.through.model.rawAttributes[attributeName];\n        }\n        this.primaryKeyDeleted = true;\n      }\n    });\n    const sourceKey = this.source.rawAttributes[this.sourceKey];\n    const sourceKeyType = sourceKey.type;\n    const sourceKeyField = this.sourceKeyField;\n    const targetKey = this.target.rawAttributes[this.targetKey];\n    const targetKeyType = targetKey.type;\n    const targetKeyField = this.targetKeyField;\n    const sourceAttribute = __spreadValues({ type: sourceKeyType }, this.foreignKeyAttribute);\n    const targetAttribute = __spreadValues({ type: targetKeyType }, this.otherKeyAttribute);\n    if (this.primaryKeyDeleted === true) {\n      targetAttribute.primaryKey = sourceAttribute.primaryKey = true;\n    } else if (this.through.unique !== false) {\n      let uniqueKey;\n      if (typeof this.options.uniqueKey === \"string\" && this.options.uniqueKey !== \"\") {\n        uniqueKey = this.options.uniqueKey;\n      } else {\n        uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, \"unique\"].join(\"_\");\n      }\n      targetAttribute.unique = sourceAttribute.unique = uniqueKey;\n    }\n    if (!this.through.model.rawAttributes[this.foreignKey]) {\n      this.through.model.rawAttributes[this.foreignKey] = {\n        _autoGenerated: true\n      };\n    }\n    if (!this.through.model.rawAttributes[this.otherKey]) {\n      this.through.model.rawAttributes[this.otherKey] = {\n        _autoGenerated: true\n      };\n    }\n    if (this.options.constraints !== false) {\n      sourceAttribute.references = {\n        model: this.source.getTableName(),\n        key: sourceKeyField\n      };\n      sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;\n      sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;\n      if (!sourceAttribute.onDelete)\n        sourceAttribute.onDelete = \"CASCADE\";\n      if (!sourceAttribute.onUpdate)\n        sourceAttribute.onUpdate = \"CASCADE\";\n      targetAttribute.references = {\n        model: this.target.getTableName(),\n        key: targetKeyField\n      };\n      targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;\n      targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;\n      if (!targetAttribute.onDelete)\n        targetAttribute.onDelete = \"CASCADE\";\n      if (!targetAttribute.onUpdate)\n        targetAttribute.onUpdate = \"CASCADE\";\n    }\n    Object.assign(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);\n    Object.assign(this.through.model.rawAttributes[this.otherKey], targetAttribute);\n    this.through.model.refreshAttributes();\n    this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;\n    if (this.options.sequelize.options.dialect === \"db2\" && this.source.rawAttributes[this.sourceKey].primaryKey !== true) {\n      this.source.rawAttributes[this.sourceKey].unique = true;\n    }\n    if (this.paired && !this.paired.foreignIdentifierField) {\n      this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;\n    }\n    this.toSource = new BelongsTo(this.through.model, this.source, {\n      foreignKey: this.foreignKey\n    });\n    this.manyFromSource = new HasMany(this.source, this.through.model, {\n      foreignKey: this.foreignKey\n    });\n    this.oneFromSource = new HasOne(this.source, this.through.model, {\n      foreignKey: this.foreignKey,\n      sourceKey: this.sourceKey,\n      as: this.through.model.name\n    });\n    this.toTarget = new BelongsTo(this.through.model, this.target, {\n      foreignKey: this.otherKey\n    });\n    this.manyFromTarget = new HasMany(this.target, this.through.model, {\n      foreignKey: this.otherKey\n    });\n    this.oneFromTarget = new HasOne(this.target, this.through.model, {\n      foreignKey: this.otherKey,\n      sourceKey: this.targetKey,\n      as: this.through.model.name\n    });\n    if (this.paired && this.paired.otherKeyDefault) {\n      this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {\n        foreignKey: this.paired.otherKey\n      });\n      this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {\n        foreignKey: this.paired.otherKey,\n        sourceKey: this.paired.targetKey,\n        as: this.paired.through.model.name\n      });\n    }\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n  mixin(obj) {\n    const methods = [\"get\", \"count\", \"hasSingle\", \"hasAll\", \"set\", \"add\", \"addMultiple\", \"remove\", \"removeMultiple\", \"create\"];\n    const aliases = {\n      hasSingle: \"has\",\n      hasAll: \"has\",\n      addMultiple: \"add\",\n      removeMultiple: \"remove\"\n    };\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n  async get(instance, options) {\n    options = Utils.cloneDeep(options) || {};\n    const through = this.through;\n    let scopeWhere;\n    let throughWhere;\n    if (this.scope) {\n      scopeWhere = __spreadValues({}, this.scope);\n    }\n    options.where = {\n      [Op.and]: [\n        scopeWhere,\n        options.where\n      ]\n    };\n    if (Object(through.model) === through.model) {\n      throughWhere = {};\n      throughWhere[this.foreignKey] = instance.get(this.sourceKey);\n      if (through.scope) {\n        Object.assign(throughWhere, through.scope);\n      }\n      if (options.through && options.through.where) {\n        throughWhere = {\n          [Op.and]: [throughWhere, options.through.where]\n        };\n      }\n      options.include = options.include || [];\n      options.include.push({\n        association: this.oneFromTarget,\n        attributes: options.joinTableAttributes,\n        required: true,\n        paranoid: _.get(options.through, \"paranoid\", true),\n        where: throughWhere\n      });\n    }\n    let model = this.target;\n    if (Object.prototype.hasOwnProperty.call(options, \"scope\")) {\n      if (!options.scope) {\n        model = model.unscoped();\n      } else {\n        model = model.scope(options.scope);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"schema\")) {\n      model = model.schema(options.schema, options.schemaDelimiter);\n    }\n    return model.findAll(options);\n  }\n  async count(instance, options) {\n    const sequelize = this.target.sequelize;\n    options = Utils.cloneDeep(options);\n    options.attributes = [\n      [sequelize.fn(\"COUNT\", sequelize.col([this.target.name, this.targetKeyField].join(\".\"))), \"count\"]\n    ];\n    options.joinTableAttributes = [];\n    options.raw = true;\n    options.plain = true;\n    const result = await this.get(instance, options);\n    return parseInt(result.count, 10);\n  }\n  async has(sourceInstance, instances, options) {\n    if (!Array.isArray(instances)) {\n      instances = [instances];\n    }\n    options = __spreadProps(__spreadValues({\n      raw: true\n    }, options), {\n      scope: false,\n      attributes: [this.targetKey],\n      joinTableAttributes: []\n    });\n    const instancePrimaryKeys = instances.map((instance) => {\n      if (instance instanceof this.target) {\n        return instance.where();\n      }\n      return {\n        [this.targetKey]: instance\n      };\n    });\n    options.where = {\n      [Op.and]: [\n        { [Op.or]: instancePrimaryKeys },\n        options.where\n      ]\n    };\n    const associatedObjects = await this.get(sourceInstance, options);\n    return _.differenceWith(instancePrimaryKeys, associatedObjects, (a, b) => _.isEqual(a[this.targetKey], b[this.targetKey])).length === 0;\n  }\n  async set(sourceInstance, newAssociatedObjects, options) {\n    options = options || {};\n    const sourceKey = this.sourceKey;\n    const targetKey = this.targetKey;\n    const identifier = this.identifier;\n    const foreignIdentifier = this.foreignIdentifier;\n    if (newAssociatedObjects === null) {\n      newAssociatedObjects = [];\n    } else {\n      newAssociatedObjects = this.toInstanceArray(newAssociatedObjects);\n    }\n    const where = __spreadValues({\n      [identifier]: sourceInstance.get(sourceKey)\n    }, this.through.scope);\n    const updateAssociations = (currentRows) => {\n      const obsoleteAssociations = [];\n      const promises = [];\n      const defaultAttributes = options.through || {};\n      const unassociatedObjects = newAssociatedObjects.filter((obj) => !currentRows.some((currentRow) => currentRow[foreignIdentifier] === obj.get(targetKey)));\n      for (const currentRow of currentRows) {\n        const newObj = newAssociatedObjects.find((obj) => currentRow[foreignIdentifier] === obj.get(targetKey));\n        if (!newObj) {\n          obsoleteAssociations.push(currentRow);\n        } else {\n          let throughAttributes = newObj[this.through.model.name];\n          if (throughAttributes instanceof this.through.model) {\n            throughAttributes = {};\n          }\n          const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);\n          if (Object.keys(attributes).length) {\n            promises.push(this.through.model.update(attributes, Object.assign(options, {\n              where: {\n                [identifier]: sourceInstance.get(sourceKey),\n                [foreignIdentifier]: newObj.get(targetKey)\n              }\n            })));\n          }\n        }\n      }\n      if (obsoleteAssociations.length > 0) {\n        promises.push(this.through.model.destroy(__spreadProps(__spreadValues({}, options), {\n          where: __spreadValues({\n            [identifier]: sourceInstance.get(sourceKey),\n            [foreignIdentifier]: obsoleteAssociations.map((obsoleteAssociation) => obsoleteAssociation[foreignIdentifier])\n          }, this.through.scope)\n        })));\n      }\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map((unassociatedObject) => {\n          return __spreadValues(__spreadProps(__spreadValues(__spreadValues({}, defaultAttributes), unassociatedObject[this.through.model.name]), {\n            [identifier]: sourceInstance.get(sourceKey),\n            [foreignIdentifier]: unassociatedObject.get(targetKey)\n          }), this.through.scope);\n        });\n        promises.push(this.through.model.bulkCreate(bulk, __spreadValues({ validate: true }, options)));\n      }\n      return Promise.all(promises);\n    };\n    try {\n      const currentRows = await this.through.model.findAll(__spreadProps(__spreadValues({}, options), { where, raw: true }));\n      return await updateAssociations(currentRows);\n    } catch (error) {\n      if (error instanceof EmptyResultError)\n        return updateAssociations([]);\n      throw error;\n    }\n  }\n  async add(sourceInstance, newInstances, options) {\n    if (!newInstances)\n      return Promise.resolve();\n    options = __spreadValues({}, options);\n    const association = this;\n    const sourceKey = association.sourceKey;\n    const targetKey = association.targetKey;\n    const identifier = association.identifier;\n    const foreignIdentifier = association.foreignIdentifier;\n    const defaultAttributes = options.through || {};\n    newInstances = association.toInstanceArray(newInstances);\n    const where = __spreadValues({\n      [identifier]: sourceInstance.get(sourceKey),\n      [foreignIdentifier]: newInstances.map((newInstance) => newInstance.get(targetKey))\n    }, association.through.scope);\n    const updateAssociations = (currentRows) => {\n      const promises = [];\n      const unassociatedObjects = [];\n      const changedAssociations = [];\n      for (const obj of newInstances) {\n        const existingAssociation = currentRows && currentRows.find((current) => current[foreignIdentifier] === obj.get(targetKey));\n        if (!existingAssociation) {\n          unassociatedObjects.push(obj);\n        } else {\n          const throughAttributes = obj[association.through.model.name];\n          const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);\n          if (Object.keys(attributes).some((attribute) => attributes[attribute] !== existingAssociation[attribute])) {\n            changedAssociations.push(obj);\n          }\n        }\n      }\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map((unassociatedObject) => {\n          const throughAttributes = unassociatedObject[association.through.model.name];\n          const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);\n          attributes[identifier] = sourceInstance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n          Object.assign(attributes, association.through.scope);\n          return attributes;\n        });\n        promises.push(association.through.model.bulkCreate(bulk, __spreadValues({ validate: true }, options)));\n      }\n      for (const assoc of changedAssociations) {\n        let throughAttributes = assoc[association.through.model.name];\n        const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);\n        if (throughAttributes instanceof association.through.model) {\n          throughAttributes = {};\n        }\n        promises.push(association.through.model.update(attributes, Object.assign(options, { where: {\n          [identifier]: sourceInstance.get(sourceKey),\n          [foreignIdentifier]: assoc.get(targetKey)\n        } })));\n      }\n      return Promise.all(promises);\n    };\n    try {\n      const currentRows = await association.through.model.findAll(__spreadProps(__spreadValues({}, options), { where, raw: true }));\n      const [associations] = await updateAssociations(currentRows);\n      return associations;\n    } catch (error) {\n      if (error instanceof EmptyResultError)\n        return updateAssociations();\n      throw error;\n    }\n  }\n  remove(sourceInstance, oldAssociatedObjects, options) {\n    const association = this;\n    options = options || {};\n    oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);\n    const where = {\n      [association.identifier]: sourceInstance.get(association.sourceKey),\n      [association.foreignIdentifier]: oldAssociatedObjects.map((newInstance) => newInstance.get(association.targetKey))\n    };\n    return association.through.model.destroy(__spreadProps(__spreadValues({}, options), { where }));\n  }\n  async create(sourceInstance, values, options) {\n    const association = this;\n    options = options || {};\n    values = values || {};\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n    if (association.scope) {\n      Object.assign(values, association.scope);\n      if (options.fields) {\n        options.fields = options.fields.concat(Object.keys(association.scope));\n      }\n    }\n    const newAssociatedObject = await association.target.create(values, options);\n    await sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, [\"fields\"]));\n    return newAssociatedObject;\n  }\n  verifyAssociationAlias(alias) {\n    if (typeof alias === \"string\") {\n      return this.as === alias;\n    }\n    if (alias && alias.plural) {\n      return this.as === alias.plural;\n    }\n    return !this.isAliased;\n  }\n}\nmodule.exports = BelongsToMany;\nmodule.exports.BelongsToMany = BelongsToMany;\nmodule.exports[\"default\"] = BelongsToMany;\n//# sourceMappingURL=belongs-to-many.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvYmVsb25ncy10by1tYW55LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQywyRUFBWTtBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyx5RkFBVztBQUNuQyxVQUFVLG1CQUFPLENBQUMsaUVBQVE7QUFDMUIsb0JBQW9CLG1CQUFPLENBQUMsbUZBQVE7QUFDcEMsa0JBQWtCLG1CQUFPLENBQUMsK0ZBQWM7QUFDeEMsZ0JBQWdCLG1CQUFPLENBQUMsMkZBQVk7QUFDcEMsZUFBZSxtQkFBTyxDQUFDLHlGQUFXO0FBQ2xDLHlCQUF5Qix5SEFBcUM7QUFDOUQseUJBQXlCLHlIQUFxQztBQUM5RCxXQUFXLG1CQUFPLENBQUMsaUZBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWSxpQkFBaUIsWUFBWTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4Qix5QkFBeUIsT0FBTztBQUNoQyxpQkFBaUIsU0FBUztBQUMxQix1QkFBdUIsU0FBUztBQUNoQyx1QkFBdUIsU0FBUztBQUNoQywrQkFBK0IsT0FBTztBQUN0Qyx1QkFBdUIsU0FBUztBQUNoQyxvQkFBb0IsT0FBTztBQUMzQixxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHFCQUFxQjtBQUNsRSw2Q0FBNkMscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFVBQVUsOEJBQThCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCwyRUFBMkUsZ0JBQWdCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLGNBQWMsa0JBQWtCO0FBQzFIO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGtGQUFrRixnQkFBZ0I7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGNBQWMsa0JBQWtCO0FBQ2pJO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsY0FBYyxPQUFPO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvYmVsb25ncy10by1tYW55LmpzPzUxZWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4vLi4vdXRpbHNcIik7XG5jb25zdCBIZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgQXNzb2NpYXRpb24gPSByZXF1aXJlKFwiLi9iYXNlXCIpO1xuY29uc3QgQmVsb25nc1RvID0gcmVxdWlyZShcIi4vYmVsb25ncy10b1wiKTtcbmNvbnN0IEhhc01hbnkgPSByZXF1aXJlKFwiLi9oYXMtbWFueVwiKTtcbmNvbnN0IEhhc09uZSA9IHJlcXVpcmUoXCIuL2hhcy1vbmVcIik7XG5jb25zdCBBc3NvY2lhdGlvbkVycm9yID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKS5Bc3NvY2lhdGlvbkVycm9yO1xuY29uc3QgRW1wdHlSZXN1bHRFcnJvciA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIikuRW1wdHlSZXN1bHRFcnJvcjtcbmNvbnN0IE9wID0gcmVxdWlyZShcIi4uL29wZXJhdG9yc1wiKTtcbmNsYXNzIEJlbG9uZ3NUb01hbnkgZXh0ZW5kcyBBc3NvY2lhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgc3VwZXIoc291cmNlLCB0YXJnZXQsIG9wdGlvbnMpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGhyb3VnaCA9PT0gdm9pZCAwIHx8IHRoaXMub3B0aW9ucy50aHJvdWdoID09PSB0cnVlIHx8IHRoaXMub3B0aW9ucy50aHJvdWdoID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgQXNzb2NpYXRpb25FcnJvcihgJHtzb3VyY2UubmFtZX0uYmVsb25nc1RvTWFueSgke3RhcmdldC5uYW1lfSkgcmVxdWlyZXMgdGhyb3VnaCBvcHRpb24sIHBhc3MgZWl0aGVyIGEgc3RyaW5nIG9yIGEgbW9kZWxgKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMudGhyb3VnaC5tb2RlbCkge1xuICAgICAgdGhpcy5vcHRpb25zLnRocm91Z2ggPSB7XG4gICAgICAgIG1vZGVsOiBvcHRpb25zLnRocm91Z2hcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuYXNzb2NpYXRpb25UeXBlID0gXCJCZWxvbmdzVG9NYW55XCI7XG4gICAgdGhpcy50YXJnZXRBc3NvY2lhdGlvbiA9IG51bGw7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzb3VyY2Uuc2VxdWVsaXplO1xuICAgIHRoaXMudGhyb3VnaCA9IF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLm9wdGlvbnMudGhyb3VnaCk7XG4gICAgdGhpcy5pc011bHRpQXNzb2NpYXRpb24gPSB0cnVlO1xuICAgIHRoaXMuZG91YmxlTGlua2VkID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLmFzICYmIHRoaXMuaXNTZWxmQXNzb2NpYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBBc3NvY2lhdGlvbkVycm9yKFwiJ2FzJyBtdXN0IGJlIGRlZmluZWQgZm9yIG1hbnktdG8tbWFueSBzZWxmLWFzc29jaWF0aW9uc1wiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXMpIHtcbiAgICAgIHRoaXMuaXNBbGlhc2VkID0gdHJ1ZTtcbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3QodGhpcy5hcykpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm5hbWUgPSB0aGlzLmFzO1xuICAgICAgICB0aGlzLmFzID0gdGhpcy5hcy5wbHVyYWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHtcbiAgICAgICAgICBwbHVyYWw6IHRoaXMuYXMsXG4gICAgICAgICAgc2luZ3VsYXI6IFV0aWxzLnNpbmd1bGFyaXplKHRoaXMuYXMpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXMgPSB0aGlzLnRhcmdldC5vcHRpb25zLm5hbWUucGx1cmFsO1xuICAgICAgdGhpcy5vcHRpb25zLm5hbWUgPSB0aGlzLnRhcmdldC5vcHRpb25zLm5hbWU7XG4gICAgfVxuICAgIHRoaXMuY29tYmluZWRUYWJsZU5hbWUgPSBVdGlscy5jb21iaW5lVGFibGVOYW1lcyh0aGlzLnNvdXJjZS50YWJsZU5hbWUsIHRoaXMuaXNTZWxmQXNzb2NpYXRpb24gPyB0aGlzLmFzIHx8IHRoaXMudGFyZ2V0LnRhYmxlTmFtZSA6IHRoaXMudGFyZ2V0LnRhYmxlTmFtZSk7XG4gICAgaWYgKHRoaXMuaXNTZWxmQXNzb2NpYXRpb24pIHtcbiAgICAgIHRoaXMudGFyZ2V0QXNzb2NpYXRpb24gPSB0aGlzO1xuICAgIH1cbiAgICBfLmVhY2godGhpcy50YXJnZXQuYXNzb2NpYXRpb25zLCAoYXNzb2NpYXRpb24pID0+IHtcbiAgICAgIGlmIChhc3NvY2lhdGlvbi5hc3NvY2lhdGlvblR5cGUgIT09IFwiQmVsb25nc1RvTWFueVwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoYXNzb2NpYXRpb24udGFyZ2V0ICE9PSB0aGlzLnNvdXJjZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy50aHJvdWdoLm1vZGVsID09PSBhc3NvY2lhdGlvbi5vcHRpb25zLnRocm91Z2gubW9kZWwpIHtcbiAgICAgICAgdGhpcy5wYWlyZWQgPSBhc3NvY2lhdGlvbjtcbiAgICAgICAgYXNzb2NpYXRpb24ucGFpcmVkID0gdGhpcztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNvdXJjZUtleSA9IHRoaXMub3B0aW9ucy5zb3VyY2VLZXkgfHwgdGhpcy5zb3VyY2UucHJpbWFyeUtleUF0dHJpYnV0ZTtcbiAgICB0aGlzLnNvdXJjZUtleUZpZWxkID0gdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLnNvdXJjZUtleV0uZmllbGQgfHwgdGhpcy5zb3VyY2VLZXk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50YXJnZXRLZXkpIHtcbiAgICAgIHRoaXMudGFyZ2V0S2V5ID0gdGhpcy5vcHRpb25zLnRhcmdldEtleTtcbiAgICAgIHRoaXMudGFyZ2V0S2V5RmllbGQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMudGFyZ2V0S2V5XS5maWVsZCB8fCB0aGlzLnRhcmdldEtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YXJnZXRLZXlEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIHRoaXMudGFyZ2V0S2V5ID0gdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZTtcbiAgICAgIHRoaXMudGFyZ2V0S2V5RmllbGQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMudGFyZ2V0S2V5XS5maWVsZCB8fCB0aGlzLnRhcmdldEtleTtcbiAgICB9XG4gICAgdGhpcy5fY3JlYXRlRm9yZWlnbkFuZE90aGVyS2V5cygpO1xuICAgIGlmICh0eXBlb2YgdGhpcy50aHJvdWdoLm1vZGVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoIXRoaXMuc2VxdWVsaXplLmlzRGVmaW5lZCh0aGlzLnRocm91Z2gubW9kZWwpKSB7XG4gICAgICAgIHRoaXMudGhyb3VnaC5tb2RlbCA9IHRoaXMuc2VxdWVsaXplLmRlZmluZSh0aGlzLnRocm91Z2gubW9kZWwsIHt9LCBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucywge1xuICAgICAgICAgIHRhYmxlTmFtZTogdGhpcy50aHJvdWdoLm1vZGVsLFxuICAgICAgICAgIGluZGV4ZXM6IFtdLFxuICAgICAgICAgIHBhcmFub2lkOiB0aGlzLnRocm91Z2gucGFyYW5vaWQgPyB0aGlzLnRocm91Z2gucGFyYW5vaWQgOiBmYWxzZSxcbiAgICAgICAgICB2YWxpZGF0ZToge31cbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50aHJvdWdoLm1vZGVsID0gdGhpcy5zZXF1ZWxpemUubW9kZWwodGhpcy50aHJvdWdoLm1vZGVsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMsIF8ucGljayh0aGlzLnRocm91Z2gubW9kZWwub3B0aW9ucywgW1xuICAgICAgXCJ0aW1lc3RhbXBzXCIsXG4gICAgICBcImNyZWF0ZWRBdFwiLFxuICAgICAgXCJ1cGRhdGVkQXRcIixcbiAgICAgIFwiZGVsZXRlZEF0XCIsXG4gICAgICBcInBhcmFub2lkXCJcbiAgICBdKSk7XG4gICAgaWYgKHRoaXMucGFpcmVkKSB7XG4gICAgICBsZXQgbmVlZEluamVjdFBhaXJlZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMudGFyZ2V0S2V5RGVmYXVsdCkge1xuICAgICAgICB0aGlzLnRhcmdldEtleSA9IHRoaXMucGFpcmVkLnNvdXJjZUtleTtcbiAgICAgICAgdGhpcy50YXJnZXRLZXlGaWVsZCA9IHRoaXMucGFpcmVkLnNvdXJjZUtleUZpZWxkO1xuICAgICAgICB0aGlzLl9jcmVhdGVGb3JlaWduQW5kT3RoZXJLZXlzKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wYWlyZWQudGFyZ2V0S2V5RGVmYXVsdCkge1xuICAgICAgICBpZiAodGhpcy5wYWlyZWQudGFyZ2V0S2V5ICE9PSB0aGlzLnNvdXJjZUtleSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLnBhaXJlZC5vdGhlcktleV07XG4gICAgICAgICAgdGhpcy5wYWlyZWQudGFyZ2V0S2V5ID0gdGhpcy5zb3VyY2VLZXk7XG4gICAgICAgICAgdGhpcy5wYWlyZWQudGFyZ2V0S2V5RmllbGQgPSB0aGlzLnNvdXJjZUtleUZpZWxkO1xuICAgICAgICAgIHRoaXMucGFpcmVkLl9jcmVhdGVGb3JlaWduQW5kT3RoZXJLZXlzKCk7XG4gICAgICAgICAgbmVlZEluamVjdFBhaXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm90aGVyS2V5RGVmYXVsdCkge1xuICAgICAgICB0aGlzLm90aGVyS2V5ID0gdGhpcy5wYWlyZWQuZm9yZWlnbktleTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBhaXJlZC5vdGhlcktleURlZmF1bHQpIHtcbiAgICAgICAgaWYgKHRoaXMucGFpcmVkLm90aGVyS2V5ICE9PSB0aGlzLmZvcmVpZ25LZXkpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5wYWlyZWQub3RoZXJLZXldO1xuICAgICAgICAgIHRoaXMucGFpcmVkLm90aGVyS2V5ID0gdGhpcy5mb3JlaWduS2V5O1xuICAgICAgICAgIG5lZWRJbmplY3RQYWlyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobmVlZEluamVjdFBhaXJlZCkge1xuICAgICAgICB0aGlzLnBhaXJlZC5faW5qZWN0QXR0cmlidXRlcygpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy50aHJvdWdoKSB7XG4gICAgICB0aGlzLnRocm91Z2hNb2RlbCA9IHRoaXMudGhyb3VnaC5tb2RlbDtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zLnRhYmxlTmFtZSA9IHRoaXMuY29tYmluZWROYW1lID0gdGhpcy50aHJvdWdoLm1vZGVsID09PSBPYmplY3QodGhpcy50aHJvdWdoLm1vZGVsKSA/IHRoaXMudGhyb3VnaC5tb2RlbC50YWJsZU5hbWUgOiB0aGlzLnRocm91Z2gubW9kZWw7XG4gICAgdGhpcy5hc3NvY2lhdGlvbkFjY2Vzc29yID0gdGhpcy5hcztcbiAgICBjb25zdCBwbHVyYWwgPSBfLnVwcGVyRmlyc3QodGhpcy5vcHRpb25zLm5hbWUucGx1cmFsKTtcbiAgICBjb25zdCBzaW5ndWxhciA9IF8udXBwZXJGaXJzdCh0aGlzLm9wdGlvbnMubmFtZS5zaW5ndWxhcik7XG4gICAgdGhpcy5hY2Nlc3NvcnMgPSB7XG4gICAgICBnZXQ6IGBnZXQke3BsdXJhbH1gLFxuICAgICAgc2V0OiBgc2V0JHtwbHVyYWx9YCxcbiAgICAgIGFkZE11bHRpcGxlOiBgYWRkJHtwbHVyYWx9YCxcbiAgICAgIGFkZDogYGFkZCR7c2luZ3VsYXJ9YCxcbiAgICAgIGNyZWF0ZTogYGNyZWF0ZSR7c2luZ3VsYXJ9YCxcbiAgICAgIHJlbW92ZTogYHJlbW92ZSR7c2luZ3VsYXJ9YCxcbiAgICAgIHJlbW92ZU11bHRpcGxlOiBgcmVtb3ZlJHtwbHVyYWx9YCxcbiAgICAgIGhhc1NpbmdsZTogYGhhcyR7c2luZ3VsYXJ9YCxcbiAgICAgIGhhc0FsbDogYGhhcyR7cGx1cmFsfWAsXG4gICAgICBjb3VudDogYGNvdW50JHtwbHVyYWx9YFxuICAgIH07XG4gIH1cbiAgX2NyZWF0ZUZvcmVpZ25BbmRPdGhlcktleXMoKSB7XG4gICAgaWYgKF8uaXNPYmplY3QodGhpcy5vcHRpb25zLmZvcmVpZ25LZXkpKSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUgPSB0aGlzLm9wdGlvbnMuZm9yZWlnbktleTtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZS5uYW1lIHx8IHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZS5maWVsZE5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZSA9IHt9O1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gdGhpcy5vcHRpb25zLmZvcmVpZ25LZXkgfHwgVXRpbHMuY2FtZWxpemUoW1xuICAgICAgICB0aGlzLnNvdXJjZS5vcHRpb25zLm5hbWUuc2luZ3VsYXIsXG4gICAgICAgIHRoaXMuc291cmNlS2V5XG4gICAgICBdLmpvaW4oXCJfXCIpKTtcbiAgICB9XG4gICAgaWYgKF8uaXNPYmplY3QodGhpcy5vcHRpb25zLm90aGVyS2V5KSkge1xuICAgICAgdGhpcy5vdGhlcktleUF0dHJpYnV0ZSA9IHRoaXMub3B0aW9ucy5vdGhlcktleTtcbiAgICAgIHRoaXMub3RoZXJLZXkgPSB0aGlzLm90aGVyS2V5QXR0cmlidXRlLm5hbWUgfHwgdGhpcy5vdGhlcktleUF0dHJpYnV0ZS5maWVsZE5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLm90aGVyS2V5KSB7XG4gICAgICAgIHRoaXMub3RoZXJLZXlEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3RoZXJLZXlBdHRyaWJ1dGUgPSB7fTtcbiAgICAgIHRoaXMub3RoZXJLZXkgPSB0aGlzLm9wdGlvbnMub3RoZXJLZXkgfHwgVXRpbHMuY2FtZWxpemUoW1xuICAgICAgICB0aGlzLmlzU2VsZkFzc29jaWF0aW9uID8gVXRpbHMuc2luZ3VsYXJpemUodGhpcy5hcykgOiB0aGlzLnRhcmdldC5vcHRpb25zLm5hbWUuc2luZ3VsYXIsXG4gICAgICAgIHRoaXMudGFyZ2V0S2V5XG4gICAgICBdLmpvaW4oXCJfXCIpKTtcbiAgICB9XG4gIH1cbiAgX2luamVjdEF0dHJpYnV0ZXMoKSB7XG4gICAgdGhpcy5pZGVudGlmaWVyID0gdGhpcy5mb3JlaWduS2V5O1xuICAgIHRoaXMuZm9yZWlnbklkZW50aWZpZXIgPSB0aGlzLm90aGVyS2V5O1xuICAgIF8uZWFjaCh0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlcywgKGF0dHJpYnV0ZSwgYXR0cmlidXRlTmFtZSkgPT4ge1xuICAgICAgaWYgKGF0dHJpYnV0ZS5wcmltYXJ5S2V5ID09PSB0cnVlICYmIGF0dHJpYnV0ZS5fYXV0b0dlbmVyYXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoW3RoaXMuZm9yZWlnbktleSwgdGhpcy5vdGhlcktleV0uaW5jbHVkZXMoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgICBhdHRyaWJ1dGUucHJpbWFyeUtleSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByaW1hcnlLZXlEZWxldGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBzb3VyY2VLZXkgPSB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuc291cmNlS2V5XTtcbiAgICBjb25zdCBzb3VyY2VLZXlUeXBlID0gc291cmNlS2V5LnR5cGU7XG4gICAgY29uc3Qgc291cmNlS2V5RmllbGQgPSB0aGlzLnNvdXJjZUtleUZpZWxkO1xuICAgIGNvbnN0IHRhcmdldEtleSA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy50YXJnZXRLZXldO1xuICAgIGNvbnN0IHRhcmdldEtleVR5cGUgPSB0YXJnZXRLZXkudHlwZTtcbiAgICBjb25zdCB0YXJnZXRLZXlGaWVsZCA9IHRoaXMudGFyZ2V0S2V5RmllbGQ7XG4gICAgY29uc3Qgc291cmNlQXR0cmlidXRlID0gX19zcHJlYWRWYWx1ZXMoeyB0eXBlOiBzb3VyY2VLZXlUeXBlIH0sIHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZSk7XG4gICAgY29uc3QgdGFyZ2V0QXR0cmlidXRlID0gX19zcHJlYWRWYWx1ZXMoeyB0eXBlOiB0YXJnZXRLZXlUeXBlIH0sIHRoaXMub3RoZXJLZXlBdHRyaWJ1dGUpO1xuICAgIGlmICh0aGlzLnByaW1hcnlLZXlEZWxldGVkID09PSB0cnVlKSB7XG4gICAgICB0YXJnZXRBdHRyaWJ1dGUucHJpbWFyeUtleSA9IHNvdXJjZUF0dHJpYnV0ZS5wcmltYXJ5S2V5ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudGhyb3VnaC51bmlxdWUgIT09IGZhbHNlKSB7XG4gICAgICBsZXQgdW5pcXVlS2V5O1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMudW5pcXVlS2V5ID09PSBcInN0cmluZ1wiICYmIHRoaXMub3B0aW9ucy51bmlxdWVLZXkgIT09IFwiXCIpIHtcbiAgICAgICAgdW5pcXVlS2V5ID0gdGhpcy5vcHRpb25zLnVuaXF1ZUtleTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaXF1ZUtleSA9IFt0aGlzLnRocm91Z2gubW9kZWwudGFibGVOYW1lLCB0aGlzLmZvcmVpZ25LZXksIHRoaXMub3RoZXJLZXksIFwidW5pcXVlXCJdLmpvaW4oXCJfXCIpO1xuICAgICAgfVxuICAgICAgdGFyZ2V0QXR0cmlidXRlLnVuaXF1ZSA9IHNvdXJjZUF0dHJpYnV0ZS51bmlxdWUgPSB1bmlxdWVLZXk7XG4gICAgfVxuICAgIGlmICghdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSkge1xuICAgICAgdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSA9IHtcbiAgICAgICAgX2F1dG9HZW5lcmF0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5vdGhlcktleV0pIHtcbiAgICAgIHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMub3RoZXJLZXldID0ge1xuICAgICAgICBfYXV0b0dlbmVyYXRlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb25zdHJhaW50cyAhPT0gZmFsc2UpIHtcbiAgICAgIHNvdXJjZUF0dHJpYnV0ZS5yZWZlcmVuY2VzID0ge1xuICAgICAgICBtb2RlbDogdGhpcy5zb3VyY2UuZ2V0VGFibGVOYW1lKCksXG4gICAgICAgIGtleTogc291cmNlS2V5RmllbGRcbiAgICAgIH07XG4gICAgICBzb3VyY2VBdHRyaWJ1dGUub25EZWxldGUgPSB0aGlzLm9wdGlvbnMub25EZWxldGUgfHwgdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XS5vbkRlbGV0ZTtcbiAgICAgIHNvdXJjZUF0dHJpYnV0ZS5vblVwZGF0ZSA9IHRoaXMub3B0aW9ucy5vblVwZGF0ZSB8fCB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLm9uVXBkYXRlO1xuICAgICAgaWYgKCFzb3VyY2VBdHRyaWJ1dGUub25EZWxldGUpXG4gICAgICAgIHNvdXJjZUF0dHJpYnV0ZS5vbkRlbGV0ZSA9IFwiQ0FTQ0FERVwiO1xuICAgICAgaWYgKCFzb3VyY2VBdHRyaWJ1dGUub25VcGRhdGUpXG4gICAgICAgIHNvdXJjZUF0dHJpYnV0ZS5vblVwZGF0ZSA9IFwiQ0FTQ0FERVwiO1xuICAgICAgdGFyZ2V0QXR0cmlidXRlLnJlZmVyZW5jZXMgPSB7XG4gICAgICAgIG1vZGVsOiB0aGlzLnRhcmdldC5nZXRUYWJsZU5hbWUoKSxcbiAgICAgICAga2V5OiB0YXJnZXRLZXlGaWVsZFxuICAgICAgfTtcbiAgICAgIHRhcmdldEF0dHJpYnV0ZS5vbkRlbGV0ZSA9IHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMub3RoZXJLZXldLm9uRGVsZXRlIHx8IHRoaXMub3B0aW9ucy5vbkRlbGV0ZTtcbiAgICAgIHRhcmdldEF0dHJpYnV0ZS5vblVwZGF0ZSA9IHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMub3RoZXJLZXldLm9uVXBkYXRlIHx8IHRoaXMub3B0aW9ucy5vblVwZGF0ZTtcbiAgICAgIGlmICghdGFyZ2V0QXR0cmlidXRlLm9uRGVsZXRlKVxuICAgICAgICB0YXJnZXRBdHRyaWJ1dGUub25EZWxldGUgPSBcIkNBU0NBREVcIjtcbiAgICAgIGlmICghdGFyZ2V0QXR0cmlidXRlLm9uVXBkYXRlKVxuICAgICAgICB0YXJnZXRBdHRyaWJ1dGUub25VcGRhdGUgPSBcIkNBU0NBREVcIjtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLCBzb3VyY2VBdHRyaWJ1dGUpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5vdGhlcktleV0sIHRhcmdldEF0dHJpYnV0ZSk7XG4gICAgdGhpcy50aHJvdWdoLm1vZGVsLnJlZnJlc2hBdHRyaWJ1dGVzKCk7XG4gICAgdGhpcy5pZGVudGlmaWVyRmllbGQgPSB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLmZpZWxkIHx8IHRoaXMuZm9yZWlnbktleTtcbiAgICB0aGlzLmZvcmVpZ25JZGVudGlmaWVyRmllbGQgPSB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm90aGVyS2V5XS5maWVsZCB8fCB0aGlzLm90aGVyS2V5O1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCA9PT0gXCJkYjJcIiAmJiB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuc291cmNlS2V5XS5wcmltYXJ5S2V5ICE9PSB0cnVlKSB7XG4gICAgICB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuc291cmNlS2V5XS51bmlxdWUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYWlyZWQgJiYgIXRoaXMucGFpcmVkLmZvcmVpZ25JZGVudGlmaWVyRmllbGQpIHtcbiAgICAgIHRoaXMucGFpcmVkLmZvcmVpZ25JZGVudGlmaWVyRmllbGQgPSB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLnBhaXJlZC5vdGhlcktleV0uZmllbGQgfHwgdGhpcy5wYWlyZWQub3RoZXJLZXk7XG4gICAgfVxuICAgIHRoaXMudG9Tb3VyY2UgPSBuZXcgQmVsb25nc1RvKHRoaXMudGhyb3VnaC5tb2RlbCwgdGhpcy5zb3VyY2UsIHtcbiAgICAgIGZvcmVpZ25LZXk6IHRoaXMuZm9yZWlnbktleVxuICAgIH0pO1xuICAgIHRoaXMubWFueUZyb21Tb3VyY2UgPSBuZXcgSGFzTWFueSh0aGlzLnNvdXJjZSwgdGhpcy50aHJvdWdoLm1vZGVsLCB7XG4gICAgICBmb3JlaWduS2V5OiB0aGlzLmZvcmVpZ25LZXlcbiAgICB9KTtcbiAgICB0aGlzLm9uZUZyb21Tb3VyY2UgPSBuZXcgSGFzT25lKHRoaXMuc291cmNlLCB0aGlzLnRocm91Z2gubW9kZWwsIHtcbiAgICAgIGZvcmVpZ25LZXk6IHRoaXMuZm9yZWlnbktleSxcbiAgICAgIHNvdXJjZUtleTogdGhpcy5zb3VyY2VLZXksXG4gICAgICBhczogdGhpcy50aHJvdWdoLm1vZGVsLm5hbWVcbiAgICB9KTtcbiAgICB0aGlzLnRvVGFyZ2V0ID0gbmV3IEJlbG9uZ3NUbyh0aGlzLnRocm91Z2gubW9kZWwsIHRoaXMudGFyZ2V0LCB7XG4gICAgICBmb3JlaWduS2V5OiB0aGlzLm90aGVyS2V5XG4gICAgfSk7XG4gICAgdGhpcy5tYW55RnJvbVRhcmdldCA9IG5ldyBIYXNNYW55KHRoaXMudGFyZ2V0LCB0aGlzLnRocm91Z2gubW9kZWwsIHtcbiAgICAgIGZvcmVpZ25LZXk6IHRoaXMub3RoZXJLZXlcbiAgICB9KTtcbiAgICB0aGlzLm9uZUZyb21UYXJnZXQgPSBuZXcgSGFzT25lKHRoaXMudGFyZ2V0LCB0aGlzLnRocm91Z2gubW9kZWwsIHtcbiAgICAgIGZvcmVpZ25LZXk6IHRoaXMub3RoZXJLZXksXG4gICAgICBzb3VyY2VLZXk6IHRoaXMudGFyZ2V0S2V5LFxuICAgICAgYXM6IHRoaXMudGhyb3VnaC5tb2RlbC5uYW1lXG4gICAgfSk7XG4gICAgaWYgKHRoaXMucGFpcmVkICYmIHRoaXMucGFpcmVkLm90aGVyS2V5RGVmYXVsdCkge1xuICAgICAgdGhpcy5wYWlyZWQudG9UYXJnZXQgPSBuZXcgQmVsb25nc1RvKHRoaXMucGFpcmVkLnRocm91Z2gubW9kZWwsIHRoaXMucGFpcmVkLnRhcmdldCwge1xuICAgICAgICBmb3JlaWduS2V5OiB0aGlzLnBhaXJlZC5vdGhlcktleVxuICAgICAgfSk7XG4gICAgICB0aGlzLnBhaXJlZC5vbmVGcm9tVGFyZ2V0ID0gbmV3IEhhc09uZSh0aGlzLnBhaXJlZC50YXJnZXQsIHRoaXMucGFpcmVkLnRocm91Z2gubW9kZWwsIHtcbiAgICAgICAgZm9yZWlnbktleTogdGhpcy5wYWlyZWQub3RoZXJLZXksXG4gICAgICAgIHNvdXJjZUtleTogdGhpcy5wYWlyZWQudGFyZ2V0S2V5LFxuICAgICAgICBhczogdGhpcy5wYWlyZWQudGhyb3VnaC5tb2RlbC5uYW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgSGVscGVycy5jaGVja05hbWluZ0NvbGxpc2lvbih0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBtaXhpbihvYmopIHtcbiAgICBjb25zdCBtZXRob2RzID0gW1wiZ2V0XCIsIFwiY291bnRcIiwgXCJoYXNTaW5nbGVcIiwgXCJoYXNBbGxcIiwgXCJzZXRcIiwgXCJhZGRcIiwgXCJhZGRNdWx0aXBsZVwiLCBcInJlbW92ZVwiLCBcInJlbW92ZU11bHRpcGxlXCIsIFwiY3JlYXRlXCJdO1xuICAgIGNvbnN0IGFsaWFzZXMgPSB7XG4gICAgICBoYXNTaW5nbGU6IFwiaGFzXCIsXG4gICAgICBoYXNBbGw6IFwiaGFzXCIsXG4gICAgICBhZGRNdWx0aXBsZTogXCJhZGRcIixcbiAgICAgIHJlbW92ZU11bHRpcGxlOiBcInJlbW92ZVwiXG4gICAgfTtcbiAgICBIZWxwZXJzLm1peGluTWV0aG9kcyh0aGlzLCBvYmosIG1ldGhvZHMsIGFsaWFzZXMpO1xuICB9XG4gIGFzeW5jIGdldChpbnN0YW5jZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucykgfHwge307XG4gICAgY29uc3QgdGhyb3VnaCA9IHRoaXMudGhyb3VnaDtcbiAgICBsZXQgc2NvcGVXaGVyZTtcbiAgICBsZXQgdGhyb3VnaFdoZXJlO1xuICAgIGlmICh0aGlzLnNjb3BlKSB7XG4gICAgICBzY29wZVdoZXJlID0gX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuc2NvcGUpO1xuICAgIH1cbiAgICBvcHRpb25zLndoZXJlID0ge1xuICAgICAgW09wLmFuZF06IFtcbiAgICAgICAgc2NvcGVXaGVyZSxcbiAgICAgICAgb3B0aW9ucy53aGVyZVxuICAgICAgXVxuICAgIH07XG4gICAgaWYgKE9iamVjdCh0aHJvdWdoLm1vZGVsKSA9PT0gdGhyb3VnaC5tb2RlbCkge1xuICAgICAgdGhyb3VnaFdoZXJlID0ge307XG4gICAgICB0aHJvdWdoV2hlcmVbdGhpcy5mb3JlaWduS2V5XSA9IGluc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSk7XG4gICAgICBpZiAodGhyb3VnaC5zY29wZSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRocm91Z2hXaGVyZSwgdGhyb3VnaC5zY29wZSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy50aHJvdWdoICYmIG9wdGlvbnMudGhyb3VnaC53aGVyZSkge1xuICAgICAgICB0aHJvdWdoV2hlcmUgPSB7XG4gICAgICAgICAgW09wLmFuZF06IFt0aHJvdWdoV2hlcmUsIG9wdGlvbnMudGhyb3VnaC53aGVyZV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuaW5jbHVkZSA9IG9wdGlvbnMuaW5jbHVkZSB8fCBbXTtcbiAgICAgIG9wdGlvbnMuaW5jbHVkZS5wdXNoKHtcbiAgICAgICAgYXNzb2NpYXRpb246IHRoaXMub25lRnJvbVRhcmdldCxcbiAgICAgICAgYXR0cmlidXRlczogb3B0aW9ucy5qb2luVGFibGVBdHRyaWJ1dGVzLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgcGFyYW5vaWQ6IF8uZ2V0KG9wdGlvbnMudGhyb3VnaCwgXCJwYXJhbm9pZFwiLCB0cnVlKSxcbiAgICAgICAgd2hlcmU6IHRocm91Z2hXaGVyZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBtb2RlbCA9IHRoaXMudGFyZ2V0O1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJzY29wZVwiKSkge1xuICAgICAgaWYgKCFvcHRpb25zLnNjb3BlKSB7XG4gICAgICAgIG1vZGVsID0gbW9kZWwudW5zY29wZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZGVsID0gbW9kZWwuc2NvcGUob3B0aW9ucy5zY29wZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJzY2hlbWFcIikpIHtcbiAgICAgIG1vZGVsID0gbW9kZWwuc2NoZW1hKG9wdGlvbnMuc2NoZW1hLCBvcHRpb25zLnNjaGVtYURlbGltaXRlcik7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbC5maW5kQWxsKG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGNvdW50KGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc2VxdWVsaXplID0gdGhpcy50YXJnZXQuc2VxdWVsaXplO1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gW1xuICAgICAgW3NlcXVlbGl6ZS5mbihcIkNPVU5UXCIsIHNlcXVlbGl6ZS5jb2woW3RoaXMudGFyZ2V0Lm5hbWUsIHRoaXMudGFyZ2V0S2V5RmllbGRdLmpvaW4oXCIuXCIpKSksIFwiY291bnRcIl1cbiAgICBdO1xuICAgIG9wdGlvbnMuam9pblRhYmxlQXR0cmlidXRlcyA9IFtdO1xuICAgIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgICBvcHRpb25zLnBsYWluID0gdHJ1ZTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldChpbnN0YW5jZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHBhcnNlSW50KHJlc3VsdC5jb3VudCwgMTApO1xuICB9XG4gIGFzeW5jIGhhcyhzb3VyY2VJbnN0YW5jZSwgaW5zdGFuY2VzLCBvcHRpb25zKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGluc3RhbmNlcykpIHtcbiAgICAgIGluc3RhbmNlcyA9IFtpbnN0YW5jZXNdO1xuICAgIH1cbiAgICBvcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgICByYXc6IHRydWVcbiAgICB9LCBvcHRpb25zKSwge1xuICAgICAgc2NvcGU6IGZhbHNlLFxuICAgICAgYXR0cmlidXRlczogW3RoaXMudGFyZ2V0S2V5XSxcbiAgICAgIGpvaW5UYWJsZUF0dHJpYnV0ZXM6IFtdXG4gICAgfSk7XG4gICAgY29uc3QgaW5zdGFuY2VQcmltYXJ5S2V5cyA9IGluc3RhbmNlcy5tYXAoKGluc3RhbmNlKSA9PiB7XG4gICAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiB0aGlzLnRhcmdldCkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2Uud2hlcmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFt0aGlzLnRhcmdldEtleV06IGluc3RhbmNlXG4gICAgICB9O1xuICAgIH0pO1xuICAgIG9wdGlvbnMud2hlcmUgPSB7XG4gICAgICBbT3AuYW5kXTogW1xuICAgICAgICB7IFtPcC5vcl06IGluc3RhbmNlUHJpbWFyeUtleXMgfSxcbiAgICAgICAgb3B0aW9ucy53aGVyZVxuICAgICAgXVxuICAgIH07XG4gICAgY29uc3QgYXNzb2NpYXRlZE9iamVjdHMgPSBhd2FpdCB0aGlzLmdldChzb3VyY2VJbnN0YW5jZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIF8uZGlmZmVyZW5jZVdpdGgoaW5zdGFuY2VQcmltYXJ5S2V5cywgYXNzb2NpYXRlZE9iamVjdHMsIChhLCBiKSA9PiBfLmlzRXF1YWwoYVt0aGlzLnRhcmdldEtleV0sIGJbdGhpcy50YXJnZXRLZXldKSkubGVuZ3RoID09PSAwO1xuICB9XG4gIGFzeW5jIHNldChzb3VyY2VJbnN0YW5jZSwgbmV3QXNzb2NpYXRlZE9iamVjdHMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzb3VyY2VLZXkgPSB0aGlzLnNvdXJjZUtleTtcbiAgICBjb25zdCB0YXJnZXRLZXkgPSB0aGlzLnRhcmdldEtleTtcbiAgICBjb25zdCBpZGVudGlmaWVyID0gdGhpcy5pZGVudGlmaWVyO1xuICAgIGNvbnN0IGZvcmVpZ25JZGVudGlmaWVyID0gdGhpcy5mb3JlaWduSWRlbnRpZmllcjtcbiAgICBpZiAobmV3QXNzb2NpYXRlZE9iamVjdHMgPT09IG51bGwpIHtcbiAgICAgIG5ld0Fzc29jaWF0ZWRPYmplY3RzID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0Fzc29jaWF0ZWRPYmplY3RzID0gdGhpcy50b0luc3RhbmNlQXJyYXkobmV3QXNzb2NpYXRlZE9iamVjdHMpO1xuICAgIH1cbiAgICBjb25zdCB3aGVyZSA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIFtpZGVudGlmaWVyXTogc291cmNlSW5zdGFuY2UuZ2V0KHNvdXJjZUtleSlcbiAgICB9LCB0aGlzLnRocm91Z2guc2NvcGUpO1xuICAgIGNvbnN0IHVwZGF0ZUFzc29jaWF0aW9ucyA9IChjdXJyZW50Um93cykgPT4ge1xuICAgICAgY29uc3Qgb2Jzb2xldGVBc3NvY2lhdGlvbnMgPSBbXTtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICBjb25zdCBkZWZhdWx0QXR0cmlidXRlcyA9IG9wdGlvbnMudGhyb3VnaCB8fCB7fTtcbiAgICAgIGNvbnN0IHVuYXNzb2NpYXRlZE9iamVjdHMgPSBuZXdBc3NvY2lhdGVkT2JqZWN0cy5maWx0ZXIoKG9iaikgPT4gIWN1cnJlbnRSb3dzLnNvbWUoKGN1cnJlbnRSb3cpID0+IGN1cnJlbnRSb3dbZm9yZWlnbklkZW50aWZpZXJdID09PSBvYmouZ2V0KHRhcmdldEtleSkpKTtcbiAgICAgIGZvciAoY29uc3QgY3VycmVudFJvdyBvZiBjdXJyZW50Um93cykge1xuICAgICAgICBjb25zdCBuZXdPYmogPSBuZXdBc3NvY2lhdGVkT2JqZWN0cy5maW5kKChvYmopID0+IGN1cnJlbnRSb3dbZm9yZWlnbklkZW50aWZpZXJdID09PSBvYmouZ2V0KHRhcmdldEtleSkpO1xuICAgICAgICBpZiAoIW5ld09iaikge1xuICAgICAgICAgIG9ic29sZXRlQXNzb2NpYXRpb25zLnB1c2goY3VycmVudFJvdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IHRocm91Z2hBdHRyaWJ1dGVzID0gbmV3T2JqW3RoaXMudGhyb3VnaC5tb2RlbC5uYW1lXTtcbiAgICAgICAgICBpZiAodGhyb3VnaEF0dHJpYnV0ZXMgaW5zdGFuY2VvZiB0aGlzLnRocm91Z2gubW9kZWwpIHtcbiAgICAgICAgICAgIHRocm91Z2hBdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgZGVmYXVsdEF0dHJpYnV0ZXMpLCB0aHJvdWdoQXR0cmlidXRlcyk7XG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnRocm91Z2gubW9kZWwudXBkYXRlKGF0dHJpYnV0ZXMsIE9iamVjdC5hc3NpZ24ob3B0aW9ucywge1xuICAgICAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgICAgIFtpZGVudGlmaWVyXTogc291cmNlSW5zdGFuY2UuZ2V0KHNvdXJjZUtleSksXG4gICAgICAgICAgICAgICAgW2ZvcmVpZ25JZGVudGlmaWVyXTogbmV3T2JqLmdldCh0YXJnZXRLZXkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2Jzb2xldGVBc3NvY2lhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMudGhyb3VnaC5tb2RlbC5kZXN0cm95KF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICAgICAgd2hlcmU6IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgICAgIFtpZGVudGlmaWVyXTogc291cmNlSW5zdGFuY2UuZ2V0KHNvdXJjZUtleSksXG4gICAgICAgICAgICBbZm9yZWlnbklkZW50aWZpZXJdOiBvYnNvbGV0ZUFzc29jaWF0aW9ucy5tYXAoKG9ic29sZXRlQXNzb2NpYXRpb24pID0+IG9ic29sZXRlQXNzb2NpYXRpb25bZm9yZWlnbklkZW50aWZpZXJdKVxuICAgICAgICAgIH0sIHRoaXMudGhyb3VnaC5zY29wZSlcbiAgICAgICAgfSkpKTtcbiAgICAgIH1cbiAgICAgIGlmICh1bmFzc29jaWF0ZWRPYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgYnVsayA9IHVuYXNzb2NpYXRlZE9iamVjdHMubWFwKCh1bmFzc29jaWF0ZWRPYmplY3QpID0+IHtcbiAgICAgICAgICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgZGVmYXVsdEF0dHJpYnV0ZXMpLCB1bmFzc29jaWF0ZWRPYmplY3RbdGhpcy50aHJvdWdoLm1vZGVsLm5hbWVdKSwge1xuICAgICAgICAgICAgW2lkZW50aWZpZXJdOiBzb3VyY2VJbnN0YW5jZS5nZXQoc291cmNlS2V5KSxcbiAgICAgICAgICAgIFtmb3JlaWduSWRlbnRpZmllcl06IHVuYXNzb2NpYXRlZE9iamVjdC5nZXQodGFyZ2V0S2V5KVxuICAgICAgICAgIH0pLCB0aGlzLnRocm91Z2guc2NvcGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnRocm91Z2gubW9kZWwuYnVsa0NyZWF0ZShidWxrLCBfX3NwcmVhZFZhbHVlcyh7IHZhbGlkYXRlOiB0cnVlIH0sIG9wdGlvbnMpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRSb3dzID0gYXdhaXQgdGhpcy50aHJvdWdoLm1vZGVsLmZpbmRBbGwoX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgd2hlcmUsIHJhdzogdHJ1ZSB9KSk7XG4gICAgICByZXR1cm4gYXdhaXQgdXBkYXRlQXNzb2NpYXRpb25zKGN1cnJlbnRSb3dzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRW1wdHlSZXN1bHRFcnJvcilcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUFzc29jaWF0aW9ucyhbXSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYWRkKHNvdXJjZUluc3RhbmNlLCBuZXdJbnN0YW5jZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW5ld0luc3RhbmNlcylcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xuICAgIGNvbnN0IGFzc29jaWF0aW9uID0gdGhpcztcbiAgICBjb25zdCBzb3VyY2VLZXkgPSBhc3NvY2lhdGlvbi5zb3VyY2VLZXk7XG4gICAgY29uc3QgdGFyZ2V0S2V5ID0gYXNzb2NpYXRpb24udGFyZ2V0S2V5O1xuICAgIGNvbnN0IGlkZW50aWZpZXIgPSBhc3NvY2lhdGlvbi5pZGVudGlmaWVyO1xuICAgIGNvbnN0IGZvcmVpZ25JZGVudGlmaWVyID0gYXNzb2NpYXRpb24uZm9yZWlnbklkZW50aWZpZXI7XG4gICAgY29uc3QgZGVmYXVsdEF0dHJpYnV0ZXMgPSBvcHRpb25zLnRocm91Z2ggfHwge307XG4gICAgbmV3SW5zdGFuY2VzID0gYXNzb2NpYXRpb24udG9JbnN0YW5jZUFycmF5KG5ld0luc3RhbmNlcyk7XG4gICAgY29uc3Qgd2hlcmUgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBbaWRlbnRpZmllcl06IHNvdXJjZUluc3RhbmNlLmdldChzb3VyY2VLZXkpLFxuICAgICAgW2ZvcmVpZ25JZGVudGlmaWVyXTogbmV3SW5zdGFuY2VzLm1hcCgobmV3SW5zdGFuY2UpID0+IG5ld0luc3RhbmNlLmdldCh0YXJnZXRLZXkpKVxuICAgIH0sIGFzc29jaWF0aW9uLnRocm91Z2guc2NvcGUpO1xuICAgIGNvbnN0IHVwZGF0ZUFzc29jaWF0aW9ucyA9IChjdXJyZW50Um93cykgPT4ge1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgIGNvbnN0IHVuYXNzb2NpYXRlZE9iamVjdHMgPSBbXTtcbiAgICAgIGNvbnN0IGNoYW5nZWRBc3NvY2lhdGlvbnMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgb2JqIG9mIG5ld0luc3RhbmNlcykge1xuICAgICAgICBjb25zdCBleGlzdGluZ0Fzc29jaWF0aW9uID0gY3VycmVudFJvd3MgJiYgY3VycmVudFJvd3MuZmluZCgoY3VycmVudCkgPT4gY3VycmVudFtmb3JlaWduSWRlbnRpZmllcl0gPT09IG9iai5nZXQodGFyZ2V0S2V5KSk7XG4gICAgICAgIGlmICghZXhpc3RpbmdBc3NvY2lhdGlvbikge1xuICAgICAgICAgIHVuYXNzb2NpYXRlZE9iamVjdHMucHVzaChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHRocm91Z2hBdHRyaWJ1dGVzID0gb2JqW2Fzc29jaWF0aW9uLnRocm91Z2gubW9kZWwubmFtZV07XG4gICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBkZWZhdWx0QXR0cmlidXRlcyksIHRocm91Z2hBdHRyaWJ1dGVzKTtcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYXR0cmlidXRlcykuc29tZSgoYXR0cmlidXRlKSA9PiBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gIT09IGV4aXN0aW5nQXNzb2NpYXRpb25bYXR0cmlidXRlXSkpIHtcbiAgICAgICAgICAgIGNoYW5nZWRBc3NvY2lhdGlvbnMucHVzaChvYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHVuYXNzb2NpYXRlZE9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBidWxrID0gdW5hc3NvY2lhdGVkT2JqZWN0cy5tYXAoKHVuYXNzb2NpYXRlZE9iamVjdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRocm91Z2hBdHRyaWJ1dGVzID0gdW5hc3NvY2lhdGVkT2JqZWN0W2Fzc29jaWF0aW9uLnRocm91Z2gubW9kZWwubmFtZV07XG4gICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBkZWZhdWx0QXR0cmlidXRlcyksIHRocm91Z2hBdHRyaWJ1dGVzKTtcbiAgICAgICAgICBhdHRyaWJ1dGVzW2lkZW50aWZpZXJdID0gc291cmNlSW5zdGFuY2UuZ2V0KHNvdXJjZUtleSk7XG4gICAgICAgICAgYXR0cmlidXRlc1tmb3JlaWduSWRlbnRpZmllcl0gPSB1bmFzc29jaWF0ZWRPYmplY3QuZ2V0KHRhcmdldEtleSk7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihhdHRyaWJ1dGVzLCBhc3NvY2lhdGlvbi50aHJvdWdoLnNjb3BlKTtcbiAgICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHByb21pc2VzLnB1c2goYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5idWxrQ3JlYXRlKGJ1bGssIF9fc3ByZWFkVmFsdWVzKHsgdmFsaWRhdGU6IHRydWUgfSwgb3B0aW9ucykpKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgYXNzb2Mgb2YgY2hhbmdlZEFzc29jaWF0aW9ucykge1xuICAgICAgICBsZXQgdGhyb3VnaEF0dHJpYnV0ZXMgPSBhc3NvY1thc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLm5hbWVdO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGRlZmF1bHRBdHRyaWJ1dGVzKSwgdGhyb3VnaEF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAodGhyb3VnaEF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBhc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsKSB7XG4gICAgICAgICAgdGhyb3VnaEF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBwcm9taXNlcy5wdXNoKGFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwudXBkYXRlKGF0dHJpYnV0ZXMsIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgeyB3aGVyZToge1xuICAgICAgICAgIFtpZGVudGlmaWVyXTogc291cmNlSW5zdGFuY2UuZ2V0KHNvdXJjZUtleSksXG4gICAgICAgICAgW2ZvcmVpZ25JZGVudGlmaWVyXTogYXNzb2MuZ2V0KHRhcmdldEtleSlcbiAgICAgICAgfSB9KSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjdXJyZW50Um93cyA9IGF3YWl0IGFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwuZmluZEFsbChfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyB3aGVyZSwgcmF3OiB0cnVlIH0pKTtcbiAgICAgIGNvbnN0IFthc3NvY2lhdGlvbnNdID0gYXdhaXQgdXBkYXRlQXNzb2NpYXRpb25zKGN1cnJlbnRSb3dzKTtcbiAgICAgIHJldHVybiBhc3NvY2lhdGlvbnM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVtcHR5UmVzdWx0RXJyb3IpXG4gICAgICAgIHJldHVybiB1cGRhdGVBc3NvY2lhdGlvbnMoKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICByZW1vdmUoc291cmNlSW5zdGFuY2UsIG9sZEFzc29jaWF0ZWRPYmplY3RzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYXNzb2NpYXRpb24gPSB0aGlzO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9sZEFzc29jaWF0ZWRPYmplY3RzID0gYXNzb2NpYXRpb24udG9JbnN0YW5jZUFycmF5KG9sZEFzc29jaWF0ZWRPYmplY3RzKTtcbiAgICBjb25zdCB3aGVyZSA9IHtcbiAgICAgIFthc3NvY2lhdGlvbi5pZGVudGlmaWVyXTogc291cmNlSW5zdGFuY2UuZ2V0KGFzc29jaWF0aW9uLnNvdXJjZUtleSksXG4gICAgICBbYXNzb2NpYXRpb24uZm9yZWlnbklkZW50aWZpZXJdOiBvbGRBc3NvY2lhdGVkT2JqZWN0cy5tYXAoKG5ld0luc3RhbmNlKSA9PiBuZXdJbnN0YW5jZS5nZXQoYXNzb2NpYXRpb24udGFyZ2V0S2V5KSlcbiAgICB9O1xuICAgIHJldHVybiBhc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLmRlc3Ryb3koX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgd2hlcmUgfSkpO1xuICB9XG4gIGFzeW5jIGNyZWF0ZShzb3VyY2VJbnN0YW5jZSwgdmFsdWVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYXNzb2NpYXRpb24gPSB0aGlzO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhbHVlcyA9IHZhbHVlcyB8fCB7fTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgZmllbGRzOiBvcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoYXNzb2NpYXRpb24uc2NvcGUpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odmFsdWVzLCBhc3NvY2lhdGlvbi5zY29wZSk7XG4gICAgICBpZiAob3B0aW9ucy5maWVsZHMpIHtcbiAgICAgICAgb3B0aW9ucy5maWVsZHMgPSBvcHRpb25zLmZpZWxkcy5jb25jYXQoT2JqZWN0LmtleXMoYXNzb2NpYXRpb24uc2NvcGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV3QXNzb2NpYXRlZE9iamVjdCA9IGF3YWl0IGFzc29jaWF0aW9uLnRhcmdldC5jcmVhdGUodmFsdWVzLCBvcHRpb25zKTtcbiAgICBhd2FpdCBzb3VyY2VJbnN0YW5jZVthc3NvY2lhdGlvbi5hY2Nlc3NvcnMuYWRkXShuZXdBc3NvY2lhdGVkT2JqZWN0LCBfLm9taXQob3B0aW9ucywgW1wiZmllbGRzXCJdKSk7XG4gICAgcmV0dXJuIG5ld0Fzc29jaWF0ZWRPYmplY3Q7XG4gIH1cbiAgdmVyaWZ5QXNzb2NpYXRpb25BbGlhcyhhbGlhcykge1xuICAgIGlmICh0eXBlb2YgYWxpYXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzID09PSBhbGlhcztcbiAgICB9XG4gICAgaWYgKGFsaWFzICYmIGFsaWFzLnBsdXJhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXMgPT09IGFsaWFzLnBsdXJhbDtcbiAgICB9XG4gICAgcmV0dXJuICF0aGlzLmlzQWxpYXNlZDtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBCZWxvbmdzVG9NYW55O1xubW9kdWxlLmV4cG9ydHMuQmVsb25nc1RvTWFueSA9IEJlbG9uZ3NUb01hbnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQmVsb25nc1RvTWFueTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlbG9uZ3MtdG8tbWFueS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/associations/belongs-to-many.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/associations/belongs-to.js":
/*!****************************************************************!*\
  !*** ../node_modules/sequelize/lib/associations/belongs-to.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst Utils = __webpack_require__(/*! ./../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst Helpers = __webpack_require__(/*! ./helpers */ \"(action-browser)/../node_modules/sequelize/lib/associations/helpers.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst Association = __webpack_require__(/*! ./base */ \"(action-browser)/../node_modules/sequelize/lib/associations/base.js\");\nconst Op = __webpack_require__(/*! ../operators */ \"(action-browser)/../node_modules/sequelize/lib/operators.js\");\nclass BelongsTo extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    this.associationType = \"BelongsTo\";\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize([\n        this.as,\n        this.target.primaryKeyAttribute\n      ].join(\"_\"));\n    }\n    this.identifier = this.foreignKey;\n    if (this.source.rawAttributes[this.identifier]) {\n      this.identifierField = this.source.rawAttributes[this.identifier].field || this.identifier;\n    }\n    if (this.options.targetKey && !this.target.rawAttributes[this.options.targetKey]) {\n      throw new Error(`Unknown attribute \"${this.options.targetKey}\" passed as targetKey, define this attribute on model \"${this.target.name}\" first`);\n    }\n    this.targetKey = this.options.targetKey || this.target.primaryKeyAttribute;\n    this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    this.targetKeyIsPrimary = this.targetKey === this.target.primaryKeyAttribute;\n    this.targetIdentifier = this.targetKey;\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks;\n    const singular = _.upperFirst(this.options.name.singular);\n    this.accessors = {\n      get: `get${singular}`,\n      set: `set${singular}`,\n      create: `create${singular}`\n    };\n  }\n  _injectAttributes() {\n    const newAttributes = {\n      [this.foreignKey]: __spreadValues({\n        type: this.options.keyType || this.target.rawAttributes[this.targetKey].type,\n        allowNull: true\n      }, this.foreignKeyAttribute)\n    };\n    if (this.options.constraints !== false) {\n      const source = this.source.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (source.allowNull ? \"SET NULL\" : \"NO ACTION\");\n      this.options.onUpdate = this.options.onUpdate || \"CASCADE\";\n    }\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.target, this.source, this.options, this.targetKeyField);\n    Utils.mergeDefaults(this.source.rawAttributes, newAttributes);\n    this.source.refreshAttributes();\n    this.identifierField = this.source.rawAttributes[this.foreignKey].field || this.foreignKey;\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n  mixin(obj) {\n    const methods = [\"get\", \"set\", \"create\"];\n    Helpers.mixinMethods(this, obj, methods);\n  }\n  async get(instances, options) {\n    const where = {};\n    let Target = this.target;\n    let instance;\n    options = Utils.cloneDeep(options);\n    if (Object.prototype.hasOwnProperty.call(options, \"scope\")) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"schema\")) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = void 0;\n    }\n    if (instances) {\n      where[this.targetKey] = {\n        [Op.in]: instances.map((_instance) => _instance.get(this.foreignKey))\n      };\n    } else {\n      if (this.targetKeyIsPrimary && !options.where) {\n        return Target.findByPk(instance.get(this.foreignKey), options);\n      }\n      where[this.targetKey] = instance.get(this.foreignKey);\n      options.limit = null;\n    }\n    options.where = options.where ? { [Op.and]: [where, options.where] } : where;\n    if (instances) {\n      const results = await Target.findAll(options);\n      const result = {};\n      for (const _instance of instances) {\n        result[_instance.get(this.foreignKey, { raw: true })] = null;\n      }\n      for (const _instance of results) {\n        result[_instance.get(this.targetKey, { raw: true })] = _instance;\n      }\n      return result;\n    }\n    return Target.findOne(options);\n  }\n  async set(sourceInstance, associatedInstance, options = {}) {\n    let value = associatedInstance;\n    if (associatedInstance instanceof this.target) {\n      value = associatedInstance[this.targetKey];\n    }\n    sourceInstance.set(this.foreignKey, value);\n    if (options.save === false)\n      return;\n    options = __spreadValues({\n      fields: [this.foreignKey],\n      allowNull: [this.foreignKey],\n      association: true\n    }, options);\n    return await sourceInstance.save(options);\n  }\n  async create(sourceInstance, values, options) {\n    values = values || {};\n    options = options || {};\n    const newAssociatedObject = await this.target.create(values, options);\n    await sourceInstance[this.accessors.set](newAssociatedObject, options);\n    return newAssociatedObject;\n  }\n  verifyAssociationAlias(alias) {\n    if (typeof alias === \"string\") {\n      return this.as === alias;\n    }\n    if (alias && alias.singular) {\n      return this.as === alias.singular;\n    }\n    return !this.isAliased;\n  }\n}\nmodule.exports = BelongsTo;\nmodule.exports.BelongsTo = BelongsTo;\nmodule.exports[\"default\"] = BelongsTo;\n//# sourceMappingURL=belongs-to.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvYmVsb25ncy10by5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsMkVBQVk7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMseUZBQVc7QUFDbkMsVUFBVSxtQkFBTyxDQUFDLGlFQUFRO0FBQzFCLG9CQUFvQixtQkFBTyxDQUFDLG1GQUFRO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxpRkFBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx1QkFBdUIseURBQXlELGlCQUFpQjtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQixpQkFBaUIsU0FBUztBQUMxQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxtQ0FBbUM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVztBQUMzRDtBQUNBO0FBQ0EsK0NBQStDLFdBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIseUJBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvLmpzPzNlYjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuLy4uL3V0aWxzXCIpO1xuY29uc3QgSGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IEFzc29jaWF0aW9uID0gcmVxdWlyZShcIi4vYmFzZVwiKTtcbmNvbnN0IE9wID0gcmVxdWlyZShcIi4uL29wZXJhdG9yc1wiKTtcbmNsYXNzIEJlbG9uZ3NUbyBleHRlbmRzIEFzc29jaWF0aW9uIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihzb3VyY2UsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgdGhpcy5hc3NvY2lhdGlvblR5cGUgPSBcIkJlbG9uZ3NUb1wiO1xuICAgIHRoaXMuaXNTaW5nbGVBc3NvY2lhdGlvbiA9IHRydWU7XG4gICAgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlID0ge307XG4gICAgaWYgKHRoaXMuYXMpIHtcbiAgICAgIHRoaXMuaXNBbGlhc2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMub3B0aW9ucy5uYW1lID0ge1xuICAgICAgICBzaW5ndWxhcjogdGhpcy5hc1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcyA9IHRoaXMudGFyZ2V0Lm9wdGlvbnMubmFtZS5zaW5ndWxhcjtcbiAgICAgIHRoaXMub3B0aW9ucy5uYW1lID0gdGhpcy50YXJnZXQub3B0aW9ucy5uYW1lO1xuICAgIH1cbiAgICBpZiAoXy5pc09iamVjdCh0aGlzLm9wdGlvbnMuZm9yZWlnbktleSkpIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZSA9IHRoaXMub3B0aW9ucy5mb3JlaWduS2V5O1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlLm5hbWUgfHwgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlLmZpZWxkTmFtZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5mb3JlaWduS2V5KSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSB0aGlzLm9wdGlvbnMuZm9yZWlnbktleTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmZvcmVpZ25LZXkpIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IFV0aWxzLmNhbWVsaXplKFtcbiAgICAgICAgdGhpcy5hcyxcbiAgICAgICAgdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZVxuICAgICAgXS5qb2luKFwiX1wiKSk7XG4gICAgfVxuICAgIHRoaXMuaWRlbnRpZmllciA9IHRoaXMuZm9yZWlnbktleTtcbiAgICBpZiAodGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLmlkZW50aWZpZXJdKSB7XG4gICAgICB0aGlzLmlkZW50aWZpZXJGaWVsZCA9IHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5pZGVudGlmaWVyXS5maWVsZCB8fCB0aGlzLmlkZW50aWZpZXI7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMudGFyZ2V0S2V5ICYmICF0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMub3B0aW9ucy50YXJnZXRLZXldKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYXR0cmlidXRlIFwiJHt0aGlzLm9wdGlvbnMudGFyZ2V0S2V5fVwiIHBhc3NlZCBhcyB0YXJnZXRLZXksIGRlZmluZSB0aGlzIGF0dHJpYnV0ZSBvbiBtb2RlbCBcIiR7dGhpcy50YXJnZXQubmFtZX1cIiBmaXJzdGApO1xuICAgIH1cbiAgICB0aGlzLnRhcmdldEtleSA9IHRoaXMub3B0aW9ucy50YXJnZXRLZXkgfHwgdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZTtcbiAgICB0aGlzLnRhcmdldEtleUZpZWxkID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLnRhcmdldEtleV0uZmllbGQgfHwgdGhpcy50YXJnZXRLZXk7XG4gICAgdGhpcy50YXJnZXRLZXlJc1ByaW1hcnkgPSB0aGlzLnRhcmdldEtleSA9PT0gdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZTtcbiAgICB0aGlzLnRhcmdldElkZW50aWZpZXIgPSB0aGlzLnRhcmdldEtleTtcbiAgICB0aGlzLmFzc29jaWF0aW9uQWNjZXNzb3IgPSB0aGlzLmFzO1xuICAgIHRoaXMub3B0aW9ucy51c2VIb29rcyA9IG9wdGlvbnMudXNlSG9va3M7XG4gICAgY29uc3Qgc2luZ3VsYXIgPSBfLnVwcGVyRmlyc3QodGhpcy5vcHRpb25zLm5hbWUuc2luZ3VsYXIpO1xuICAgIHRoaXMuYWNjZXNzb3JzID0ge1xuICAgICAgZ2V0OiBgZ2V0JHtzaW5ndWxhcn1gLFxuICAgICAgc2V0OiBgc2V0JHtzaW5ndWxhcn1gLFxuICAgICAgY3JlYXRlOiBgY3JlYXRlJHtzaW5ndWxhcn1gXG4gICAgfTtcbiAgfVxuICBfaW5qZWN0QXR0cmlidXRlcygpIHtcbiAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0ge1xuICAgICAgW3RoaXMuZm9yZWlnbktleV06IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgdHlwZTogdGhpcy5vcHRpb25zLmtleVR5cGUgfHwgdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLnRhcmdldEtleV0udHlwZSxcbiAgICAgICAgYWxsb3dOdWxsOiB0cnVlXG4gICAgICB9LCB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUpXG4gICAgfTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbnN0cmFpbnRzICE9PSBmYWxzZSkge1xuICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldIHx8IG5ld0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XTtcbiAgICAgIHRoaXMub3B0aW9ucy5vbkRlbGV0ZSA9IHRoaXMub3B0aW9ucy5vbkRlbGV0ZSB8fCAoc291cmNlLmFsbG93TnVsbCA/IFwiU0VUIE5VTExcIiA6IFwiTk8gQUNUSU9OXCIpO1xuICAgICAgdGhpcy5vcHRpb25zLm9uVXBkYXRlID0gdGhpcy5vcHRpb25zLm9uVXBkYXRlIHx8IFwiQ0FTQ0FERVwiO1xuICAgIH1cbiAgICBIZWxwZXJzLmFkZEZvcmVpZ25LZXlDb25zdHJhaW50cyhuZXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0sIHRoaXMudGFyZ2V0LCB0aGlzLnNvdXJjZSwgdGhpcy5vcHRpb25zLCB0aGlzLnRhcmdldEtleUZpZWxkKTtcbiAgICBVdGlscy5tZXJnZURlZmF1bHRzKHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXMsIG5ld0F0dHJpYnV0ZXMpO1xuICAgIHRoaXMuc291cmNlLnJlZnJlc2hBdHRyaWJ1dGVzKCk7XG4gICAgdGhpcy5pZGVudGlmaWVyRmllbGQgPSB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0uZmllbGQgfHwgdGhpcy5mb3JlaWduS2V5O1xuICAgIEhlbHBlcnMuY2hlY2tOYW1pbmdDb2xsaXNpb24odGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbWl4aW4ob2JqKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IFtcImdldFwiLCBcInNldFwiLCBcImNyZWF0ZVwiXTtcbiAgICBIZWxwZXJzLm1peGluTWV0aG9kcyh0aGlzLCBvYmosIG1ldGhvZHMpO1xuICB9XG4gIGFzeW5jIGdldChpbnN0YW5jZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB3aGVyZSA9IHt9O1xuICAgIGxldCBUYXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICBsZXQgaW5zdGFuY2U7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwic2NvcGVcIikpIHtcbiAgICAgIGlmICghb3B0aW9ucy5zY29wZSkge1xuICAgICAgICBUYXJnZXQgPSBUYXJnZXQudW5zY29wZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFRhcmdldCA9IFRhcmdldC5zY29wZShvcHRpb25zLnNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcInNjaGVtYVwiKSkge1xuICAgICAgVGFyZ2V0ID0gVGFyZ2V0LnNjaGVtYShvcHRpb25zLnNjaGVtYSwgb3B0aW9ucy5zY2hlbWFEZWxpbWl0ZXIpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5zdGFuY2VzKSkge1xuICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZXM7XG4gICAgICBpbnN0YW5jZXMgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZXMpIHtcbiAgICAgIHdoZXJlW3RoaXMudGFyZ2V0S2V5XSA9IHtcbiAgICAgICAgW09wLmluXTogaW5zdGFuY2VzLm1hcCgoX2luc3RhbmNlKSA9PiBfaW5zdGFuY2UuZ2V0KHRoaXMuZm9yZWlnbktleSkpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy50YXJnZXRLZXlJc1ByaW1hcnkgJiYgIW9wdGlvbnMud2hlcmUpIHtcbiAgICAgICAgcmV0dXJuIFRhcmdldC5maW5kQnlQayhpbnN0YW5jZS5nZXQodGhpcy5mb3JlaWduS2V5KSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICB3aGVyZVt0aGlzLnRhcmdldEtleV0gPSBpbnN0YW5jZS5nZXQodGhpcy5mb3JlaWduS2V5KTtcbiAgICAgIG9wdGlvbnMubGltaXQgPSBudWxsO1xuICAgIH1cbiAgICBvcHRpb25zLndoZXJlID0gb3B0aW9ucy53aGVyZSA/IHsgW09wLmFuZF06IFt3aGVyZSwgb3B0aW9ucy53aGVyZV0gfSA6IHdoZXJlO1xuICAgIGlmIChpbnN0YW5jZXMpIHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBUYXJnZXQuZmluZEFsbChvcHRpb25zKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBfaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XG4gICAgICAgIHJlc3VsdFtfaW5zdGFuY2UuZ2V0KHRoaXMuZm9yZWlnbktleSwgeyByYXc6IHRydWUgfSldID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgX2luc3RhbmNlIG9mIHJlc3VsdHMpIHtcbiAgICAgICAgcmVzdWx0W19pbnN0YW5jZS5nZXQodGhpcy50YXJnZXRLZXksIHsgcmF3OiB0cnVlIH0pXSA9IF9pbnN0YW5jZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBUYXJnZXQuZmluZE9uZShvcHRpb25zKTtcbiAgfVxuICBhc3luYyBzZXQoc291cmNlSW5zdGFuY2UsIGFzc29jaWF0ZWRJbnN0YW5jZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHZhbHVlID0gYXNzb2NpYXRlZEluc3RhbmNlO1xuICAgIGlmIChhc3NvY2lhdGVkSW5zdGFuY2UgaW5zdGFuY2VvZiB0aGlzLnRhcmdldCkge1xuICAgICAgdmFsdWUgPSBhc3NvY2lhdGVkSW5zdGFuY2VbdGhpcy50YXJnZXRLZXldO1xuICAgIH1cbiAgICBzb3VyY2VJbnN0YW5jZS5zZXQodGhpcy5mb3JlaWduS2V5LCB2YWx1ZSk7XG4gICAgaWYgKG9wdGlvbnMuc2F2ZSA9PT0gZmFsc2UpXG4gICAgICByZXR1cm47XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGZpZWxkczogW3RoaXMuZm9yZWlnbktleV0sXG4gICAgICBhbGxvd051bGw6IFt0aGlzLmZvcmVpZ25LZXldLFxuICAgICAgYXNzb2NpYXRpb246IHRydWVcbiAgICB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgc291cmNlSW5zdGFuY2Uuc2F2ZShvcHRpb25zKTtcbiAgfVxuICBhc3luYyBjcmVhdGUoc291cmNlSW5zdGFuY2UsIHZhbHVlcywgb3B0aW9ucykge1xuICAgIHZhbHVlcyA9IHZhbHVlcyB8fCB7fTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBuZXdBc3NvY2lhdGVkT2JqZWN0ID0gYXdhaXQgdGhpcy50YXJnZXQuY3JlYXRlKHZhbHVlcywgb3B0aW9ucyk7XG4gICAgYXdhaXQgc291cmNlSW5zdGFuY2VbdGhpcy5hY2Nlc3NvcnMuc2V0XShuZXdBc3NvY2lhdGVkT2JqZWN0LCBvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3QXNzb2NpYXRlZE9iamVjdDtcbiAgfVxuICB2ZXJpZnlBc3NvY2lhdGlvbkFsaWFzKGFsaWFzKSB7XG4gICAgaWYgKHR5cGVvZiBhbGlhcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRoaXMuYXMgPT09IGFsaWFzO1xuICAgIH1cbiAgICBpZiAoYWxpYXMgJiYgYWxpYXMuc2luZ3VsYXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzID09PSBhbGlhcy5zaW5ndWxhcjtcbiAgICB9XG4gICAgcmV0dXJuICF0aGlzLmlzQWxpYXNlZDtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBCZWxvbmdzVG87XG5tb2R1bGUuZXhwb3J0cy5CZWxvbmdzVG8gPSBCZWxvbmdzVG87XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQmVsb25nc1RvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVsb25ncy10by5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/associations/belongs-to.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/associations/has-many.js":
/*!**************************************************************!*\
  !*** ../node_modules/sequelize/lib/associations/has-many.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst Utils = __webpack_require__(/*! ./../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst Helpers = __webpack_require__(/*! ./helpers */ \"(action-browser)/../node_modules/sequelize/lib/associations/helpers.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst Association = __webpack_require__(/*! ./base */ \"(action-browser)/../node_modules/sequelize/lib/associations/base.js\");\nconst Op = __webpack_require__(/*! ../operators */ \"(action-browser)/../node_modules/sequelize/lib/operators.js\");\nclass HasMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    this.associationType = \"HasMany\";\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.isMultiAssociation = true;\n    this.foreignKeyAttribute = {};\n    if (this.options.through) {\n      throw new Error(\"N:M associations are not supported with hasMany. Use belongsToMany instead\");\n    }\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n    if (this.as) {\n      this.isAliased = true;\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize([\n        this.source.options.name.singular,\n        this.source.primaryKeyAttribute\n      ].join(\"_\"));\n    }\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n      this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    }\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n    if (this.source.rawAttributes[this.sourceKey]) {\n      this.sourceKeyAttribute = this.sourceKey;\n      this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    } else {\n      this.sourceKeyAttribute = this.source.primaryKeyAttribute;\n      this.sourceKeyField = this.source.primaryKeyField;\n    }\n    const plural = _.upperFirst(this.options.name.plural);\n    const singular = _.upperFirst(this.options.name.singular);\n    this.associationAccessor = this.as;\n    this.accessors = {\n      get: `get${plural}`,\n      set: `set${plural}`,\n      addMultiple: `add${plural}`,\n      add: `add${singular}`,\n      create: `create${singular}`,\n      remove: `remove${singular}`,\n      removeMultiple: `remove${plural}`,\n      hasSingle: `has${singular}`,\n      hasAll: `has${plural}`,\n      count: `count${plural}`\n    };\n  }\n  _injectAttributes() {\n    const newAttributes = {\n      [this.foreignKey]: __spreadValues({\n        type: this.options.keyType || this.source.rawAttributes[this.sourceKeyAttribute].type,\n        allowNull: true\n      }, this.foreignKeyAttribute)\n    };\n    const constraintOptions = __spreadValues({}, this.options);\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      constraintOptions.onDelete = constraintOptions.onDelete || (target.allowNull ? \"SET NULL\" : \"CASCADE\");\n      constraintOptions.onUpdate = constraintOptions.onUpdate || \"CASCADE\";\n    }\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, constraintOptions, this.sourceKeyField);\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n    this.target.refreshAttributes();\n    this.source.refreshAttributes();\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n  mixin(obj) {\n    const methods = [\"get\", \"count\", \"hasSingle\", \"hasAll\", \"set\", \"add\", \"addMultiple\", \"remove\", \"removeMultiple\", \"create\"];\n    const aliases = {\n      hasSingle: \"has\",\n      hasAll: \"has\",\n      addMultiple: \"add\",\n      removeMultiple: \"remove\"\n    };\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n  async get(instances, options = {}) {\n    const where = {};\n    let Model = this.target;\n    let instance;\n    let values;\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = void 0;\n    }\n    options = __spreadValues({}, options);\n    if (this.scope) {\n      Object.assign(where, this.scope);\n    }\n    if (instances) {\n      values = instances.map((_instance) => _instance.get(this.sourceKey, { raw: true }));\n      if (options.limit && instances.length > 1) {\n        options.groupedLimit = {\n          limit: options.limit,\n          on: this,\n          values\n        };\n        delete options.limit;\n      } else {\n        where[this.foreignKey] = {\n          [Op.in]: values\n        };\n        delete options.groupedLimit;\n      }\n    } else {\n      where[this.foreignKey] = instance.get(this.sourceKey, { raw: true });\n    }\n    options.where = options.where ? { [Op.and]: [where, options.where] } : where;\n    if (Object.prototype.hasOwnProperty.call(options, \"scope\")) {\n      if (!options.scope) {\n        Model = Model.unscoped();\n      } else {\n        Model = Model.scope(options.scope);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"schema\")) {\n      Model = Model.schema(options.schema, options.schemaDelimiter);\n    }\n    const results = await Model.findAll(options);\n    if (instance)\n      return results;\n    const result = {};\n    for (const _instance of instances) {\n      result[_instance.get(this.sourceKey, { raw: true })] = [];\n    }\n    for (const _instance of results) {\n      result[_instance.get(this.foreignKey, { raw: true })].push(_instance);\n    }\n    return result;\n  }\n  async count(instance, options) {\n    options = Utils.cloneDeep(options);\n    options.attributes = [\n      [\n        this.sequelize.fn(\"COUNT\", this.sequelize.col(`${this.target.name}.${this.target.primaryKeyField}`)),\n        \"count\"\n      ]\n    ];\n    options.raw = true;\n    options.plain = true;\n    const result = await this.get(instance, options);\n    return parseInt(result.count, 10);\n  }\n  async has(sourceInstance, targetInstances, options) {\n    const where = {};\n    if (!Array.isArray(targetInstances)) {\n      targetInstances = [targetInstances];\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      scope: false,\n      attributes: [this.target.primaryKeyAttribute],\n      raw: true\n    });\n    where[Op.or] = targetInstances.map((instance) => {\n      if (instance instanceof this.target) {\n        return instance.where();\n      }\n      return {\n        [this.target.primaryKeyAttribute]: instance\n      };\n    });\n    options.where = {\n      [Op.and]: [\n        where,\n        options.where\n      ]\n    };\n    const associatedObjects = await this.get(sourceInstance, options);\n    return associatedObjects.length === targetInstances.length;\n  }\n  async set(sourceInstance, targetInstances, options) {\n    if (targetInstances === null) {\n      targetInstances = [];\n    } else {\n      targetInstances = this.toInstanceArray(targetInstances);\n    }\n    const oldAssociations = await this.get(sourceInstance, __spreadProps(__spreadValues({}, options), { scope: false, raw: true }));\n    const promises = [];\n    const obsoleteAssociations = oldAssociations.filter((old) => !targetInstances.find((obj) => obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]));\n    const unassociatedObjects = targetInstances.filter((obj) => !oldAssociations.find((old) => obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]));\n    let updateWhere;\n    let update;\n    if (obsoleteAssociations.length > 0) {\n      update = {};\n      update[this.foreignKey] = null;\n      updateWhere = {\n        [this.target.primaryKeyAttribute]: obsoleteAssociations.map((associatedObject) => associatedObject[this.target.primaryKeyAttribute])\n      };\n      promises.push(this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), {\n        where: updateWhere\n      })));\n    }\n    if (unassociatedObjects.length > 0) {\n      updateWhere = {};\n      update = {};\n      update[this.foreignKey] = sourceInstance.get(this.sourceKey);\n      Object.assign(update, this.scope);\n      updateWhere[this.target.primaryKeyAttribute] = unassociatedObjects.map((unassociatedObject) => unassociatedObject[this.target.primaryKeyAttribute]);\n      promises.push(this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), {\n        where: updateWhere\n      })));\n    }\n    await Promise.all(promises);\n    return sourceInstance;\n  }\n  async add(sourceInstance, targetInstances, options = {}) {\n    if (!targetInstances)\n      return Promise.resolve();\n    targetInstances = this.toInstanceArray(targetInstances);\n    const update = __spreadValues({\n      [this.foreignKey]: sourceInstance.get(this.sourceKey)\n    }, this.scope);\n    const where = {\n      [this.target.primaryKeyAttribute]: targetInstances.map((unassociatedObject) => unassociatedObject.get(this.target.primaryKeyAttribute))\n    };\n    await this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), { where }));\n    return sourceInstance;\n  }\n  async remove(sourceInstance, targetInstances, options = {}) {\n    const update = {\n      [this.foreignKey]: null\n    };\n    targetInstances = this.toInstanceArray(targetInstances);\n    const where = {\n      [this.foreignKey]: sourceInstance.get(this.sourceKey),\n      [this.target.primaryKeyAttribute]: targetInstances.map((targetInstance) => targetInstance.get(this.target.primaryKeyAttribute))\n    };\n    await this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), { where }));\n    return this;\n  }\n  async create(sourceInstance, values, options = {}) {\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n    if (values === void 0) {\n      values = {};\n    }\n    if (this.scope) {\n      for (const attribute of Object.keys(this.scope)) {\n        values[attribute] = this.scope[attribute];\n        if (options.fields)\n          options.fields.push(attribute);\n      }\n    }\n    values[this.foreignKey] = sourceInstance.get(this.sourceKey);\n    if (options.fields)\n      options.fields.push(this.foreignKey);\n    return await this.target.create(values, options);\n  }\n  verifyAssociationAlias(alias) {\n    if (typeof alias === \"string\") {\n      return this.as === alias;\n    }\n    if (alias && alias.plural) {\n      return this.as === alias.plural;\n    }\n    return !this.isAliased;\n  }\n}\nmodule.exports = HasMany;\nmodule.exports.HasMany = HasMany;\nmodule.exports[\"default\"] = HasMany;\n//# sourceMappingURL=has-many.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvaGFzLW1hbnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLDJFQUFZO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLHlGQUFXO0FBQ25DLFVBQVUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMxQixvQkFBb0IsbUJBQU8sQ0FBQyxtRkFBUTtBQUNwQyxXQUFXLG1CQUFPLENBQUMsaUZBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4Qix5QkFBeUIsT0FBTztBQUNoQyxpQkFBaUIsU0FBUztBQUMxQix1QkFBdUIsU0FBUztBQUNoQyx1QkFBdUIsU0FBUztBQUNoQywrQkFBK0IsT0FBTztBQUN0Qyx1QkFBdUIsU0FBUztBQUNoQyxvQkFBb0IsT0FBTztBQUMzQixxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLFdBQVc7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw4REFBOEQsV0FBVztBQUN6RTtBQUNBLHNDQUFzQyxtQ0FBbUM7QUFDekU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVztBQUN4RDtBQUNBO0FBQ0EsOENBQThDLFdBQVc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsaUJBQWlCLEdBQUcsNEJBQTRCO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDBGQUEwRixjQUFjLHlCQUF5QjtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGNBQWMsT0FBTztBQUNwRztBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsY0FBYyxPQUFPO0FBQ3BHO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIseUJBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Fzc29jaWF0aW9ucy9oYXMtbWFueS5qcz81NDQxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuLy4uL3V0aWxzXCIpO1xuY29uc3QgSGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IEFzc29jaWF0aW9uID0gcmVxdWlyZShcIi4vYmFzZVwiKTtcbmNvbnN0IE9wID0gcmVxdWlyZShcIi4uL29wZXJhdG9yc1wiKTtcbmNsYXNzIEhhc01hbnkgZXh0ZW5kcyBBc3NvY2lhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgc3VwZXIoc291cmNlLCB0YXJnZXQsIG9wdGlvbnMpO1xuICAgIHRoaXMuYXNzb2NpYXRpb25UeXBlID0gXCJIYXNNYW55XCI7XG4gICAgdGhpcy50YXJnZXRBc3NvY2lhdGlvbiA9IG51bGw7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzb3VyY2Uuc2VxdWVsaXplO1xuICAgIHRoaXMuaXNNdWx0aUFzc29jaWF0aW9uID0gdHJ1ZTtcbiAgICB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUgPSB7fTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRocm91Z2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk46TSBhc3NvY2lhdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBoYXNNYW55LiBVc2UgYmVsb25nc1RvTWFueSBpbnN0ZWFkXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1NlbGZBc3NvY2lhdGlvbikge1xuICAgICAgdGhpcy50YXJnZXRBc3NvY2lhdGlvbiA9IHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLmFzKSB7XG4gICAgICB0aGlzLmlzQWxpYXNlZCA9IHRydWU7XG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHRoaXMuYXMpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5uYW1lID0gdGhpcy5hcztcbiAgICAgICAgdGhpcy5hcyA9IHRoaXMuYXMucGx1cmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm5hbWUgPSB7XG4gICAgICAgICAgcGx1cmFsOiB0aGlzLmFzLFxuICAgICAgICAgIHNpbmd1bGFyOiBVdGlscy5zaW5ndWxhcml6ZSh0aGlzLmFzKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzID0gdGhpcy50YXJnZXQub3B0aW9ucy5uYW1lLnBsdXJhbDtcbiAgICAgIHRoaXMub3B0aW9ucy5uYW1lID0gdGhpcy50YXJnZXQub3B0aW9ucy5uYW1lO1xuICAgIH1cbiAgICBpZiAoXy5pc09iamVjdCh0aGlzLm9wdGlvbnMuZm9yZWlnbktleSkpIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZSA9IHRoaXMub3B0aW9ucy5mb3JlaWduS2V5O1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlLm5hbWUgfHwgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlLmZpZWxkTmFtZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5mb3JlaWduS2V5KSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSB0aGlzLm9wdGlvbnMuZm9yZWlnbktleTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmZvcmVpZ25LZXkpIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IFV0aWxzLmNhbWVsaXplKFtcbiAgICAgICAgdGhpcy5zb3VyY2Uub3B0aW9ucy5uYW1lLnNpbmd1bGFyLFxuICAgICAgICB0aGlzLnNvdXJjZS5wcmltYXJ5S2V5QXR0cmlidXRlXG4gICAgICBdLmpvaW4oXCJfXCIpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSkge1xuICAgICAgdGhpcy5pZGVudGlmaWVyRmllbGQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0uZmllbGQgfHwgdGhpcy5mb3JlaWduS2V5O1xuICAgICAgdGhpcy5mb3JlaWduS2V5RmllbGQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0uZmllbGQgfHwgdGhpcy5mb3JlaWduS2V5O1xuICAgIH1cbiAgICB0aGlzLnNvdXJjZUtleSA9IHRoaXMub3B0aW9ucy5zb3VyY2VLZXkgfHwgdGhpcy5zb3VyY2UucHJpbWFyeUtleUF0dHJpYnV0ZTtcbiAgICBpZiAodGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLnNvdXJjZUtleV0pIHtcbiAgICAgIHRoaXMuc291cmNlS2V5QXR0cmlidXRlID0gdGhpcy5zb3VyY2VLZXk7XG4gICAgICB0aGlzLnNvdXJjZUtleUZpZWxkID0gdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLnNvdXJjZUtleV0uZmllbGQgfHwgdGhpcy5zb3VyY2VLZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc291cmNlS2V5QXR0cmlidXRlID0gdGhpcy5zb3VyY2UucHJpbWFyeUtleUF0dHJpYnV0ZTtcbiAgICAgIHRoaXMuc291cmNlS2V5RmllbGQgPSB0aGlzLnNvdXJjZS5wcmltYXJ5S2V5RmllbGQ7XG4gICAgfVxuICAgIGNvbnN0IHBsdXJhbCA9IF8udXBwZXJGaXJzdCh0aGlzLm9wdGlvbnMubmFtZS5wbHVyYWwpO1xuICAgIGNvbnN0IHNpbmd1bGFyID0gXy51cHBlckZpcnN0KHRoaXMub3B0aW9ucy5uYW1lLnNpbmd1bGFyKTtcbiAgICB0aGlzLmFzc29jaWF0aW9uQWNjZXNzb3IgPSB0aGlzLmFzO1xuICAgIHRoaXMuYWNjZXNzb3JzID0ge1xuICAgICAgZ2V0OiBgZ2V0JHtwbHVyYWx9YCxcbiAgICAgIHNldDogYHNldCR7cGx1cmFsfWAsXG4gICAgICBhZGRNdWx0aXBsZTogYGFkZCR7cGx1cmFsfWAsXG4gICAgICBhZGQ6IGBhZGQke3Npbmd1bGFyfWAsXG4gICAgICBjcmVhdGU6IGBjcmVhdGUke3Npbmd1bGFyfWAsXG4gICAgICByZW1vdmU6IGByZW1vdmUke3Npbmd1bGFyfWAsXG4gICAgICByZW1vdmVNdWx0aXBsZTogYHJlbW92ZSR7cGx1cmFsfWAsXG4gICAgICBoYXNTaW5nbGU6IGBoYXMke3Npbmd1bGFyfWAsXG4gICAgICBoYXNBbGw6IGBoYXMke3BsdXJhbH1gLFxuICAgICAgY291bnQ6IGBjb3VudCR7cGx1cmFsfWBcbiAgICB9O1xuICB9XG4gIF9pbmplY3RBdHRyaWJ1dGVzKCkge1xuICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSB7XG4gICAgICBbdGhpcy5mb3JlaWduS2V5XTogX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMua2V5VHlwZSB8fCB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuc291cmNlS2V5QXR0cmlidXRlXS50eXBlLFxuICAgICAgICBhbGxvd051bGw6IHRydWVcbiAgICAgIH0sIHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZSlcbiAgICB9O1xuICAgIGNvbnN0IGNvbnN0cmFpbnRPcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMub3B0aW9ucyk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb25zdHJhaW50cyAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSB8fCBuZXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV07XG4gICAgICBjb25zdHJhaW50T3B0aW9ucy5vbkRlbGV0ZSA9IGNvbnN0cmFpbnRPcHRpb25zLm9uRGVsZXRlIHx8ICh0YXJnZXQuYWxsb3dOdWxsID8gXCJTRVQgTlVMTFwiIDogXCJDQVNDQURFXCIpO1xuICAgICAgY29uc3RyYWludE9wdGlvbnMub25VcGRhdGUgPSBjb25zdHJhaW50T3B0aW9ucy5vblVwZGF0ZSB8fCBcIkNBU0NBREVcIjtcbiAgICB9XG4gICAgSGVscGVycy5hZGRGb3JlaWduS2V5Q29uc3RyYWludHMobmV3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLCB0aGlzLnNvdXJjZSwgdGhpcy50YXJnZXQsIGNvbnN0cmFpbnRPcHRpb25zLCB0aGlzLnNvdXJjZUtleUZpZWxkKTtcbiAgICBVdGlscy5tZXJnZURlZmF1bHRzKHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXMsIG5ld0F0dHJpYnV0ZXMpO1xuICAgIHRoaXMudGFyZ2V0LnJlZnJlc2hBdHRyaWJ1dGVzKCk7XG4gICAgdGhpcy5zb3VyY2UucmVmcmVzaEF0dHJpYnV0ZXMoKTtcbiAgICB0aGlzLmlkZW50aWZpZXJGaWVsZCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XS5maWVsZCB8fCB0aGlzLmZvcmVpZ25LZXk7XG4gICAgdGhpcy5mb3JlaWduS2V5RmllbGQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0uZmllbGQgfHwgdGhpcy5mb3JlaWduS2V5O1xuICAgIHRoaXMuc291cmNlS2V5RmllbGQgPSB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuc291cmNlS2V5XS5maWVsZCB8fCB0aGlzLnNvdXJjZUtleTtcbiAgICBIZWxwZXJzLmNoZWNrTmFtaW5nQ29sbGlzaW9uKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG1peGluKG9iaikge1xuICAgIGNvbnN0IG1ldGhvZHMgPSBbXCJnZXRcIiwgXCJjb3VudFwiLCBcImhhc1NpbmdsZVwiLCBcImhhc0FsbFwiLCBcInNldFwiLCBcImFkZFwiLCBcImFkZE11bHRpcGxlXCIsIFwicmVtb3ZlXCIsIFwicmVtb3ZlTXVsdGlwbGVcIiwgXCJjcmVhdGVcIl07XG4gICAgY29uc3QgYWxpYXNlcyA9IHtcbiAgICAgIGhhc1NpbmdsZTogXCJoYXNcIixcbiAgICAgIGhhc0FsbDogXCJoYXNcIixcbiAgICAgIGFkZE11bHRpcGxlOiBcImFkZFwiLFxuICAgICAgcmVtb3ZlTXVsdGlwbGU6IFwicmVtb3ZlXCJcbiAgICB9O1xuICAgIEhlbHBlcnMubWl4aW5NZXRob2RzKHRoaXMsIG9iaiwgbWV0aG9kcywgYWxpYXNlcyk7XG4gIH1cbiAgYXN5bmMgZ2V0KGluc3RhbmNlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgd2hlcmUgPSB7fTtcbiAgICBsZXQgTW9kZWwgPSB0aGlzLnRhcmdldDtcbiAgICBsZXQgaW5zdGFuY2U7XG4gICAgbGV0IHZhbHVlcztcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5zdGFuY2VzKSkge1xuICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZXM7XG4gICAgICBpbnN0YW5jZXMgPSB2b2lkIDA7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyk7XG4gICAgaWYgKHRoaXMuc2NvcGUpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24od2hlcmUsIHRoaXMuc2NvcGUpO1xuICAgIH1cbiAgICBpZiAoaW5zdGFuY2VzKSB7XG4gICAgICB2YWx1ZXMgPSBpbnN0YW5jZXMubWFwKChfaW5zdGFuY2UpID0+IF9pbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXksIHsgcmF3OiB0cnVlIH0pKTtcbiAgICAgIGlmIChvcHRpb25zLmxpbWl0ICYmIGluc3RhbmNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIG9wdGlvbnMuZ3JvdXBlZExpbWl0ID0ge1xuICAgICAgICAgIGxpbWl0OiBvcHRpb25zLmxpbWl0LFxuICAgICAgICAgIG9uOiB0aGlzLFxuICAgICAgICAgIHZhbHVlc1xuICAgICAgICB9O1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5saW1pdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoZXJlW3RoaXMuZm9yZWlnbktleV0gPSB7XG4gICAgICAgICAgW09wLmluXTogdmFsdWVzXG4gICAgICAgIH07XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmdyb3VwZWRMaW1pdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hlcmVbdGhpcy5mb3JlaWduS2V5XSA9IGluc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSwgeyByYXc6IHRydWUgfSk7XG4gICAgfVxuICAgIG9wdGlvbnMud2hlcmUgPSBvcHRpb25zLndoZXJlID8geyBbT3AuYW5kXTogW3doZXJlLCBvcHRpb25zLndoZXJlXSB9IDogd2hlcmU7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcInNjb3BlXCIpKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuc2NvcGUpIHtcbiAgICAgICAgTW9kZWwgPSBNb2RlbC51bnNjb3BlZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgTW9kZWwgPSBNb2RlbC5zY29wZShvcHRpb25zLnNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcInNjaGVtYVwiKSkge1xuICAgICAgTW9kZWwgPSBNb2RlbC5zY2hlbWEob3B0aW9ucy5zY2hlbWEsIG9wdGlvbnMuc2NoZW1hRGVsaW1pdGVyKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IE1vZGVsLmZpbmRBbGwob3B0aW9ucyk7XG4gICAgaWYgKGluc3RhbmNlKVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBfaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XG4gICAgICByZXN1bHRbX2luc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSwgeyByYXc6IHRydWUgfSldID0gW107XG4gICAgfVxuICAgIGZvciAoY29uc3QgX2luc3RhbmNlIG9mIHJlc3VsdHMpIHtcbiAgICAgIHJlc3VsdFtfaW5zdGFuY2UuZ2V0KHRoaXMuZm9yZWlnbktleSwgeyByYXc6IHRydWUgfSldLnB1c2goX2luc3RhbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyBjb3VudChpbnN0YW5jZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gW1xuICAgICAgW1xuICAgICAgICB0aGlzLnNlcXVlbGl6ZS5mbihcIkNPVU5UXCIsIHRoaXMuc2VxdWVsaXplLmNvbChgJHt0aGlzLnRhcmdldC5uYW1lfS4ke3RoaXMudGFyZ2V0LnByaW1hcnlLZXlGaWVsZH1gKSksXG4gICAgICAgIFwiY291bnRcIlxuICAgICAgXVxuICAgIF07XG4gICAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICAgIG9wdGlvbnMucGxhaW4gPSB0cnVlO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2V0KGluc3RhbmNlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcGFyc2VJbnQocmVzdWx0LmNvdW50LCAxMCk7XG4gIH1cbiAgYXN5bmMgaGFzKHNvdXJjZUluc3RhbmNlLCB0YXJnZXRJbnN0YW5jZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB3aGVyZSA9IHt9O1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0YXJnZXRJbnN0YW5jZXMpKSB7XG4gICAgICB0YXJnZXRJbnN0YW5jZXMgPSBbdGFyZ2V0SW5zdGFuY2VzXTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICBzY29wZTogZmFsc2UsXG4gICAgICBhdHRyaWJ1dGVzOiBbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV0sXG4gICAgICByYXc6IHRydWVcbiAgICB9KTtcbiAgICB3aGVyZVtPcC5vcl0gPSB0YXJnZXRJbnN0YW5jZXMubWFwKChpbnN0YW5jZSkgPT4ge1xuICAgICAgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgdGhpcy50YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLndoZXJlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV06IGluc3RhbmNlXG4gICAgICB9O1xuICAgIH0pO1xuICAgIG9wdGlvbnMud2hlcmUgPSB7XG4gICAgICBbT3AuYW5kXTogW1xuICAgICAgICB3aGVyZSxcbiAgICAgICAgb3B0aW9ucy53aGVyZVxuICAgICAgXVxuICAgIH07XG4gICAgY29uc3QgYXNzb2NpYXRlZE9iamVjdHMgPSBhd2FpdCB0aGlzLmdldChzb3VyY2VJbnN0YW5jZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGFzc29jaWF0ZWRPYmplY3RzLmxlbmd0aCA9PT0gdGFyZ2V0SW5zdGFuY2VzLmxlbmd0aDtcbiAgfVxuICBhc3luYyBzZXQoc291cmNlSW5zdGFuY2UsIHRhcmdldEluc3RhbmNlcywgb3B0aW9ucykge1xuICAgIGlmICh0YXJnZXRJbnN0YW5jZXMgPT09IG51bGwpIHtcbiAgICAgIHRhcmdldEluc3RhbmNlcyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRJbnN0YW5jZXMgPSB0aGlzLnRvSW5zdGFuY2VBcnJheSh0YXJnZXRJbnN0YW5jZXMpO1xuICAgIH1cbiAgICBjb25zdCBvbGRBc3NvY2lhdGlvbnMgPSBhd2FpdCB0aGlzLmdldChzb3VyY2VJbnN0YW5jZSwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgc2NvcGU6IGZhbHNlLCByYXc6IHRydWUgfSkpO1xuICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgY29uc3Qgb2Jzb2xldGVBc3NvY2lhdGlvbnMgPSBvbGRBc3NvY2lhdGlvbnMuZmlsdGVyKChvbGQpID0+ICF0YXJnZXRJbnN0YW5jZXMuZmluZCgob2JqKSA9PiBvYmpbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV0gPT09IG9sZFt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXSkpO1xuICAgIGNvbnN0IHVuYXNzb2NpYXRlZE9iamVjdHMgPSB0YXJnZXRJbnN0YW5jZXMuZmlsdGVyKChvYmopID0+ICFvbGRBc3NvY2lhdGlvbnMuZmluZCgob2xkKSA9PiBvYmpbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV0gPT09IG9sZFt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXSkpO1xuICAgIGxldCB1cGRhdGVXaGVyZTtcbiAgICBsZXQgdXBkYXRlO1xuICAgIGlmIChvYnNvbGV0ZUFzc29jaWF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICB1cGRhdGUgPSB7fTtcbiAgICAgIHVwZGF0ZVt0aGlzLmZvcmVpZ25LZXldID0gbnVsbDtcbiAgICAgIHVwZGF0ZVdoZXJlID0ge1xuICAgICAgICBbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV06IG9ic29sZXRlQXNzb2NpYXRpb25zLm1hcCgoYXNzb2NpYXRlZE9iamVjdCkgPT4gYXNzb2NpYXRlZE9iamVjdFt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXSlcbiAgICAgIH07XG4gICAgICBwcm9taXNlcy5wdXNoKHRoaXMudGFyZ2V0LnVuc2NvcGVkKCkudXBkYXRlKHVwZGF0ZSwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgICAgd2hlcmU6IHVwZGF0ZVdoZXJlXG4gICAgICB9KSkpO1xuICAgIH1cbiAgICBpZiAodW5hc3NvY2lhdGVkT2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICB1cGRhdGVXaGVyZSA9IHt9O1xuICAgICAgdXBkYXRlID0ge307XG4gICAgICB1cGRhdGVbdGhpcy5mb3JlaWduS2V5XSA9IHNvdXJjZUluc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSk7XG4gICAgICBPYmplY3QuYXNzaWduKHVwZGF0ZSwgdGhpcy5zY29wZSk7XG4gICAgICB1cGRhdGVXaGVyZVt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXSA9IHVuYXNzb2NpYXRlZE9iamVjdHMubWFwKCh1bmFzc29jaWF0ZWRPYmplY3QpID0+IHVuYXNzb2NpYXRlZE9iamVjdFt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXSk7XG4gICAgICBwcm9taXNlcy5wdXNoKHRoaXMudGFyZ2V0LnVuc2NvcGVkKCkudXBkYXRlKHVwZGF0ZSwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgICAgd2hlcmU6IHVwZGF0ZVdoZXJlXG4gICAgICB9KSkpO1xuICAgIH1cbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgcmV0dXJuIHNvdXJjZUluc3RhbmNlO1xuICB9XG4gIGFzeW5jIGFkZChzb3VyY2VJbnN0YW5jZSwgdGFyZ2V0SW5zdGFuY2VzLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXRhcmdldEluc3RhbmNlcylcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB0YXJnZXRJbnN0YW5jZXMgPSB0aGlzLnRvSW5zdGFuY2VBcnJheSh0YXJnZXRJbnN0YW5jZXMpO1xuICAgIGNvbnN0IHVwZGF0ZSA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIFt0aGlzLmZvcmVpZ25LZXldOiBzb3VyY2VJbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXkpXG4gICAgfSwgdGhpcy5zY29wZSk7XG4gICAgY29uc3Qgd2hlcmUgPSB7XG4gICAgICBbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV06IHRhcmdldEluc3RhbmNlcy5tYXAoKHVuYXNzb2NpYXRlZE9iamVjdCkgPT4gdW5hc3NvY2lhdGVkT2JqZWN0LmdldCh0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlKSlcbiAgICB9O1xuICAgIGF3YWl0IHRoaXMudGFyZ2V0LnVuc2NvcGVkKCkudXBkYXRlKHVwZGF0ZSwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgd2hlcmUgfSkpO1xuICAgIHJldHVybiBzb3VyY2VJbnN0YW5jZTtcbiAgfVxuICBhc3luYyByZW1vdmUoc291cmNlSW5zdGFuY2UsIHRhcmdldEluc3RhbmNlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdXBkYXRlID0ge1xuICAgICAgW3RoaXMuZm9yZWlnbktleV06IG51bGxcbiAgICB9O1xuICAgIHRhcmdldEluc3RhbmNlcyA9IHRoaXMudG9JbnN0YW5jZUFycmF5KHRhcmdldEluc3RhbmNlcyk7XG4gICAgY29uc3Qgd2hlcmUgPSB7XG4gICAgICBbdGhpcy5mb3JlaWduS2V5XTogc291cmNlSW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5KSxcbiAgICAgIFt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXTogdGFyZ2V0SW5zdGFuY2VzLm1hcCgodGFyZ2V0SW5zdGFuY2UpID0+IHRhcmdldEluc3RhbmNlLmdldCh0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlKSlcbiAgICB9O1xuICAgIGF3YWl0IHRoaXMudGFyZ2V0LnVuc2NvcGVkKCkudXBkYXRlKHVwZGF0ZSwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgd2hlcmUgfSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFzeW5jIGNyZWF0ZShzb3VyY2VJbnN0YW5jZSwgdmFsdWVzLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgZmllbGRzOiBvcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodmFsdWVzID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlcyA9IHt9O1xuICAgIH1cbiAgICBpZiAodGhpcy5zY29wZSkge1xuICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgT2JqZWN0LmtleXModGhpcy5zY29wZSkpIHtcbiAgICAgICAgdmFsdWVzW2F0dHJpYnV0ZV0gPSB0aGlzLnNjb3BlW2F0dHJpYnV0ZV07XG4gICAgICAgIGlmIChvcHRpb25zLmZpZWxkcylcbiAgICAgICAgICBvcHRpb25zLmZpZWxkcy5wdXNoKGF0dHJpYnV0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhbHVlc1t0aGlzLmZvcmVpZ25LZXldID0gc291cmNlSW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5KTtcbiAgICBpZiAob3B0aW9ucy5maWVsZHMpXG4gICAgICBvcHRpb25zLmZpZWxkcy5wdXNoKHRoaXMuZm9yZWlnbktleSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudGFyZ2V0LmNyZWF0ZSh2YWx1ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHZlcmlmeUFzc29jaWF0aW9uQWxpYXMoYWxpYXMpIHtcbiAgICBpZiAodHlwZW9mIGFsaWFzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcyA9PT0gYWxpYXM7XG4gICAgfVxuICAgIGlmIChhbGlhcyAmJiBhbGlhcy5wbHVyYWwpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzID09PSBhbGlhcy5wbHVyYWw7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy5pc0FsaWFzZWQ7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gSGFzTWFueTtcbm1vZHVsZS5leHBvcnRzLkhhc01hbnkgPSBIYXNNYW55O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IEhhc01hbnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXMtbWFueS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/associations/has-many.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/associations/has-one.js":
/*!*************************************************************!*\
  !*** ../node_modules/sequelize/lib/associations/has-one.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst Utils = __webpack_require__(/*! ./../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst Helpers = __webpack_require__(/*! ./helpers */ \"(action-browser)/../node_modules/sequelize/lib/associations/helpers.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst Association = __webpack_require__(/*! ./base */ \"(action-browser)/../node_modules/sequelize/lib/associations/base.js\");\nconst Op = __webpack_require__(/*! ../operators */ \"(action-browser)/../node_modules/sequelize/lib/operators.js\");\nclass HasOne extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    this.associationType = \"HasOne\";\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize([\n        Utils.singularize(this.options.as || this.source.name),\n        this.source.primaryKeyAttribute\n      ].join(\"_\"));\n    }\n    if (this.options.sourceKey && !this.source.rawAttributes[this.options.sourceKey]) {\n      throw new Error(`Unknown attribute \"${this.options.sourceKey}\" passed as sourceKey, define this attribute on model \"${this.source.name}\" first`);\n    }\n    this.sourceKey = this.sourceKeyAttribute = this.options.sourceKey || this.source.primaryKeyAttribute;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    this.sourceKeyIsPrimary = this.sourceKey === this.source.primaryKeyAttribute;\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks;\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    }\n    const singular = _.upperFirst(this.options.name.singular);\n    this.accessors = {\n      get: `get${singular}`,\n      set: `set${singular}`,\n      create: `create${singular}`\n    };\n  }\n  _injectAttributes() {\n    const newAttributes = {\n      [this.foreignKey]: __spreadValues({\n        type: this.options.keyType || this.source.rawAttributes[this.sourceKey].type,\n        allowNull: true\n      }, this.foreignKeyAttribute)\n    };\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (target.allowNull ? \"SET NULL\" : \"CASCADE\");\n      this.options.onUpdate = this.options.onUpdate || \"CASCADE\";\n    }\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, this.options, this.sourceKeyField);\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n    this.target.refreshAttributes();\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n  mixin(obj) {\n    const methods = [\"get\", \"set\", \"create\"];\n    Helpers.mixinMethods(this, obj, methods);\n  }\n  async get(instances, options) {\n    const where = {};\n    let Target = this.target;\n    let instance;\n    options = Utils.cloneDeep(options);\n    if (Object.prototype.hasOwnProperty.call(options, \"scope\")) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"schema\")) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = void 0;\n    }\n    if (instances) {\n      where[this.foreignKey] = {\n        [Op.in]: instances.map((_instance) => _instance.get(this.sourceKey))\n      };\n    } else {\n      where[this.foreignKey] = instance.get(this.sourceKey);\n    }\n    if (this.scope) {\n      Object.assign(where, this.scope);\n    }\n    options.where = options.where ? { [Op.and]: [where, options.where] } : where;\n    if (instances) {\n      const results = await Target.findAll(options);\n      const result = {};\n      for (const _instance of instances) {\n        result[_instance.get(this.sourceKey, { raw: true })] = null;\n      }\n      for (const _instance of results) {\n        result[_instance.get(this.foreignKey, { raw: true })] = _instance;\n      }\n      return result;\n    }\n    return Target.findOne(options);\n  }\n  async set(sourceInstance, associatedInstance, options) {\n    options = __spreadProps(__spreadValues({}, options), { scope: false });\n    const oldInstance = await sourceInstance[this.accessors.get](options);\n    const alreadyAssociated = oldInstance && associatedInstance && this.target.primaryKeyAttributes.every((attribute) => oldInstance.get(attribute, { raw: true }) === (associatedInstance.get ? associatedInstance.get(attribute, { raw: true }) : associatedInstance));\n    if (oldInstance && !alreadyAssociated) {\n      oldInstance[this.foreignKey] = null;\n      await oldInstance.save(__spreadProps(__spreadValues({}, options), {\n        fields: [this.foreignKey],\n        allowNull: [this.foreignKey],\n        association: true\n      }));\n    }\n    if (associatedInstance && !alreadyAssociated) {\n      if (!(associatedInstance instanceof this.target)) {\n        const tmpInstance = {};\n        tmpInstance[this.target.primaryKeyAttribute] = associatedInstance;\n        associatedInstance = this.target.build(tmpInstance, {\n          isNewRecord: false\n        });\n      }\n      Object.assign(associatedInstance, this.scope);\n      associatedInstance.set(this.foreignKey, sourceInstance.get(this.sourceKeyAttribute));\n      return associatedInstance.save(options);\n    }\n    return null;\n  }\n  async create(sourceInstance, values, options) {\n    values = values || {};\n    options = options || {};\n    if (this.scope) {\n      for (const attribute of Object.keys(this.scope)) {\n        values[attribute] = this.scope[attribute];\n        if (options.fields) {\n          options.fields.push(attribute);\n        }\n      }\n    }\n    values[this.foreignKey] = sourceInstance.get(this.sourceKeyAttribute);\n    if (options.fields) {\n      options.fields.push(this.foreignKey);\n    }\n    return await this.target.create(values, options);\n  }\n  verifyAssociationAlias(alias) {\n    if (typeof alias === \"string\") {\n      return this.as === alias;\n    }\n    if (alias && alias.singular) {\n      return this.as === alias.singular;\n    }\n    return !this.isAliased;\n  }\n}\nmodule.exports = HasOne;\n//# sourceMappingURL=has-one.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvaGFzLW9uZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsMkVBQVk7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMseUZBQVc7QUFDbkMsVUFBVSxtQkFBTyxDQUFDLGlFQUFRO0FBQzFCLG9CQUFvQixtQkFBTyxDQUFDLG1GQUFRO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxpRkFBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsdUJBQXVCLHlEQUF5RCxpQkFBaUI7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCLGlCQUFpQixTQUFTO0FBQzFCLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxtQ0FBbUM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsV0FBVztBQUMxRDtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWMsY0FBYztBQUN6RTtBQUNBLHNKQUFzSixXQUFXLG9FQUFvRSxXQUFXO0FBQ2hQO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvaGFzLW9uZS5qcz9kNDNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuLy4uL3V0aWxzXCIpO1xuY29uc3QgSGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IEFzc29jaWF0aW9uID0gcmVxdWlyZShcIi4vYmFzZVwiKTtcbmNvbnN0IE9wID0gcmVxdWlyZShcIi4uL29wZXJhdG9yc1wiKTtcbmNsYXNzIEhhc09uZSBleHRlbmRzIEFzc29jaWF0aW9uIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihzb3VyY2UsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgdGhpcy5hc3NvY2lhdGlvblR5cGUgPSBcIkhhc09uZVwiO1xuICAgIHRoaXMuaXNTaW5nbGVBc3NvY2lhdGlvbiA9IHRydWU7XG4gICAgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlID0ge307XG4gICAgaWYgKHRoaXMuYXMpIHtcbiAgICAgIHRoaXMuaXNBbGlhc2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMub3B0aW9ucy5uYW1lID0ge1xuICAgICAgICBzaW5ndWxhcjogdGhpcy5hc1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcyA9IHRoaXMudGFyZ2V0Lm9wdGlvbnMubmFtZS5zaW5ndWxhcjtcbiAgICAgIHRoaXMub3B0aW9ucy5uYW1lID0gdGhpcy50YXJnZXQub3B0aW9ucy5uYW1lO1xuICAgIH1cbiAgICBpZiAoXy5pc09iamVjdCh0aGlzLm9wdGlvbnMuZm9yZWlnbktleSkpIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZSA9IHRoaXMub3B0aW9ucy5mb3JlaWduS2V5O1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlLm5hbWUgfHwgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlLmZpZWxkTmFtZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5mb3JlaWduS2V5KSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSB0aGlzLm9wdGlvbnMuZm9yZWlnbktleTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmZvcmVpZ25LZXkpIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IFV0aWxzLmNhbWVsaXplKFtcbiAgICAgICAgVXRpbHMuc2luZ3VsYXJpemUodGhpcy5vcHRpb25zLmFzIHx8IHRoaXMuc291cmNlLm5hbWUpLFxuICAgICAgICB0aGlzLnNvdXJjZS5wcmltYXJ5S2V5QXR0cmlidXRlXG4gICAgICBdLmpvaW4oXCJfXCIpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zb3VyY2VLZXkgJiYgIXRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5vcHRpb25zLnNvdXJjZUtleV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhdHRyaWJ1dGUgXCIke3RoaXMub3B0aW9ucy5zb3VyY2VLZXl9XCIgcGFzc2VkIGFzIHNvdXJjZUtleSwgZGVmaW5lIHRoaXMgYXR0cmlidXRlIG9uIG1vZGVsIFwiJHt0aGlzLnNvdXJjZS5uYW1lfVwiIGZpcnN0YCk7XG4gICAgfVxuICAgIHRoaXMuc291cmNlS2V5ID0gdGhpcy5zb3VyY2VLZXlBdHRyaWJ1dGUgPSB0aGlzLm9wdGlvbnMuc291cmNlS2V5IHx8IHRoaXMuc291cmNlLnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgdGhpcy5zb3VyY2VLZXlGaWVsZCA9IHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5zb3VyY2VLZXldLmZpZWxkIHx8IHRoaXMuc291cmNlS2V5O1xuICAgIHRoaXMuc291cmNlS2V5SXNQcmltYXJ5ID0gdGhpcy5zb3VyY2VLZXkgPT09IHRoaXMuc291cmNlLnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgdGhpcy5hc3NvY2lhdGlvbkFjY2Vzc29yID0gdGhpcy5hcztcbiAgICB0aGlzLm9wdGlvbnMudXNlSG9va3MgPSBvcHRpb25zLnVzZUhvb2tzO1xuICAgIGlmICh0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0pIHtcbiAgICAgIHRoaXMuaWRlbnRpZmllckZpZWxkID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLmZpZWxkIHx8IHRoaXMuZm9yZWlnbktleTtcbiAgICB9XG4gICAgY29uc3Qgc2luZ3VsYXIgPSBfLnVwcGVyRmlyc3QodGhpcy5vcHRpb25zLm5hbWUuc2luZ3VsYXIpO1xuICAgIHRoaXMuYWNjZXNzb3JzID0ge1xuICAgICAgZ2V0OiBgZ2V0JHtzaW5ndWxhcn1gLFxuICAgICAgc2V0OiBgc2V0JHtzaW5ndWxhcn1gLFxuICAgICAgY3JlYXRlOiBgY3JlYXRlJHtzaW5ndWxhcn1gXG4gICAgfTtcbiAgfVxuICBfaW5qZWN0QXR0cmlidXRlcygpIHtcbiAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0ge1xuICAgICAgW3RoaXMuZm9yZWlnbktleV06IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgdHlwZTogdGhpcy5vcHRpb25zLmtleVR5cGUgfHwgdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLnNvdXJjZUtleV0udHlwZSxcbiAgICAgICAgYWxsb3dOdWxsOiB0cnVlXG4gICAgICB9LCB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUpXG4gICAgfTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbnN0cmFpbnRzICE9PSBmYWxzZSkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldIHx8IG5ld0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XTtcbiAgICAgIHRoaXMub3B0aW9ucy5vbkRlbGV0ZSA9IHRoaXMub3B0aW9ucy5vbkRlbGV0ZSB8fCAodGFyZ2V0LmFsbG93TnVsbCA/IFwiU0VUIE5VTExcIiA6IFwiQ0FTQ0FERVwiKTtcbiAgICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZSA9IHRoaXMub3B0aW9ucy5vblVwZGF0ZSB8fCBcIkNBU0NBREVcIjtcbiAgICB9XG4gICAgSGVscGVycy5hZGRGb3JlaWduS2V5Q29uc3RyYWludHMobmV3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLCB0aGlzLnNvdXJjZSwgdGhpcy50YXJnZXQsIHRoaXMub3B0aW9ucywgdGhpcy5zb3VyY2VLZXlGaWVsZCk7XG4gICAgVXRpbHMubWVyZ2VEZWZhdWx0cyh0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzLCBuZXdBdHRyaWJ1dGVzKTtcbiAgICB0aGlzLnRhcmdldC5yZWZyZXNoQXR0cmlidXRlcygpO1xuICAgIHRoaXMuaWRlbnRpZmllckZpZWxkID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLmZpZWxkIHx8IHRoaXMuZm9yZWlnbktleTtcbiAgICBIZWxwZXJzLmNoZWNrTmFtaW5nQ29sbGlzaW9uKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG1peGluKG9iaikge1xuICAgIGNvbnN0IG1ldGhvZHMgPSBbXCJnZXRcIiwgXCJzZXRcIiwgXCJjcmVhdGVcIl07XG4gICAgSGVscGVycy5taXhpbk1ldGhvZHModGhpcywgb2JqLCBtZXRob2RzKTtcbiAgfVxuICBhc3luYyBnZXQoaW5zdGFuY2VzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgd2hlcmUgPSB7fTtcbiAgICBsZXQgVGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgbGV0IGluc3RhbmNlO1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcInNjb3BlXCIpKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuc2NvcGUpIHtcbiAgICAgICAgVGFyZ2V0ID0gVGFyZ2V0LnVuc2NvcGVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBUYXJnZXQgPSBUYXJnZXQuc2NvcGUob3B0aW9ucy5zY29wZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJzY2hlbWFcIikpIHtcbiAgICAgIFRhcmdldCA9IFRhcmdldC5zY2hlbWEob3B0aW9ucy5zY2hlbWEsIG9wdGlvbnMuc2NoZW1hRGVsaW1pdGVyKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGluc3RhbmNlcykpIHtcbiAgICAgIGluc3RhbmNlID0gaW5zdGFuY2VzO1xuICAgICAgaW5zdGFuY2VzID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoaW5zdGFuY2VzKSB7XG4gICAgICB3aGVyZVt0aGlzLmZvcmVpZ25LZXldID0ge1xuICAgICAgICBbT3AuaW5dOiBpbnN0YW5jZXMubWFwKChfaW5zdGFuY2UpID0+IF9pbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXkpKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hlcmVbdGhpcy5mb3JlaWduS2V5XSA9IGluc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNjb3BlKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHdoZXJlLCB0aGlzLnNjb3BlKTtcbiAgICB9XG4gICAgb3B0aW9ucy53aGVyZSA9IG9wdGlvbnMud2hlcmUgPyB7IFtPcC5hbmRdOiBbd2hlcmUsIG9wdGlvbnMud2hlcmVdIH0gOiB3aGVyZTtcbiAgICBpZiAoaW5zdGFuY2VzKSB7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgVGFyZ2V0LmZpbmRBbGwob3B0aW9ucyk7XG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgX2luc3RhbmNlIG9mIGluc3RhbmNlcykge1xuICAgICAgICByZXN1bHRbX2luc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSwgeyByYXc6IHRydWUgfSldID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgX2luc3RhbmNlIG9mIHJlc3VsdHMpIHtcbiAgICAgICAgcmVzdWx0W19pbnN0YW5jZS5nZXQodGhpcy5mb3JlaWduS2V5LCB7IHJhdzogdHJ1ZSB9KV0gPSBfaW5zdGFuY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gVGFyZ2V0LmZpbmRPbmUob3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgc2V0KHNvdXJjZUluc3RhbmNlLCBhc3NvY2lhdGVkSW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgc2NvcGU6IGZhbHNlIH0pO1xuICAgIGNvbnN0IG9sZEluc3RhbmNlID0gYXdhaXQgc291cmNlSW5zdGFuY2VbdGhpcy5hY2Nlc3NvcnMuZ2V0XShvcHRpb25zKTtcbiAgICBjb25zdCBhbHJlYWR5QXNzb2NpYXRlZCA9IG9sZEluc3RhbmNlICYmIGFzc29jaWF0ZWRJbnN0YW5jZSAmJiB0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlcy5ldmVyeSgoYXR0cmlidXRlKSA9PiBvbGRJbnN0YW5jZS5nZXQoYXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KSA9PT0gKGFzc29jaWF0ZWRJbnN0YW5jZS5nZXQgPyBhc3NvY2lhdGVkSW5zdGFuY2UuZ2V0KGF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSkgOiBhc3NvY2lhdGVkSW5zdGFuY2UpKTtcbiAgICBpZiAob2xkSW5zdGFuY2UgJiYgIWFscmVhZHlBc3NvY2lhdGVkKSB7XG4gICAgICBvbGRJbnN0YW5jZVt0aGlzLmZvcmVpZ25LZXldID0gbnVsbDtcbiAgICAgIGF3YWl0IG9sZEluc3RhbmNlLnNhdmUoX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgICAgZmllbGRzOiBbdGhpcy5mb3JlaWduS2V5XSxcbiAgICAgICAgYWxsb3dOdWxsOiBbdGhpcy5mb3JlaWduS2V5XSxcbiAgICAgICAgYXNzb2NpYXRpb246IHRydWVcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKGFzc29jaWF0ZWRJbnN0YW5jZSAmJiAhYWxyZWFkeUFzc29jaWF0ZWQpIHtcbiAgICAgIGlmICghKGFzc29jaWF0ZWRJbnN0YW5jZSBpbnN0YW5jZW9mIHRoaXMudGFyZ2V0KSkge1xuICAgICAgICBjb25zdCB0bXBJbnN0YW5jZSA9IHt9O1xuICAgICAgICB0bXBJbnN0YW5jZVt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXSA9IGFzc29jaWF0ZWRJbnN0YW5jZTtcbiAgICAgICAgYXNzb2NpYXRlZEluc3RhbmNlID0gdGhpcy50YXJnZXQuYnVpbGQodG1wSW5zdGFuY2UsIHtcbiAgICAgICAgICBpc05ld1JlY29yZDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBPYmplY3QuYXNzaWduKGFzc29jaWF0ZWRJbnN0YW5jZSwgdGhpcy5zY29wZSk7XG4gICAgICBhc3NvY2lhdGVkSW5zdGFuY2Uuc2V0KHRoaXMuZm9yZWlnbktleSwgc291cmNlSW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5QXR0cmlidXRlKSk7XG4gICAgICByZXR1cm4gYXNzb2NpYXRlZEluc3RhbmNlLnNhdmUob3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGFzeW5jIGNyZWF0ZShzb3VyY2VJbnN0YW5jZSwgdmFsdWVzLCBvcHRpb25zKSB7XG4gICAgdmFsdWVzID0gdmFsdWVzIHx8IHt9O1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICh0aGlzLnNjb3BlKSB7XG4gICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBPYmplY3Qua2V5cyh0aGlzLnNjb3BlKSkge1xuICAgICAgICB2YWx1ZXNbYXR0cmlidXRlXSA9IHRoaXMuc2NvcGVbYXR0cmlidXRlXTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZmllbGRzKSB7XG4gICAgICAgICAgb3B0aW9ucy5maWVsZHMucHVzaChhdHRyaWJ1dGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhbHVlc1t0aGlzLmZvcmVpZ25LZXldID0gc291cmNlSW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5QXR0cmlidXRlKTtcbiAgICBpZiAob3B0aW9ucy5maWVsZHMpIHtcbiAgICAgIG9wdGlvbnMuZmllbGRzLnB1c2godGhpcy5mb3JlaWduS2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudGFyZ2V0LmNyZWF0ZSh2YWx1ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHZlcmlmeUFzc29jaWF0aW9uQWxpYXMoYWxpYXMpIHtcbiAgICBpZiAodHlwZW9mIGFsaWFzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcyA9PT0gYWxpYXM7XG4gICAgfVxuICAgIGlmIChhbGlhcyAmJiBhbGlhcy5zaW5ndWxhcikge1xuICAgICAgcmV0dXJuIHRoaXMuYXMgPT09IGFsaWFzLnNpbmd1bGFyO1xuICAgIH1cbiAgICByZXR1cm4gIXRoaXMuaXNBbGlhc2VkO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IEhhc09uZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhcy1vbmUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/associations/has-one.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/associations/helpers.js":
/*!*************************************************************!*\
  !*** ../node_modules/sequelize/lib/associations/helpers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nfunction checkNamingCollision(association) {\n  if (Object.prototype.hasOwnProperty.call(association.source.rawAttributes, association.as)) {\n    throw new Error(`Naming collision between attribute '${association.as}' and association '${association.as}' on model ${association.source.name}. To remedy this, change either foreignKey or as in your association definition`);\n  }\n}\nexports.checkNamingCollision = checkNamingCollision;\nfunction addForeignKeyConstraints(newAttribute, source, target, options, key) {\n  if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {\n    const primaryKeys = Object.keys(source.primaryKeys).map((primaryKeyAttribute) => source.rawAttributes[primaryKeyAttribute].field || primaryKeyAttribute);\n    if (primaryKeys.length === 1 || !primaryKeys.includes(key)) {\n      newAttribute.references = {\n        model: source.getTableName(),\n        key: key || primaryKeys[0]\n      };\n      newAttribute.onDelete = options.onDelete;\n      newAttribute.onUpdate = options.onUpdate;\n    }\n  }\n}\nexports.addForeignKeyConstraints = addForeignKeyConstraints;\nfunction mixinMethods(association, obj, methods, aliases) {\n  aliases = aliases || {};\n  for (const method of methods) {\n    if (!Object.prototype.hasOwnProperty.call(obj, association.accessors[method])) {\n      const realMethod = aliases[method] || method;\n      obj[association.accessors[method]] = function() {\n        return association[realMethod](this, ...Array.from(arguments));\n      };\n    }\n  }\n}\nexports.mixinMethods = mixinMethods;\n//# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSwyREFBMkQsZUFBZSxxQkFBcUIsZUFBZSxhQUFhLHdCQUF3QjtBQUNuSjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvYXNzb2NpYXRpb25zL2hlbHBlcnMuanM/ZmZkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGNoZWNrTmFtaW5nQ29sbGlzaW9uKGFzc29jaWF0aW9uKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXNzb2NpYXRpb24uc291cmNlLnJhd0F0dHJpYnV0ZXMsIGFzc29jaWF0aW9uLmFzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTmFtaW5nIGNvbGxpc2lvbiBiZXR3ZWVuIGF0dHJpYnV0ZSAnJHthc3NvY2lhdGlvbi5hc30nIGFuZCBhc3NvY2lhdGlvbiAnJHthc3NvY2lhdGlvbi5hc30nIG9uIG1vZGVsICR7YXNzb2NpYXRpb24uc291cmNlLm5hbWV9LiBUbyByZW1lZHkgdGhpcywgY2hhbmdlIGVpdGhlciBmb3JlaWduS2V5IG9yIGFzIGluIHlvdXIgYXNzb2NpYXRpb24gZGVmaW5pdGlvbmApO1xuICB9XG59XG5leHBvcnRzLmNoZWNrTmFtaW5nQ29sbGlzaW9uID0gY2hlY2tOYW1pbmdDb2xsaXNpb247XG5mdW5jdGlvbiBhZGRGb3JlaWduS2V5Q29uc3RyYWludHMobmV3QXR0cmlidXRlLCBzb3VyY2UsIHRhcmdldCwgb3B0aW9ucywga2V5KSB7XG4gIGlmIChvcHRpb25zLmZvcmVpZ25LZXlDb25zdHJhaW50IHx8IG9wdGlvbnMub25EZWxldGUgfHwgb3B0aW9ucy5vblVwZGF0ZSkge1xuICAgIGNvbnN0IHByaW1hcnlLZXlzID0gT2JqZWN0LmtleXMoc291cmNlLnByaW1hcnlLZXlzKS5tYXAoKHByaW1hcnlLZXlBdHRyaWJ1dGUpID0+IHNvdXJjZS5yYXdBdHRyaWJ1dGVzW3ByaW1hcnlLZXlBdHRyaWJ1dGVdLmZpZWxkIHx8IHByaW1hcnlLZXlBdHRyaWJ1dGUpO1xuICAgIGlmIChwcmltYXJ5S2V5cy5sZW5ndGggPT09IDEgfHwgIXByaW1hcnlLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIG5ld0F0dHJpYnV0ZS5yZWZlcmVuY2VzID0ge1xuICAgICAgICBtb2RlbDogc291cmNlLmdldFRhYmxlTmFtZSgpLFxuICAgICAgICBrZXk6IGtleSB8fCBwcmltYXJ5S2V5c1swXVxuICAgICAgfTtcbiAgICAgIG5ld0F0dHJpYnV0ZS5vbkRlbGV0ZSA9IG9wdGlvbnMub25EZWxldGU7XG4gICAgICBuZXdBdHRyaWJ1dGUub25VcGRhdGUgPSBvcHRpb25zLm9uVXBkYXRlO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0cy5hZGRGb3JlaWduS2V5Q29uc3RyYWludHMgPSBhZGRGb3JlaWduS2V5Q29uc3RyYWludHM7XG5mdW5jdGlvbiBtaXhpbk1ldGhvZHMoYXNzb2NpYXRpb24sIG9iaiwgbWV0aG9kcywgYWxpYXNlcykge1xuICBhbGlhc2VzID0gYWxpYXNlcyB8fCB7fTtcbiAgZm9yIChjb25zdCBtZXRob2Qgb2YgbWV0aG9kcykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgYXNzb2NpYXRpb24uYWNjZXNzb3JzW21ldGhvZF0pKSB7XG4gICAgICBjb25zdCByZWFsTWV0aG9kID0gYWxpYXNlc1ttZXRob2RdIHx8IG1ldGhvZDtcbiAgICAgIG9ialthc3NvY2lhdGlvbi5hY2Nlc3NvcnNbbWV0aG9kXV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFzc29jaWF0aW9uW3JlYWxNZXRob2RdKHRoaXMsIC4uLkFycmF5LmZyb20oYXJndW1lbnRzKSk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuZXhwb3J0cy5taXhpbk1ldGhvZHMgPSBtaXhpbk1ldGhvZHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/associations/helpers.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/associations/index.js":
/*!***********************************************************!*\
  !*** ../node_modules/sequelize/lib/associations/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Association = __webpack_require__(/*! ./base */ \"(action-browser)/../node_modules/sequelize/lib/associations/base.js\");\nAssociation.BelongsTo = __webpack_require__(/*! ./belongs-to */ \"(action-browser)/../node_modules/sequelize/lib/associations/belongs-to.js\");\nAssociation.HasOne = __webpack_require__(/*! ./has-one */ \"(action-browser)/../node_modules/sequelize/lib/associations/has-one.js\");\nAssociation.HasMany = __webpack_require__(/*! ./has-many */ \"(action-browser)/../node_modules/sequelize/lib/associations/has-many.js\");\nAssociation.BelongsToMany = __webpack_require__(/*! ./belongs-to-many */ \"(action-browser)/../node_modules/sequelize/lib/associations/belongs-to-many.js\");\nmodule.exports = Association;\nmodule.exports[\"default\"] = Association;\nmodule.exports.Association = Association;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixvQkFBb0IsbUJBQU8sQ0FBQyxtRkFBUTtBQUNwQyx3QkFBd0IsbUJBQU8sQ0FBQywrRkFBYztBQUM5QyxxQkFBcUIsbUJBQU8sQ0FBQyx5RkFBVztBQUN4QyxzQkFBc0IsbUJBQU8sQ0FBQywyRkFBWTtBQUMxQyw0QkFBNEIsbUJBQU8sQ0FBQyx5R0FBbUI7QUFDdkQ7QUFDQSx5QkFBc0I7QUFDdEIsMEJBQTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Fzc29jaWF0aW9ucy9pbmRleC5qcz9kZGM3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgQXNzb2NpYXRpb24gPSByZXF1aXJlKFwiLi9iYXNlXCIpO1xuQXNzb2NpYXRpb24uQmVsb25nc1RvID0gcmVxdWlyZShcIi4vYmVsb25ncy10b1wiKTtcbkFzc29jaWF0aW9uLkhhc09uZSA9IHJlcXVpcmUoXCIuL2hhcy1vbmVcIik7XG5Bc3NvY2lhdGlvbi5IYXNNYW55ID0gcmVxdWlyZShcIi4vaGFzLW1hbnlcIik7XG5Bc3NvY2lhdGlvbi5CZWxvbmdzVG9NYW55ID0gcmVxdWlyZShcIi4vYmVsb25ncy10by1tYW55XCIpO1xubW9kdWxlLmV4cG9ydHMgPSBBc3NvY2lhdGlvbjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBBc3NvY2lhdGlvbjtcbm1vZHVsZS5leHBvcnRzLkFzc29jaWF0aW9uID0gQXNzb2NpYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/associations/index.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/associations/mixin.js":
/*!***********************************************************!*\
  !*** ../node_modules/sequelize/lib/associations/mixin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst HasOne = __webpack_require__(/*! ./has-one */ \"(action-browser)/../node_modules/sequelize/lib/associations/has-one.js\");\nconst HasMany = __webpack_require__(/*! ./has-many */ \"(action-browser)/../node_modules/sequelize/lib/associations/has-many.js\");\nconst BelongsToMany = __webpack_require__(/*! ./belongs-to-many */ \"(action-browser)/../node_modules/sequelize/lib/associations/belongs-to-many.js\");\nconst BelongsTo = __webpack_require__(/*! ./belongs-to */ \"(action-browser)/../node_modules/sequelize/lib/associations/belongs-to.js\");\nfunction isModel(model, sequelize) {\n  return model && model.prototype && model.prototype instanceof sequelize.Sequelize.Model;\n}\nconst Mixin = {\n  hasMany(target, options = {}) {\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(`${this.name}.hasMany called with something that's not a subclass of Sequelize.Model`);\n    }\n    const source = this;\n    options.hooks = options.hooks === void 0 ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    Object.assign(options, _.omit(source.options, [\"hooks\"]));\n    if (options.useHooks) {\n      this.runHooks(\"beforeAssociate\", { source, target, type: HasMany }, options);\n    }\n    const association = new HasMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n    association._injectAttributes();\n    association.mixin(source.prototype);\n    if (options.useHooks) {\n      this.runHooks(\"afterAssociate\", { source, target, type: HasMany, association }, options);\n    }\n    return association;\n  },\n  belongsToMany(target, options = {}) {\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(`${this.name}.belongsToMany called with something that's not a subclass of Sequelize.Model`);\n    }\n    const source = this;\n    options.hooks = options.hooks === void 0 ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    options.timestamps = options.timestamps === void 0 ? this.sequelize.options.timestamps : options.timestamps;\n    Object.assign(options, _.omit(source.options, [\"hooks\", \"timestamps\", \"scopes\", \"defaultScope\"]));\n    if (options.useHooks) {\n      this.runHooks(\"beforeAssociate\", { source, target, type: BelongsToMany }, options);\n    }\n    const association = new BelongsToMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n    association._injectAttributes();\n    association.mixin(source.prototype);\n    if (options.useHooks) {\n      this.runHooks(\"afterAssociate\", { source, target, type: BelongsToMany, association }, options);\n    }\n    return association;\n  },\n  getAssociations(target) {\n    return Object.values(this.associations).filter((association) => association.target.name === target.name);\n  },\n  getAssociationForAlias(target, alias) {\n    return this.getAssociations(target).find((association) => association.verifyAssociationAlias(alias)) || null;\n  }\n};\nfunction singleLinked(Type) {\n  return function(target, options = {}) {\n    const source = this;\n    if (!isModel(target, source.sequelize)) {\n      throw new Error(`${source.name}.${_.lowerFirst(Type.name)} called with something that's not a subclass of Sequelize.Model`);\n    }\n    options.hooks = options.hooks === void 0 ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    if (options.useHooks) {\n      source.runHooks(\"beforeAssociate\", { source, target, type: Type }, options);\n    }\n    const association = new Type(source, target, Object.assign(options, source.options));\n    source.associations[association.associationAccessor] = association;\n    association._injectAttributes();\n    association.mixin(source.prototype);\n    if (options.useHooks) {\n      source.runHooks(\"afterAssociate\", { source, target, type: Type, association }, options);\n    }\n    return association;\n  };\n}\nMixin.hasOne = singleLinked(HasOne);\nMixin.belongsTo = singleLinked(BelongsTo);\nmodule.exports = Mixin;\nmodule.exports.Mixin = Mixin;\nmodule.exports[\"default\"] = Mixin;\n//# sourceMappingURL=mixin.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvbWl4aW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixVQUFVLG1CQUFPLENBQUMsaUVBQVE7QUFDMUIsZUFBZSxtQkFBTyxDQUFDLHlGQUFXO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLDJGQUFZO0FBQ3BDLHNCQUFzQixtQkFBTyxDQUFDLHlHQUFtQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQywrRkFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywrQkFBK0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDRDQUE0QztBQUNwRjtBQUNBO0FBQ0EsR0FBRztBQUNILG9DQUFvQztBQUNwQztBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHFDQUFxQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0RBQWtEO0FBQzFGO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWSxHQUFHLHlCQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw0QkFBNEI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHlDQUF5QztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQix5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvYXNzb2NpYXRpb25zL21peGluLmpzPzg5NzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IEhhc09uZSA9IHJlcXVpcmUoXCIuL2hhcy1vbmVcIik7XG5jb25zdCBIYXNNYW55ID0gcmVxdWlyZShcIi4vaGFzLW1hbnlcIik7XG5jb25zdCBCZWxvbmdzVG9NYW55ID0gcmVxdWlyZShcIi4vYmVsb25ncy10by1tYW55XCIpO1xuY29uc3QgQmVsb25nc1RvID0gcmVxdWlyZShcIi4vYmVsb25ncy10b1wiKTtcbmZ1bmN0aW9uIGlzTW9kZWwobW9kZWwsIHNlcXVlbGl6ZSkge1xuICByZXR1cm4gbW9kZWwgJiYgbW9kZWwucHJvdG90eXBlICYmIG1vZGVsLnByb3RvdHlwZSBpbnN0YW5jZW9mIHNlcXVlbGl6ZS5TZXF1ZWxpemUuTW9kZWw7XG59XG5jb25zdCBNaXhpbiA9IHtcbiAgaGFzTWFueSh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNNb2RlbCh0YXJnZXQsIHRoaXMuc2VxdWVsaXplKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMubmFtZX0uaGFzTWFueSBjYWxsZWQgd2l0aCBzb21ldGhpbmcgdGhhdCdzIG5vdCBhIHN1YmNsYXNzIG9mIFNlcXVlbGl6ZS5Nb2RlbGApO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzO1xuICAgIG9wdGlvbnMuaG9va3MgPSBvcHRpb25zLmhvb2tzID09PSB2b2lkIDAgPyBmYWxzZSA6IEJvb2xlYW4ob3B0aW9ucy5ob29rcyk7XG4gICAgb3B0aW9ucy51c2VIb29rcyA9IG9wdGlvbnMuaG9va3M7XG4gICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBfLm9taXQoc291cmNlLm9wdGlvbnMsIFtcImhvb2tzXCJdKSk7XG4gICAgaWYgKG9wdGlvbnMudXNlSG9va3MpIHtcbiAgICAgIHRoaXMucnVuSG9va3MoXCJiZWZvcmVBc3NvY2lhdGVcIiwgeyBzb3VyY2UsIHRhcmdldCwgdHlwZTogSGFzTWFueSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgYXNzb2NpYXRpb24gPSBuZXcgSGFzTWFueShzb3VyY2UsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgc291cmNlLmFzc29jaWF0aW9uc1thc3NvY2lhdGlvbi5hc3NvY2lhdGlvbkFjY2Vzc29yXSA9IGFzc29jaWF0aW9uO1xuICAgIGFzc29jaWF0aW9uLl9pbmplY3RBdHRyaWJ1dGVzKCk7XG4gICAgYXNzb2NpYXRpb24ubWl4aW4oc291cmNlLnByb3RvdHlwZSk7XG4gICAgaWYgKG9wdGlvbnMudXNlSG9va3MpIHtcbiAgICAgIHRoaXMucnVuSG9va3MoXCJhZnRlckFzc29jaWF0ZVwiLCB7IHNvdXJjZSwgdGFyZ2V0LCB0eXBlOiBIYXNNYW55LCBhc3NvY2lhdGlvbiB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc29jaWF0aW9uO1xuICB9LFxuICBiZWxvbmdzVG9NYW55KHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc01vZGVsKHRhcmdldCwgdGhpcy5zZXF1ZWxpemUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5uYW1lfS5iZWxvbmdzVG9NYW55IGNhbGxlZCB3aXRoIHNvbWV0aGluZyB0aGF0J3Mgbm90IGEgc3ViY2xhc3Mgb2YgU2VxdWVsaXplLk1vZGVsYCk7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXM7XG4gICAgb3B0aW9ucy5ob29rcyA9IG9wdGlvbnMuaG9va3MgPT09IHZvaWQgMCA/IGZhbHNlIDogQm9vbGVhbihvcHRpb25zLmhvb2tzKTtcbiAgICBvcHRpb25zLnVzZUhvb2tzID0gb3B0aW9ucy5ob29rcztcbiAgICBvcHRpb25zLnRpbWVzdGFtcHMgPSBvcHRpb25zLnRpbWVzdGFtcHMgPT09IHZvaWQgMCA/IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMudGltZXN0YW1wcyA6IG9wdGlvbnMudGltZXN0YW1wcztcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIF8ub21pdChzb3VyY2Uub3B0aW9ucywgW1wiaG9va3NcIiwgXCJ0aW1lc3RhbXBzXCIsIFwic2NvcGVzXCIsIFwiZGVmYXVsdFNjb3BlXCJdKSk7XG4gICAgaWYgKG9wdGlvbnMudXNlSG9va3MpIHtcbiAgICAgIHRoaXMucnVuSG9va3MoXCJiZWZvcmVBc3NvY2lhdGVcIiwgeyBzb3VyY2UsIHRhcmdldCwgdHlwZTogQmVsb25nc1RvTWFueSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgYXNzb2NpYXRpb24gPSBuZXcgQmVsb25nc1RvTWFueShzb3VyY2UsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgc291cmNlLmFzc29jaWF0aW9uc1thc3NvY2lhdGlvbi5hc3NvY2lhdGlvbkFjY2Vzc29yXSA9IGFzc29jaWF0aW9uO1xuICAgIGFzc29jaWF0aW9uLl9pbmplY3RBdHRyaWJ1dGVzKCk7XG4gICAgYXNzb2NpYXRpb24ubWl4aW4oc291cmNlLnByb3RvdHlwZSk7XG4gICAgaWYgKG9wdGlvbnMudXNlSG9va3MpIHtcbiAgICAgIHRoaXMucnVuSG9va3MoXCJhZnRlckFzc29jaWF0ZVwiLCB7IHNvdXJjZSwgdGFyZ2V0LCB0eXBlOiBCZWxvbmdzVG9NYW55LCBhc3NvY2lhdGlvbiB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc29jaWF0aW9uO1xuICB9LFxuICBnZXRBc3NvY2lhdGlvbnModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5hc3NvY2lhdGlvbnMpLmZpbHRlcigoYXNzb2NpYXRpb24pID0+IGFzc29jaWF0aW9uLnRhcmdldC5uYW1lID09PSB0YXJnZXQubmFtZSk7XG4gIH0sXG4gIGdldEFzc29jaWF0aW9uRm9yQWxpYXModGFyZ2V0LCBhbGlhcykge1xuICAgIHJldHVybiB0aGlzLmdldEFzc29jaWF0aW9ucyh0YXJnZXQpLmZpbmQoKGFzc29jaWF0aW9uKSA9PiBhc3NvY2lhdGlvbi52ZXJpZnlBc3NvY2lhdGlvbkFsaWFzKGFsaWFzKSkgfHwgbnVsbDtcbiAgfVxufTtcbmZ1bmN0aW9uIHNpbmdsZUxpbmtlZChUeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXM7XG4gICAgaWYgKCFpc01vZGVsKHRhcmdldCwgc291cmNlLnNlcXVlbGl6ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtzb3VyY2UubmFtZX0uJHtfLmxvd2VyRmlyc3QoVHlwZS5uYW1lKX0gY2FsbGVkIHdpdGggc29tZXRoaW5nIHRoYXQncyBub3QgYSBzdWJjbGFzcyBvZiBTZXF1ZWxpemUuTW9kZWxgKTtcbiAgICB9XG4gICAgb3B0aW9ucy5ob29rcyA9IG9wdGlvbnMuaG9va3MgPT09IHZvaWQgMCA/IGZhbHNlIDogQm9vbGVhbihvcHRpb25zLmhvb2tzKTtcbiAgICBvcHRpb25zLnVzZUhvb2tzID0gb3B0aW9ucy5ob29rcztcbiAgICBpZiAob3B0aW9ucy51c2VIb29rcykge1xuICAgICAgc291cmNlLnJ1bkhvb2tzKFwiYmVmb3JlQXNzb2NpYXRlXCIsIHsgc291cmNlLCB0YXJnZXQsIHR5cGU6IFR5cGUgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IGFzc29jaWF0aW9uID0gbmV3IFR5cGUoc291cmNlLCB0YXJnZXQsIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgc291cmNlLm9wdGlvbnMpKTtcbiAgICBzb3VyY2UuYXNzb2NpYXRpb25zW2Fzc29jaWF0aW9uLmFzc29jaWF0aW9uQWNjZXNzb3JdID0gYXNzb2NpYXRpb247XG4gICAgYXNzb2NpYXRpb24uX2luamVjdEF0dHJpYnV0ZXMoKTtcbiAgICBhc3NvY2lhdGlvbi5taXhpbihzb3VyY2UucHJvdG90eXBlKTtcbiAgICBpZiAob3B0aW9ucy51c2VIb29rcykge1xuICAgICAgc291cmNlLnJ1bkhvb2tzKFwiYWZ0ZXJBc3NvY2lhdGVcIiwgeyBzb3VyY2UsIHRhcmdldCwgdHlwZTogVHlwZSwgYXNzb2NpYXRpb24gfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBhc3NvY2lhdGlvbjtcbiAgfTtcbn1cbk1peGluLmhhc09uZSA9IHNpbmdsZUxpbmtlZChIYXNPbmUpO1xuTWl4aW4uYmVsb25nc1RvID0gc2luZ2xlTGlua2VkKEJlbG9uZ3NUbyk7XG5tb2R1bGUuZXhwb3J0cyA9IE1peGluO1xubW9kdWxlLmV4cG9ydHMuTWl4aW4gPSBNaXhpbjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBNaXhpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1peGluLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/associations/mixin.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/data-types.js":
/*!***************************************************!*\
  !*** ../node_modules/sequelize/lib/data-types.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst util = __webpack_require__(/*! util */ \"util\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst wkx = __webpack_require__(/*! wkx */ \"(action-browser)/../node_modules/wkx/lib/wkx.js\");\nconst sequelizeErrors = __webpack_require__(/*! ./errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst Validator = (__webpack_require__(/*! ./utils/validator-extras */ \"(action-browser)/../node_modules/sequelize/lib/utils/validator-extras.js\").validator);\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(action-browser)/../node_modules/moment-timezone/index.js\");\nconst moment = __webpack_require__(/*! moment */ \"(action-browser)/../node_modules/moment/moment.js\");\nconst { logger } = __webpack_require__(/*! ./utils/logger */ \"(action-browser)/../node_modules/sequelize/lib/utils/logger.js\");\nconst warnings = {};\nconst { classToInvokable } = __webpack_require__(/*! ./utils/class-to-invokable */ \"(action-browser)/../node_modules/sequelize/lib/utils/class-to-invokable.js\");\nconst { joinSQLFragments } = __webpack_require__(/*! ./utils/join-sql-fragments */ \"(action-browser)/../node_modules/sequelize/lib/utils/join-sql-fragments.js\");\nclass ABSTRACT {\n  toString(options) {\n    return this.toSql(options);\n  }\n  toSql() {\n    return this.key;\n  }\n  stringify(value, options) {\n    if (this._stringify) {\n      return this._stringify(value, options);\n    }\n    return value;\n  }\n  bindParam(value, options) {\n    if (this._bindParam) {\n      return this._bindParam(value, options);\n    }\n    return options.bindParam(this.stringify(value, options));\n  }\n  static toString() {\n    return this.name;\n  }\n  static warn(link, text) {\n    if (!warnings[text]) {\n      warnings[text] = true;\n      logger.warn(`${text} \n>> Check: ${link}`);\n    }\n  }\n  static extend(oldType) {\n    return new this(oldType.options);\n  }\n}\nABSTRACT.prototype.dialectTypes = \"\";\nclass STRING extends ABSTRACT {\n  constructor(length, binary) {\n    super();\n    const options = typeof length === \"object\" && length || { length, binary };\n    this.options = options;\n    this._binary = options.binary;\n    this._length = options.length || 255;\n  }\n  toSql() {\n    return joinSQLFragments([\n      `VARCHAR(${this._length})`,\n      this._binary && \"BINARY\"\n    ]);\n  }\n  validate(value) {\n    if (Object.prototype.toString.call(value) !== \"[object String]\") {\n      if (this.options.binary && Buffer.isBuffer(value) || typeof value === \"number\") {\n        return true;\n      }\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid string\", value));\n    }\n    return true;\n  }\n  get BINARY() {\n    this._binary = true;\n    this.options.binary = true;\n    return this;\n  }\n  static get BINARY() {\n    return new this().BINARY;\n  }\n}\nclass CHAR extends STRING {\n  constructor(length, binary) {\n    super(typeof length === \"object\" && length || { length, binary });\n  }\n  toSql() {\n    return joinSQLFragments([\n      `CHAR(${this._length})`,\n      this._binary && \"BINARY\"\n    ]);\n  }\n}\nclass TEXT extends ABSTRACT {\n  constructor(length) {\n    super();\n    const options = typeof length === \"object\" && length || { length };\n    this.options = options;\n    this._length = options.length || \"\";\n  }\n  toSql() {\n    switch (this._length.toLowerCase()) {\n      case \"tiny\":\n        return \"TINYTEXT\";\n      case \"medium\":\n        return \"MEDIUMTEXT\";\n      case \"long\":\n        return \"LONGTEXT\";\n      default:\n        return this.key;\n    }\n  }\n  validate(value) {\n    if (typeof value !== \"string\") {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid string\", value));\n    }\n    return true;\n  }\n}\nclass CITEXT extends ABSTRACT {\n  toSql() {\n    return \"CITEXT\";\n  }\n  validate(value) {\n    if (typeof value !== \"string\") {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid string\", value));\n    }\n    return true;\n  }\n}\nclass NUMBER extends ABSTRACT {\n  constructor(options = {}) {\n    super();\n    if (typeof options === \"number\") {\n      options = {\n        length: options\n      };\n    }\n    this.options = options;\n    this._length = options.length;\n    this._zerofill = options.zerofill;\n    this._decimals = options.decimals;\n    this._precision = options.precision;\n    this._scale = options.scale;\n    this._unsigned = options.unsigned;\n  }\n  toSql() {\n    let result = this.key;\n    if (this._length) {\n      result += `(${this._length}`;\n      if (typeof this._decimals === \"number\") {\n        result += `,${this._decimals}`;\n      }\n      result += \")\";\n    }\n    if (this._unsigned) {\n      result += \" UNSIGNED\";\n    }\n    if (this._zerofill) {\n      result += \" ZEROFILL\";\n    }\n    return result;\n  }\n  validate(value) {\n    if (!Validator.isFloat(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));\n    }\n    return true;\n  }\n  _stringify(number) {\n    if (typeof number === \"number\" || typeof number === \"bigint\" || typeof number === \"boolean\" || number === null || number === void 0) {\n      return number;\n    }\n    if (typeof number.toString === \"function\") {\n      return number.toString();\n    }\n    return number;\n  }\n  get UNSIGNED() {\n    this._unsigned = true;\n    this.options.unsigned = true;\n    return this;\n  }\n  get ZEROFILL() {\n    this._zerofill = true;\n    this.options.zerofill = true;\n    return this;\n  }\n  static get UNSIGNED() {\n    return new this().UNSIGNED;\n  }\n  static get ZEROFILL() {\n    return new this().ZEROFILL;\n  }\n}\nclass INTEGER extends NUMBER {\n  validate(value) {\n    if (!Validator.isInt(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));\n    }\n    return true;\n  }\n}\nclass TINYINT extends INTEGER {\n}\nclass SMALLINT extends INTEGER {\n}\nclass MEDIUMINT extends INTEGER {\n}\nclass BIGINT extends INTEGER {\n}\nclass FLOAT extends NUMBER {\n  constructor(length, decimals) {\n    super(typeof length === \"object\" && length || { length, decimals });\n  }\n  validate(value) {\n    if (!Validator.isFloat(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid float\", value));\n    }\n    return true;\n  }\n}\nclass REAL extends NUMBER {\n  constructor(length, decimals) {\n    super(typeof length === \"object\" && length || { length, decimals });\n  }\n}\nclass DOUBLE extends NUMBER {\n  constructor(length, decimals) {\n    super(typeof length === \"object\" && length || { length, decimals });\n  }\n}\nclass DECIMAL extends NUMBER {\n  constructor(precision, scale) {\n    super(typeof precision === \"object\" && precision || { precision, scale });\n  }\n  toSql() {\n    if (this._precision || this._scale) {\n      return `DECIMAL(${[this._precision, this._scale].filter(_.identity).join(\",\")})`;\n    }\n    return \"DECIMAL\";\n  }\n  validate(value) {\n    if (!Validator.isDecimal(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid decimal\", value));\n    }\n    return true;\n  }\n}\nconst protoExtensions = {\n  escape: false,\n  _value(value) {\n    if (isNaN(value)) {\n      return \"NaN\";\n    }\n    if (!isFinite(value)) {\n      const sign = value < 0 ? \"-\" : \"\";\n      return `${sign}Infinity`;\n    }\n    return value;\n  },\n  _stringify(value) {\n    return `'${this._value(value)}'`;\n  },\n  _bindParam(value, options) {\n    return options.bindParam(this._value(value));\n  }\n};\nfor (const floating of [FLOAT, DOUBLE, REAL]) {\n  Object.assign(floating.prototype, protoExtensions);\n}\nclass BOOLEAN extends ABSTRACT {\n  toSql() {\n    return \"TINYINT(1)\";\n  }\n  validate(value) {\n    if (!Validator.isBoolean(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid boolean\", value));\n    }\n    return true;\n  }\n  _sanitize(value) {\n    if (value !== null && value !== void 0) {\n      if (Buffer.isBuffer(value) && value.length === 1) {\n        value = value[0];\n      }\n      const type = typeof value;\n      if (type === \"string\") {\n        return value === \"true\" ? true : value === \"false\" ? false : value;\n      }\n      if (type === \"number\") {\n        return value === 1 ? true : value === 0 ? false : value;\n      }\n    }\n    return value;\n  }\n}\nBOOLEAN.parse = BOOLEAN.prototype._sanitize;\nclass TIME extends ABSTRACT {\n  toSql() {\n    return \"TIME\";\n  }\n}\nclass DATE extends ABSTRACT {\n  constructor(length) {\n    super();\n    const options = typeof length === \"object\" && length || { length };\n    this.options = options;\n    this._length = options.length || \"\";\n  }\n  toSql() {\n    return \"DATETIME\";\n  }\n  validate(value) {\n    if (!Validator.isDate(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid date\", value));\n    }\n    return true;\n  }\n  _sanitize(value, options) {\n    if ((!options || options && !options.raw) && !(value instanceof Date) && !!value) {\n      return new Date(value);\n    }\n    return value;\n  }\n  _isChanged(value, originalValue) {\n    if (originalValue && !!value && (value === originalValue || value instanceof Date && originalValue instanceof Date && value.getTime() === originalValue.getTime())) {\n      return false;\n    }\n    if (!originalValue && !value && originalValue === value) {\n      return false;\n    }\n    return true;\n  }\n  _applyTimezone(date, options) {\n    if (options.timezone) {\n      if (momentTz.tz.zone(options.timezone)) {\n        return momentTz(date).tz(options.timezone);\n      }\n      return date = moment(date).utcOffset(options.timezone);\n    }\n    return momentTz(date);\n  }\n  _stringify(date, options) {\n    if (!moment.isMoment(date)) {\n      date = this._applyTimezone(date, options);\n    }\n    return date.format(\"YYYY-MM-DD HH:mm:ss.SSS Z\");\n  }\n}\nclass DATEONLY extends ABSTRACT {\n  toSql() {\n    return \"DATE\";\n  }\n  _stringify(date) {\n    return moment(date).format(\"YYYY-MM-DD\");\n  }\n  _sanitize(value, options) {\n    if ((!options || options && !options.raw) && !!value) {\n      return moment(value).format(\"YYYY-MM-DD\");\n    }\n    return value;\n  }\n  _isChanged(value, originalValue) {\n    if (originalValue && !!value && originalValue === value) {\n      return false;\n    }\n    if (!originalValue && !value && originalValue === value) {\n      return false;\n    }\n    return true;\n  }\n}\nclass HSTORE extends ABSTRACT {\n  validate(value) {\n    if (!_.isPlainObject(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid hstore\", value));\n    }\n    return true;\n  }\n}\nclass JSONTYPE extends ABSTRACT {\n  validate() {\n    return true;\n  }\n  _stringify(value) {\n    return JSON.stringify(value);\n  }\n}\nclass JSONB extends JSONTYPE {\n}\nclass NOW extends ABSTRACT {\n}\nclass BLOB extends ABSTRACT {\n  constructor(length) {\n    super();\n    const options = typeof length === \"object\" && length || { length };\n    this.options = options;\n    this._length = options.length || \"\";\n  }\n  toSql() {\n    switch (this._length.toLowerCase()) {\n      case \"tiny\":\n        return \"TINYBLOB\";\n      case \"medium\":\n        return \"MEDIUMBLOB\";\n      case \"long\":\n        return \"LONGBLOB\";\n      default:\n        return this.key;\n    }\n  }\n  validate(value) {\n    if (typeof value !== \"string\" && !Buffer.isBuffer(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid blob\", value));\n    }\n    return true;\n  }\n  _stringify(value) {\n    if (!Buffer.isBuffer(value)) {\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      } else {\n        value = Buffer.from(value.toString());\n      }\n    }\n    const hex = value.toString(\"hex\");\n    return this._hexify(hex);\n  }\n  _hexify(hex) {\n    return `X'${hex}'`;\n  }\n  _bindParam(value, options) {\n    if (!Buffer.isBuffer(value)) {\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      } else {\n        value = Buffer.from(value.toString());\n      }\n    }\n    return options.bindParam(value);\n  }\n}\nBLOB.prototype.escape = false;\nclass RANGE extends ABSTRACT {\n  constructor(subtype) {\n    super();\n    const options = _.isPlainObject(subtype) ? subtype : { subtype };\n    if (!options.subtype)\n      options.subtype = new INTEGER();\n    if (typeof options.subtype === \"function\") {\n      options.subtype = new options.subtype();\n    }\n    this._subtype = options.subtype.key;\n    this.options = options;\n  }\n  validate(value) {\n    if (!Array.isArray(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid range\", value));\n    }\n    if (value.length !== 2) {\n      throw new sequelizeErrors.ValidationError(\"A range must be an array with two elements\");\n    }\n    return true;\n  }\n}\nclass UUID extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== \"string\" || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid uuid\", value));\n    }\n    return true;\n  }\n}\nclass UUIDV1 extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== \"string\" || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid uuid\", value));\n    }\n    return true;\n  }\n}\nclass UUIDV4 extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== \"string\" || !Validator.isUUID(value, 4) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid uuidv4\", value));\n    }\n    return true;\n  }\n}\nclass VIRTUAL extends ABSTRACT {\n  constructor(ReturnType, fields) {\n    super();\n    if (typeof ReturnType === \"function\")\n      ReturnType = new ReturnType();\n    this.returnType = ReturnType;\n    this.fields = fields;\n  }\n}\nclass ENUM extends ABSTRACT {\n  constructor(...args) {\n    super();\n    const value = args[0];\n    const options = typeof value === \"object\" && !Array.isArray(value) && value || {\n      values: args.reduce((result, element) => {\n        return result.concat(Array.isArray(element) ? element : [element]);\n      }, [])\n    };\n    this.values = options.values;\n    this.options = options;\n  }\n  validate(value) {\n    if (!this.values.includes(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid choice in %j\", value, this.values));\n    }\n    return true;\n  }\n}\nclass ARRAY extends ABSTRACT {\n  constructor(type) {\n    super();\n    const options = _.isPlainObject(type) ? type : { type };\n    this.options = options;\n    this.type = typeof options.type === \"function\" ? new options.type() : options.type;\n  }\n  toSql() {\n    return `${this.type.toSql()}[]`;\n  }\n  validate(value) {\n    if (!Array.isArray(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid array\", value));\n    }\n    return true;\n  }\n  static is(obj, type) {\n    return obj instanceof ARRAY && obj.type instanceof type;\n  }\n}\nclass GEOMETRY extends ABSTRACT {\n  constructor(type, srid) {\n    super();\n    const options = _.isPlainObject(type) ? type : { type, srid };\n    this.options = options;\n    this.type = options.type;\n    this.srid = options.srid;\n  }\n  _stringify(value, options) {\n    return `ST_GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n  _bindParam(value, options) {\n    return `ST_GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n}\nGEOMETRY.prototype.escape = false;\nclass GEOGRAPHY extends ABSTRACT {\n  constructor(type, srid) {\n    super();\n    const options = _.isPlainObject(type) ? type : { type, srid };\n    this.options = options;\n    this.type = options.type;\n    this.srid = options.srid;\n  }\n  _stringify(value, options) {\n    return `ST_GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n  _bindParam(value, options) {\n    return `ST_GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n}\nGEOGRAPHY.prototype.escape = false;\nclass CIDR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== \"string\" || !Validator.isIPRange(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid CIDR\", value));\n    }\n    return true;\n  }\n}\nclass INET extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== \"string\" || !Validator.isIP(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid INET\", value));\n    }\n    return true;\n  }\n}\nclass MACADDR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== \"string\" || !Validator.isMACAddress(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid MACADDR\", value));\n    }\n    return true;\n  }\n}\nclass TSVECTOR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== \"string\") {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid string\", value));\n    }\n    return true;\n  }\n}\nconst DataTypes = module.exports = {\n  ABSTRACT,\n  STRING,\n  CHAR,\n  TEXT,\n  NUMBER,\n  TINYINT,\n  SMALLINT,\n  MEDIUMINT,\n  INTEGER,\n  BIGINT,\n  FLOAT,\n  TIME,\n  DATE,\n  DATEONLY,\n  BOOLEAN,\n  NOW,\n  BLOB,\n  DECIMAL,\n  NUMERIC: DECIMAL,\n  UUID,\n  UUIDV1,\n  UUIDV4,\n  HSTORE,\n  JSON: JSONTYPE,\n  JSONB,\n  VIRTUAL,\n  ARRAY,\n  ENUM,\n  RANGE,\n  REAL,\n  \"DOUBLE PRECISION\": DOUBLE,\n  DOUBLE,\n  GEOMETRY,\n  GEOGRAPHY,\n  CIDR,\n  INET,\n  MACADDR,\n  CITEXT,\n  TSVECTOR\n};\n_.each(DataTypes, (dataType, name) => {\n  if (!Object.prototype.hasOwnProperty.call(dataType, \"key\")) {\n    dataType.types = {};\n    dataType.key = dataType.prototype.key = name;\n  }\n});\nconst dialectMap = {};\ndialectMap.postgres = __webpack_require__(/*! ./dialects/postgres/data-types */ \"(action-browser)/../node_modules/sequelize/lib/dialects/postgres/data-types.js\")(DataTypes);\ndialectMap.mysql = __webpack_require__(/*! ./dialects/mysql/data-types */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mysql/data-types.js\")(DataTypes);\ndialectMap.mariadb = __webpack_require__(/*! ./dialects/mariadb/data-types */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mariadb/data-types.js\")(DataTypes);\ndialectMap.sqlite = __webpack_require__(/*! ./dialects/sqlite/data-types */ \"(action-browser)/../node_modules/sequelize/lib/dialects/sqlite/data-types.js\")(DataTypes);\ndialectMap.mssql = __webpack_require__(/*! ./dialects/mssql/data-types */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mssql/data-types.js\")(DataTypes);\ndialectMap.db2 = __webpack_require__(/*! ./dialects/db2/data-types */ \"(action-browser)/../node_modules/sequelize/lib/dialects/db2/data-types.js\")(DataTypes);\ndialectMap.snowflake = __webpack_require__(/*! ./dialects/snowflake/data-types */ \"(action-browser)/../node_modules/sequelize/lib/dialects/snowflake/data-types.js\")(DataTypes);\ndialectMap.oracle = __webpack_require__(/*! ./dialects/oracle/data-types */ \"(action-browser)/../node_modules/sequelize/lib/dialects/oracle/data-types.js\")(DataTypes);\nconst dialectList = Object.values(dialectMap);\nfor (const dataTypes of dialectList) {\n  _.each(dataTypes, (DataType, key) => {\n    if (!DataType.key) {\n      DataType.key = DataType.prototype.key = key;\n    }\n  });\n}\nfor (const dataTypes of [DataTypes, ...dialectList]) {\n  _.each(dataTypes, (DataType, key) => {\n    dataTypes[key] = classToInvokable(DataType);\n  });\n}\nObject.assign(DataTypes, dialectMap);\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kYXRhLXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFVBQVUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMxQixZQUFZLG1CQUFPLENBQUMsNERBQUs7QUFDekIsd0JBQXdCLG1CQUFPLENBQUMsZ0ZBQVU7QUFDMUMsa0JBQWtCLDJJQUE2QztBQUMvRCxpQkFBaUIsbUJBQU8sQ0FBQyxrRkFBaUI7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLGlFQUFRO0FBQy9CLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0ZBQWdCO0FBQzNDO0FBQ0EsUUFBUSxtQkFBbUIsRUFBRSxtQkFBTyxDQUFDLDhHQUE0QjtBQUNqRSxRQUFRLG1CQUFtQixFQUFFLG1CQUFPLENBQUMsOEdBQTRCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGdCQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsdUJBQXVCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsdUJBQXVCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0JBQWtCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0REFBNEQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5REFBeUQ7QUFDdkY7QUFDQTtBQUNBLDhCQUE4Qiw0REFBNEQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseURBQXlEO0FBQ3ZGO0FBQ0E7QUFDQSw4QkFBOEIsNERBQTREO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHNIQUFnQztBQUM5RCxtQkFBbUIsbUJBQU8sQ0FBQyxnSEFBNkI7QUFDeEQscUJBQXFCLG1CQUFPLENBQUMsb0hBQStCO0FBQzVELG9CQUFvQixtQkFBTyxDQUFDLGtIQUE4QjtBQUMxRCxtQkFBbUIsbUJBQU8sQ0FBQyxnSEFBNkI7QUFDeEQsaUJBQWlCLG1CQUFPLENBQUMsNEdBQTJCO0FBQ3BELHVCQUF1QixtQkFBTyxDQUFDLHdIQUFpQztBQUNoRSxvQkFBb0IsbUJBQU8sQ0FBQyxrSEFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kYXRhLXR5cGVzLmpzPzhhYTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IHdreCA9IHJlcXVpcmUoXCJ3a3hcIik7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBWYWxpZGF0b3IgPSByZXF1aXJlKFwiLi91dGlscy92YWxpZGF0b3ItZXh0cmFzXCIpLnZhbGlkYXRvcjtcbmNvbnN0IG1vbWVudFR6ID0gcmVxdWlyZShcIm1vbWVudC10aW1lem9uZVwiKTtcbmNvbnN0IG1vbWVudCA9IHJlcXVpcmUoXCJtb21lbnRcIik7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZShcIi4vdXRpbHMvbG9nZ2VyXCIpO1xuY29uc3Qgd2FybmluZ3MgPSB7fTtcbmNvbnN0IHsgY2xhc3NUb0ludm9rYWJsZSB9ID0gcmVxdWlyZShcIi4vdXRpbHMvY2xhc3MtdG8taW52b2thYmxlXCIpO1xuY29uc3QgeyBqb2luU1FMRnJhZ21lbnRzIH0gPSByZXF1aXJlKFwiLi91dGlscy9qb2luLXNxbC1mcmFnbWVudHNcIik7XG5jbGFzcyBBQlNUUkFDVCB7XG4gIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy50b1NxbChvcHRpb25zKTtcbiAgfVxuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gdGhpcy5rZXk7XG4gIH1cbiAgc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuX3N0cmluZ2lmeSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBiaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5fYmluZFBhcmFtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMuYmluZFBhcmFtKHRoaXMuc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSk7XG4gIH1cbiAgc3RhdGljIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cbiAgc3RhdGljIHdhcm4obGluaywgdGV4dCkge1xuICAgIGlmICghd2FybmluZ3NbdGV4dF0pIHtcbiAgICAgIHdhcm5pbmdzW3RleHRdID0gdHJ1ZTtcbiAgICAgIGxvZ2dlci53YXJuKGAke3RleHR9IFxuPj4gQ2hlY2s6ICR7bGlua31gKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGV4dGVuZChvbGRUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKG9sZFR5cGUub3B0aW9ucyk7XG4gIH1cbn1cbkFCU1RSQUNULnByb3RvdHlwZS5kaWFsZWN0VHlwZXMgPSBcIlwiO1xuY2xhc3MgU1RSSU5HIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICBjb25zdHJ1Y3RvcihsZW5ndGgsIGJpbmFyeSkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBsZW5ndGggPT09IFwib2JqZWN0XCIgJiYgbGVuZ3RoIHx8IHsgbGVuZ3RoLCBiaW5hcnkgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2JpbmFyeSA9IG9wdGlvbnMuYmluYXJ5O1xuICAgIHRoaXMuX2xlbmd0aCA9IG9wdGlvbnMubGVuZ3RoIHx8IDI1NTtcbiAgfVxuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBgVkFSQ0hBUigke3RoaXMuX2xlbmd0aH0pYCxcbiAgICAgIHRoaXMuX2JpbmFyeSAmJiBcIkJJTkFSWVwiXG4gICAgXSk7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSAhPT0gXCJbb2JqZWN0IFN0cmluZ11cIikge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5iaW5hcnkgJiYgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChcIiVqIGlzIG5vdCBhIHZhbGlkIHN0cmluZ1wiLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXQgQklOQVJZKCkge1xuICAgIHRoaXMuX2JpbmFyeSA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zLmJpbmFyeSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RhdGljIGdldCBCSU5BUlkoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKCkuQklOQVJZO1xuICB9XG59XG5jbGFzcyBDSEFSIGV4dGVuZHMgU1RSSU5HIHtcbiAgY29uc3RydWN0b3IobGVuZ3RoLCBiaW5hcnkpIHtcbiAgICBzdXBlcih0eXBlb2YgbGVuZ3RoID09PSBcIm9iamVjdFwiICYmIGxlbmd0aCB8fCB7IGxlbmd0aCwgYmluYXJ5IH0pO1xuICB9XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiBqb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIGBDSEFSKCR7dGhpcy5fbGVuZ3RofSlgLFxuICAgICAgdGhpcy5fYmluYXJ5ICYmIFwiQklOQVJZXCJcbiAgICBdKTtcbiAgfVxufVxuY2xhc3MgVEVYVCBleHRlbmRzIEFCU1RSQUNUIHtcbiAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIGxlbmd0aCA9PT0gXCJvYmplY3RcIiAmJiBsZW5ndGggfHwgeyBsZW5ndGggfTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2xlbmd0aCA9IG9wdGlvbnMubGVuZ3RoIHx8IFwiXCI7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgc3dpdGNoICh0aGlzLl9sZW5ndGgudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY2FzZSBcInRpbnlcIjpcbiAgICAgICAgcmV0dXJuIFwiVElOWVRFWFRcIjtcbiAgICAgIGNhc2UgXCJtZWRpdW1cIjpcbiAgICAgICAgcmV0dXJuIFwiTUVESVVNVEVYVFwiO1xuICAgICAgY2FzZSBcImxvbmdcIjpcbiAgICAgICAgcmV0dXJuIFwiTE9OR1RFWFRcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLmtleTtcbiAgICB9XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChcIiVqIGlzIG5vdCBhIHZhbGlkIHN0cmluZ1wiLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY2xhc3MgQ0lURVhUIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gXCJDSVRFWFRcIjtcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KFwiJWogaXMgbm90IGEgdmFsaWQgc3RyaW5nXCIsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jbGFzcyBOVU1CRVIgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBsZW5ndGg6IG9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fbGVuZ3RoID0gb3B0aW9ucy5sZW5ndGg7XG4gICAgdGhpcy5femVyb2ZpbGwgPSBvcHRpb25zLnplcm9maWxsO1xuICAgIHRoaXMuX2RlY2ltYWxzID0gb3B0aW9ucy5kZWNpbWFscztcbiAgICB0aGlzLl9wcmVjaXNpb24gPSBvcHRpb25zLnByZWNpc2lvbjtcbiAgICB0aGlzLl9zY2FsZSA9IG9wdGlvbnMuc2NhbGU7XG4gICAgdGhpcy5fdW5zaWduZWQgPSBvcHRpb25zLnVuc2lnbmVkO1xuICB9XG4gIHRvU3FsKCkge1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmtleTtcbiAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICByZXN1bHQgKz0gYCgke3RoaXMuX2xlbmd0aH1gO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9kZWNpbWFscyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXN1bHQgKz0gYCwke3RoaXMuX2RlY2ltYWxzfWA7XG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gXCIpXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLl91bnNpZ25lZCkge1xuICAgICAgcmVzdWx0ICs9IFwiIFVOU0lHTkVEXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLl96ZXJvZmlsbCkge1xuICAgICAgcmVzdWx0ICs9IFwiIFpFUk9GSUxMXCI7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoIVZhbGlkYXRvci5pc0Zsb2F0KFN0cmluZyh2YWx1ZSkpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChgJWogaXMgbm90IGEgdmFsaWQgJHt0aGlzLmtleS50b0xvd2VyQ2FzZSgpfWAsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIF9zdHJpbmdpZnkobnVtYmVyKSB7XG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIG51bWJlciA9PT0gXCJiaWdpbnRcIiB8fCB0eXBlb2YgbnVtYmVyID09PSBcImJvb2xlYW5cIiB8fCBudW1iZXIgPT09IG51bGwgfHwgbnVtYmVyID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbnVtYmVyLnRvU3RyaW5nID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBudW1iZXIudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bWJlcjtcbiAgfVxuICBnZXQgVU5TSUdORUQoKSB7XG4gICAgdGhpcy5fdW5zaWduZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucy51bnNpZ25lZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0IFpFUk9GSUxMKCkge1xuICAgIHRoaXMuX3plcm9maWxsID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMuemVyb2ZpbGwgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0YXRpYyBnZXQgVU5TSUdORUQoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKCkuVU5TSUdORUQ7XG4gIH1cbiAgc3RhdGljIGdldCBaRVJPRklMTCgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoKS5aRVJPRklMTDtcbiAgfVxufVxuY2xhc3MgSU5URUdFUiBleHRlbmRzIE5VTUJFUiB7XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCFWYWxpZGF0b3IuaXNJbnQoU3RyaW5nKHZhbHVlKSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KGAlaiBpcyBub3QgYSB2YWxpZCAke3RoaXMua2V5LnRvTG93ZXJDYXNlKCl9YCwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNsYXNzIFRJTllJTlQgZXh0ZW5kcyBJTlRFR0VSIHtcbn1cbmNsYXNzIFNNQUxMSU5UIGV4dGVuZHMgSU5URUdFUiB7XG59XG5jbGFzcyBNRURJVU1JTlQgZXh0ZW5kcyBJTlRFR0VSIHtcbn1cbmNsYXNzIEJJR0lOVCBleHRlbmRzIElOVEVHRVIge1xufVxuY2xhc3MgRkxPQVQgZXh0ZW5kcyBOVU1CRVIge1xuICBjb25zdHJ1Y3RvcihsZW5ndGgsIGRlY2ltYWxzKSB7XG4gICAgc3VwZXIodHlwZW9mIGxlbmd0aCA9PT0gXCJvYmplY3RcIiAmJiBsZW5ndGggfHwgeyBsZW5ndGgsIGRlY2ltYWxzIH0pO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCFWYWxpZGF0b3IuaXNGbG9hdChTdHJpbmcodmFsdWUpKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoXCIlaiBpcyBub3QgYSB2YWxpZCBmbG9hdFwiLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY2xhc3MgUkVBTCBleHRlbmRzIE5VTUJFUiB7XG4gIGNvbnN0cnVjdG9yKGxlbmd0aCwgZGVjaW1hbHMpIHtcbiAgICBzdXBlcih0eXBlb2YgbGVuZ3RoID09PSBcIm9iamVjdFwiICYmIGxlbmd0aCB8fCB7IGxlbmd0aCwgZGVjaW1hbHMgfSk7XG4gIH1cbn1cbmNsYXNzIERPVUJMRSBleHRlbmRzIE5VTUJFUiB7XG4gIGNvbnN0cnVjdG9yKGxlbmd0aCwgZGVjaW1hbHMpIHtcbiAgICBzdXBlcih0eXBlb2YgbGVuZ3RoID09PSBcIm9iamVjdFwiICYmIGxlbmd0aCB8fCB7IGxlbmd0aCwgZGVjaW1hbHMgfSk7XG4gIH1cbn1cbmNsYXNzIERFQ0lNQUwgZXh0ZW5kcyBOVU1CRVIge1xuICBjb25zdHJ1Y3RvcihwcmVjaXNpb24sIHNjYWxlKSB7XG4gICAgc3VwZXIodHlwZW9mIHByZWNpc2lvbiA9PT0gXCJvYmplY3RcIiAmJiBwcmVjaXNpb24gfHwgeyBwcmVjaXNpb24sIHNjYWxlIH0pO1xuICB9XG4gIHRvU3FsKCkge1xuICAgIGlmICh0aGlzLl9wcmVjaXNpb24gfHwgdGhpcy5fc2NhbGUpIHtcbiAgICAgIHJldHVybiBgREVDSU1BTCgke1t0aGlzLl9wcmVjaXNpb24sIHRoaXMuX3NjYWxlXS5maWx0ZXIoXy5pZGVudGl0eSkuam9pbihcIixcIil9KWA7XG4gICAgfVxuICAgIHJldHVybiBcIkRFQ0lNQUxcIjtcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghVmFsaWRhdG9yLmlzRGVjaW1hbChTdHJpbmcodmFsdWUpKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoXCIlaiBpcyBub3QgYSB2YWxpZCBkZWNpbWFsXCIsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jb25zdCBwcm90b0V4dGVuc2lvbnMgPSB7XG4gIGVzY2FwZTogZmFsc2UsXG4gIF92YWx1ZSh2YWx1ZSkge1xuICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBcIk5hTlwiO1xuICAgIH1cbiAgICBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgY29uc3Qgc2lnbiA9IHZhbHVlIDwgMCA/IFwiLVwiIDogXCJcIjtcbiAgICAgIHJldHVybiBgJHtzaWdufUluZmluaXR5YDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBfc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGAnJHt0aGlzLl92YWx1ZSh2YWx1ZSl9J2A7XG4gIH0sXG4gIF9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5iaW5kUGFyYW0odGhpcy5fdmFsdWUodmFsdWUpKTtcbiAgfVxufTtcbmZvciAoY29uc3QgZmxvYXRpbmcgb2YgW0ZMT0FULCBET1VCTEUsIFJFQUxdKSB7XG4gIE9iamVjdC5hc3NpZ24oZmxvYXRpbmcucHJvdG90eXBlLCBwcm90b0V4dGVuc2lvbnMpO1xufVxuY2xhc3MgQk9PTEVBTiBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuIFwiVElOWUlOVCgxKVwiO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCFWYWxpZGF0b3IuaXNCb29sZWFuKFN0cmluZyh2YWx1ZSkpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChcIiVqIGlzIG5vdCBhIHZhbGlkIGJvb2xlYW5cIiwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgX3Nhbml0aXplKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuICAgICAgfVxuICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDogdmFsdWUgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDogdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDEgPyB0cnVlIDogdmFsdWUgPT09IDAgPyBmYWxzZSA6IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbkJPT0xFQU4ucGFyc2UgPSBCT09MRUFOLnByb3RvdHlwZS5fc2FuaXRpemU7XG5jbGFzcyBUSU1FIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gXCJUSU1FXCI7XG4gIH1cbn1cbmNsYXNzIERBVEUgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBsZW5ndGggPT09IFwib2JqZWN0XCIgJiYgbGVuZ3RoIHx8IHsgbGVuZ3RoIH07XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9sZW5ndGggPSBvcHRpb25zLmxlbmd0aCB8fCBcIlwiO1xuICB9XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiBcIkRBVEVUSU1FXCI7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoIVZhbGlkYXRvci5pc0RhdGUoU3RyaW5nKHZhbHVlKSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KFwiJWogaXMgbm90IGEgdmFsaWQgZGF0ZVwiLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfc2FuaXRpemUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoKCFvcHRpb25zIHx8IG9wdGlvbnMgJiYgIW9wdGlvbnMucmF3KSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgJiYgISF2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIF9pc0NoYW5nZWQodmFsdWUsIG9yaWdpbmFsVmFsdWUpIHtcbiAgICBpZiAob3JpZ2luYWxWYWx1ZSAmJiAhIXZhbHVlICYmICh2YWx1ZSA9PT0gb3JpZ2luYWxWYWx1ZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgJiYgb3JpZ2luYWxWYWx1ZSBpbnN0YW5jZW9mIERhdGUgJiYgdmFsdWUuZ2V0VGltZSgpID09PSBvcmlnaW5hbFZhbHVlLmdldFRpbWUoKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFvcmlnaW5hbFZhbHVlICYmICF2YWx1ZSAmJiBvcmlnaW5hbFZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfYXBwbHlUaW1lem9uZShkYXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMudGltZXpvbmUpIHtcbiAgICAgIGlmIChtb21lbnRUei50ei56b25lKG9wdGlvbnMudGltZXpvbmUpKSB7XG4gICAgICAgIHJldHVybiBtb21lbnRUeihkYXRlKS50eihvcHRpb25zLnRpbWV6b25lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRlID0gbW9tZW50KGRhdGUpLnV0Y09mZnNldChvcHRpb25zLnRpbWV6b25lKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vbWVudFR6KGRhdGUpO1xuICB9XG4gIF9zdHJpbmdpZnkoZGF0ZSwgb3B0aW9ucykge1xuICAgIGlmICghbW9tZW50LmlzTW9tZW50KGRhdGUpKSB7XG4gICAgICBkYXRlID0gdGhpcy5fYXBwbHlUaW1lem9uZShkYXRlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGUuZm9ybWF0KFwiWVlZWS1NTS1ERCBISDptbTpzcy5TU1MgWlwiKTtcbiAgfVxufVxuY2xhc3MgREFURU9OTFkgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiBcIkRBVEVcIjtcbiAgfVxuICBfc3RyaW5naWZ5KGRhdGUpIHtcbiAgICByZXR1cm4gbW9tZW50KGRhdGUpLmZvcm1hdChcIllZWVktTU0tRERcIik7XG4gIH1cbiAgX3Nhbml0aXplKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKCghb3B0aW9ucyB8fCBvcHRpb25zICYmICFvcHRpb25zLnJhdykgJiYgISF2YWx1ZSkge1xuICAgICAgcmV0dXJuIG1vbWVudCh2YWx1ZSkuZm9ybWF0KFwiWVlZWS1NTS1ERFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIF9pc0NoYW5nZWQodmFsdWUsIG9yaWdpbmFsVmFsdWUpIHtcbiAgICBpZiAob3JpZ2luYWxWYWx1ZSAmJiAhIXZhbHVlICYmIG9yaWdpbmFsVmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghb3JpZ2luYWxWYWx1ZSAmJiAhdmFsdWUgJiYgb3JpZ2luYWxWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNsYXNzIEhTVE9SRSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoIV8uaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KFwiJWogaXMgbm90IGEgdmFsaWQgaHN0b3JlXCIsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jbGFzcyBKU09OVFlQRSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdmFsaWRhdGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgX3N0cmluZ2lmeSh2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gIH1cbn1cbmNsYXNzIEpTT05CIGV4dGVuZHMgSlNPTlRZUEUge1xufVxuY2xhc3MgTk9XIGV4dGVuZHMgQUJTVFJBQ1Qge1xufVxuY2xhc3MgQkxPQiBleHRlbmRzIEFCU1RSQUNUIHtcbiAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIGxlbmd0aCA9PT0gXCJvYmplY3RcIiAmJiBsZW5ndGggfHwgeyBsZW5ndGggfTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2xlbmd0aCA9IG9wdGlvbnMubGVuZ3RoIHx8IFwiXCI7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgc3dpdGNoICh0aGlzLl9sZW5ndGgudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY2FzZSBcInRpbnlcIjpcbiAgICAgICAgcmV0dXJuIFwiVElOWUJMT0JcIjtcbiAgICAgIGNhc2UgXCJtZWRpdW1cIjpcbiAgICAgICAgcmV0dXJuIFwiTUVESVVNQkxPQlwiO1xuICAgICAgY2FzZSBcImxvbmdcIjpcbiAgICAgICAgcmV0dXJuIFwiTE9OR0JMT0JcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLmtleTtcbiAgICB9XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiICYmICFCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChcIiVqIGlzIG5vdCBhIHZhbGlkIGJsb2JcIiwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgX3N0cmluZ2lmeSh2YWx1ZSkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaGV4ID0gdmFsdWUudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgcmV0dXJuIHRoaXMuX2hleGlmeShoZXgpO1xuICB9XG4gIF9oZXhpZnkoaGV4KSB7XG4gICAgcmV0dXJuIGBYJyR7aGV4fSdgO1xuICB9XG4gIF9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zLmJpbmRQYXJhbSh2YWx1ZSk7XG4gIH1cbn1cbkJMT0IucHJvdG90eXBlLmVzY2FwZSA9IGZhbHNlO1xuY2xhc3MgUkFOR0UgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIGNvbnN0cnVjdG9yKHN1YnR5cGUpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBfLmlzUGxhaW5PYmplY3Qoc3VidHlwZSkgPyBzdWJ0eXBlIDogeyBzdWJ0eXBlIH07XG4gICAgaWYgKCFvcHRpb25zLnN1YnR5cGUpXG4gICAgICBvcHRpb25zLnN1YnR5cGUgPSBuZXcgSU5URUdFUigpO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zdWJ0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIG9wdGlvbnMuc3VidHlwZSA9IG5ldyBvcHRpb25zLnN1YnR5cGUoKTtcbiAgICB9XG4gICAgdGhpcy5fc3VidHlwZSA9IG9wdGlvbnMuc3VidHlwZS5rZXk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KFwiJWogaXMgbm90IGEgdmFsaWQgcmFuZ2VcIiwgdmFsdWUpKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IoXCJBIHJhbmdlIG11c3QgYmUgYW4gYXJyYXkgd2l0aCB0d28gZWxlbWVudHNcIik7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jbGFzcyBVVUlEIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgfHwgIVZhbGlkYXRvci5pc1VVSUQodmFsdWUpICYmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5hY2NlcHRTdHJpbmdzKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoXCIlaiBpcyBub3QgYSB2YWxpZCB1dWlkXCIsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jbGFzcyBVVUlEVjEgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiB8fCAhVmFsaWRhdG9yLmlzVVVJRCh2YWx1ZSkgJiYgKCFvcHRpb25zIHx8ICFvcHRpb25zLmFjY2VwdFN0cmluZ3MpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChcIiVqIGlzIG5vdCBhIHZhbGlkIHV1aWRcIiwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNsYXNzIFVVSURWNCBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiIHx8ICFWYWxpZGF0b3IuaXNVVUlEKHZhbHVlLCA0KSAmJiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuYWNjZXB0U3RyaW5ncykpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KFwiJWogaXMgbm90IGEgdmFsaWQgdXVpZHY0XCIsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jbGFzcyBWSVJUVUFMIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICBjb25zdHJ1Y3RvcihSZXR1cm5UeXBlLCBmaWVsZHMpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmICh0eXBlb2YgUmV0dXJuVHlwZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgUmV0dXJuVHlwZSA9IG5ldyBSZXR1cm5UeXBlKCk7XG4gICAgdGhpcy5yZXR1cm5UeXBlID0gUmV0dXJuVHlwZTtcbiAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgfVxufVxuY2xhc3MgRU5VTSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgdmFsdWUgPSBhcmdzWzBdO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlIHx8IHtcbiAgICAgIHZhbHVlczogYXJncy5yZWR1Y2UoKHJlc3VsdCwgZWxlbWVudCkgPT4ge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChBcnJheS5pc0FycmF5KGVsZW1lbnQpID8gZWxlbWVudCA6IFtlbGVtZW50XSk7XG4gICAgICB9LCBbXSlcbiAgICB9O1xuICAgIHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghdGhpcy52YWx1ZXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChcIiVqIGlzIG5vdCBhIHZhbGlkIGNob2ljZSBpbiAlalwiLCB2YWx1ZSwgdGhpcy52YWx1ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNsYXNzIEFSUkFZIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBvcHRpb25zID0gXy5pc1BsYWluT2JqZWN0KHR5cGUpID8gdHlwZSA6IHsgdHlwZSB9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy50eXBlID0gdHlwZW9mIG9wdGlvbnMudHlwZSA9PT0gXCJmdW5jdGlvblwiID8gbmV3IG9wdGlvbnMudHlwZSgpIDogb3B0aW9ucy50eXBlO1xuICB9XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiBgJHt0aGlzLnR5cGUudG9TcWwoKX1bXWA7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChcIiVqIGlzIG5vdCBhIHZhbGlkIGFycmF5XCIsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0YXRpYyBpcyhvYmosIHR5cGUpIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgQVJSQVkgJiYgb2JqLnR5cGUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG59XG5jbGFzcyBHRU9NRVRSWSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgY29uc3RydWN0b3IodHlwZSwgc3JpZCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IF8uaXNQbGFpbk9iamVjdCh0eXBlKSA/IHR5cGUgOiB7IHR5cGUsIHNyaWQgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICB0aGlzLnNyaWQgPSBvcHRpb25zLnNyaWQ7XG4gIH1cbiAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBgU1RfR2VvbUZyb21UZXh0KCR7b3B0aW9ucy5lc2NhcGUod2t4Lkdlb21ldHJ5LnBhcnNlR2VvSlNPTih2YWx1ZSkudG9Xa3QoKSl9KWA7XG4gIH1cbiAgX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBgU1RfR2VvbUZyb21UZXh0KCR7b3B0aW9ucy5iaW5kUGFyYW0od2t4Lkdlb21ldHJ5LnBhcnNlR2VvSlNPTih2YWx1ZSkudG9Xa3QoKSl9KWA7XG4gIH1cbn1cbkdFT01FVFJZLnByb3RvdHlwZS5lc2NhcGUgPSBmYWxzZTtcbmNsYXNzIEdFT0dSQVBIWSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgY29uc3RydWN0b3IodHlwZSwgc3JpZCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IF8uaXNQbGFpbk9iamVjdCh0eXBlKSA/IHR5cGUgOiB7IHR5cGUsIHNyaWQgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICB0aGlzLnNyaWQgPSBvcHRpb25zLnNyaWQ7XG4gIH1cbiAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBgU1RfR2VvbUZyb21UZXh0KCR7b3B0aW9ucy5lc2NhcGUod2t4Lkdlb21ldHJ5LnBhcnNlR2VvSlNPTih2YWx1ZSkudG9Xa3QoKSl9KWA7XG4gIH1cbiAgX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBgU1RfR2VvbUZyb21UZXh0KCR7b3B0aW9ucy5iaW5kUGFyYW0od2t4Lkdlb21ldHJ5LnBhcnNlR2VvSlNPTih2YWx1ZSkudG9Xa3QoKSl9KWA7XG4gIH1cbn1cbkdFT0dSQVBIWS5wcm90b3R5cGUuZXNjYXBlID0gZmFsc2U7XG5jbGFzcyBDSURSIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgfHwgIVZhbGlkYXRvci5pc0lQUmFuZ2UodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChcIiVqIGlzIG5vdCBhIHZhbGlkIENJRFJcIiwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNsYXNzIElORVQgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiB8fCAhVmFsaWRhdG9yLmlzSVAodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChcIiVqIGlzIG5vdCBhIHZhbGlkIElORVRcIiwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNsYXNzIE1BQ0FERFIgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiB8fCAhVmFsaWRhdG9yLmlzTUFDQWRkcmVzcyh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KFwiJWogaXMgbm90IGEgdmFsaWQgTUFDQUREUlwiLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY2xhc3MgVFNWRUNUT1IgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoXCIlaiBpcyBub3QgYSB2YWxpZCBzdHJpbmdcIiwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNvbnN0IERhdGFUeXBlcyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBBQlNUUkFDVCxcbiAgU1RSSU5HLFxuICBDSEFSLFxuICBURVhULFxuICBOVU1CRVIsXG4gIFRJTllJTlQsXG4gIFNNQUxMSU5ULFxuICBNRURJVU1JTlQsXG4gIElOVEVHRVIsXG4gIEJJR0lOVCxcbiAgRkxPQVQsXG4gIFRJTUUsXG4gIERBVEUsXG4gIERBVEVPTkxZLFxuICBCT09MRUFOLFxuICBOT1csXG4gIEJMT0IsXG4gIERFQ0lNQUwsXG4gIE5VTUVSSUM6IERFQ0lNQUwsXG4gIFVVSUQsXG4gIFVVSURWMSxcbiAgVVVJRFY0LFxuICBIU1RPUkUsXG4gIEpTT046IEpTT05UWVBFLFxuICBKU09OQixcbiAgVklSVFVBTCxcbiAgQVJSQVksXG4gIEVOVU0sXG4gIFJBTkdFLFxuICBSRUFMLFxuICBcIkRPVUJMRSBQUkVDSVNJT05cIjogRE9VQkxFLFxuICBET1VCTEUsXG4gIEdFT01FVFJZLFxuICBHRU9HUkFQSFksXG4gIENJRFIsXG4gIElORVQsXG4gIE1BQ0FERFIsXG4gIENJVEVYVCxcbiAgVFNWRUNUT1Jcbn07XG5fLmVhY2goRGF0YVR5cGVzLCAoZGF0YVR5cGUsIG5hbWUpID0+IHtcbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YVR5cGUsIFwia2V5XCIpKSB7XG4gICAgZGF0YVR5cGUudHlwZXMgPSB7fTtcbiAgICBkYXRhVHlwZS5rZXkgPSBkYXRhVHlwZS5wcm90b3R5cGUua2V5ID0gbmFtZTtcbiAgfVxufSk7XG5jb25zdCBkaWFsZWN0TWFwID0ge307XG5kaWFsZWN0TWFwLnBvc3RncmVzID0gcmVxdWlyZShcIi4vZGlhbGVjdHMvcG9zdGdyZXMvZGF0YS10eXBlc1wiKShEYXRhVHlwZXMpO1xuZGlhbGVjdE1hcC5teXNxbCA9IHJlcXVpcmUoXCIuL2RpYWxlY3RzL215c3FsL2RhdGEtdHlwZXNcIikoRGF0YVR5cGVzKTtcbmRpYWxlY3RNYXAubWFyaWFkYiA9IHJlcXVpcmUoXCIuL2RpYWxlY3RzL21hcmlhZGIvZGF0YS10eXBlc1wiKShEYXRhVHlwZXMpO1xuZGlhbGVjdE1hcC5zcWxpdGUgPSByZXF1aXJlKFwiLi9kaWFsZWN0cy9zcWxpdGUvZGF0YS10eXBlc1wiKShEYXRhVHlwZXMpO1xuZGlhbGVjdE1hcC5tc3NxbCA9IHJlcXVpcmUoXCIuL2RpYWxlY3RzL21zc3FsL2RhdGEtdHlwZXNcIikoRGF0YVR5cGVzKTtcbmRpYWxlY3RNYXAuZGIyID0gcmVxdWlyZShcIi4vZGlhbGVjdHMvZGIyL2RhdGEtdHlwZXNcIikoRGF0YVR5cGVzKTtcbmRpYWxlY3RNYXAuc25vd2ZsYWtlID0gcmVxdWlyZShcIi4vZGlhbGVjdHMvc25vd2ZsYWtlL2RhdGEtdHlwZXNcIikoRGF0YVR5cGVzKTtcbmRpYWxlY3RNYXAub3JhY2xlID0gcmVxdWlyZShcIi4vZGlhbGVjdHMvb3JhY2xlL2RhdGEtdHlwZXNcIikoRGF0YVR5cGVzKTtcbmNvbnN0IGRpYWxlY3RMaXN0ID0gT2JqZWN0LnZhbHVlcyhkaWFsZWN0TWFwKTtcbmZvciAoY29uc3QgZGF0YVR5cGVzIG9mIGRpYWxlY3RMaXN0KSB7XG4gIF8uZWFjaChkYXRhVHlwZXMsIChEYXRhVHlwZSwga2V5KSA9PiB7XG4gICAgaWYgKCFEYXRhVHlwZS5rZXkpIHtcbiAgICAgIERhdGFUeXBlLmtleSA9IERhdGFUeXBlLnByb3RvdHlwZS5rZXkgPSBrZXk7XG4gICAgfVxuICB9KTtcbn1cbmZvciAoY29uc3QgZGF0YVR5cGVzIG9mIFtEYXRhVHlwZXMsIC4uLmRpYWxlY3RMaXN0XSkge1xuICBfLmVhY2goZGF0YVR5cGVzLCAoRGF0YVR5cGUsIGtleSkgPT4ge1xuICAgIGRhdGFUeXBlc1trZXldID0gY2xhc3NUb0ludm9rYWJsZShEYXRhVHlwZSk7XG4gIH0pO1xufVxuT2JqZWN0LmFzc2lnbihEYXRhVHlwZXMsIGRpYWxlY3RNYXApO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS10eXBlcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/data-types.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/deferrable.js":
/*!***************************************************!*\
  !*** ../node_modules/sequelize/lib/deferrable.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { classToInvokable } = __webpack_require__(/*! ./utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nclass ABSTRACT {\n  static toString(...args) {\n    return new this().toString(...args);\n  }\n  toString(...args) {\n    return this.toSql(...args);\n  }\n  toSql() {\n    throw new Error(\"toSql implementation missing\");\n  }\n}\nclass INITIALLY_DEFERRED extends ABSTRACT {\n  toSql() {\n    return \"DEFERRABLE INITIALLY DEFERRED\";\n  }\n}\nclass INITIALLY_IMMEDIATE extends ABSTRACT {\n  toSql() {\n    return \"DEFERRABLE INITIALLY IMMEDIATE\";\n  }\n}\nclass NOT extends ABSTRACT {\n  toSql() {\n    return \"NOT DEFERRABLE\";\n  }\n}\nclass SET_DEFERRED extends ABSTRACT {\n  constructor(constraints) {\n    super();\n    this.constraints = constraints;\n  }\n  toSql(queryGenerator) {\n    return queryGenerator.setDeferredQuery(this.constraints);\n  }\n}\nclass SET_IMMEDIATE extends ABSTRACT {\n  constructor(constraints) {\n    super();\n    this.constraints = constraints;\n  }\n  toSql(queryGenerator) {\n    return queryGenerator.setImmediateQuery(this.constraints);\n  }\n}\nconst Deferrable = {\n  INITIALLY_DEFERRED: classToInvokable(INITIALLY_DEFERRED),\n  INITIALLY_IMMEDIATE: classToInvokable(INITIALLY_IMMEDIATE),\n  NOT: classToInvokable(NOT),\n  SET_DEFERRED: classToInvokable(SET_DEFERRED),\n  SET_IMMEDIATE: classToInvokable(SET_IMMEDIATE)\n};\nmodule.exports = Deferrable;\n//# sourceMappingURL=deferrable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kZWZlcnJhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsUUFBUSxtQkFBbUIsRUFBRSxtQkFBTyxDQUFDLHdFQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGVmZXJyYWJsZS5qcz83ODJjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgeyBjbGFzc1RvSW52b2thYmxlIH0gPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNsYXNzIEFCU1RSQUNUIHtcbiAgc3RhdGljIHRvU3RyaW5nKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoKS50b1N0cmluZyguLi5hcmdzKTtcbiAgfVxuICB0b1N0cmluZyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TcWwoLi4uYXJncyk7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidG9TcWwgaW1wbGVtZW50YXRpb24gbWlzc2luZ1wiKTtcbiAgfVxufVxuY2xhc3MgSU5JVElBTExZX0RFRkVSUkVEIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gXCJERUZFUlJBQkxFIElOSVRJQUxMWSBERUZFUlJFRFwiO1xuICB9XG59XG5jbGFzcyBJTklUSUFMTFlfSU1NRURJQVRFIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gXCJERUZFUlJBQkxFIElOSVRJQUxMWSBJTU1FRElBVEVcIjtcbiAgfVxufVxuY2xhc3MgTk9UIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gXCJOT1QgREVGRVJSQUJMRVwiO1xuICB9XG59XG5jbGFzcyBTRVRfREVGRVJSRUQgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIGNvbnN0cnVjdG9yKGNvbnN0cmFpbnRzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNvbnN0cmFpbnRzID0gY29uc3RyYWludHM7XG4gIH1cbiAgdG9TcWwocXVlcnlHZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gcXVlcnlHZW5lcmF0b3Iuc2V0RGVmZXJyZWRRdWVyeSh0aGlzLmNvbnN0cmFpbnRzKTtcbiAgfVxufVxuY2xhc3MgU0VUX0lNTUVESUFURSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgY29uc3RydWN0b3IoY29uc3RyYWludHMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29uc3RyYWludHMgPSBjb25zdHJhaW50cztcbiAgfVxuICB0b1NxbChxdWVyeUdlbmVyYXRvcikge1xuICAgIHJldHVybiBxdWVyeUdlbmVyYXRvci5zZXRJbW1lZGlhdGVRdWVyeSh0aGlzLmNvbnN0cmFpbnRzKTtcbiAgfVxufVxuY29uc3QgRGVmZXJyYWJsZSA9IHtcbiAgSU5JVElBTExZX0RFRkVSUkVEOiBjbGFzc1RvSW52b2thYmxlKElOSVRJQUxMWV9ERUZFUlJFRCksXG4gIElOSVRJQUxMWV9JTU1FRElBVEU6IGNsYXNzVG9JbnZva2FibGUoSU5JVElBTExZX0lNTUVESUFURSksXG4gIE5PVDogY2xhc3NUb0ludm9rYWJsZShOT1QpLFxuICBTRVRfREVGRVJSRUQ6IGNsYXNzVG9JbnZva2FibGUoU0VUX0RFRkVSUkVEKSxcbiAgU0VUX0lNTUVESUFURTogY2xhc3NUb0ludm9rYWJsZShTRVRfSU1NRURJQVRFKVxufTtcbm1vZHVsZS5leHBvcnRzID0gRGVmZXJyYWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmVycmFibGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/deferrable.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/abstract/connection-manager.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/abstract/connection-manager.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { Pool, TimeoutError } = __webpack_require__(/*! sequelize-pool */ \"(action-browser)/../node_modules/sequelize-pool/lib/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst semver = __webpack_require__(/*! semver */ \"(action-browser)/../node_modules/semver/index.js\");\nconst errors = __webpack_require__(/*! ../../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(action-browser)/../node_modules/sequelize/lib/utils/logger.js\");\nconst deprecations = __webpack_require__(/*! ../../utils/deprecations */ \"(action-browser)/../node_modules/sequelize/lib/utils/deprecations.js\");\nconst debug = logger.debugContext(\"pool\");\nclass ConnectionManager {\n  constructor(dialect, sequelize) {\n    const config = _.cloneDeep(sequelize.config);\n    this.sequelize = sequelize;\n    this.config = config;\n    this.dialect = dialect;\n    this.versionPromise = null;\n    this.dialectName = this.sequelize.options.dialect;\n    if (config.pool === false) {\n      throw new Error(\"Support for pool:false was removed in v4.0\");\n    }\n    config.pool = _.defaults(config.pool || {}, {\n      max: 5,\n      min: 0,\n      idle: 1e4,\n      acquire: 6e4,\n      evict: 1e3,\n      validate: this._validate.bind(this)\n    });\n    this.initPools();\n  }\n  refreshTypeParser(dataTypes) {\n    _.each(dataTypes, (dataType) => {\n      if (Object.prototype.hasOwnProperty.call(dataType, \"parse\")) {\n        if (dataType.types[this.dialectName]) {\n          this._refreshTypeParser(dataType);\n        } else {\n          throw new Error(`Parse function not supported for type ${dataType.key} in dialect ${this.dialectName}`);\n        }\n      }\n    });\n  }\n  _loadDialectModule(moduleName) {\n    try {\n      if (this.sequelize.config.dialectModulePath) {\n        return __webpack_require__(\"(action-browser)/../node_modules/sequelize/lib/dialects/abstract sync recursive\")(this.sequelize.config.dialectModulePath);\n      }\n      if (this.sequelize.config.dialectModule) {\n        return this.sequelize.config.dialectModule;\n      }\n      return __webpack_require__(\"(action-browser)/../node_modules/sequelize/lib/dialects/abstract sync recursive\")(moduleName);\n    } catch (err) {\n      if (err.code === \"MODULE_NOT_FOUND\") {\n        if (this.sequelize.config.dialectModulePath) {\n          throw new Error(`Unable to find dialect at ${this.sequelize.config.dialectModulePath}`);\n        }\n        throw new Error(`Please install ${moduleName} package manually`);\n      }\n      throw err;\n    }\n  }\n  async _onProcessExit() {\n    if (!this.pool) {\n      return;\n    }\n    await this.pool.drain();\n    debug(\"connection drain due to process exit\");\n    return await this.pool.destroyAllNow();\n  }\n  async close() {\n    this.getConnection = async function getConnection() {\n      throw new Error(\"ConnectionManager.getConnection was called after the connection manager was closed!\");\n    };\n    return await this._onProcessExit();\n  }\n  initPools() {\n    const config = this.config;\n    if (!config.replication) {\n      this.pool = new Pool({\n        name: \"sequelize\",\n        create: () => this._connect(config),\n        destroy: async (connection) => {\n          const result = await this._disconnect(connection);\n          debug(\"connection destroy\");\n          return result;\n        },\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      });\n      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);\n      return;\n    }\n    if (!Array.isArray(config.replication.read)) {\n      config.replication.read = [config.replication.read];\n    }\n    config.replication.write = _.defaults(config.replication.write, _.omit(config, \"replication\"));\n    config.replication.read = config.replication.read.map((readConfig) => _.defaults(readConfig, _.omit(this.config, \"replication\")));\n    let reads = 0;\n    this.pool = {\n      release: (client) => {\n        if (client.queryType === \"read\") {\n          this.pool.read.release(client);\n        } else {\n          this.pool.write.release(client);\n        }\n      },\n      acquire: (queryType, useMaster) => {\n        useMaster = useMaster === void 0 ? false : useMaster;\n        if (queryType === \"SELECT\" && !useMaster) {\n          return this.pool.read.acquire();\n        }\n        return this.pool.write.acquire();\n      },\n      destroy: (connection) => {\n        this.pool[connection.queryType].destroy(connection);\n        debug(\"connection destroy\");\n      },\n      destroyAllNow: async () => {\n        await Promise.all([\n          this.pool.read.destroyAllNow(),\n          this.pool.write.destroyAllNow()\n        ]);\n        debug(\"all connections destroyed\");\n      },\n      drain: async () => Promise.all([\n        this.pool.write.drain(),\n        this.pool.read.drain()\n      ]),\n      read: new Pool({\n        name: \"sequelize:read\",\n        create: async () => {\n          const nextRead = reads++ % config.replication.read.length;\n          const connection = await this._connect(config.replication.read[nextRead]);\n          connection.queryType = \"read\";\n          return connection;\n        },\n        destroy: (connection) => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      }),\n      write: new Pool({\n        name: \"sequelize:write\",\n        create: async () => {\n          const connection = await this._connect(config.replication.write);\n          connection.queryType = \"write\";\n          return connection;\n        },\n        destroy: (connection) => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      })\n    };\n    debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);\n  }\n  async getConnection(options) {\n    options = options || {};\n    if (this.sequelize.options.databaseVersion === 0) {\n      if (!this.versionPromise) {\n        this.versionPromise = (async () => {\n          try {\n            const connection = await this._connect(this.config.replication.write || this.config);\n            const _options = {};\n            _options.transaction = { connection };\n            _options.logging = () => {\n            };\n            _options.logging.__testLoggingFn = true;\n            if (this.sequelize.options.databaseVersion === 0) {\n              const version = await this.sequelize.databaseVersion(_options);\n              const parsedVersion = _.get(semver.coerce(version), \"version\") || version;\n              this.sequelize.options.databaseVersion = semver.valid(parsedVersion) ? parsedVersion : this.dialect.defaultVersion;\n            }\n            if (semver.lt(this.sequelize.options.databaseVersion, this.dialect.defaultVersion)) {\n              deprecations.unsupportedEngine();\n              debug(`Unsupported database engine version ${this.sequelize.options.databaseVersion}`);\n            }\n            this.versionPromise = null;\n            return await this._disconnect(connection);\n          } catch (err) {\n            this.versionPromise = null;\n            throw err;\n          }\n        })();\n      }\n      await this.versionPromise;\n    }\n    let result;\n    try {\n      await this.sequelize.runHooks(\"beforePoolAcquire\", options);\n      result = await this.pool.acquire(options.type, options.useMaster);\n      await this.sequelize.runHooks(\"afterPoolAcquire\", result, options);\n    } catch (error) {\n      if (error instanceof TimeoutError)\n        throw new errors.ConnectionAcquireTimeoutError(error);\n      throw error;\n    }\n    debug(\"connection acquired\");\n    return result;\n  }\n  releaseConnection(connection) {\n    this.pool.release(connection);\n    debug(\"connection released\");\n  }\n  async destroyConnection(connection) {\n    await this.pool.destroy(connection);\n    debug(`connection ${connection.uuid} destroyed`);\n  }\n  async _connect(config) {\n    await this.sequelize.runHooks(\"beforeConnect\", config);\n    const connection = await this.dialect.connectionManager.connect(config);\n    await this.sequelize.runHooks(\"afterConnect\", connection, config);\n    return connection;\n  }\n  async _disconnect(connection) {\n    await this.sequelize.runHooks(\"beforeDisconnect\", connection);\n    await this.dialect.connectionManager.disconnect(connection);\n    return this.sequelize.runHooks(\"afterDisconnect\", connection);\n  }\n  _validate(connection) {\n    if (!this.dialect.connectionManager.validate) {\n      return true;\n    }\n    return this.dialect.connectionManager.validate(connection);\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9jb25uZWN0aW9uLW1hbmFnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixRQUFRLHFCQUFxQixFQUFFLG1CQUFPLENBQUMsb0ZBQWdCO0FBQ3ZELFVBQVUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMxQixlQUFlLG1CQUFPLENBQUMsZ0VBQVE7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLG9GQUFjO0FBQ3JDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsMEZBQW9CO0FBQy9DLHFCQUFxQixtQkFBTyxDQUFDLHNHQUEwQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG1FQUFtRSxjQUFjLGFBQWEsaUJBQWlCO0FBQy9HO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVHQUFRLHVDQUF1QyxDQUFDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1R0FBUSxVQUFVLENBQUM7QUFDaEMsTUFBTTtBQUNOO0FBQ0E7QUFDQSx1REFBdUQsd0NBQXdDO0FBQy9GO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMENBQTBDLGdCQUFnQixHQUFHLGdCQUFnQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3Q0FBd0MsZ0JBQWdCLEdBQUcsZ0JBQWdCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCx1Q0FBdUM7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9jb25uZWN0aW9uLW1hbmFnZXIuanM/YTU2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHsgUG9vbCwgVGltZW91dEVycm9yIH0gPSByZXF1aXJlKFwic2VxdWVsaXplLXBvb2xcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IHNlbXZlciA9IHJlcXVpcmUoXCJzZW12ZXJcIik7XG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzXCIpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9sb2dnZXJcIik7XG5jb25zdCBkZXByZWNhdGlvbnMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvZGVwcmVjYXRpb25zXCIpO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KFwicG9vbFwiKTtcbmNsYXNzIENvbm5lY3Rpb25NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZGlhbGVjdCwgc2VxdWVsaXplKSB7XG4gICAgY29uc3QgY29uZmlnID0gXy5jbG9uZURlZXAoc2VxdWVsaXplLmNvbmZpZyk7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5kaWFsZWN0ID0gZGlhbGVjdDtcbiAgICB0aGlzLnZlcnNpb25Qcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLmRpYWxlY3ROYW1lID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0O1xuICAgIGlmIChjb25maWcucG9vbCA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1cHBvcnQgZm9yIHBvb2w6ZmFsc2Ugd2FzIHJlbW92ZWQgaW4gdjQuMFwiKTtcbiAgICB9XG4gICAgY29uZmlnLnBvb2wgPSBfLmRlZmF1bHRzKGNvbmZpZy5wb29sIHx8IHt9LCB7XG4gICAgICBtYXg6IDUsXG4gICAgICBtaW46IDAsXG4gICAgICBpZGxlOiAxZTQsXG4gICAgICBhY3F1aXJlOiA2ZTQsXG4gICAgICBldmljdDogMWUzLFxuICAgICAgdmFsaWRhdGU6IHRoaXMuX3ZhbGlkYXRlLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLmluaXRQb29scygpO1xuICB9XG4gIHJlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlcykge1xuICAgIF8uZWFjaChkYXRhVHlwZXMsIChkYXRhVHlwZSkgPT4ge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhVHlwZSwgXCJwYXJzZVwiKSkge1xuICAgICAgICBpZiAoZGF0YVR5cGUudHlwZXNbdGhpcy5kaWFsZWN0TmFtZV0pIHtcbiAgICAgICAgICB0aGlzLl9yZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJzZSBmdW5jdGlvbiBub3Qgc3VwcG9ydGVkIGZvciB0eXBlICR7ZGF0YVR5cGUua2V5fSBpbiBkaWFsZWN0ICR7dGhpcy5kaWFsZWN0TmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9sb2FkRGlhbGVjdE1vZHVsZShtb2R1bGVOYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGlhbGVjdE1vZHVsZVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUodGhpcy5zZXF1ZWxpemUuY29uZmlnLmRpYWxlY3RNb2R1bGVQYXRoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGlhbGVjdE1vZHVsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUuY29uZmlnLmRpYWxlY3RNb2R1bGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWlyZShtb2R1bGVOYW1lKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gXCJNT0RVTEVfTk9UX0ZPVU5EXCIpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kaWFsZWN0TW9kdWxlUGF0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgZGlhbGVjdCBhdCAke3RoaXMuc2VxdWVsaXplLmNvbmZpZy5kaWFsZWN0TW9kdWxlUGF0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBsZWFzZSBpbnN0YWxsICR7bW9kdWxlTmFtZX0gcGFja2FnZSBtYW51YWxseWApO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICBhc3luYyBfb25Qcm9jZXNzRXhpdCgpIHtcbiAgICBpZiAoIXRoaXMucG9vbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnBvb2wuZHJhaW4oKTtcbiAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gZHJhaW4gZHVlIHRvIHByb2Nlc3MgZXhpdFwiKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5wb29sLmRlc3Ryb3lBbGxOb3coKTtcbiAgfVxuICBhc3luYyBjbG9zZSgpIHtcbiAgICB0aGlzLmdldENvbm5lY3Rpb24gPSBhc3luYyBmdW5jdGlvbiBnZXRDb25uZWN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ubmVjdGlvbk1hbmFnZXIuZ2V0Q29ubmVjdGlvbiB3YXMgY2FsbGVkIGFmdGVyIHRoZSBjb25uZWN0aW9uIG1hbmFnZXIgd2FzIGNsb3NlZCFcIik7XG4gICAgfTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fb25Qcm9jZXNzRXhpdCgpO1xuICB9XG4gIGluaXRQb29scygpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoIWNvbmZpZy5yZXBsaWNhdGlvbikge1xuICAgICAgdGhpcy5wb29sID0gbmV3IFBvb2woe1xuICAgICAgICBuYW1lOiBcInNlcXVlbGl6ZVwiLFxuICAgICAgICBjcmVhdGU6ICgpID0+IHRoaXMuX2Nvbm5lY3QoY29uZmlnKSxcbiAgICAgICAgZGVzdHJveTogYXN5bmMgKGNvbm5lY3Rpb24pID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9kaXNjb25uZWN0KGNvbm5lY3Rpb24pO1xuICAgICAgICAgIGRlYnVnKFwiY29ubmVjdGlvbiBkZXN0cm95XCIpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRlOiBjb25maWcucG9vbC52YWxpZGF0ZSxcbiAgICAgICAgbWF4OiBjb25maWcucG9vbC5tYXgsXG4gICAgICAgIG1pbjogY29uZmlnLnBvb2wubWluLFxuICAgICAgICBhY3F1aXJlVGltZW91dE1pbGxpczogY29uZmlnLnBvb2wuYWNxdWlyZSxcbiAgICAgICAgaWRsZVRpbWVvdXRNaWxsaXM6IGNvbmZpZy5wb29sLmlkbGUsXG4gICAgICAgIHJlYXBJbnRlcnZhbE1pbGxpczogY29uZmlnLnBvb2wuZXZpY3QsXG4gICAgICAgIG1heFVzZXM6IGNvbmZpZy5wb29sLm1heFVzZXNcbiAgICAgIH0pO1xuICAgICAgZGVidWcoYHBvb2wgY3JlYXRlZCB3aXRoIG1heC9taW46ICR7Y29uZmlnLnBvb2wubWF4fS8ke2NvbmZpZy5wb29sLm1pbn0sIG5vIHJlcGxpY2F0aW9uYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShjb25maWcucmVwbGljYXRpb24ucmVhZCkpIHtcbiAgICAgIGNvbmZpZy5yZXBsaWNhdGlvbi5yZWFkID0gW2NvbmZpZy5yZXBsaWNhdGlvbi5yZWFkXTtcbiAgICB9XG4gICAgY29uZmlnLnJlcGxpY2F0aW9uLndyaXRlID0gXy5kZWZhdWx0cyhjb25maWcucmVwbGljYXRpb24ud3JpdGUsIF8ub21pdChjb25maWcsIFwicmVwbGljYXRpb25cIikpO1xuICAgIGNvbmZpZy5yZXBsaWNhdGlvbi5yZWFkID0gY29uZmlnLnJlcGxpY2F0aW9uLnJlYWQubWFwKChyZWFkQ29uZmlnKSA9PiBfLmRlZmF1bHRzKHJlYWRDb25maWcsIF8ub21pdCh0aGlzLmNvbmZpZywgXCJyZXBsaWNhdGlvblwiKSkpO1xuICAgIGxldCByZWFkcyA9IDA7XG4gICAgdGhpcy5wb29sID0ge1xuICAgICAgcmVsZWFzZTogKGNsaWVudCkgPT4ge1xuICAgICAgICBpZiAoY2xpZW50LnF1ZXJ5VHlwZSA9PT0gXCJyZWFkXCIpIHtcbiAgICAgICAgICB0aGlzLnBvb2wucmVhZC5yZWxlYXNlKGNsaWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wb29sLndyaXRlLnJlbGVhc2UoY2xpZW50KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFjcXVpcmU6IChxdWVyeVR5cGUsIHVzZU1hc3RlcikgPT4ge1xuICAgICAgICB1c2VNYXN0ZXIgPSB1c2VNYXN0ZXIgPT09IHZvaWQgMCA/IGZhbHNlIDogdXNlTWFzdGVyO1xuICAgICAgICBpZiAocXVlcnlUeXBlID09PSBcIlNFTEVDVFwiICYmICF1c2VNYXN0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wb29sLnJlYWQuYWNxdWlyZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvb2wud3JpdGUuYWNxdWlyZSgpO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3k6IChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgIHRoaXMucG9vbFtjb25uZWN0aW9uLnF1ZXJ5VHlwZV0uZGVzdHJveShjb25uZWN0aW9uKTtcbiAgICAgICAgZGVidWcoXCJjb25uZWN0aW9uIGRlc3Ryb3lcIik7XG4gICAgICB9LFxuICAgICAgZGVzdHJveUFsbE5vdzogYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgdGhpcy5wb29sLnJlYWQuZGVzdHJveUFsbE5vdygpLFxuICAgICAgICAgIHRoaXMucG9vbC53cml0ZS5kZXN0cm95QWxsTm93KClcbiAgICAgICAgXSk7XG4gICAgICAgIGRlYnVnKFwiYWxsIGNvbm5lY3Rpb25zIGRlc3Ryb3llZFwiKTtcbiAgICAgIH0sXG4gICAgICBkcmFpbjogYXN5bmMgKCkgPT4gUHJvbWlzZS5hbGwoW1xuICAgICAgICB0aGlzLnBvb2wud3JpdGUuZHJhaW4oKSxcbiAgICAgICAgdGhpcy5wb29sLnJlYWQuZHJhaW4oKVxuICAgICAgXSksXG4gICAgICByZWFkOiBuZXcgUG9vbCh7XG4gICAgICAgIG5hbWU6IFwic2VxdWVsaXplOnJlYWRcIixcbiAgICAgICAgY3JlYXRlOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV4dFJlYWQgPSByZWFkcysrICUgY29uZmlnLnJlcGxpY2F0aW9uLnJlYWQubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCB0aGlzLl9jb25uZWN0KGNvbmZpZy5yZXBsaWNhdGlvbi5yZWFkW25leHRSZWFkXSk7XG4gICAgICAgICAgY29ubmVjdGlvbi5xdWVyeVR5cGUgPSBcInJlYWRcIjtcbiAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveTogKGNvbm5lY3Rpb24pID0+IHRoaXMuX2Rpc2Nvbm5lY3QoY29ubmVjdGlvbiksXG4gICAgICAgIHZhbGlkYXRlOiBjb25maWcucG9vbC52YWxpZGF0ZSxcbiAgICAgICAgbWF4OiBjb25maWcucG9vbC5tYXgsXG4gICAgICAgIG1pbjogY29uZmlnLnBvb2wubWluLFxuICAgICAgICBhY3F1aXJlVGltZW91dE1pbGxpczogY29uZmlnLnBvb2wuYWNxdWlyZSxcbiAgICAgICAgaWRsZVRpbWVvdXRNaWxsaXM6IGNvbmZpZy5wb29sLmlkbGUsXG4gICAgICAgIHJlYXBJbnRlcnZhbE1pbGxpczogY29uZmlnLnBvb2wuZXZpY3QsXG4gICAgICAgIG1heFVzZXM6IGNvbmZpZy5wb29sLm1heFVzZXNcbiAgICAgIH0pLFxuICAgICAgd3JpdGU6IG5ldyBQb29sKHtcbiAgICAgICAgbmFtZTogXCJzZXF1ZWxpemU6d3JpdGVcIixcbiAgICAgICAgY3JlYXRlOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHRoaXMuX2Nvbm5lY3QoY29uZmlnLnJlcGxpY2F0aW9uLndyaXRlKTtcbiAgICAgICAgICBjb25uZWN0aW9uLnF1ZXJ5VHlwZSA9IFwid3JpdGVcIjtcbiAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveTogKGNvbm5lY3Rpb24pID0+IHRoaXMuX2Rpc2Nvbm5lY3QoY29ubmVjdGlvbiksXG4gICAgICAgIHZhbGlkYXRlOiBjb25maWcucG9vbC52YWxpZGF0ZSxcbiAgICAgICAgbWF4OiBjb25maWcucG9vbC5tYXgsXG4gICAgICAgIG1pbjogY29uZmlnLnBvb2wubWluLFxuICAgICAgICBhY3F1aXJlVGltZW91dE1pbGxpczogY29uZmlnLnBvb2wuYWNxdWlyZSxcbiAgICAgICAgaWRsZVRpbWVvdXRNaWxsaXM6IGNvbmZpZy5wb29sLmlkbGUsXG4gICAgICAgIHJlYXBJbnRlcnZhbE1pbGxpczogY29uZmlnLnBvb2wuZXZpY3QsXG4gICAgICAgIG1heFVzZXM6IGNvbmZpZy5wb29sLm1heFVzZXNcbiAgICAgIH0pXG4gICAgfTtcbiAgICBkZWJ1ZyhgcG9vbCBjcmVhdGVkIHdpdGggbWF4L21pbjogJHtjb25maWcucG9vbC5tYXh9LyR7Y29uZmlnLnBvb2wubWlufSwgd2l0aCByZXBsaWNhdGlvbmApO1xuICB9XG4gIGFzeW5jIGdldENvbm5lY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbiA9PT0gMCkge1xuICAgICAgaWYgKCF0aGlzLnZlcnNpb25Qcm9taXNlKSB7XG4gICAgICAgIHRoaXMudmVyc2lvblByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgdGhpcy5fY29ubmVjdCh0aGlzLmNvbmZpZy5yZXBsaWNhdGlvbi53cml0ZSB8fCB0aGlzLmNvbmZpZyk7XG4gICAgICAgICAgICBjb25zdCBfb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgX29wdGlvbnMudHJhbnNhY3Rpb24gPSB7IGNvbm5lY3Rpb24gfTtcbiAgICAgICAgICAgIF9vcHRpb25zLmxvZ2dpbmcgPSAoKSA9PiB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX29wdGlvbnMubG9nZ2luZy5fX3Rlc3RMb2dnaW5nRm4gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5kYXRhYmFzZVZlcnNpb24oX29wdGlvbnMpO1xuICAgICAgICAgICAgICBjb25zdCBwYXJzZWRWZXJzaW9uID0gXy5nZXQoc2VtdmVyLmNvZXJjZSh2ZXJzaW9uKSwgXCJ2ZXJzaW9uXCIpIHx8IHZlcnNpb247XG4gICAgICAgICAgICAgIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uID0gc2VtdmVyLnZhbGlkKHBhcnNlZFZlcnNpb24pID8gcGFyc2VkVmVyc2lvbiA6IHRoaXMuZGlhbGVjdC5kZWZhdWx0VmVyc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZW12ZXIubHQodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24sIHRoaXMuZGlhbGVjdC5kZWZhdWx0VmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgZGVwcmVjYXRpb25zLnVuc3VwcG9ydGVkRW5naW5lKCk7XG4gICAgICAgICAgICAgIGRlYnVnKGBVbnN1cHBvcnRlZCBkYXRhYmFzZSBlbmdpbmUgdmVyc2lvbiAke3RoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9ufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52ZXJzaW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fZGlzY29ubmVjdChjb25uZWN0aW9uKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMudmVyc2lvblByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMudmVyc2lvblByb21pc2U7XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnJ1bkhvb2tzKFwiYmVmb3JlUG9vbEFjcXVpcmVcIiwgb3B0aW9ucyk7XG4gICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnBvb2wuYWNxdWlyZShvcHRpb25zLnR5cGUsIG9wdGlvbnMudXNlTWFzdGVyKTtcbiAgICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnJ1bkhvb2tzKFwiYWZ0ZXJQb29sQWNxdWlyZVwiLCByZXN1bHQsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUaW1lb3V0RXJyb3IpXG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuQ29ubmVjdGlvbkFjcXVpcmVUaW1lb3V0RXJyb3IoZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGRlYnVnKFwiY29ubmVjdGlvbiBhY3F1aXJlZFwiKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJlbGVhc2VDb25uZWN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICB0aGlzLnBvb2wucmVsZWFzZShjb25uZWN0aW9uKTtcbiAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gcmVsZWFzZWRcIik7XG4gIH1cbiAgYXN5bmMgZGVzdHJveUNvbm5lY3Rpb24oY29ubmVjdGlvbikge1xuICAgIGF3YWl0IHRoaXMucG9vbC5kZXN0cm95KGNvbm5lY3Rpb24pO1xuICAgIGRlYnVnKGBjb25uZWN0aW9uICR7Y29ubmVjdGlvbi51dWlkfSBkZXN0cm95ZWRgKTtcbiAgfVxuICBhc3luYyBfY29ubmVjdChjb25maWcpIHtcbiAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5ydW5Ib29rcyhcImJlZm9yZUNvbm5lY3RcIiwgY29uZmlnKTtcbiAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgdGhpcy5kaWFsZWN0LmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3QoY29uZmlnKTtcbiAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5ydW5Ib29rcyhcImFmdGVyQ29ubmVjdFwiLCBjb25uZWN0aW9uLCBjb25maWcpO1xuICAgIHJldHVybiBjb25uZWN0aW9uO1xuICB9XG4gIGFzeW5jIF9kaXNjb25uZWN0KGNvbm5lY3Rpb24pIHtcbiAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5ydW5Ib29rcyhcImJlZm9yZURpc2Nvbm5lY3RcIiwgY29ubmVjdGlvbik7XG4gICAgYXdhaXQgdGhpcy5kaWFsZWN0LmNvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3QoY29ubmVjdGlvbik7XG4gICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnJ1bkhvb2tzKFwiYWZ0ZXJEaXNjb25uZWN0XCIsIGNvbm5lY3Rpb24pO1xuICB9XG4gIF92YWxpZGF0ZShjb25uZWN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmRpYWxlY3QuY29ubmVjdGlvbk1hbmFnZXIudmFsaWRhdGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kaWFsZWN0LmNvbm5lY3Rpb25NYW5hZ2VyLnZhbGlkYXRlKGNvbm5lY3Rpb24pO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbk1hbmFnZXIgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpb24tbWFuYWdlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/abstract/connection-manager.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/abstract/index.js":
/*!****************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/abstract/index.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
eval("\nclass AbstractDialect {\n  canBackslashEscape() {\n    return false;\n  }\n}\nAbstractDialect.prototype.supports = {\n  \"DEFAULT\": true,\n  \"DEFAULT VALUES\": false,\n  \"VALUES ()\": false,\n  \"LIMIT ON UPDATE\": false,\n  \"ON DUPLICATE KEY\": true,\n  \"ORDER NULLS\": false,\n  \"UNION\": true,\n  \"UNION ALL\": true,\n  \"RIGHT JOIN\": true,\n  returnValues: false,\n  autoIncrement: {\n    identityInsert: false,\n    defaultValue: true,\n    update: true\n  },\n  bulkDefault: false,\n  schemas: false,\n  transactions: true,\n  settingIsolationLevelDuringTransaction: true,\n  transactionOptions: {\n    type: false\n  },\n  migrations: true,\n  upserts: true,\n  inserts: {\n    ignoreDuplicates: \"\",\n    updateOnDuplicate: false,\n    onConflictDoNothing: \"\",\n    onConflictWhere: false,\n    conflictFields: false\n  },\n  constraints: {\n    restrict: true,\n    addConstraint: true,\n    dropConstraint: true,\n    unique: true,\n    default: false,\n    check: true,\n    foreignKey: true,\n    primaryKey: true\n  },\n  index: {\n    collate: true,\n    length: false,\n    parser: false,\n    concurrently: false,\n    type: false,\n    using: true,\n    functionBased: false,\n    operator: false\n  },\n  groupedLimit: true,\n  indexViaAlter: false,\n  JSON: false,\n  deferrableConstraints: false,\n  escapeStringConstants: false\n};\nmodule.exports = AbstractDialect;\nmodule.exports.AbstractDialect = AbstractDialect;\nmodule.exports[\"default\"] = AbstractDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qix5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvYWJzdHJhY3QvaW5kZXguanM/NmU1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIEFic3RyYWN0RGlhbGVjdCB7XG4gIGNhbkJhY2tzbGFzaEVzY2FwZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbkFic3RyYWN0RGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMgPSB7XG4gIFwiREVGQVVMVFwiOiB0cnVlLFxuICBcIkRFRkFVTFQgVkFMVUVTXCI6IGZhbHNlLFxuICBcIlZBTFVFUyAoKVwiOiBmYWxzZSxcbiAgXCJMSU1JVCBPTiBVUERBVEVcIjogZmFsc2UsXG4gIFwiT04gRFVQTElDQVRFIEtFWVwiOiB0cnVlLFxuICBcIk9SREVSIE5VTExTXCI6IGZhbHNlLFxuICBcIlVOSU9OXCI6IHRydWUsXG4gIFwiVU5JT04gQUxMXCI6IHRydWUsXG4gIFwiUklHSFQgSk9JTlwiOiB0cnVlLFxuICByZXR1cm5WYWx1ZXM6IGZhbHNlLFxuICBhdXRvSW5jcmVtZW50OiB7XG4gICAgaWRlbnRpdHlJbnNlcnQ6IGZhbHNlLFxuICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZSxcbiAgICB1cGRhdGU6IHRydWVcbiAgfSxcbiAgYnVsa0RlZmF1bHQ6IGZhbHNlLFxuICBzY2hlbWFzOiBmYWxzZSxcbiAgdHJhbnNhY3Rpb25zOiB0cnVlLFxuICBzZXR0aW5nSXNvbGF0aW9uTGV2ZWxEdXJpbmdUcmFuc2FjdGlvbjogdHJ1ZSxcbiAgdHJhbnNhY3Rpb25PcHRpb25zOiB7XG4gICAgdHlwZTogZmFsc2VcbiAgfSxcbiAgbWlncmF0aW9uczogdHJ1ZSxcbiAgdXBzZXJ0czogdHJ1ZSxcbiAgaW5zZXJ0czoge1xuICAgIGlnbm9yZUR1cGxpY2F0ZXM6IFwiXCIsXG4gICAgdXBkYXRlT25EdXBsaWNhdGU6IGZhbHNlLFxuICAgIG9uQ29uZmxpY3REb05vdGhpbmc6IFwiXCIsXG4gICAgb25Db25mbGljdFdoZXJlOiBmYWxzZSxcbiAgICBjb25mbGljdEZpZWxkczogZmFsc2VcbiAgfSxcbiAgY29uc3RyYWludHM6IHtcbiAgICByZXN0cmljdDogdHJ1ZSxcbiAgICBhZGRDb25zdHJhaW50OiB0cnVlLFxuICAgIGRyb3BDb25zdHJhaW50OiB0cnVlLFxuICAgIHVuaXF1ZTogdHJ1ZSxcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICBjaGVjazogdHJ1ZSxcbiAgICBmb3JlaWduS2V5OiB0cnVlLFxuICAgIHByaW1hcnlLZXk6IHRydWVcbiAgfSxcbiAgaW5kZXg6IHtcbiAgICBjb2xsYXRlOiB0cnVlLFxuICAgIGxlbmd0aDogZmFsc2UsXG4gICAgcGFyc2VyOiBmYWxzZSxcbiAgICBjb25jdXJyZW50bHk6IGZhbHNlLFxuICAgIHR5cGU6IGZhbHNlLFxuICAgIHVzaW5nOiB0cnVlLFxuICAgIGZ1bmN0aW9uQmFzZWQ6IGZhbHNlLFxuICAgIG9wZXJhdG9yOiBmYWxzZVxuICB9LFxuICBncm91cGVkTGltaXQ6IHRydWUsXG4gIGluZGV4VmlhQWx0ZXI6IGZhbHNlLFxuICBKU09OOiBmYWxzZSxcbiAgZGVmZXJyYWJsZUNvbnN0cmFpbnRzOiBmYWxzZSxcbiAgZXNjYXBlU3RyaW5nQ29uc3RhbnRzOiBmYWxzZVxufTtcbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3REaWFsZWN0O1xubW9kdWxlLmV4cG9ydHMuQWJzdHJhY3REaWFsZWN0ID0gQWJzdHJhY3REaWFsZWN0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IEFic3RyYWN0RGlhbGVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/abstract/index.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-generator.js":
/*!**************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/abstract/query-generator.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst util = __webpack_require__(/*! util */ \"util\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst uuidv4 = (__webpack_require__(/*! uuid */ \"(action-browser)/../node_modules/uuid/dist/esm-node/index.js\").v4);\nconst Utils = __webpack_require__(/*! ../../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst deprecations = __webpack_require__(/*! ../../utils/deprecations */ \"(action-browser)/../node_modules/sequelize/lib/utils/deprecations.js\");\nconst SqlString = __webpack_require__(/*! ../../sql-string */ \"(action-browser)/../node_modules/sequelize/lib/sql-string.js\");\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\");\nconst Model = __webpack_require__(/*! ../../model */ \"(action-browser)/../node_modules/sequelize/lib/model.js\");\nconst Association = __webpack_require__(/*! ../../associations/base */ \"(action-browser)/../node_modules/sequelize/lib/associations/base.js\");\nconst BelongsTo = __webpack_require__(/*! ../../associations/belongs-to */ \"(action-browser)/../node_modules/sequelize/lib/associations/belongs-to.js\");\nconst BelongsToMany = __webpack_require__(/*! ../../associations/belongs-to-many */ \"(action-browser)/../node_modules/sequelize/lib/associations/belongs-to-many.js\");\nconst HasMany = __webpack_require__(/*! ../../associations/has-many */ \"(action-browser)/../node_modules/sequelize/lib/associations/has-many.js\");\nconst Op = __webpack_require__(/*! ../../operators */ \"(action-browser)/../node_modules/sequelize/lib/operators.js\");\nconst sequelizeError = __webpack_require__(/*! ../../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst IndexHints = __webpack_require__(/*! ../../index-hints */ \"(action-browser)/../node_modules/sequelize/lib/index-hints.js\");\nclass QueryGenerator {\n  constructor(options) {\n    if (!options.sequelize)\n      throw new Error(\"QueryGenerator initialized without options.sequelize\");\n    if (!options._dialect)\n      throw new Error(\"QueryGenerator initialized without options._dialect\");\n    this.sequelize = options.sequelize;\n    this.options = options.sequelize.options;\n    this.dialect = options._dialect.name;\n    this._dialect = options._dialect;\n    this._initQuoteIdentifier();\n  }\n  extractTableDetails(tableName, options) {\n    options = options || {};\n    tableName = tableName || {};\n    return {\n      schema: tableName.schema || options.schema || this.options.schema || \"public\",\n      tableName: _.isPlainObject(tableName) ? tableName.tableName : tableName,\n      delimiter: tableName.delimiter || options.delimiter || \".\"\n    };\n  }\n  addSchema(param) {\n    if (!param._schema)\n      return param.tableName || param;\n    const self = this;\n    return {\n      tableName: param.tableName || param,\n      table: param.tableName || param,\n      name: param.name || param,\n      schema: param._schema,\n      delimiter: param._schemaDelimiter || \".\",\n      toString() {\n        return self.quoteTable(this);\n      }\n    };\n  }\n  dropSchema(tableName, options) {\n    return this.dropTableQuery(tableName, options);\n  }\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(this.addSchema({\n      tableName,\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter\n    }));\n    return `DESCRIBE ${table};`;\n  }\n  dropTableQuery(tableName) {\n    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)};`;\n  }\n  renameTableQuery(before, after) {\n    return `ALTER TABLE ${this.quoteTable(before)} RENAME TO ${this.quoteTable(after)};`;\n  }\n  populateInsertQueryReturnIntoBinds() {\n  }\n  insertQuery(table, valueHash, modelAttributes, options) {\n    options = options || {};\n    _.defaults(options, this.options);\n    const modelAttributeMap = {};\n    const bind = options.bind || [];\n    const fields = [];\n    const returningModelAttributes = [];\n    const returnTypes = [];\n    const values = [];\n    const quotedTable = this.quoteTable(table);\n    const bindParam = options.bindParam === void 0 ? this.bindParam(bind) : options.bindParam;\n    const returnAttributes = [];\n    let query;\n    let valueQuery = \"\";\n    let emptyQuery = \"\";\n    let outputFragment = \"\";\n    let returningFragment = \"\";\n    let identityWrapperRequired = false;\n    let tmpTable = \"\";\n    if (modelAttributes) {\n      _.each(modelAttributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n    if (this._dialect.supports[\"DEFAULT VALUES\"]) {\n      emptyQuery += \" DEFAULT VALUES\";\n    } else if (this._dialect.supports[\"VALUES ()\"]) {\n      emptyQuery += \" VALUES ()\";\n    }\n    if ((this._dialect.supports.returnValues || this._dialect.supports.returnIntoValues) && options.returning) {\n      const returnValues = this.generateReturnValues(modelAttributes, options);\n      returningModelAttributes.push(...returnValues.returnFields);\n      if (this._dialect.supports.returnIntoValues) {\n        returnTypes.push(...returnValues.returnTypes);\n      }\n      returningFragment = returnValues.returningFragment;\n      tmpTable = returnValues.tmpTable || \"\";\n      outputFragment = returnValues.outputFragment || \"\";\n    }\n    if (_.get(this, [\"sequelize\", \"options\", \"dialectOptions\", \"prependSearchPath\"]) || options.searchPath) {\n      options.bindParam = false;\n    }\n    if (this._dialect.supports.EXCEPTION && options.exception) {\n      options.bindParam = false;\n    }\n    valueHash = Utils.removeNullValuesFromHash(valueHash, this.options.omitNull);\n    for (const key in valueHash) {\n      if (Object.prototype.hasOwnProperty.call(valueHash, key)) {\n        const value = valueHash[key];\n        fields.push(this.quoteIdentifier(key));\n        if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && value == null) {\n          if (!this._dialect.supports.autoIncrement.defaultValue) {\n            fields.splice(-1, 1);\n          } else if (this._dialect.supports.DEFAULT) {\n            values.push(\"DEFAULT\");\n          } else {\n            values.push(this.escape(null));\n          }\n        } else {\n          if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true) {\n            identityWrapperRequired = true;\n          }\n          if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n            values.push(this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"INSERT\" }));\n          } else {\n            values.push(this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"INSERT\" }, bindParam));\n          }\n        }\n      }\n    }\n    let onDuplicateKeyUpdate = \"\";\n    if (!_.isEmpty(options.conflictWhere) && !this._dialect.supports.inserts.onConflictWhere) {\n      throw new Error(\"missing dialect support for conflictWhere option\");\n    }\n    if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {\n      if (this._dialect.supports.inserts.updateOnDuplicate == \" ON CONFLICT DO UPDATE SET\") {\n        const conflictKeys = options.upsertKeys.map((attr) => this.quoteIdentifier(attr));\n        const updateKeys = options.updateOnDuplicate.map((attr) => `${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);\n        const fragments = [\n          \"ON CONFLICT\",\n          \"(\",\n          conflictKeys.join(\",\"),\n          \")\"\n        ];\n        if (!_.isEmpty(options.conflictWhere)) {\n          fragments.push(this.whereQuery(options.conflictWhere, options));\n        }\n        if (_.isEmpty(updateKeys)) {\n          fragments.push(\"DO NOTHING\");\n        } else {\n          fragments.push(\"DO UPDATE SET\", updateKeys.join(\",\"));\n        }\n        onDuplicateKeyUpdate = ` ${Utils.joinSQLFragments(fragments)}`;\n      } else {\n        const valueKeys = options.updateOnDuplicate.map((attr) => `${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);\n        if (_.isEmpty(valueKeys) && options.upsertKeys) {\n          valueKeys.push(...options.upsertKeys.map((attr) => `${this.quoteIdentifier(attr)}=${this.quoteIdentifier(attr)}`));\n        }\n        if (_.isEmpty(valueKeys)) {\n          throw new Error(\"No update values found for ON DUPLICATE KEY UPDATE clause, and no identifier fields could be found to use instead.\");\n        }\n        onDuplicateKeyUpdate += `${this._dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(\",\")}`;\n      }\n    }\n    const replacements = {\n      ignoreDuplicates: options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : \"\",\n      onConflictDoNothing: options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : \"\",\n      attributes: fields.join(\",\"),\n      output: outputFragment,\n      values: values.join(\",\"),\n      tmpTable\n    };\n    valueQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable} (${replacements.attributes})${replacements.output} VALUES (${replacements.values})${onDuplicateKeyUpdate}${replacements.onConflictDoNothing}${valueQuery}`;\n    emptyQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable}${replacements.output}${onDuplicateKeyUpdate}${replacements.onConflictDoNothing}${emptyQuery}`;\n    if (this._dialect.supports.EXCEPTION && options.exception) {\n      const dropFunction = \"DROP FUNCTION IF EXISTS pg_temp.testfunc()\";\n      if (returningModelAttributes.length === 0) {\n        returningModelAttributes.push(\"*\");\n      }\n      const delimiter = `$func_${uuidv4().replace(/-/g, \"\")}$`;\n      const selectQuery = `SELECT (testfunc.response).${returningModelAttributes.join(\", (testfunc.response).\")}, testfunc.sequelize_caught_exception FROM pg_temp.testfunc();`;\n      options.exception = \"WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;\";\n      valueQuery = `CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response ${quotedTable}, OUT sequelize_caught_exception text) RETURNS RECORD AS ${delimiter} BEGIN ${valueQuery} RETURNING * INTO response; EXCEPTION ${options.exception} END ${delimiter} LANGUAGE plpgsql; ${selectQuery} ${dropFunction}`;\n    } else {\n      valueQuery += returningFragment;\n      emptyQuery += returningFragment;\n    }\n    if (this._dialect.supports.returnIntoValues && options.returning) {\n      this.populateInsertQueryReturnIntoBinds(returningModelAttributes, returnTypes, bind.length, returnAttributes, options);\n    }\n    query = `${replacements.attributes.length ? valueQuery : emptyQuery}${returnAttributes.join(\",\")};`;\n    if (this._dialect.supports.finalTable) {\n      query = `SELECT * FROM FINAL TABLE(${replacements.attributes.length ? valueQuery : emptyQuery});`;\n    }\n    if (identityWrapperRequired && this._dialect.supports.autoIncrement.identityInsert) {\n      query = `SET IDENTITY_INSERT ${quotedTable} ON; ${query} SET IDENTITY_INSERT ${quotedTable} OFF;`;\n    }\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = bind;\n    }\n    return result;\n  }\n  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n    options = options || {};\n    fieldMappedAttributes = fieldMappedAttributes || {};\n    const tuples = [];\n    const serials = {};\n    const allAttributes = [];\n    let onDuplicateKeyUpdate = \"\";\n    for (const fieldValueHash of fieldValueHashes) {\n      _.forOwn(fieldValueHash, (value, key) => {\n        if (!allAttributes.includes(key)) {\n          allAttributes.push(key);\n        }\n        if (fieldMappedAttributes[key] && fieldMappedAttributes[key].autoIncrement === true) {\n          serials[key] = true;\n        }\n      });\n    }\n    for (const fieldValueHash of fieldValueHashes) {\n      const values = allAttributes.map((key) => {\n        if (this._dialect.supports.bulkDefault && serials[key] === true) {\n          return fieldValueHash[key] != null ? fieldValueHash[key] : \"DEFAULT\";\n        }\n        return this.escape(fieldValueHash[key], fieldMappedAttributes[key], { context: \"INSERT\" });\n      });\n      tuples.push(`(${values.join(\",\")})`);\n    }\n    if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {\n      if (this._dialect.supports.inserts.updateOnDuplicate == \" ON CONFLICT DO UPDATE SET\") {\n        const conflictKeys = options.upsertKeys.map((attr) => this.quoteIdentifier(attr));\n        const updateKeys = options.updateOnDuplicate.map((attr) => `${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);\n        let whereClause = false;\n        if (options.conflictWhere) {\n          if (!this._dialect.supports.inserts.onConflictWhere) {\n            throw new Error(`conflictWhere not supported for dialect ${this._dialect.name}`);\n          }\n          whereClause = this.whereQuery(options.conflictWhere, options);\n        }\n        onDuplicateKeyUpdate = [\n          \"ON CONFLICT\",\n          \"(\",\n          conflictKeys.join(\",\"),\n          \")\",\n          whereClause,\n          \"DO UPDATE SET\",\n          updateKeys.join(\",\")\n        ];\n      } else {\n        if (options.conflictWhere) {\n          throw new Error(`conflictWhere not supported for dialect ${this._dialect.name}`);\n        }\n        const valueKeys = options.updateOnDuplicate.map((attr) => `${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);\n        onDuplicateKeyUpdate = `${this._dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(\",\")}`;\n      }\n    }\n    const ignoreDuplicates = options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : \"\";\n    const attributes = allAttributes.map((attr) => this.quoteIdentifier(attr)).join(\",\");\n    const onConflictDoNothing = options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : \"\";\n    let returning = \"\";\n    if (this._dialect.supports.returnValues && options.returning) {\n      const returnValues = this.generateReturnValues(fieldMappedAttributes, options);\n      returning += returnValues.returningFragment;\n    }\n    return Utils.joinSQLFragments([\n      \"INSERT\",\n      ignoreDuplicates,\n      \"INTO\",\n      this.quoteTable(tableName),\n      `(${attributes})`,\n      \"VALUES\",\n      tuples.join(\",\"),\n      onDuplicateKeyUpdate,\n      onConflictDoNothing,\n      returning,\n      \";\"\n    ]);\n  }\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n    const values = [];\n    const bind = [];\n    const modelAttributeMap = {};\n    let outputFragment = \"\";\n    let tmpTable = \"\";\n    let suffix = \"\";\n    if (_.get(this, [\"sequelize\", \"options\", \"dialectOptions\", \"prependSearchPath\"]) || options.searchPath) {\n      options.bindParam = false;\n    }\n    const bindParam = options.bindParam === void 0 ? this.bindParam(bind) : options.bindParam;\n    if (this._dialect.supports[\"LIMIT ON UPDATE\"] && options.limit) {\n      if (![\"mssql\", \"db2\", \"oracle\"].includes(this.dialect)) {\n        suffix = ` LIMIT ${this.escape(options.limit)} `;\n      } else if (this.dialect === \"oracle\") {\n        if (where && (where.length && where.length > 0 || Object.keys(where).length > 0)) {\n          suffix += \" AND \";\n        } else {\n          suffix += \" WHERE \";\n        }\n        suffix += `rownum <= ${this.escape(options.limit)} `;\n      }\n    }\n    if (this._dialect.supports.returnValues && options.returning) {\n      const returnValues = this.generateReturnValues(attributes, options);\n      suffix += returnValues.returningFragment;\n      tmpTable = returnValues.tmpTable || \"\";\n      outputFragment = returnValues.outputFragment || \"\";\n      if (!this._dialect.supports.returnValues.output && options.returning) {\n        options.mapToModel = true;\n      }\n    }\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n    for (const key in attrValueHash) {\n      if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && !this._dialect.supports.autoIncrement.update) {\n        continue;\n      }\n      const value = attrValueHash[key];\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"UPDATE\" })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"UPDATE\" }, bindParam)}`);\n      }\n    }\n    const whereOptions = __spreadProps(__spreadValues({}, options), { bindParam });\n    if (values.length === 0) {\n      return \"\";\n    }\n    const query = `${tmpTable}UPDATE ${this.quoteTable(tableName)} SET ${values.join(\",\")}${outputFragment} ${this.whereQuery(where, whereOptions)}${suffix}`.trim();\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = bind;\n    }\n    return result;\n  }\n  arithmeticQuery(operator, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = options || {};\n    _.defaults(options, { returning: true });\n    extraAttributesToBeUpdated = Utils.removeNullValuesFromHash(extraAttributesToBeUpdated, this.options.omitNull);\n    let outputFragment = \"\";\n    let returningFragment = \"\";\n    if (this._dialect.supports.returnValues && options.returning) {\n      const returnValues = this.generateReturnValues(null, options);\n      outputFragment = returnValues.outputFragment;\n      returningFragment = returnValues.returningFragment;\n    }\n    const updateSetSqlFragments = [];\n    for (const field in incrementAmountsByField) {\n      const incrementAmount = incrementAmountsByField[field];\n      const quotedField = this.quoteIdentifier(field);\n      const escapedAmount = this.escape(incrementAmount);\n      updateSetSqlFragments.push(`${quotedField}=${quotedField}${operator} ${escapedAmount}`);\n    }\n    for (const field in extraAttributesToBeUpdated) {\n      const newValue = extraAttributesToBeUpdated[field];\n      const quotedField = this.quoteIdentifier(field);\n      const escapedValue = this.escape(newValue);\n      updateSetSqlFragments.push(`${quotedField}=${escapedValue}`);\n    }\n    return Utils.joinSQLFragments([\n      \"UPDATE\",\n      this.quoteTable(tableName),\n      \"SET\",\n      updateSetSqlFragments.join(\",\"),\n      outputFragment,\n      this.whereQuery(where),\n      returningFragment\n    ]);\n  }\n  addIndexQuery(tableName, attributes, options, rawTablename) {\n    options = options || {};\n    if (!Array.isArray(attributes)) {\n      options = attributes;\n      attributes = void 0;\n    } else {\n      options.fields = attributes;\n    }\n    options.prefix = options.prefix || rawTablename || tableName;\n    if (options.prefix && typeof options.prefix === \"string\") {\n      options.prefix = options.prefix.replace(/\\./g, \"_\");\n      options.prefix = options.prefix.replace(/(\"|')/g, \"\");\n    }\n    const fieldsSql = options.fields.map((field) => {\n      if (field instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      }\n      if (typeof field === \"string\") {\n        field = {\n          name: field\n        };\n      }\n      let result = \"\";\n      if (field.attribute) {\n        field.name = field.attribute;\n      }\n      if (!field.name) {\n        throw new Error(`The following index field has no name: ${util.inspect(field)}`);\n      }\n      result += this.quoteIdentifier(field.name);\n      if (this._dialect.supports.index.collate && field.collate) {\n        result += ` COLLATE ${this.quoteIdentifier(field.collate)}`;\n      }\n      if (this._dialect.supports.index.operator) {\n        const operator = field.operator || options.operator;\n        if (operator) {\n          result += ` ${operator}`;\n        }\n      }\n      if (this._dialect.supports.index.length && field.length) {\n        result += `(${field.length})`;\n      }\n      if (field.order) {\n        result += ` ${field.order}`;\n      }\n      return result;\n    });\n    if (!options.name) {\n      options = Utils.nameIndex(options, options.prefix);\n    }\n    options = Model._conformIndex(options);\n    if (!this._dialect.supports.index.type) {\n      delete options.type;\n    }\n    if (options.where) {\n      options.where = this.whereQuery(options.where);\n    }\n    if (typeof tableName === \"string\") {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n    const concurrently = this._dialect.supports.index.concurrently && options.concurrently ? \"CONCURRENTLY\" : void 0;\n    let ind;\n    if (this._dialect.supports.indexViaAlter) {\n      ind = [\n        \"ALTER TABLE\",\n        tableName,\n        concurrently,\n        \"ADD\"\n      ];\n    } else {\n      ind = [\"CREATE\"];\n    }\n    ind = ind.concat(options.unique ? \"UNIQUE\" : \"\", options.type, \"INDEX\", !this._dialect.supports.indexViaAlter ? concurrently : void 0, this.quoteIdentifiers(options.name), this._dialect.supports.index.using === 1 && options.using ? `USING ${options.using}` : \"\", !this._dialect.supports.indexViaAlter ? `ON ${tableName}` : void 0, this._dialect.supports.index.using === 2 && options.using ? `USING ${options.using}` : \"\", `(${fieldsSql.join(\", \")})`, this._dialect.supports.index.parser && options.parser ? `WITH PARSER ${options.parser}` : void 0, this._dialect.supports.index.where && options.where ? options.where : void 0);\n    return _.compact(ind).join(\" \");\n  }\n  addConstraintQuery(tableName, options) {\n    if (typeof tableName === \"string\") {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      tableName,\n      \"ADD\",\n      this.getConstraintSnippet(tableName, options || {}),\n      \";\"\n    ]);\n  }\n  getConstraintSnippet(tableName, options) {\n    let constraintSnippet, constraintName;\n    const fieldsSql = options.fields.map((field) => {\n      if (typeof field === \"string\") {\n        return this.quoteIdentifier(field);\n      }\n      if (field instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      }\n      if (field.attribute) {\n        field.name = field.attribute;\n      }\n      if (!field.name) {\n        throw new Error(`The following index field has no name: ${field}`);\n      }\n      return this.quoteIdentifier(field.name);\n    });\n    const fieldsSqlQuotedString = fieldsSql.join(\", \");\n    const fieldsSqlString = fieldsSql.join(\"_\");\n    switch (options.type.toUpperCase()) {\n      case \"UNIQUE\":\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_uk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} UNIQUE (${fieldsSqlQuotedString})`;\n        break;\n      case \"CHECK\":\n        options.where = this.whereItemsQuery(options.where);\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_ck`);\n        constraintSnippet = `CONSTRAINT ${constraintName} CHECK (${options.where})`;\n        break;\n      case \"DEFAULT\":\n        if (options.defaultValue === void 0) {\n          throw new Error(\"Default value must be specified for DEFAULT CONSTRAINT\");\n        }\n        if (this._dialect.name !== \"mssql\") {\n          throw new Error(\"Default constraints are supported only for MSSQL dialect.\");\n        }\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_df`);\n        constraintSnippet = `CONSTRAINT ${constraintName} DEFAULT (${this.escape(options.defaultValue)}) FOR ${fieldsSql[0]}`;\n        break;\n      case \"PRIMARY KEY\":\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_pk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} PRIMARY KEY (${fieldsSqlQuotedString})`;\n        break;\n      case \"FOREIGN KEY\":\n        const references = options.references;\n        if (!references || !references.table || !(references.field || references.fields)) {\n          throw new Error(\"references object with table and field must be specified\");\n        }\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_${references.table}_fk`);\n        const quotedReferences = typeof references.field !== \"undefined\" ? this.quoteIdentifier(references.field) : references.fields.map((f) => this.quoteIdentifier(f)).join(\", \");\n        const referencesSnippet = `${this.quoteTable(references.table)} (${quotedReferences})`;\n        constraintSnippet = `CONSTRAINT ${constraintName} `;\n        constraintSnippet += `FOREIGN KEY (${fieldsSqlQuotedString}) REFERENCES ${referencesSnippet}`;\n        if (options.onUpdate) {\n          constraintSnippet += ` ON UPDATE ${options.onUpdate.toUpperCase()}`;\n        }\n        if (options.onDelete) {\n          constraintSnippet += ` ON DELETE ${options.onDelete.toUpperCase()}`;\n        }\n        break;\n      default:\n        throw new Error(`${options.type} is invalid.`);\n    }\n    if (options.deferrable && [\"UNIQUE\", \"PRIMARY KEY\", \"FOREIGN KEY\"].includes(options.type.toUpperCase())) {\n      constraintSnippet += ` ${this.deferConstraintsQuery(options)}`;\n    }\n    return constraintSnippet;\n  }\n  removeConstraintQuery(tableName, constraintName) {\n    if (typeof tableName === \"string\") {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      tableName,\n      \"DROP CONSTRAINT\",\n      this.quoteIdentifiers(constraintName)\n    ]);\n  }\n  quote(collection, parent, connector) {\n    const validOrderOptions = [\n      \"ASC\",\n      \"DESC\",\n      \"ASC NULLS LAST\",\n      \"DESC NULLS LAST\",\n      \"ASC NULLS FIRST\",\n      \"DESC NULLS FIRST\",\n      \"NULLS FIRST\",\n      \"NULLS LAST\"\n    ];\n    connector = connector || \".\";\n    if (typeof collection === \"string\") {\n      return this.quoteIdentifiers(collection);\n    }\n    if (Array.isArray(collection)) {\n      collection.forEach((item2, index) => {\n        const previous = collection[index - 1];\n        let previousAssociation;\n        let previousModel;\n        if (!previous && parent !== void 0) {\n          previousModel = parent;\n        } else if (previous && previous instanceof Association) {\n          previousAssociation = previous;\n          previousModel = previous.target;\n        }\n        if (previousModel && previousModel.prototype instanceof Model) {\n          let model;\n          let as;\n          if (typeof item2 === \"function\" && item2.prototype instanceof Model) {\n            model = item2;\n          } else if (_.isPlainObject(item2) && item2.model && item2.model.prototype instanceof Model) {\n            model = item2.model;\n            as = item2.as;\n          }\n          if (model) {\n            if (!as && previousAssociation && previousAssociation instanceof Association && previousAssociation.through && previousAssociation.through.model === model) {\n              item2 = new Association(previousModel, model, {\n                as: model.name\n              });\n            } else {\n              item2 = previousModel.getAssociationForAlias(model, as);\n              if (!item2) {\n                item2 = previousModel.getAssociationForAlias(model, model.name);\n              }\n            }\n            if (!(item2 instanceof Association)) {\n              throw new Error(util.format(\"Unable to find a valid association for model, '%s'\", model.name));\n            }\n          }\n        }\n        if (typeof item2 === \"string\") {\n          const orderIndex = validOrderOptions.indexOf(item2.toUpperCase());\n          if (index > 0 && orderIndex !== -1) {\n            item2 = this.sequelize.literal(` ${validOrderOptions[orderIndex]}`);\n          } else if (previousModel && previousModel.prototype instanceof Model) {\n            if (previousModel.associations !== void 0 && previousModel.associations[item2]) {\n              item2 = previousModel.associations[item2];\n            } else if (previousModel.rawAttributes !== void 0 && previousModel.rawAttributes[item2] && item2 !== previousModel.rawAttributes[item2].field) {\n              item2 = previousModel.rawAttributes[item2].field;\n            } else if (item2.includes(\".\") && previousModel.rawAttributes !== void 0) {\n              const itemSplit = item2.split(\".\");\n              if (previousModel.rawAttributes[itemSplit[0]].type instanceof DataTypes.JSON) {\n                const identifier = this.quoteIdentifiers(`${previousModel.name}.${previousModel.rawAttributes[itemSplit[0]].field}`);\n                const path = itemSplit.slice(1);\n                item2 = this.jsonPathExtractionQuery(identifier, path);\n                item2 = this.sequelize.literal(item2);\n              }\n            }\n          }\n        }\n        collection[index] = item2;\n      }, this);\n      const collectionLength = collection.length;\n      const tableNames = [];\n      let item;\n      let i = 0;\n      for (i = 0; i < collectionLength - 1; i++) {\n        item = collection[i];\n        if (typeof item === \"string\" || item._modelAttribute || item instanceof Utils.SequelizeMethod) {\n          break;\n        } else if (item instanceof Association) {\n          tableNames[i] = item.as;\n        }\n      }\n      let sql = \"\";\n      if (i > 0) {\n        sql += `${this.quoteIdentifier(tableNames.join(connector))}.`;\n      } else if (typeof collection[0] === \"string\" && parent) {\n        sql += `${this.quoteIdentifier(parent.name)}.`;\n      }\n      collection.slice(i).forEach((collectionItem) => {\n        sql += this.quote(collectionItem, parent, connector);\n      }, this);\n      return sql;\n    }\n    if (collection._modelAttribute) {\n      return `${this.quoteTable(collection.Model.name)}.${this.quoteIdentifier(collection.fieldName)}`;\n    }\n    if (collection instanceof Utils.SequelizeMethod) {\n      return this.handleSequelizeMethod(collection);\n    }\n    if (_.isPlainObject(collection) && collection.raw) {\n      throw new Error('The `{raw: \"...\"}` syntax is no longer supported.  Use `sequelize.literal` instead.');\n    }\n    throw new Error(`Unknown structure passed to order / group: ${util.inspect(collection)}`);\n  }\n  _initQuoteIdentifier() {\n    this._quoteIdentifier = this.quoteIdentifier;\n    this.quoteIdentifier = function(identifier, force) {\n      if (identifier === \"*\")\n        return identifier;\n      return this._quoteIdentifier(identifier, force);\n    };\n  }\n  quoteIdentifier(identifier, force) {\n    throw new Error(`quoteIdentifier for Dialect \"${this.dialect}\" is not implemented`);\n  }\n  quoteIdentifiers(identifiers) {\n    if (identifiers.includes(\".\")) {\n      identifiers = identifiers.split(\".\");\n      const head = identifiers.slice(0, identifiers.length - 1).join(\"->\");\n      const tail = identifiers[identifiers.length - 1];\n      return `${this.quoteIdentifier(head)}.${this.quoteIdentifier(tail)}`;\n    }\n    return this.quoteIdentifier(identifiers);\n  }\n  quoteAttribute(attribute, model) {\n    if (model && attribute in model.rawAttributes) {\n      return this.quoteIdentifier(attribute);\n    }\n    return this.quoteIdentifiers(attribute);\n  }\n  getAliasToken() {\n    return \"AS\";\n  }\n  quoteTable(param, alias) {\n    let table = \"\";\n    if (alias === true) {\n      alias = param.as || param.name || param;\n    }\n    if (_.isObject(param)) {\n      if (this._dialect.supports.schemas) {\n        if (param.schema) {\n          table += `${this.quoteIdentifier(param.schema)}.`;\n        }\n        table += this.quoteIdentifier(param.tableName);\n      } else {\n        if (param.schema) {\n          table += param.schema + (param.delimiter || \".\");\n        }\n        table += param.tableName;\n        table = this.quoteIdentifier(table);\n      }\n    } else {\n      table = this.quoteIdentifier(param);\n    }\n    if (alias) {\n      table += ` ${this.getAliasToken()} ${this.quoteIdentifier(alias)}`;\n    }\n    return table;\n  }\n  escape(value, field, options) {\n    options = options || {};\n    if (value !== null && value !== void 0) {\n      if (value instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(value);\n      }\n      if (field && field.type) {\n        if (field.type instanceof DataTypes.STRING && [\"mysql\", \"mariadb\"].includes(this.dialect) && [\"number\", \"boolean\"].includes(typeof value)) {\n          value = String(Number(value));\n        }\n        this.validate(value, field, options);\n        if (field.type.stringify) {\n          const simpleEscape = (escVal) => SqlString.escape(escVal, this.options.timezone, this.dialect);\n          value = field.type.stringify(value, { escape: simpleEscape, field, timezone: this.options.timezone, operation: options.operation });\n          if (field.type.escape === false) {\n            return value;\n          }\n        }\n      }\n    }\n    return SqlString.escape(value, this.options.timezone, this.dialect);\n  }\n  bindParam(bind) {\n    return (value) => {\n      bind.push(value);\n      return `$${bind.length}`;\n    };\n  }\n  format(value, field, options, bindParam) {\n    options = options || {};\n    if (value !== null && value !== void 0) {\n      if (value instanceof Utils.SequelizeMethod) {\n        throw new Error(\"Cannot pass SequelizeMethod as a bind parameter - use escape instead\");\n      }\n      if (field && field.type) {\n        this.validate(value, field, options);\n        if (field.type.bindParam) {\n          return field.type.bindParam(value, { escape: _.identity, field, timezone: this.options.timezone, operation: options.operation, bindParam });\n        }\n      }\n    }\n    return bindParam(value);\n  }\n  validate(value, field, options) {\n    if (this.typeValidation && field.type.validate && value) {\n      try {\n        if (options.isList && Array.isArray(value)) {\n          for (const item of value) {\n            field.type.validate(item, options);\n          }\n        } else {\n          field.type.validate(value, options);\n        }\n      } catch (error) {\n        if (error instanceof sequelizeError.ValidationError) {\n          error.errors.push(new sequelizeError.ValidationErrorItem(error.message, \"Validation error\", field.fieldName, value, null, `${field.type.key} validator`));\n        }\n        throw error;\n      }\n    }\n  }\n  isIdentifierQuoted(identifier) {\n    return /^\\s*(?:([`\"'])(?:(?!\\1).|\\1{2})*\\1\\.?)+\\s*$/i.test(identifier);\n  }\n  jsonPathExtractionQuery(column, path, isJson) {\n    let paths = _.toPath(path);\n    let pathStr;\n    const quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n    switch (this.dialect) {\n      case \"mysql\":\n      case \"mariadb\":\n      case \"sqlite\":\n        if (this.dialect === \"mysql\") {\n          paths = paths.map((subPath) => {\n            return /\\D/.test(subPath) ? Utils.addTicks(subPath, '\"') : subPath;\n          });\n        }\n        pathStr = this.escape([\"$\"].concat(paths).join(\".\").replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (__, digit) => `[${digit}]`));\n        if (this.dialect === \"sqlite\") {\n          return `json_extract(${quotedColumn},${pathStr})`;\n        }\n        return `json_unquote(json_extract(${quotedColumn},${pathStr}))`;\n      case \"postgres\":\n        const join = isJson ? \"#>\" : \"#>>\";\n        pathStr = this.escape(`{${paths.join(\",\")}}`);\n        return `(${quotedColumn}${join}${pathStr})`;\n      default:\n        throw new Error(`Unsupported ${this.dialect} for JSON operations`);\n    }\n  }\n  selectQuery(tableName, options, model) {\n    options = options || {};\n    const limit = options.limit;\n    const mainQueryItems = [];\n    const subQueryItems = [];\n    const subQuery = options.subQuery === void 0 ? limit && options.hasMultiAssociation : options.subQuery;\n    const attributes = {\n      main: options.attributes && options.attributes.slice(),\n      subQuery: null\n    };\n    const mainTable = {\n      name: tableName,\n      quotedName: null,\n      as: null,\n      model\n    };\n    const topLevelInfo = {\n      names: mainTable,\n      options,\n      subQuery\n    };\n    let mainJoinQueries = [];\n    let subJoinQueries = [];\n    let query;\n    if (this.options.minifyAliases && !options.aliasesMapping) {\n      options.aliasesMapping = /* @__PURE__ */ new Map();\n      options.aliasesByTable = {};\n      options.includeAliases = /* @__PURE__ */ new Map();\n    }\n    if (options.tableAs) {\n      mainTable.as = this.quoteIdentifier(options.tableAs);\n    } else if (!Array.isArray(mainTable.name) && mainTable.model) {\n      mainTable.as = this.quoteIdentifier(mainTable.model.name);\n    }\n    mainTable.quotedName = !Array.isArray(mainTable.name) ? this.quoteTable(mainTable.name) : tableName.map((t) => {\n      return Array.isArray(t) ? this.quoteTable(t[0], t[1]) : this.quoteTable(t, true);\n    }).join(\", \");\n    if (subQuery && attributes.main) {\n      for (const keyAtt of mainTable.model.primaryKeyAttributes) {\n        if (!attributes.main.some((attr) => keyAtt === attr || keyAtt === attr[0] || keyAtt === attr[1])) {\n          attributes.main.push(mainTable.model.rawAttributes[keyAtt].field ? [keyAtt, mainTable.model.rawAttributes[keyAtt].field] : keyAtt);\n        }\n      }\n    }\n    attributes.main = this.escapeAttributes(attributes.main, options, mainTable.as);\n    attributes.main = attributes.main || (options.include ? [`${mainTable.as}.*`] : [\"*\"]);\n    if (subQuery || options.groupedLimit) {\n      attributes.subQuery = attributes.main;\n      attributes.main = [`${mainTable.as || mainTable.quotedName}.*`];\n    }\n    if (options.include) {\n      for (const include of options.include) {\n        if (include.separate) {\n          continue;\n        }\n        const joinQueries = this.generateInclude(include, { externalAs: mainTable.as, internalAs: mainTable.as }, topLevelInfo);\n        subJoinQueries = subJoinQueries.concat(joinQueries.subQuery);\n        mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n        if (joinQueries.attributes.main.length > 0) {\n          attributes.main = _.uniq(attributes.main.concat(joinQueries.attributes.main));\n        }\n        if (joinQueries.attributes.subQuery.length > 0) {\n          attributes.subQuery = _.uniq(attributes.subQuery.concat(joinQueries.attributes.subQuery));\n        }\n      }\n    }\n    if (subQuery) {\n      subQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.subQuery, mainTable.quotedName, mainTable.as));\n      subQueryItems.push(subJoinQueries.join(\"\"));\n    } else {\n      if (options.groupedLimit) {\n        if (!mainTable.as) {\n          mainTable.as = mainTable.quotedName;\n        }\n        const where = __spreadValues({}, options.where);\n        let groupedLimitOrder, whereKey, include, groupedTableName = mainTable.as;\n        if (typeof options.groupedLimit.on === \"string\") {\n          whereKey = options.groupedLimit.on;\n        } else if (options.groupedLimit.on instanceof HasMany) {\n          whereKey = options.groupedLimit.on.foreignKeyField;\n        }\n        if (options.groupedLimit.on instanceof BelongsToMany) {\n          groupedTableName = options.groupedLimit.on.manyFromSource.as;\n          const groupedLimitOptions = Model._validateIncludedElements({\n            include: [{\n              association: options.groupedLimit.on.manyFromSource,\n              duplicating: false,\n              required: true,\n              where: __spreadValues({\n                [Op.placeholder]: true\n              }, options.groupedLimit.through && options.groupedLimit.through.where)\n            }],\n            model\n          });\n          options.hasJoin = true;\n          options.hasMultiAssociation = true;\n          options.includeMap = Object.assign(groupedLimitOptions.includeMap, options.includeMap);\n          options.includeNames = groupedLimitOptions.includeNames.concat(options.includeNames || []);\n          include = groupedLimitOptions.include;\n          if (Array.isArray(options.order)) {\n            options.order.forEach((order, i) => {\n              if (Array.isArray(order)) {\n                order = order[0];\n              }\n              let alias = `subquery_order_${i}`;\n              options.attributes.push([order, alias]);\n              alias = this.sequelize.literal(this.quote(alias));\n              if (Array.isArray(options.order[i])) {\n                options.order[i][0] = alias;\n              } else {\n                options.order[i] = alias;\n              }\n            });\n            groupedLimitOrder = options.order;\n          }\n        } else {\n          groupedLimitOrder = options.order;\n          if (!this._dialect.supports.topLevelOrderByRequired) {\n            delete options.order;\n          }\n          where[Op.placeholder] = true;\n        }\n        const baseQuery = `SELECT * FROM (${this.selectQuery(tableName, {\n          attributes: options.attributes,\n          offset: options.offset,\n          limit: options.groupedLimit.limit,\n          order: groupedLimitOrder,\n          aliasesMapping: options.aliasesMapping,\n          aliasesByTable: options.aliasesByTable,\n          where,\n          include,\n          model\n        }, model).replace(/;$/, \"\")}) ${this.getAliasToken()} sub`;\n        const placeHolder = this.whereItemQuery(Op.placeholder, true, { model });\n        const splicePos = baseQuery.indexOf(placeHolder);\n        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, `(${options.groupedLimit.values.map((value) => {\n          let groupWhere;\n          if (whereKey) {\n            groupWhere = {\n              [whereKey]: value\n            };\n          }\n          if (include) {\n            groupWhere = {\n              [options.groupedLimit.on.foreignIdentifierField]: value\n            };\n          }\n          return Utils.spliceStr(baseQuery, splicePos, placeHolder.length, this.getWhereConditions(groupWhere, groupedTableName));\n        }).join(this._dialect.supports[\"UNION ALL\"] ? \" UNION ALL \" : \" UNION \")})`, mainTable.as));\n      } else {\n        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, mainTable.quotedName, mainTable.as));\n      }\n      mainQueryItems.push(mainJoinQueries.join(\"\"));\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"where\") && !options.groupedLimit) {\n      options.where = this.getWhereConditions(options.where, mainTable.as || tableName, model, options);\n      if (options.where) {\n        if (subQuery) {\n          subQueryItems.push(` WHERE ${options.where}`);\n        } else {\n          mainQueryItems.push(` WHERE ${options.where}`);\n          mainQueryItems.forEach((value, key) => {\n            if (value.startsWith(\"SELECT\")) {\n              mainQueryItems[key] = this.selectFromTableFragment(options, model, attributes.main, mainTable.quotedName, mainTable.as, options.where);\n            }\n          });\n        }\n      }\n    }\n    if (options.group) {\n      options.group = Array.isArray(options.group) ? options.group.map((t) => this.aliasGrouping(t, model, mainTable.as, options)).join(\", \") : this.aliasGrouping(options.group, model, mainTable.as, options);\n      if (subQuery && options.group) {\n        subQueryItems.push(` GROUP BY ${options.group}`);\n      } else if (options.group) {\n        mainQueryItems.push(` GROUP BY ${options.group}`);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"having\")) {\n      options.having = this.getWhereConditions(options.having, tableName, model, options, false);\n      if (options.having) {\n        if (subQuery) {\n          subQueryItems.push(` HAVING ${options.having}`);\n        } else {\n          mainQueryItems.push(` HAVING ${options.having}`);\n        }\n      }\n    }\n    if (options.order) {\n      const orders = this.getQueryOrders(options, model, subQuery);\n      if (orders.mainQueryOrder.length) {\n        mainQueryItems.push(` ORDER BY ${orders.mainQueryOrder.join(\", \")}`);\n      }\n      if (orders.subQueryOrder.length) {\n        subQueryItems.push(` ORDER BY ${orders.subQueryOrder.join(\", \")}`);\n      }\n    }\n    const limitOrder = this.addLimitAndOffset(options, mainTable.model);\n    if (limitOrder && !options.groupedLimit) {\n      if (subQuery) {\n        subQueryItems.push(limitOrder);\n      } else {\n        mainQueryItems.push(limitOrder);\n      }\n    }\n    if (subQuery) {\n      this._throwOnEmptyAttributes(attributes.main, { modelName: model && model.name, as: mainTable.as });\n      query = `SELECT ${attributes.main.join(\", \")} FROM (${subQueryItems.join(\"\")}) ${this.getAliasToken()} ${mainTable.as}${mainJoinQueries.join(\"\")}${mainQueryItems.join(\"\")}`;\n    } else {\n      query = mainQueryItems.join(\"\");\n    }\n    if (options.lock && this._dialect.supports.lock) {\n      let lock = options.lock;\n      if (typeof options.lock === \"object\") {\n        lock = options.lock.level;\n      }\n      if (this._dialect.supports.lockKey && [\"KEY SHARE\", \"NO KEY UPDATE\"].includes(lock)) {\n        query += ` FOR ${lock}`;\n      } else if (lock === \"SHARE\") {\n        query += ` ${this._dialect.supports.forShare}`;\n      } else {\n        query += \" FOR UPDATE\";\n      }\n      if (this._dialect.supports.lockOf && options.lock.of && options.lock.of.prototype instanceof Model) {\n        query += ` OF ${this.quoteTable(options.lock.of.name)}`;\n      }\n      if (this._dialect.supports.skipLocked && options.skipLocked) {\n        query += \" SKIP LOCKED\";\n      }\n    }\n    return `${query};`;\n  }\n  aliasGrouping(field, model, tableName, options) {\n    const src = Array.isArray(field) ? field[0] : field;\n    return this.quote(this._getAliasForField(tableName, src, options) || src, model);\n  }\n  escapeAttributes(attributes, options, mainTableAs) {\n    return attributes && attributes.map((attr) => {\n      let addTable = true;\n      if (attr instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(attr);\n      }\n      if (Array.isArray(attr)) {\n        if (attr.length !== 2) {\n          throw new Error(`${JSON.stringify(attr)} is not a valid attribute definition. Please use the following format: ['attribute definition', 'alias']`);\n        }\n        attr = attr.slice();\n        if (attr[0] instanceof Utils.SequelizeMethod) {\n          attr[0] = this.handleSequelizeMethod(attr[0]);\n          addTable = false;\n        } else if (this.options.attributeBehavior === \"escape\" || !attr[0].includes(\"(\") && !attr[0].includes(\")\")) {\n          attr[0] = this.quoteIdentifier(attr[0]);\n        } else if (this.options.attributeBehavior !== \"unsafe-legacy\") {\n          throw new Error(`Attributes cannot include parentheses in Sequelize 6:\nIn order to fix the vulnerability CVE-2023-22578, we had to remove support for treating attributes as raw SQL if they included parentheses.\nSequelize 7 escapes all attributes, even if they include parentheses.\nFor Sequelize 6, because we're introducing this change in a minor release, we've opted for throwing an error instead of silently escaping the attribute as a way to warn you about this change.\n\nHere is what you can do to fix this error:\n- Wrap the attribute in a literal() call. This will make Sequelize treat it as raw SQL.\n- Set the \"attributeBehavior\" sequelize option to \"escape\" to make Sequelize escape the attribute, like in Sequelize v7. We highly recommend this option.\n- Set the \"attributeBehavior\" sequelize option to \"unsafe-legacy\" to make Sequelize escape the attribute, like in Sequelize v5.\n\nWe sincerely apologize for the inconvenience this may cause you. You can find more information on the following threads:\nhttps://github.com/sequelize/sequelize/security/advisories/GHSA-f598-mfpv-gmfx\nhttps://github.com/sequelize/sequelize/discussions/15694`);\n        }\n        let alias = attr[1];\n        if (this.options.minifyAliases) {\n          alias = this._getMinifiedAlias(alias, mainTableAs, options);\n        }\n        attr = [attr[0], this.quoteIdentifier(alias)].join(\" AS \");\n      } else {\n        attr = !attr.includes(Utils.TICK_CHAR) && !attr.includes('\"') ? this.quoteAttribute(attr, options.model) : this.escape(attr);\n      }\n      if (!_.isEmpty(options.include) && (!attr.includes(\".\") || options.dotNotation) && addTable) {\n        attr = `${mainTableAs}.${attr}`;\n      }\n      return attr;\n    });\n  }\n  generateInclude(include, parentTableName, topLevelInfo) {\n    const joinQueries = {\n      mainQuery: [],\n      subQuery: []\n    };\n    const mainChildIncludes = [];\n    const subChildIncludes = [];\n    let requiredMismatch = false;\n    const includeAs = {\n      internalAs: include.as,\n      externalAs: include.as\n    };\n    const attributes = {\n      main: [],\n      subQuery: []\n    };\n    let joinQuery;\n    topLevelInfo.options.keysEscaped = true;\n    if (topLevelInfo.names.name !== parentTableName.externalAs && topLevelInfo.names.as !== parentTableName.externalAs) {\n      includeAs.internalAs = `${parentTableName.internalAs}->${include.as}`;\n      includeAs.externalAs = `${parentTableName.externalAs}.${include.as}`;\n    }\n    if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n      include.model._expandAttributes(include);\n      Utils.mapFinderOptions(include, include.model);\n      const includeAttributes = include.attributes.map((attr) => {\n        let attrAs = attr;\n        let verbatim = false;\n        if (Array.isArray(attr) && attr.length === 2) {\n          if (attr[0] instanceof Utils.SequelizeMethod && (attr[0] instanceof Utils.Literal || attr[0] instanceof Utils.Cast || attr[0] instanceof Utils.Fn)) {\n            verbatim = true;\n          }\n          attr = attr.map((attr2) => attr2 instanceof Utils.SequelizeMethod ? this.handleSequelizeMethod(attr2) : attr2);\n          attrAs = attr[1];\n          attr = attr[0];\n        }\n        if (attr instanceof Utils.Literal) {\n          return attr.val;\n        }\n        if (attr instanceof Utils.Cast || attr instanceof Utils.Fn) {\n          throw new Error(\"Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. This means the attribute will not be added to the returned instance\");\n        }\n        let prefix;\n        if (verbatim === true) {\n          prefix = attr;\n        } else if (/#>>|->>/.test(attr)) {\n          prefix = `(${this.quoteIdentifier(includeAs.internalAs)}.${attr.replace(/\\(|\\)/g, \"\")})`;\n        } else if (/json_extract\\(/.test(attr)) {\n          prefix = attr.replace(/json_extract\\(/i, `json_extract(${this.quoteIdentifier(includeAs.internalAs)}.`);\n        } else if (/json_value\\(/.test(attr)) {\n          prefix = attr.replace(/json_value\\(/i, `json_value(${this.quoteIdentifier(includeAs.internalAs)}.`);\n        } else {\n          prefix = `${this.quoteIdentifier(includeAs.internalAs)}.${this.quoteIdentifier(attr)}`;\n        }\n        let alias = `${includeAs.externalAs}.${attrAs}`;\n        if (this.options.minifyAliases) {\n          alias = this._getMinifiedAlias(alias, includeAs.internalAs, topLevelInfo.options);\n        }\n        return Utils.joinSQLFragments([\n          prefix,\n          \"AS\",\n          this.quoteIdentifier(alias, true)\n        ]);\n      });\n      if (include.subQuery && topLevelInfo.subQuery) {\n        for (const attr of includeAttributes) {\n          attributes.subQuery.push(attr);\n        }\n      } else {\n        for (const attr of includeAttributes) {\n          attributes.main.push(attr);\n        }\n      }\n    }\n    if (include.through) {\n      joinQuery = this.generateThroughJoin(include, includeAs, parentTableName.internalAs, topLevelInfo);\n    } else {\n      this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n      joinQuery = this.generateJoin(include, topLevelInfo);\n    }\n    if (joinQuery.attributes.main.length > 0) {\n      attributes.main = attributes.main.concat(joinQuery.attributes.main);\n    }\n    if (joinQuery.attributes.subQuery.length > 0) {\n      attributes.subQuery = attributes.subQuery.concat(joinQuery.attributes.subQuery);\n    }\n    if (include.include) {\n      for (const childInclude of include.include) {\n        if (childInclude.separate || childInclude._pseudo) {\n          continue;\n        }\n        const childJoinQueries = this.generateInclude(childInclude, includeAs, topLevelInfo);\n        if (include.required === false && childInclude.required === true) {\n          requiredMismatch = true;\n        }\n        if (childInclude.subQuery && topLevelInfo.subQuery) {\n          subChildIncludes.push(childJoinQueries.subQuery);\n        }\n        if (childJoinQueries.mainQuery) {\n          mainChildIncludes.push(childJoinQueries.mainQuery);\n        }\n        if (childJoinQueries.attributes.main.length > 0) {\n          attributes.main = attributes.main.concat(childJoinQueries.attributes.main);\n        }\n        if (childJoinQueries.attributes.subQuery.length > 0) {\n          attributes.subQuery = attributes.subQuery.concat(childJoinQueries.attributes.subQuery);\n        }\n      }\n    }\n    if (include.subQuery && topLevelInfo.subQuery) {\n      if (requiredMismatch && subChildIncludes.length > 0) {\n        joinQueries.subQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${subChildIncludes.join(\"\")} ) ON ${joinQuery.condition}`);\n      } else {\n        joinQueries.subQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);\n        if (subChildIncludes.length > 0) {\n          joinQueries.subQuery.push(subChildIncludes.join(\"\"));\n        }\n      }\n      joinQueries.mainQuery.push(mainChildIncludes.join(\"\"));\n    } else {\n      if (requiredMismatch && mainChildIncludes.length > 0) {\n        joinQueries.mainQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${mainChildIncludes.join(\"\")} ) ON ${joinQuery.condition}`);\n      } else {\n        joinQueries.mainQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);\n        if (mainChildIncludes.length > 0) {\n          joinQueries.mainQuery.push(mainChildIncludes.join(\"\"));\n        }\n      }\n      joinQueries.subQuery.push(subChildIncludes.join(\"\"));\n    }\n    return {\n      mainQuery: joinQueries.mainQuery.join(\"\"),\n      subQuery: joinQueries.subQuery.join(\"\"),\n      attributes\n    };\n  }\n  _getMinifiedAlias(alias, tableName, options) {\n    if (options.aliasesByTable[`${tableName}${alias}`]) {\n      return options.aliasesByTable[`${tableName}${alias}`];\n    }\n    if (alias.match(/subquery_order_[0-9]/)) {\n      return alias;\n    }\n    const minifiedAlias = `_${options.aliasesMapping.size}`;\n    options.aliasesMapping.set(minifiedAlias, alias);\n    options.aliasesByTable[`${tableName}${alias}`] = minifiedAlias;\n    return minifiedAlias;\n  }\n  _getAliasForField(tableName, field, options) {\n    if (this.options.minifyAliases) {\n      if (options.aliasesByTable[`${tableName}${field}`]) {\n        return options.aliasesByTable[`${tableName}${field}`];\n      }\n    }\n    return null;\n  }\n  generateJoin(include, topLevelInfo) {\n    const association = include.association;\n    const parent = include.parent;\n    const parentIsTop = !!parent && !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n    let $parent;\n    let joinWhere;\n    const left = association.source;\n    const attrLeft = association instanceof BelongsTo ? association.identifier : association.sourceKeyAttribute || left.primaryKeyAttribute;\n    const fieldLeft = association instanceof BelongsTo ? association.identifierField : left.rawAttributes[association.sourceKeyAttribute || left.primaryKeyAttribute].field;\n    let asLeft;\n    const right = include.model;\n    const tableRight = right.getTableName();\n    const fieldRight = association instanceof BelongsTo ? right.rawAttributes[association.targetIdentifier || right.primaryKeyAttribute].field : association.identifierField;\n    let asRight = include.as;\n    while (($parent = $parent && $parent.parent || include.parent) && $parent.association) {\n      if (asLeft) {\n        asLeft = `${$parent.as}->${asLeft}`;\n      } else {\n        asLeft = $parent.as;\n      }\n    }\n    if (!asLeft)\n      asLeft = parent.as || parent.model.name;\n    else\n      asRight = `${asLeft}->${asRight}`;\n    let joinOn = `${this.quoteTable(asLeft)}.${this.quoteIdentifier(fieldLeft)}`;\n    const subqueryAttributes = [];\n    if (topLevelInfo.options.groupedLimit && parentIsTop || topLevelInfo.subQuery && include.parent.subQuery && !include.subQuery) {\n      if (parentIsTop) {\n        const tableName = this.quoteTable(parent.as || parent.model.name);\n        joinOn = this._getAliasForField(tableName, attrLeft, topLevelInfo.options) || `${tableName}.${this.quoteIdentifier(attrLeft)}`;\n        if (topLevelInfo.subQuery) {\n          const dbIdentifier = `${tableName}.${this.quoteIdentifier(fieldLeft)}`;\n          subqueryAttributes.push(dbIdentifier !== joinOn ? `${dbIdentifier} AS ${this.quoteIdentifier(attrLeft)}` : dbIdentifier);\n        }\n      } else {\n        const joinSource = `${asLeft.replace(/->/g, \".\")}.${attrLeft}`;\n        joinOn = this._getAliasForField(asLeft, joinSource, topLevelInfo.options) || this.quoteIdentifier(joinSource);\n      }\n    }\n    joinOn += ` = ${this.quoteIdentifier(asRight)}.${this.quoteIdentifier(fieldRight)}`;\n    if (include.on) {\n      joinOn = this.whereItemsQuery(include.on, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n    }\n    if (include.where) {\n      joinWhere = this.whereItemsQuery(include.where, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n      if (joinWhere) {\n        if (include.or) {\n          joinOn += ` OR ${joinWhere}`;\n        } else {\n          joinOn += ` AND ${joinWhere}`;\n        }\n      }\n    }\n    this.aliasAs(asRight, topLevelInfo);\n    return {\n      join: include.required ? \"INNER JOIN\" : include.right && this._dialect.supports[\"RIGHT JOIN\"] ? \"RIGHT OUTER JOIN\" : \"LEFT OUTER JOIN\",\n      body: this.quoteTable(tableRight, asRight),\n      condition: joinOn,\n      attributes: {\n        main: [],\n        subQuery: subqueryAttributes\n      }\n    };\n  }\n  generateReturnValues(modelAttributes, options) {\n    const returnFields = [];\n    const returnTypes = [];\n    let outputFragment = \"\";\n    let returningFragment = \"\";\n    let tmpTable = \"\";\n    if (Array.isArray(options.returning)) {\n      returnFields.push(...options.returning.map((field) => this.quoteIdentifier(field)));\n    } else if (modelAttributes) {\n      _.each(modelAttributes, (attribute) => {\n        if (!(attribute.type instanceof DataTypes.VIRTUAL)) {\n          returnFields.push(this.quoteIdentifier(attribute.field));\n          returnTypes.push(attribute.type);\n        }\n      });\n    }\n    if (_.isEmpty(returnFields)) {\n      returnFields.push(\"*\");\n    }\n    if (this._dialect.supports.returnValues.returning) {\n      returningFragment = ` RETURNING ${returnFields.join(\",\")}`;\n    } else if (this._dialect.supports.returnIntoValues) {\n      returningFragment = ` RETURNING ${returnFields.join(\",\")} INTO `;\n    } else if (this._dialect.supports.returnValues.output) {\n      outputFragment = ` OUTPUT ${returnFields.map((field) => `INSERTED.${field}`).join(\",\")}`;\n      if (options.hasTrigger && this._dialect.supports.tmpTableTrigger) {\n        const tmpColumns = returnFields.map((field, i) => `${field} ${returnTypes[i].toSql()}`);\n        tmpTable = `DECLARE @tmp TABLE (${tmpColumns.join(\",\")}); `;\n        outputFragment += \" INTO @tmp\";\n        returningFragment = \"; SELECT * FROM @tmp\";\n      }\n    }\n    return { outputFragment, returnFields, returnTypes, returningFragment, tmpTable };\n  }\n  generateThroughJoin(include, includeAs, parentTableName, topLevelInfo) {\n    const through = include.through;\n    const throughTable = through.model.getTableName();\n    const throughAs = `${includeAs.internalAs}->${through.as}`;\n    const externalThroughAs = `${includeAs.externalAs}.${through.as}`;\n    const throughAttributes = through.attributes.map((attr) => {\n      let alias = `${externalThroughAs}.${Array.isArray(attr) ? attr[1] : attr}`;\n      if (this.options.minifyAliases) {\n        alias = this._getMinifiedAlias(alias, throughAs, topLevelInfo.options);\n      }\n      return Utils.joinSQLFragments([\n        `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(Array.isArray(attr) ? attr[0] : attr)}`,\n        \"AS\",\n        this.quoteIdentifier(alias)\n      ]);\n    });\n    const association = include.association;\n    const parentIsTop = !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n    const tableSource = parentTableName;\n    const identSource = association.identifierField;\n    const tableTarget = includeAs.internalAs;\n    const identTarget = association.foreignIdentifierField;\n    const attrTarget = association.targetKeyField;\n    const joinType = include.required ? \"INNER JOIN\" : include.right && this._dialect.supports[\"RIGHT JOIN\"] ? \"RIGHT OUTER JOIN\" : \"LEFT OUTER JOIN\";\n    let joinBody;\n    let joinCondition;\n    const attributes = {\n      main: [],\n      subQuery: []\n    };\n    let attrSource = association.sourceKey;\n    let sourceJoinOn;\n    let targetJoinOn;\n    let throughWhere;\n    let targetWhere;\n    if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n      for (const attr of throughAttributes) {\n        attributes.main.push(attr);\n      }\n    }\n    if (!topLevelInfo.subQuery) {\n      attrSource = association.sourceKeyField;\n    }\n    if (topLevelInfo.subQuery && !include.subQuery && !include.parent.subQuery && include.parent.model !== topLevelInfo.options.mainModel) {\n      attrSource = association.sourceKeyField;\n    }\n    if (topLevelInfo.subQuery && !include.subQuery && include.parent.subQuery && !parentIsTop) {\n      const joinSource = this._getAliasForField(tableSource, `${tableSource}.${attrSource}`, topLevelInfo.options) || `${tableSource}.${attrSource}`;\n      sourceJoinOn = `${this.quoteIdentifier(joinSource)} = `;\n    } else {\n      const aliasedSource = this._getAliasForField(tableSource, attrSource, topLevelInfo.options) || attrSource;\n      sourceJoinOn = `${this.quoteTable(tableSource)}.${this.quoteIdentifier(aliasedSource)} = `;\n    }\n    sourceJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identSource)}`;\n    targetJoinOn = `${this.quoteIdentifier(tableTarget)}.${this.quoteIdentifier(attrTarget)} = `;\n    targetJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identTarget)}`;\n    if (through.where) {\n      throughWhere = this.getWhereConditions(through.where, this.sequelize.literal(this.quoteIdentifier(throughAs)), through.model);\n    }\n    this.aliasAs(includeAs.internalAs, topLevelInfo);\n    joinBody = `( ${this.quoteTable(throughTable, throughAs)} INNER JOIN ${this.quoteTable(include.model.getTableName(), includeAs.internalAs)} ON ${targetJoinOn}`;\n    if (throughWhere) {\n      joinBody += ` AND ${throughWhere}`;\n    }\n    joinBody += \")\";\n    joinCondition = sourceJoinOn;\n    if (include.where || include.through.where) {\n      if (include.where) {\n        targetWhere = this.getWhereConditions(include.where, this.sequelize.literal(this.quoteIdentifier(includeAs.internalAs)), include.model, topLevelInfo.options);\n        if (targetWhere) {\n          joinCondition += ` AND ${targetWhere}`;\n        }\n      }\n    }\n    this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n    return {\n      join: joinType,\n      body: joinBody,\n      condition: joinCondition,\n      attributes\n    };\n  }\n  aliasAs(as, topLevelInfo) {\n    if (this.options.minifyAliases && as.length >= 64) {\n      const alias = `%${topLevelInfo.options.includeAliases.size}`;\n      topLevelInfo.options.includeAliases.set(alias, as);\n    }\n  }\n  _generateSubQueryFilter(include, includeAs, topLevelInfo) {\n    if (!topLevelInfo.subQuery || !include.subQueryFilter) {\n      return;\n    }\n    if (!topLevelInfo.options.where) {\n      topLevelInfo.options.where = {};\n    }\n    let parent = include;\n    let child = include;\n    let nestedIncludes = this._getRequiredClosure(include).include;\n    let query;\n    while (parent = parent.parent) {\n      if (parent.parent && !parent.required) {\n        return;\n      }\n      if (parent.subQueryFilter) {\n        return;\n      }\n      nestedIncludes = [__spreadProps(__spreadValues({}, child), { include: nestedIncludes, attributes: [] })];\n      child = parent;\n    }\n    const topInclude = nestedIncludes[0];\n    const topParent = topInclude.parent;\n    const topAssociation = topInclude.association;\n    topInclude.association = void 0;\n    if (topInclude.through && Object(topInclude.through.model) === topInclude.through.model) {\n      query = this.selectQuery(topInclude.through.model.getTableName(), {\n        attributes: [topInclude.through.model.primaryKeyField],\n        include: Model._validateIncludedElements({\n          model: topInclude.through.model,\n          include: [{\n            association: topAssociation.toTarget,\n            required: true,\n            where: topInclude.where,\n            include: topInclude.include\n          }]\n        }).include,\n        model: topInclude.through.model,\n        where: {\n          [Op.and]: [\n            this.sequelize.literal([\n              `${this.quoteTable(topParent.model.name)}.${this.quoteIdentifier(topParent.model.primaryKeyField)}`,\n              `${this.quoteIdentifier(topInclude.through.model.name)}.${this.quoteIdentifier(topAssociation.identifierField)}`\n            ].join(\" = \")),\n            topInclude.through.where\n          ]\n        },\n        limit: 1,\n        includeIgnoreAttributes: false\n      }, topInclude.through.model);\n    } else {\n      const isBelongsTo = topAssociation.associationType === \"BelongsTo\";\n      const sourceField = isBelongsTo ? topAssociation.identifierField : topAssociation.sourceKeyField || topParent.model.primaryKeyField;\n      const targetField = isBelongsTo ? topAssociation.sourceKeyField || topInclude.model.primaryKeyField : topAssociation.identifierField;\n      const join = [\n        `${this.quoteIdentifier(topInclude.as)}.${this.quoteIdentifier(targetField)}`,\n        `${this.quoteTable(topParent.as || topParent.model.name)}.${this.quoteIdentifier(sourceField)}`\n      ].join(\" = \");\n      query = this.selectQuery(topInclude.model.getTableName(), {\n        attributes: [targetField],\n        include: Model._validateIncludedElements(topInclude).include,\n        model: topInclude.model,\n        where: {\n          [Op.and]: [\n            topInclude.where,\n            { [Op.join]: this.sequelize.literal(join) }\n          ]\n        },\n        limit: 1,\n        tableAs: topInclude.as,\n        includeIgnoreAttributes: false\n      }, topInclude.model);\n    }\n    if (!topLevelInfo.options.where[Op.and]) {\n      topLevelInfo.options.where[Op.and] = [];\n    }\n    topLevelInfo.options.where[`__${includeAs.internalAs}`] = this.sequelize.literal([\n      \"(\",\n      query.replace(/;$/, \"\"),\n      \")\",\n      \"IS NOT NULL\"\n    ].join(\" \"));\n  }\n  _getRequiredClosure(include) {\n    const copy = __spreadProps(__spreadValues({}, include), { attributes: [], include: [] });\n    if (Array.isArray(include.include)) {\n      copy.include = include.include.filter((i) => i.required).map((inc) => this._getRequiredClosure(inc));\n    }\n    return copy;\n  }\n  getQueryOrders(options, model, subQuery) {\n    const mainQueryOrder = [];\n    const subQueryOrder = [];\n    if (Array.isArray(options.order)) {\n      for (let order of options.order) {\n        if (!Array.isArray(order)) {\n          order = [order];\n        }\n        if (subQuery && Array.isArray(order) && order[0] && !(order[0] instanceof Association) && !(typeof order[0] === \"function\" && order[0].prototype instanceof Model) && !(typeof order[0].model === \"function\" && order[0].model.prototype instanceof Model) && !(typeof order[0] === \"string\" && model && model.associations !== void 0 && model.associations[order[0]])) {\n          const field = model.rawAttributes[order[0]] ? model.rawAttributes[order[0]].field : order[0];\n          const subQueryAlias = this._getAliasForField(this.quoteIdentifier(model.name), field, options);\n          let parent = null;\n          let orderToQuote = [];\n          if (subQueryAlias === null) {\n            orderToQuote = order;\n            parent = model;\n          } else {\n            orderToQuote = [subQueryAlias, order.length > 1 ? order[1] : \"ASC\"];\n            parent = null;\n          }\n          subQueryOrder.push(this.quote(orderToQuote, parent, \"->\"));\n        }\n        if (options.attributes && model) {\n          const aliasedAttribute = options.attributes.find((attr) => Array.isArray(attr) && attr[1] && (attr[0] === order[0] || attr[1] === order[0]));\n          if (aliasedAttribute) {\n            const modelName = this.quoteIdentifier(model.name);\n            const alias = this._getAliasForField(modelName, aliasedAttribute[1], options);\n            order[0] = new Utils.Col(alias || aliasedAttribute[1]);\n          }\n        }\n        mainQueryOrder.push(this.quote(order, model, \"->\"));\n      }\n    } else if (options.order instanceof Utils.SequelizeMethod) {\n      const sql = this.quote(options.order, model, \"->\");\n      if (subQuery) {\n        subQueryOrder.push(sql);\n      }\n      mainQueryOrder.push(sql);\n    } else {\n      throw new Error(\"Order must be type of array or instance of a valid sequelize method.\");\n    }\n    return { mainQueryOrder, subQueryOrder };\n  }\n  _throwOnEmptyAttributes(attributes, extraInfo = {}) {\n    if (attributes.length > 0)\n      return;\n    const asPart = extraInfo.as && `as ${extraInfo.as}` || \"\";\n    const namePart = extraInfo.modelName && `for model '${extraInfo.modelName}'` || \"\";\n    const message = `Attempted a SELECT query ${namePart} ${asPart} without selecting any columns`;\n    throw new sequelizeError.QueryError(message.replace(/ +/g, \" \"));\n  }\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs) {\n    this._throwOnEmptyAttributes(attributes, { modelName: model && model.name, as: mainTableAs });\n    let fragment = `SELECT ${attributes.join(\", \")} FROM ${tables}`;\n    if (mainTableAs) {\n      fragment += ` ${this.getAliasToken()} ${mainTableAs}`;\n    }\n    if (options.indexHints && this._dialect.supports.indexHints) {\n      for (const hint of options.indexHints) {\n        if (IndexHints[hint.type]) {\n          fragment += ` ${IndexHints[hint.type]} INDEX (${hint.values.map((indexName) => this.quoteIdentifiers(indexName)).join(\",\")})`;\n        }\n      }\n    }\n    return fragment;\n  }\n  addLimitAndOffset(options) {\n    let fragment = \"\";\n    if (options.offset != null && options.limit == null) {\n      fragment += \" LIMIT \" + this.escape(options.offset) + \", \" + 1e13;\n    } else if (options.limit != null) {\n      if (options.offset != null) {\n        fragment += \" LIMIT \" + this.escape(options.offset) + \", \" + this.escape(options.limit);\n      } else {\n        fragment += \" LIMIT \" + this.escape(options.limit);\n      }\n    }\n    return fragment;\n  }\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    let result;\n    if (Object.prototype.hasOwnProperty.call(this.OperatorMap, smth.comparator)) {\n      smth.comparator = this.OperatorMap[smth.comparator];\n    }\n    if (smth instanceof Utils.Where) {\n      let value = smth.logic;\n      let key;\n      if (smth.attribute instanceof Utils.SequelizeMethod) {\n        key = this.getWhereConditions(smth.attribute, tableName, factory, options, prepend);\n      } else {\n        key = `${this.quoteTable(smth.attribute.Model.name)}.${this.quoteIdentifier(smth.attribute.field || smth.attribute.fieldName)}`;\n      }\n      if (value && value instanceof Utils.SequelizeMethod) {\n        value = this.getWhereConditions(value, tableName, factory, options, prepend);\n        if (value === \"NULL\") {\n          if (smth.comparator === \"=\") {\n            smth.comparator = \"IS\";\n          }\n          if (smth.comparator === \"!=\") {\n            smth.comparator = \"IS NOT\";\n          }\n        }\n        return [key, value].join(` ${smth.comparator} `);\n      }\n      if (_.isPlainObject(value)) {\n        return this.whereItemQuery(smth.attribute, value, {\n          model: factory\n        });\n      }\n      if ([this.OperatorMap[Op.between], this.OperatorMap[Op.notBetween]].includes(smth.comparator)) {\n        value = `${this.escape(value[0])} AND ${this.escape(value[1])}`;\n      } else if (typeof value === \"boolean\") {\n        value = this.booleanValue(value);\n      } else {\n        value = this.escape(value);\n      }\n      if (value === \"NULL\") {\n        if (smth.comparator === \"=\") {\n          smth.comparator = \"IS\";\n        }\n        if (smth.comparator === \"!=\") {\n          smth.comparator = \"IS NOT\";\n        }\n      }\n      return [key, value].join(` ${smth.comparator} `);\n    }\n    if (smth instanceof Utils.Literal) {\n      return smth.val;\n    }\n    if (smth instanceof Utils.Cast) {\n      if (smth.val instanceof Utils.SequelizeMethod) {\n        result = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n      } else if (_.isPlainObject(smth.val)) {\n        result = this.whereItemsQuery(smth.val);\n      } else {\n        result = this.escape(smth.val);\n      }\n      return `CAST(${result} AS ${smth.type.toUpperCase()})`;\n    }\n    if (smth instanceof Utils.Fn) {\n      return `${smth.fn}(${smth.args.map((arg) => {\n        if (arg instanceof Utils.SequelizeMethod) {\n          return this.handleSequelizeMethod(arg, tableName, factory, options, prepend);\n        }\n        if (_.isPlainObject(arg)) {\n          return this.whereItemsQuery(arg);\n        }\n        return this.escape(typeof arg === \"string\" ? arg.replace(/\\$/g, \"$$$\") : arg);\n      }).join(\", \")})`;\n    }\n    if (smth instanceof Utils.Col) {\n      if (Array.isArray(smth.col) && !factory) {\n        throw new Error(\"Cannot call Sequelize.col() with array outside of order / group clause\");\n      }\n      if (smth.col.startsWith(\"*\")) {\n        return \"*\";\n      }\n      return this.quote(smth.col, factory);\n    }\n    return smth.toString(this, factory);\n  }\n  whereQuery(where, options) {\n    const query = this.whereItemsQuery(where, options);\n    if (query && query.length) {\n      return `WHERE ${query}`;\n    }\n    return \"\";\n  }\n  whereItemsQuery(where, options, binding) {\n    if (where === null || where === void 0 || Utils.getComplexSize(where) === 0) {\n      return \"\";\n    }\n    if (typeof where === \"string\") {\n      throw new Error(\"Support for `{where: 'raw query'}` has been removed.\");\n    }\n    const items = [];\n    binding = binding || \"AND\";\n    if (binding[0] !== \" \")\n      binding = ` ${binding} `;\n    if (_.isPlainObject(where)) {\n      Utils.getComplexKeys(where).forEach((prop) => {\n        const item = where[prop];\n        items.push(this.whereItemQuery(prop, item, options));\n      });\n    } else {\n      items.push(this.whereItemQuery(void 0, where, options));\n    }\n    return items.length && items.filter((item) => item && item.length).join(binding) || \"\";\n  }\n  whereItemQuery(key, value, options = {}) {\n    if (value === void 0) {\n      throw new Error(`WHERE parameter \"${key}\" has invalid \"undefined\" value`);\n    }\n    if (typeof key === \"string\" && key.includes(\".\") && options.model) {\n      const keyParts = key.split(\".\");\n      if (options.model.rawAttributes[keyParts[0]] && options.model.rawAttributes[keyParts[0]].type instanceof DataTypes.JSON) {\n        const tmp = {};\n        const field2 = options.model.rawAttributes[keyParts[0]];\n        _.set(tmp, keyParts.slice(1), value);\n        return this.whereItemQuery(field2.field || keyParts[0], tmp, __spreadValues({ field: field2 }, options));\n      }\n    }\n    const field = this._findField(key, options);\n    const fieldType = field && field.type || options.type;\n    const isPlainObject = _.isPlainObject(value);\n    const isArray = !isPlainObject && Array.isArray(value);\n    key = this.OperatorsAliasMap && this.OperatorsAliasMap[key] || key;\n    if (isPlainObject) {\n      value = this._replaceAliases(value);\n    }\n    const valueKeys = isPlainObject && Utils.getComplexKeys(value);\n    if (key === void 0) {\n      if (typeof value === \"string\") {\n        return value;\n      }\n      if (isPlainObject && valueKeys.length === 1) {\n        return this.whereItemQuery(valueKeys[0], value[valueKeys[0]], options);\n      }\n    }\n    if (value === null) {\n      const opValue2 = options.bindParam ? \"NULL\" : this.escape(value, field);\n      return this._joinKeyValue(key, opValue2, this.OperatorMap[Op.is], options.prefix);\n    }\n    if (!value) {\n      const opValue2 = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(key, opValue2, this.OperatorMap[Op.eq], options.prefix);\n    }\n    if (value instanceof Utils.SequelizeMethod && !(key !== void 0 && value instanceof Utils.Fn)) {\n      return this.handleSequelizeMethod(value);\n    }\n    if (key === void 0 && isArray) {\n      if (Utils.canTreatArrayAsAnd(value)) {\n        key = Op.and;\n      } else {\n        throw new Error(\"Support for literal replacements in the `where` object has been removed.\");\n      }\n    }\n    if (key === Op.or || key === Op.and || key === Op.not) {\n      return this._whereGroupBind(key, value, options);\n    }\n    if (value[Op.or]) {\n      return this._whereBind(this.OperatorMap[Op.or], key, value[Op.or], options);\n    }\n    if (value[Op.and]) {\n      return this._whereBind(this.OperatorMap[Op.and], key, value[Op.and], options);\n    }\n    if (isArray && fieldType instanceof DataTypes.ARRAY) {\n      const opValue2 = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(key, opValue2, this.OperatorMap[Op.eq], options.prefix);\n    }\n    if (isPlainObject && fieldType instanceof DataTypes.JSON && options.json !== false) {\n      return this._whereJSON(key, value, options);\n    }\n    if (isPlainObject && valueKeys.length > 1) {\n      return this._whereBind(this.OperatorMap[Op.and], key, value, options);\n    }\n    if (isArray) {\n      return this._whereParseSingleValueObject(key, field, Op.in, value, options);\n    }\n    if (isPlainObject) {\n      if (this.OperatorMap[valueKeys[0]]) {\n        return this._whereParseSingleValueObject(key, field, valueKeys[0], value[valueKeys[0]], options);\n      }\n      return this._whereParseSingleValueObject(key, field, this.OperatorMap[Op.eq], value, options);\n    }\n    if (key === Op.placeholder) {\n      const opValue2 = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(this.OperatorMap[key], opValue2, this.OperatorMap[Op.eq], options.prefix);\n    }\n    const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n    return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n  }\n  _findField(key, options) {\n    if (options.field) {\n      return options.field;\n    }\n    if (options.model && options.model.rawAttributes && options.model.rawAttributes[key]) {\n      return options.model.rawAttributes[key];\n    }\n    if (options.model && options.model.fieldRawAttributesMap && options.model.fieldRawAttributesMap[key]) {\n      return options.model.fieldRawAttributesMap[key];\n    }\n  }\n  _whereGroupBind(key, value, options) {\n    const binding = key === Op.or ? this.OperatorMap[Op.or] : this.OperatorMap[Op.and];\n    const outerBinding = key === Op.not ? \"NOT \" : \"\";\n    if (Array.isArray(value)) {\n      value = value.map((item) => {\n        let itemQuery = this.whereItemsQuery(item, options, this.OperatorMap[Op.and]);\n        if (itemQuery && itemQuery.length && (Array.isArray(item) || _.isPlainObject(item)) && Utils.getComplexSize(item) > 1) {\n          itemQuery = `(${itemQuery})`;\n        }\n        return itemQuery;\n      }).filter((item) => item && item.length);\n      value = value.length && value.join(binding);\n    } else {\n      value = this.whereItemsQuery(value, options, binding);\n    }\n    if ((key === Op.or || key === Op.not) && !value) {\n      return \"0 = 1\";\n    }\n    return value ? `${outerBinding}(${value})` : void 0;\n  }\n  _whereBind(binding, key, value, options) {\n    if (_.isPlainObject(value)) {\n      value = Utils.getComplexKeys(value).map((prop) => {\n        const item = value[prop];\n        return this.whereItemQuery(key, { [prop]: item }, options);\n      });\n    } else {\n      value = value.map((item) => this.whereItemQuery(key, item, options));\n    }\n    value = value.filter((item) => item && item.length);\n    return value.length ? `(${value.join(binding)})` : void 0;\n  }\n  _whereJSON(key, value, options) {\n    const items = [];\n    let baseKey = this.quoteIdentifier(key);\n    if (options.prefix) {\n      if (options.prefix instanceof Utils.Literal) {\n        baseKey = `${this.handleSequelizeMethod(options.prefix)}.${baseKey}`;\n      } else {\n        baseKey = `${this.quoteTable(options.prefix)}.${baseKey}`;\n      }\n    }\n    Utils.getOperators(value).forEach((op) => {\n      const where = {\n        [op]: value[op]\n      };\n      items.push(this.whereItemQuery(key, where, __spreadProps(__spreadValues({}, options), { json: false })));\n    });\n    _.forOwn(value, (item, prop) => {\n      this._traverseJSON(items, baseKey, prop, item, [prop]);\n    });\n    const result = items.join(this.OperatorMap[Op.and]);\n    return items.length > 1 ? `(${result})` : result;\n  }\n  _traverseJSON(items, baseKey, prop, item, path) {\n    let cast;\n    if (path[path.length - 1].includes(\"::\")) {\n      const tmp = path[path.length - 1].split(\"::\");\n      cast = tmp[1];\n      path[path.length - 1] = tmp[0];\n    }\n    let pathKey = this.jsonPathExtractionQuery(baseKey, path);\n    if (_.isPlainObject(item)) {\n      Utils.getOperators(item).forEach((op) => {\n        const value = this._toJSONValue(item[op]);\n        let isJson = false;\n        if (typeof value === \"string\" && op === Op.contains) {\n          try {\n            JSON.stringify(value);\n            isJson = true;\n          } catch (e) {\n          }\n        }\n        pathKey = this.jsonPathExtractionQuery(baseKey, path, isJson);\n        items.push(this.whereItemQuery(this._castKey(pathKey, value, cast), { [op]: value }));\n      });\n      _.forOwn(item, (value, itemProp) => {\n        this._traverseJSON(items, baseKey, itemProp, value, path.concat([itemProp]));\n      });\n      return;\n    }\n    item = this._toJSONValue(item);\n    items.push(this.whereItemQuery(this._castKey(pathKey, item, cast), { [Op.eq]: item }));\n  }\n  _toJSONValue(value) {\n    return value;\n  }\n  _castKey(key, value, cast, json) {\n    cast = cast || this._getJsonCast(Array.isArray(value) ? value[0] : value);\n    if (cast) {\n      return new Utils.Literal(this.handleSequelizeMethod(new Utils.Cast(new Utils.Literal(key), cast, json)));\n    }\n    return new Utils.Literal(key);\n  }\n  _getJsonCast(value) {\n    if (typeof value === \"number\") {\n      return \"double precision\";\n    }\n    if (value instanceof Date) {\n      return \"timestamptz\";\n    }\n    if (typeof value === \"boolean\") {\n      return \"boolean\";\n    }\n    return;\n  }\n  _joinKeyValue(key, value, comparator, prefix) {\n    if (!key) {\n      return value;\n    }\n    if (comparator === void 0) {\n      throw new Error(`${key} and ${value} has no comparator`);\n    }\n    key = this._getSafeKey(key, prefix);\n    return [key, value].join(` ${comparator} `);\n  }\n  _getSafeKey(key, prefix) {\n    if (key instanceof Utils.SequelizeMethod) {\n      key = this.handleSequelizeMethod(key);\n      return this._prefixKey(this.handleSequelizeMethod(key), prefix);\n    }\n    if (Utils.isColString(key)) {\n      key = key.substr(1, key.length - 2).split(\".\");\n      if (key.length > 2) {\n        key = [\n          key.slice(0, -1).join(\"->\"),\n          key[key.length - 1]\n        ];\n      }\n      return key.map((identifier) => this.quoteIdentifier(identifier)).join(\".\");\n    }\n    return this._prefixKey(this.quoteIdentifier(key), prefix);\n  }\n  _prefixKey(key, prefix) {\n    if (prefix) {\n      if (prefix instanceof Utils.Literal) {\n        return [this.handleSequelizeMethod(prefix), key].join(\".\");\n      }\n      return [this.quoteTable(prefix), key].join(\".\");\n    }\n    return key;\n  }\n  _whereParseSingleValueObject(key, field, prop, value, options) {\n    if (prop === Op.not) {\n      if (Array.isArray(value)) {\n        prop = Op.notIn;\n      } else if (value !== null && value !== true && value !== false) {\n        prop = Op.ne;\n      }\n    }\n    let comparator = this.OperatorMap[prop] || this.OperatorMap[Op.eq];\n    switch (prop) {\n      case Op.in:\n      case Op.notIn:\n        if (value instanceof Utils.Literal) {\n          return this._joinKeyValue(key, value.val, comparator, options.prefix);\n        }\n        if (value.length) {\n          return this._joinKeyValue(key, `(${value.map((item) => this.escape(item, field)).join(\", \")})`, comparator, options.prefix);\n        }\n        if (comparator === this.OperatorMap[Op.in]) {\n          return this._joinKeyValue(key, \"(NULL)\", comparator, options.prefix);\n        }\n        return \"\";\n      case Op.any:\n      case Op.all:\n        comparator = `${this.OperatorMap[Op.eq]} ${comparator}`;\n        if (value[Op.values]) {\n          return this._joinKeyValue(key, `(VALUES ${value[Op.values].map((item) => `(${this.escape(item)})`).join(\", \")})`, comparator, options.prefix);\n        }\n        return this._joinKeyValue(key, `(${this.escape(value, field)})`, comparator, options.prefix);\n      case Op.between:\n      case Op.notBetween:\n        return this._joinKeyValue(key, `${this.escape(value[0], field)} AND ${this.escape(value[1], field)}`, comparator, options.prefix);\n      case Op.raw:\n        throw new Error(\"The `$raw` where property is no longer supported.  Use `sequelize.literal` instead.\");\n      case Op.col:\n        comparator = this.OperatorMap[Op.eq];\n        value = value.split(\".\");\n        if (value.length > 2) {\n          value = [\n            value.slice(0, -1).join(\"->\"),\n            value[value.length - 1]\n          ];\n        }\n        return this._joinKeyValue(key, value.map((identifier) => this.quoteIdentifier(identifier)).join(\".\"), comparator, options.prefix);\n      case Op.startsWith:\n      case Op.endsWith:\n      case Op.substring:\n        comparator = this.OperatorMap[Op.like];\n        if (value instanceof Utils.Literal) {\n          value = value.val;\n        }\n        let pattern = `${value}%`;\n        if (prop === Op.endsWith)\n          pattern = `%${value}`;\n        if (prop === Op.substring)\n          pattern = `%${value}%`;\n        return this._joinKeyValue(key, this.escape(pattern), comparator, options.prefix);\n    }\n    const escapeOptions = {\n      acceptStrings: comparator.includes(this.OperatorMap[Op.like])\n    };\n    if (_.isPlainObject(value)) {\n      if (value[Op.col]) {\n        return this._joinKeyValue(key, this.whereItemQuery(null, value), comparator, options.prefix);\n      }\n      if (value[Op.any]) {\n        escapeOptions.isList = true;\n        return this._joinKeyValue(key, `(${this.escape(value[Op.any], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.any]}`, options.prefix);\n      }\n      if (value[Op.all]) {\n        escapeOptions.isList = true;\n        return this._joinKeyValue(key, `(${this.escape(value[Op.all], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.all]}`, options.prefix);\n      }\n    }\n    if (value === null && comparator === this.OperatorMap[Op.eq]) {\n      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.is], options.prefix);\n    }\n    if (value === null && comparator === this.OperatorMap[Op.ne]) {\n      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.not], options.prefix);\n    }\n    return this._joinKeyValue(key, this.escape(value, field, escapeOptions), comparator, options.prefix);\n  }\n  getWhereConditions(smth, tableName, factory, options, prepend) {\n    const where = {};\n    if (Array.isArray(tableName)) {\n      tableName = tableName[0];\n      if (Array.isArray(tableName)) {\n        tableName = tableName[1];\n      }\n    }\n    options = options || {};\n    if (prepend === void 0) {\n      prepend = true;\n    }\n    if (smth && smth instanceof Utils.SequelizeMethod) {\n      return this.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n    if (_.isPlainObject(smth)) {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName,\n        type: options.type\n      });\n    }\n    if (typeof smth === \"number\" || typeof smth === \"bigint\") {\n      let primaryKeys = factory ? Object.keys(factory.primaryKeys) : [];\n      if (primaryKeys.length > 0) {\n        primaryKeys = primaryKeys[0];\n      } else {\n        primaryKeys = \"id\";\n      }\n      where[primaryKeys] = smth;\n      return this.whereItemsQuery(where, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n    if (typeof smth === \"string\") {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n    if (Buffer.isBuffer(smth)) {\n      return this.escape(smth);\n    }\n    if (Array.isArray(smth)) {\n      if (smth.length === 0 || smth.length > 0 && smth[0].length === 0)\n        return \"1=1\";\n      if (Utils.canTreatArrayAsAnd(smth)) {\n        const _smth = { [Op.and]: smth };\n        return this.getWhereConditions(_smth, tableName, factory, options, prepend);\n      }\n      throw new Error(\"Support for literal replacements in the `where` object has been removed.\");\n    }\n    if (smth == null) {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n    throw new Error(`Unsupported where option value: ${util.inspect(smth)}. Please refer to the Sequelize documentation to learn more about which values are accepted as part of the where option.`);\n  }\n  parseConditionObject(conditions, path) {\n    path = path || [];\n    return _.reduce(conditions, (result, value, key) => {\n      if (_.isObject(value)) {\n        return result.concat(this.parseConditionObject(value, path.concat(key)));\n      }\n      result.push({ path: path.concat(key), value });\n      return result;\n    }, []);\n  }\n  booleanValue(value) {\n    return value;\n  }\n  authTestQuery() {\n    return \"SELECT 1+1 AS result\";\n  }\n}\nObject.assign(QueryGenerator.prototype, __webpack_require__(/*! ./query-generator/operators */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js\"));\nObject.assign(QueryGenerator.prototype, __webpack_require__(/*! ./query-generator/transaction */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js\"));\nmodule.exports = QueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFVBQVUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMxQixlQUFlLG9HQUFrQjtBQUNqQyxjQUFjLG1CQUFPLENBQUMsNEVBQWE7QUFDbkMscUJBQXFCLG1CQUFPLENBQUMsc0dBQTBCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLHNGQUFrQjtBQUM1QyxrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBa0I7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLDRFQUFhO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLG9HQUF5QjtBQUNyRCxrQkFBa0IsbUJBQU8sQ0FBQyxnSEFBK0I7QUFDekQsc0JBQXNCLG1CQUFPLENBQUMsMEhBQW9DO0FBQ2xFLGdCQUFnQixtQkFBTyxDQUFDLDRHQUE2QjtBQUNyRCxXQUFXLG1CQUFPLENBQUMsb0ZBQWlCO0FBQ3BDLHVCQUF1QixtQkFBTyxDQUFDLG9GQUFjO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLHdGQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQSxtQ0FBbUMsNEJBQTRCO0FBQy9EO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCLFlBQVksd0JBQXdCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csbUJBQW1CO0FBQ3ZILFlBQVk7QUFDWixvR0FBb0csbUJBQW1CO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsMkJBQTJCLFlBQVksMkJBQTJCO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG1DQUFtQyxrQ0FBa0M7QUFDckUsUUFBUTtBQUNSLHFFQUFxRSwyQkFBMkIsVUFBVSwyQkFBMkI7QUFDckk7QUFDQSxnRUFBZ0UsMkJBQTJCLEdBQUcsMkJBQTJCO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtEQUFrRCxFQUFFLG9CQUFvQjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTLFFBQVEsK0JBQStCLE9BQU8sYUFBYSxHQUFHLHdCQUF3QixHQUFHLHFCQUFxQixVQUFVLG9CQUFvQixHQUFHLHFCQUFxQixFQUFFLGlDQUFpQyxFQUFFLFdBQVc7QUFDalAsb0JBQW9CLFNBQVMsUUFBUSwrQkFBK0IsT0FBTyxZQUFZLEVBQUUsb0JBQW9CLEVBQUUscUJBQXFCLEVBQUUsaUNBQWlDLEVBQUUsV0FBVztBQUNwTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJCQUEyQjtBQUM1RCx3REFBd0Qsd0RBQXdELDhEQUE4RDtBQUM5SywrSEFBK0g7QUFDL0gsK0VBQStFLFlBQVksMkRBQTJELFdBQVcsUUFBUSxZQUFZLDJCQUEyQixZQUFZLG1CQUFtQixNQUFNLFdBQVcsa0JBQWtCLEVBQUUsYUFBYSxFQUFFLGFBQWE7QUFDaFQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQXlELEVBQUUsNEJBQTRCO0FBQ3RHO0FBQ0EsMkNBQTJDLHlEQUF5RCxFQUFFO0FBQ3RHO0FBQ0E7QUFDQSxxQ0FBcUMsYUFBYSxJQUFJLEVBQUUsT0FBTyxzQkFBc0IsYUFBYSxJQUFJO0FBQ3RHO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLG1CQUFtQjtBQUNqRyxPQUFPO0FBQ1Asc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSwyQkFBMkIsWUFBWSwyQkFBMkI7QUFDeEk7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLG1CQUFtQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxxRUFBcUUsbUJBQW1CO0FBQ3hGO0FBQ0EscUVBQXFFLDJCQUEyQixVQUFVLDJCQUEyQjtBQUNySSxrQ0FBa0Msa0RBQWtELEVBQUUsb0JBQW9CO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0QkFBNEI7QUFDdkQsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLCtCQUErQiw0QkFBNEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEIsR0FBRyw0RUFBNEUsbUJBQW1CLEVBQUU7QUFDckosUUFBUTtBQUNSLHVCQUF1QiwwQkFBMEIsR0FBRyw0RUFBNEUsbUJBQW1CLGFBQWE7QUFDaEs7QUFDQTtBQUNBLHdEQUF3RCxjQUFjLFdBQVc7QUFDakY7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVMsU0FBUyw0QkFBNEIsTUFBTSxpQkFBaUIsRUFBRSxnQkFBZ0IsRUFBRSxxQ0FBcUMsRUFBRSxPQUFPO0FBQzVKLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWSxHQUFHLFlBQVksRUFBRSxVQUFVLEVBQUUsY0FBYztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVksR0FBRyxhQUFhO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxvQkFBb0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9DQUFvQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxxUEFBcVAsY0FBYyxzREFBc0QsVUFBVSxpRkFBaUYsY0FBYyxZQUFZLHFCQUFxQiwyRUFBMkUsZUFBZTtBQUM3aEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxNQUFNO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVSxHQUFHLGdCQUFnQjtBQUM5RiwwQ0FBMEMsZ0JBQWdCLFVBQVUsc0JBQXNCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxVQUFVLEdBQUcsZ0JBQWdCO0FBQzlGLDBDQUEwQyxnQkFBZ0IsU0FBUyxjQUFjO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVSxHQUFHLGdCQUFnQjtBQUM5RiwwQ0FBMEMsZ0JBQWdCLFdBQVcsa0NBQWtDLFFBQVEsYUFBYTtBQUM1SDtBQUNBO0FBQ0EsaUVBQWlFLFVBQVUsR0FBRyxnQkFBZ0I7QUFDOUYsMENBQTBDLGdCQUFnQixlQUFlLHNCQUFzQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVSxHQUFHLGdCQUFnQixHQUFHLGlCQUFpQjtBQUNsSDtBQUNBLHFDQUFxQyxtQ0FBbUMsR0FBRyxpQkFBaUI7QUFDNUYsMENBQTBDLGdCQUFnQjtBQUMxRCw2Q0FBNkMsc0JBQXNCLGVBQWUsa0JBQWtCO0FBQ3BHO0FBQ0EsNkNBQTZDLCtCQUErQjtBQUM1RTtBQUNBO0FBQ0EsNkNBQTZDLCtCQUErQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0EsK0JBQStCLG9DQUFvQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsOEJBQThCO0FBQzdFLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSw0REFBNEQsbUJBQW1CLEdBQUcsZ0RBQWdEO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlEQUFpRDtBQUNuRSxRQUFRO0FBQ1Isa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QyxHQUFHLDJDQUEyQztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQSxrRUFBa0UseUJBQXlCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGFBQWE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQixHQUFHLDJCQUEyQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1DQUFtQztBQUN6RDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCLEVBQUUsNEJBQTRCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDRGQUE0RjtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxxR0FBcUc7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx1SUFBdUksZ0JBQWdCO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxFQUFFO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLCtHQUErRyxNQUFNO0FBQ3JIO0FBQ0EsaUNBQWlDLGFBQWEsR0FBRyxRQUFRO0FBQ3pEO0FBQ0EsNENBQTRDLGFBQWEsR0FBRyxRQUFRO0FBQ3BFO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRSxpQkFBaUI7QUFDbkQsbUJBQW1CLGFBQWEsRUFBRSxLQUFLLEVBQUUsUUFBUTtBQUNqRDtBQUNBLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGFBQWE7QUFDN0U7QUFDQTtBQUNBLDRCQUE0QixxQ0FBcUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELG9EQUFvRDtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsRUFBRTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUJBQW1CLFFBQVEsSUFBSSxzQkFBc0I7QUFDOUQsd0VBQXdFLE9BQU87QUFDL0U7QUFDQSx3R0FBd0c7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3RUFBd0U7QUFDakYsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRCxVQUFVO0FBQ1Ysd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQsUUFBUTtBQUNSLHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZELFVBQVU7QUFDVix5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUNBQWlDO0FBQzFFO0FBQ0E7QUFDQSx3Q0FBd0MsZ0NBQWdDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrREFBa0Q7QUFDeEcsd0JBQXdCLDRCQUE0QixRQUFRLHVCQUF1QixJQUFJLHNCQUFzQixFQUFFLGFBQWEsRUFBRSx5QkFBeUIsRUFBRSx3QkFBd0I7QUFDakwsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSztBQUM5QixRQUFRO0FBQ1IscUJBQXFCLGdDQUFnQztBQUNyRCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWSxHQUFHLEtBQUs7QUFDdEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQixJQUFJLFdBQVc7QUFDMUUsZ0NBQWdDLDJCQUEyQixHQUFHLFdBQVc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVCQUF1QiwyQ0FBMkMsR0FBRywyQkFBMkI7QUFDaEcsVUFBVTtBQUNWLG1FQUFtRSwyQ0FBMkM7QUFDOUcsVUFBVTtBQUNWLCtEQUErRCwyQ0FBMkM7QUFDMUcsVUFBVTtBQUNWLHNCQUFzQiwyQ0FBMkMsR0FBRywyQkFBMkI7QUFDL0Y7QUFDQSx1QkFBdUIscUJBQXFCLEdBQUcsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQixJQUFJLGVBQWUsRUFBRSwyQkFBMkIsT0FBTyxvQkFBb0I7QUFDakksUUFBUTtBQUNSLHNDQUFzQyxnQkFBZ0IsRUFBRSxnQkFBZ0IsS0FBSyxvQkFBb0I7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHVDQUF1QyxnQkFBZ0IsSUFBSSxlQUFlLEVBQUUsNEJBQTRCLE9BQU8sb0JBQW9CO0FBQ25JLFFBQVE7QUFDUix1Q0FBdUMsZ0JBQWdCLEVBQUUsZ0JBQWdCLEtBQUssb0JBQW9CO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVUsRUFBRSxNQUFNO0FBQ3BELHVDQUF1QyxVQUFVLEVBQUUsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw0QkFBNEI7QUFDMUQ7QUFDQSw4QkFBOEIsVUFBVSxFQUFFLE1BQU07QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVSxFQUFFLE1BQU07QUFDdEQseUNBQXlDLFVBQVUsRUFBRSxNQUFNO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVyxJQUFJLE9BQU87QUFDMUMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPLElBQUksUUFBUTtBQUN0QyxvQkFBb0Isd0JBQXdCLEdBQUcsZ0NBQWdDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLFVBQVUsR0FBRywrQkFBK0I7QUFDckk7QUFDQSxrQ0FBa0MsVUFBVSxHQUFHLGdDQUFnQztBQUMvRSwrREFBK0QsY0FBYyxLQUFLLCtCQUErQjtBQUNqSDtBQUNBLFFBQVE7QUFDUiw4QkFBOEIsMkJBQTJCLEdBQUcsU0FBUztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCLEdBQUcsaUNBQWlDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDLFVBQVU7QUFDViw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdUJBQXVCO0FBQy9ELE1BQU07QUFDTix3Q0FBd0Msd0JBQXdCO0FBQ2hFLE1BQU07QUFDTixrQ0FBa0Msd0NBQXdDLE1BQU0sYUFBYTtBQUM3RjtBQUNBLDZEQUE2RCxPQUFPLEVBQUUsdUJBQXVCO0FBQzdGLDBDQUEwQyxxQkFBcUIsR0FBRztBQUNsRTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQixJQUFJLFdBQVc7QUFDN0QsaUNBQWlDLHFCQUFxQixHQUFHLFdBQVc7QUFDcEU7QUFDQSxxQkFBcUIsa0JBQWtCLEdBQUcscUNBQXFDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQ0FBZ0MsR0FBRywyREFBMkQ7QUFDekc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFlBQVksR0FBRyxXQUFXLCtCQUErQixZQUFZLEdBQUcsV0FBVztBQUNuSix3QkFBd0Isa0NBQWtDO0FBQzFELE1BQU07QUFDTjtBQUNBLHdCQUF3Qiw2QkFBNkIsR0FBRyxxQ0FBcUM7QUFDN0Y7QUFDQSx1QkFBdUIsZ0NBQWdDLEdBQUcsa0NBQWtDO0FBQzVGLHNCQUFzQixrQ0FBa0MsR0FBRyxrQ0FBa0M7QUFDN0YsdUJBQXVCLGdDQUFnQyxHQUFHLGtDQUFrQztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQ0FBMEMsYUFBYSxxRUFBcUUsS0FBSyxhQUFhO0FBQ2xLO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5Q0FBeUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFlBQVkseUNBQXlDO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQ0FBc0MsR0FBRyxzREFBc0Q7QUFDaEgsaUJBQWlCLG9EQUFvRCxHQUFHLHFEQUFxRDtBQUM3SDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9DQUFvQyxHQUFHLGtDQUFrQztBQUNwRixXQUFXLHNEQUFzRCxHQUFHLGtDQUFrQztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjLDZCQUE2QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQsMERBQTBELG9CQUFvQjtBQUM5RSxnREFBZ0QsVUFBVSxFQUFFLFFBQVE7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlEQUFpRDtBQUNoRyw2QkFBNkIsdUJBQXVCLE9BQU8sT0FBTztBQUNsRTtBQUNBLHNCQUFzQixzQkFBc0IsRUFBRSxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QixTQUFTLDJFQUEyRTtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsaUJBQWlCLDJDQUEyQyxHQUFHLHVFQUF1RTtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlCQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QixNQUFNLHNCQUFzQjtBQUN0RSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUSxLQUFLLHdCQUF3QjtBQUMxRDtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVEsR0FBRztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sYUFBYTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLDBDQUEwQyxJQUFJO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLGVBQWU7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYSxHQUFHLE1BQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjO0FBQ3hELE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9CQUFvQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkNBQTJDLEdBQUcsUUFBUTtBQUMzRSxRQUFRO0FBQ1IscUJBQXFCLGdDQUFnQyxHQUFHLFFBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLGNBQWMsYUFBYTtBQUMzRyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLGFBQWE7QUFDM0YsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGVBQWU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSyxNQUFNLE9BQU87QUFDM0M7QUFDQTtBQUNBLGlDQUFpQyxZQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMseURBQXlEO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QixFQUFFLFdBQVc7QUFDOUQ7QUFDQSxvREFBb0QsbUNBQW1DLGtCQUFrQixlQUFlO0FBQ3hIO0FBQ0EsMkNBQTJDLDBCQUEwQjtBQUNyRTtBQUNBO0FBQ0EsMENBQTBDLDhCQUE4QixNQUFNLDZCQUE2QjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUI7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlEQUFpRCxPQUFPLFlBQVksRUFBRSx5QkFBeUI7QUFDMUk7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlEQUFpRCxPQUFPLFlBQVksRUFBRSx5QkFBeUI7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsdURBQXVELG1CQUFtQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtQkFBTyxDQUFDLGtJQUE2QjtBQUM3RSx3Q0FBd0MsbUJBQU8sQ0FBQyxzSUFBK0I7QUFDL0U7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3IuanM/ZDZlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCB1dWlkdjQgPSByZXF1aXJlKFwidXVpZFwiKS52NDtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuY29uc3QgZGVwcmVjYXRpb25zID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2RlcHJlY2F0aW9uc1wiKTtcbmNvbnN0IFNxbFN0cmluZyA9IHJlcXVpcmUoXCIuLi8uLi9zcWwtc3RyaW5nXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIik7XG5jb25zdCBNb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbFwiKTtcbmNvbnN0IEFzc29jaWF0aW9uID0gcmVxdWlyZShcIi4uLy4uL2Fzc29jaWF0aW9ucy9iYXNlXCIpO1xuY29uc3QgQmVsb25nc1RvID0gcmVxdWlyZShcIi4uLy4uL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvXCIpO1xuY29uc3QgQmVsb25nc1RvTWFueSA9IHJlcXVpcmUoXCIuLi8uLi9hc3NvY2lhdGlvbnMvYmVsb25ncy10by1tYW55XCIpO1xuY29uc3QgSGFzTWFueSA9IHJlcXVpcmUoXCIuLi8uLi9hc3NvY2lhdGlvbnMvaGFzLW1hbnlcIik7XG5jb25zdCBPcCA9IHJlcXVpcmUoXCIuLi8uLi9vcGVyYXRvcnNcIik7XG5jb25zdCBzZXF1ZWxpemVFcnJvciA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCBJbmRleEhpbnRzID0gcmVxdWlyZShcIi4uLy4uL2luZGV4LWhpbnRzXCIpO1xuY2xhc3MgUXVlcnlHZW5lcmF0b3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLnNlcXVlbGl6ZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXJ5R2VuZXJhdG9yIGluaXRpYWxpemVkIHdpdGhvdXQgb3B0aW9ucy5zZXF1ZWxpemVcIik7XG4gICAgaWYgKCFvcHRpb25zLl9kaWFsZWN0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUXVlcnlHZW5lcmF0b3IgaW5pdGlhbGl6ZWQgd2l0aG91dCBvcHRpb25zLl9kaWFsZWN0XCIpO1xuICAgIHRoaXMuc2VxdWVsaXplID0gb3B0aW9ucy5zZXF1ZWxpemU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucy5zZXF1ZWxpemUub3B0aW9ucztcbiAgICB0aGlzLmRpYWxlY3QgPSBvcHRpb25zLl9kaWFsZWN0Lm5hbWU7XG4gICAgdGhpcy5fZGlhbGVjdCA9IG9wdGlvbnMuX2RpYWxlY3Q7XG4gICAgdGhpcy5faW5pdFF1b3RlSWRlbnRpZmllcigpO1xuICB9XG4gIGV4dHJhY3RUYWJsZURldGFpbHModGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGFibGVOYW1lID0gdGFibGVOYW1lIHx8IHt9O1xuICAgIHJldHVybiB7XG4gICAgICBzY2hlbWE6IHRhYmxlTmFtZS5zY2hlbWEgfHwgb3B0aW9ucy5zY2hlbWEgfHwgdGhpcy5vcHRpb25zLnNjaGVtYSB8fCBcInB1YmxpY1wiLFxuICAgICAgdGFibGVOYW1lOiBfLmlzUGxhaW5PYmplY3QodGFibGVOYW1lKSA/IHRhYmxlTmFtZS50YWJsZU5hbWUgOiB0YWJsZU5hbWUsXG4gICAgICBkZWxpbWl0ZXI6IHRhYmxlTmFtZS5kZWxpbWl0ZXIgfHwgb3B0aW9ucy5kZWxpbWl0ZXIgfHwgXCIuXCJcbiAgICB9O1xuICB9XG4gIGFkZFNjaGVtYShwYXJhbSkge1xuICAgIGlmICghcGFyYW0uX3NjaGVtYSlcbiAgICAgIHJldHVybiBwYXJhbS50YWJsZU5hbWUgfHwgcGFyYW07XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhYmxlTmFtZTogcGFyYW0udGFibGVOYW1lIHx8IHBhcmFtLFxuICAgICAgdGFibGU6IHBhcmFtLnRhYmxlTmFtZSB8fCBwYXJhbSxcbiAgICAgIG5hbWU6IHBhcmFtLm5hbWUgfHwgcGFyYW0sXG4gICAgICBzY2hlbWE6IHBhcmFtLl9zY2hlbWEsXG4gICAgICBkZWxpbWl0ZXI6IHBhcmFtLl9zY2hlbWFEZWxpbWl0ZXIgfHwgXCIuXCIsXG4gICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYucXVvdGVUYWJsZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGRyb3BTY2hlbWEodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJvcFRhYmxlUXVlcnkodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgfVxuICBkZXNjcmliZVRhYmxlUXVlcnkodGFibGVOYW1lLCBzY2hlbWEsIHNjaGVtYURlbGltaXRlcikge1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRoaXMuYWRkU2NoZW1hKHtcbiAgICAgIHRhYmxlTmFtZSxcbiAgICAgIF9zY2hlbWE6IHNjaGVtYSxcbiAgICAgIF9zY2hlbWFEZWxpbWl0ZXI6IHNjaGVtYURlbGltaXRlclxuICAgIH0pKTtcbiAgICByZXR1cm4gYERFU0NSSUJFICR7dGFibGV9O2A7XG4gIH1cbiAgZHJvcFRhYmxlUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIGBEUk9QIFRBQkxFIElGIEVYSVNUUyAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfTtgO1xuICB9XG4gIHJlbmFtZVRhYmxlUXVlcnkoYmVmb3JlLCBhZnRlcikge1xuICAgIHJldHVybiBgQUxURVIgVEFCTEUgJHt0aGlzLnF1b3RlVGFibGUoYmVmb3JlKX0gUkVOQU1FIFRPICR7dGhpcy5xdW90ZVRhYmxlKGFmdGVyKX07YDtcbiAgfVxuICBwb3B1bGF0ZUluc2VydFF1ZXJ5UmV0dXJuSW50b0JpbmRzKCkge1xuICB9XG4gIGluc2VydFF1ZXJ5KHRhYmxlLCB2YWx1ZUhhc2gsIG1vZGVsQXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIF8uZGVmYXVsdHMob3B0aW9ucywgdGhpcy5vcHRpb25zKTtcbiAgICBjb25zdCBtb2RlbEF0dHJpYnV0ZU1hcCA9IHt9O1xuICAgIGNvbnN0IGJpbmQgPSBvcHRpb25zLmJpbmQgfHwgW107XG4gICAgY29uc3QgZmllbGRzID0gW107XG4gICAgY29uc3QgcmV0dXJuaW5nTW9kZWxBdHRyaWJ1dGVzID0gW107XG4gICAgY29uc3QgcmV0dXJuVHlwZXMgPSBbXTtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBjb25zdCBxdW90ZWRUYWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZSk7XG4gICAgY29uc3QgYmluZFBhcmFtID0gb3B0aW9ucy5iaW5kUGFyYW0gPT09IHZvaWQgMCA/IHRoaXMuYmluZFBhcmFtKGJpbmQpIDogb3B0aW9ucy5iaW5kUGFyYW07XG4gICAgY29uc3QgcmV0dXJuQXR0cmlidXRlcyA9IFtdO1xuICAgIGxldCBxdWVyeTtcbiAgICBsZXQgdmFsdWVRdWVyeSA9IFwiXCI7XG4gICAgbGV0IGVtcHR5UXVlcnkgPSBcIlwiO1xuICAgIGxldCBvdXRwdXRGcmFnbWVudCA9IFwiXCI7XG4gICAgbGV0IHJldHVybmluZ0ZyYWdtZW50ID0gXCJcIjtcbiAgICBsZXQgaWRlbnRpdHlXcmFwcGVyUmVxdWlyZWQgPSBmYWxzZTtcbiAgICBsZXQgdG1wVGFibGUgPSBcIlwiO1xuICAgIGlmIChtb2RlbEF0dHJpYnV0ZXMpIHtcbiAgICAgIF8uZWFjaChtb2RlbEF0dHJpYnV0ZXMsIChhdHRyaWJ1dGUsIGtleSkgPT4ge1xuICAgICAgICBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldID0gYXR0cmlidXRlO1xuICAgICAgICBpZiAoYXR0cmlidXRlLmZpZWxkKSB7XG4gICAgICAgICAgbW9kZWxBdHRyaWJ1dGVNYXBbYXR0cmlidXRlLmZpZWxkXSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzW1wiREVGQVVMVCBWQUxVRVNcIl0pIHtcbiAgICAgIGVtcHR5UXVlcnkgKz0gXCIgREVGQVVMVCBWQUxVRVNcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHNbXCJWQUxVRVMgKClcIl0pIHtcbiAgICAgIGVtcHR5UXVlcnkgKz0gXCIgVkFMVUVTICgpXCI7XG4gICAgfVxuICAgIGlmICgodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5yZXR1cm5WYWx1ZXMgfHwgdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5yZXR1cm5JbnRvVmFsdWVzKSAmJiBvcHRpb25zLnJldHVybmluZykge1xuICAgICAgY29uc3QgcmV0dXJuVmFsdWVzID0gdGhpcy5nZW5lcmF0ZVJldHVyblZhbHVlcyhtb2RlbEF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuaW5nTW9kZWxBdHRyaWJ1dGVzLnB1c2goLi4ucmV0dXJuVmFsdWVzLnJldHVybkZpZWxkcyk7XG4gICAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5yZXR1cm5JbnRvVmFsdWVzKSB7XG4gICAgICAgIHJldHVyblR5cGVzLnB1c2goLi4ucmV0dXJuVmFsdWVzLnJldHVyblR5cGVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybmluZ0ZyYWdtZW50ID0gcmV0dXJuVmFsdWVzLnJldHVybmluZ0ZyYWdtZW50O1xuICAgICAgdG1wVGFibGUgPSByZXR1cm5WYWx1ZXMudG1wVGFibGUgfHwgXCJcIjtcbiAgICAgIG91dHB1dEZyYWdtZW50ID0gcmV0dXJuVmFsdWVzLm91dHB1dEZyYWdtZW50IHx8IFwiXCI7XG4gICAgfVxuICAgIGlmIChfLmdldCh0aGlzLCBbXCJzZXF1ZWxpemVcIiwgXCJvcHRpb25zXCIsIFwiZGlhbGVjdE9wdGlvbnNcIiwgXCJwcmVwZW5kU2VhcmNoUGF0aFwiXSkgfHwgb3B0aW9ucy5zZWFyY2hQYXRoKSB7XG4gICAgICBvcHRpb25zLmJpbmRQYXJhbSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5FWENFUFRJT04gJiYgb3B0aW9ucy5leGNlcHRpb24pIHtcbiAgICAgIG9wdGlvbnMuYmluZFBhcmFtID0gZmFsc2U7XG4gICAgfVxuICAgIHZhbHVlSGFzaCA9IFV0aWxzLnJlbW92ZU51bGxWYWx1ZXNGcm9tSGFzaCh2YWx1ZUhhc2gsIHRoaXMub3B0aW9ucy5vbWl0TnVsbCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWVIYXNoKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlSGFzaCwga2V5KSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlSGFzaFtrZXldO1xuICAgICAgICBmaWVsZHMucHVzaCh0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpKTtcbiAgICAgICAgaWYgKG1vZGVsQXR0cmlidXRlTWFwICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XS5hdXRvSW5jcmVtZW50ID09PSB0cnVlICYmIHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuYXV0b0luY3JlbWVudC5kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIGZpZWxkcy5zcGxpY2UoLTEsIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5ERUZBVUxUKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChcIkRFRkFVTFRcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXMuZXNjYXBlKG51bGwpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG1vZGVsQXR0cmlidXRlTWFwICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XS5hdXRvSW5jcmVtZW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZGVudGl0eVdyYXBwZXJSZXF1aXJlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCB8fCBvcHRpb25zLmJpbmRQYXJhbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXMuZXNjYXBlKHZhbHVlLCBtb2RlbEF0dHJpYnV0ZU1hcCAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldIHx8IHZvaWQgMCwgeyBjb250ZXh0OiBcIklOU0VSVFwiIH0pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5mb3JtYXQodmFsdWUsIG1vZGVsQXR0cmlidXRlTWFwICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gfHwgdm9pZCAwLCB7IGNvbnRleHQ6IFwiSU5TRVJUXCIgfSwgYmluZFBhcmFtKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBvbkR1cGxpY2F0ZUtleVVwZGF0ZSA9IFwiXCI7XG4gICAgaWYgKCFfLmlzRW1wdHkob3B0aW9ucy5jb25mbGljdFdoZXJlKSAmJiAhdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLm9uQ29uZmxpY3RXaGVyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBkaWFsZWN0IHN1cHBvcnQgZm9yIGNvbmZsaWN0V2hlcmUgb3B0aW9uXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLnVwZGF0ZU9uRHVwbGljYXRlICYmIG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUpIHtcbiAgICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMudXBkYXRlT25EdXBsaWNhdGUgPT0gXCIgT04gQ09ORkxJQ1QgRE8gVVBEQVRFIFNFVFwiKSB7XG4gICAgICAgIGNvbnN0IGNvbmZsaWN0S2V5cyA9IG9wdGlvbnMudXBzZXJ0S2V5cy5tYXAoKGF0dHIpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpKTtcbiAgICAgICAgY29uc3QgdXBkYXRlS2V5cyA9IG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUubWFwKChhdHRyKSA9PiBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX09RVhDTFVERUQuJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX1gKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnRzID0gW1xuICAgICAgICAgIFwiT04gQ09ORkxJQ1RcIixcbiAgICAgICAgICBcIihcIixcbiAgICAgICAgICBjb25mbGljdEtleXMuam9pbihcIixcIiksXG4gICAgICAgICAgXCIpXCJcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKCFfLmlzRW1wdHkob3B0aW9ucy5jb25mbGljdFdoZXJlKSkge1xuICAgICAgICAgIGZyYWdtZW50cy5wdXNoKHRoaXMud2hlcmVRdWVyeShvcHRpb25zLmNvbmZsaWN0V2hlcmUsIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXy5pc0VtcHR5KHVwZGF0ZUtleXMpKSB7XG4gICAgICAgICAgZnJhZ21lbnRzLnB1c2goXCJETyBOT1RISU5HXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyYWdtZW50cy5wdXNoKFwiRE8gVVBEQVRFIFNFVFwiLCB1cGRhdGVLZXlzLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBvbkR1cGxpY2F0ZUtleVVwZGF0ZSA9IGAgJHtVdGlscy5qb2luU1FMRnJhZ21lbnRzKGZyYWdtZW50cyl9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHZhbHVlS2V5cyA9IG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUubWFwKChhdHRyKSA9PiBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX09VkFMVUVTKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9KWApO1xuICAgICAgICBpZiAoXy5pc0VtcHR5KHZhbHVlS2V5cykgJiYgb3B0aW9ucy51cHNlcnRLZXlzKSB7XG4gICAgICAgICAgdmFsdWVLZXlzLnB1c2goLi4ub3B0aW9ucy51cHNlcnRLZXlzLm1hcCgoYXR0cikgPT4gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9PSR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9YCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfLmlzRW1wdHkodmFsdWVLZXlzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHVwZGF0ZSB2YWx1ZXMgZm91bmQgZm9yIE9OIERVUExJQ0FURSBLRVkgVVBEQVRFIGNsYXVzZSwgYW5kIG5vIGlkZW50aWZpZXIgZmllbGRzIGNvdWxkIGJlIGZvdW5kIHRvIHVzZSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBvbkR1cGxpY2F0ZUtleVVwZGF0ZSArPSBgJHt0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMudXBkYXRlT25EdXBsaWNhdGV9ICR7dmFsdWVLZXlzLmpvaW4oXCIsXCIpfWA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlcGxhY2VtZW50cyA9IHtcbiAgICAgIGlnbm9yZUR1cGxpY2F0ZXM6IG9wdGlvbnMuaWdub3JlRHVwbGljYXRlcyA/IHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy5pZ25vcmVEdXBsaWNhdGVzIDogXCJcIixcbiAgICAgIG9uQ29uZmxpY3REb05vdGhpbmc6IG9wdGlvbnMuaWdub3JlRHVwbGljYXRlcyA/IHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy5vbkNvbmZsaWN0RG9Ob3RoaW5nIDogXCJcIixcbiAgICAgIGF0dHJpYnV0ZXM6IGZpZWxkcy5qb2luKFwiLFwiKSxcbiAgICAgIG91dHB1dDogb3V0cHV0RnJhZ21lbnQsXG4gICAgICB2YWx1ZXM6IHZhbHVlcy5qb2luKFwiLFwiKSxcbiAgICAgIHRtcFRhYmxlXG4gICAgfTtcbiAgICB2YWx1ZVF1ZXJ5ID0gYCR7dG1wVGFibGV9SU5TRVJUJHtyZXBsYWNlbWVudHMuaWdub3JlRHVwbGljYXRlc30gSU5UTyAke3F1b3RlZFRhYmxlfSAoJHtyZXBsYWNlbWVudHMuYXR0cmlidXRlc30pJHtyZXBsYWNlbWVudHMub3V0cHV0fSBWQUxVRVMgKCR7cmVwbGFjZW1lbnRzLnZhbHVlc30pJHtvbkR1cGxpY2F0ZUtleVVwZGF0ZX0ke3JlcGxhY2VtZW50cy5vbkNvbmZsaWN0RG9Ob3RoaW5nfSR7dmFsdWVRdWVyeX1gO1xuICAgIGVtcHR5UXVlcnkgPSBgJHt0bXBUYWJsZX1JTlNFUlQke3JlcGxhY2VtZW50cy5pZ25vcmVEdXBsaWNhdGVzfSBJTlRPICR7cXVvdGVkVGFibGV9JHtyZXBsYWNlbWVudHMub3V0cHV0fSR7b25EdXBsaWNhdGVLZXlVcGRhdGV9JHtyZXBsYWNlbWVudHMub25Db25mbGljdERvTm90aGluZ30ke2VtcHR5UXVlcnl9YDtcbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5FWENFUFRJT04gJiYgb3B0aW9ucy5leGNlcHRpb24pIHtcbiAgICAgIGNvbnN0IGRyb3BGdW5jdGlvbiA9IFwiRFJPUCBGVU5DVElPTiBJRiBFWElTVFMgcGdfdGVtcC50ZXN0ZnVuYygpXCI7XG4gICAgICBpZiAocmV0dXJuaW5nTW9kZWxBdHRyaWJ1dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm5pbmdNb2RlbEF0dHJpYnV0ZXMucHVzaChcIipcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBkZWxpbWl0ZXIgPSBgJGZ1bmNfJHt1dWlkdjQoKS5yZXBsYWNlKC8tL2csIFwiXCIpfSRgO1xuICAgICAgY29uc3Qgc2VsZWN0UXVlcnkgPSBgU0VMRUNUICh0ZXN0ZnVuYy5yZXNwb25zZSkuJHtyZXR1cm5pbmdNb2RlbEF0dHJpYnV0ZXMuam9pbihcIiwgKHRlc3RmdW5jLnJlc3BvbnNlKS5cIil9LCB0ZXN0ZnVuYy5zZXF1ZWxpemVfY2F1Z2h0X2V4Y2VwdGlvbiBGUk9NIHBnX3RlbXAudGVzdGZ1bmMoKTtgO1xuICAgICAgb3B0aW9ucy5leGNlcHRpb24gPSBcIldIRU4gdW5pcXVlX3Zpb2xhdGlvbiBUSEVOIEdFVCBTVEFDS0VEIERJQUdOT1NUSUNTIHNlcXVlbGl6ZV9jYXVnaHRfZXhjZXB0aW9uID0gUEdfRVhDRVBUSU9OX0RFVEFJTDtcIjtcbiAgICAgIHZhbHVlUXVlcnkgPSBgQ1JFQVRFIE9SIFJFUExBQ0UgRlVOQ1RJT04gcGdfdGVtcC50ZXN0ZnVuYyhPVVQgcmVzcG9uc2UgJHtxdW90ZWRUYWJsZX0sIE9VVCBzZXF1ZWxpemVfY2F1Z2h0X2V4Y2VwdGlvbiB0ZXh0KSBSRVRVUk5TIFJFQ09SRCBBUyAke2RlbGltaXRlcn0gQkVHSU4gJHt2YWx1ZVF1ZXJ5fSBSRVRVUk5JTkcgKiBJTlRPIHJlc3BvbnNlOyBFWENFUFRJT04gJHtvcHRpb25zLmV4Y2VwdGlvbn0gRU5EICR7ZGVsaW1pdGVyfSBMQU5HVUFHRSBwbHBnc3FsOyAke3NlbGVjdFF1ZXJ5fSAke2Ryb3BGdW5jdGlvbn1gO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZVF1ZXJ5ICs9IHJldHVybmluZ0ZyYWdtZW50O1xuICAgICAgZW1wdHlRdWVyeSArPSByZXR1cm5pbmdGcmFnbWVudDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMucmV0dXJuSW50b1ZhbHVlcyAmJiBvcHRpb25zLnJldHVybmluZykge1xuICAgICAgdGhpcy5wb3B1bGF0ZUluc2VydFF1ZXJ5UmV0dXJuSW50b0JpbmRzKHJldHVybmluZ01vZGVsQXR0cmlidXRlcywgcmV0dXJuVHlwZXMsIGJpbmQubGVuZ3RoLCByZXR1cm5BdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcXVlcnkgPSBgJHtyZXBsYWNlbWVudHMuYXR0cmlidXRlcy5sZW5ndGggPyB2YWx1ZVF1ZXJ5IDogZW1wdHlRdWVyeX0ke3JldHVybkF0dHJpYnV0ZXMuam9pbihcIixcIil9O2A7XG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuZmluYWxUYWJsZSkge1xuICAgICAgcXVlcnkgPSBgU0VMRUNUICogRlJPTSBGSU5BTCBUQUJMRSgke3JlcGxhY2VtZW50cy5hdHRyaWJ1dGVzLmxlbmd0aCA/IHZhbHVlUXVlcnkgOiBlbXB0eVF1ZXJ5fSk7YDtcbiAgICB9XG4gICAgaWYgKGlkZW50aXR5V3JhcHBlclJlcXVpcmVkICYmIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuYXV0b0luY3JlbWVudC5pZGVudGl0eUluc2VydCkge1xuICAgICAgcXVlcnkgPSBgU0VUIElERU5USVRZX0lOU0VSVCAke3F1b3RlZFRhYmxlfSBPTjsgJHtxdWVyeX0gU0VUIElERU5USVRZX0lOU0VSVCAke3F1b3RlZFRhYmxlfSBPRkY7YDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0geyBxdWVyeSB9O1xuICAgIGlmIChvcHRpb25zLmJpbmRQYXJhbSAhPT0gZmFsc2UpIHtcbiAgICAgIHJlc3VsdC5iaW5kID0gYmluZDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBidWxrSW5zZXJ0UXVlcnkodGFibGVOYW1lLCBmaWVsZFZhbHVlSGFzaGVzLCBvcHRpb25zLCBmaWVsZE1hcHBlZEF0dHJpYnV0ZXMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBmaWVsZE1hcHBlZEF0dHJpYnV0ZXMgPSBmaWVsZE1hcHBlZEF0dHJpYnV0ZXMgfHwge307XG4gICAgY29uc3QgdHVwbGVzID0gW107XG4gICAgY29uc3Qgc2VyaWFscyA9IHt9O1xuICAgIGNvbnN0IGFsbEF0dHJpYnV0ZXMgPSBbXTtcbiAgICBsZXQgb25EdXBsaWNhdGVLZXlVcGRhdGUgPSBcIlwiO1xuICAgIGZvciAoY29uc3QgZmllbGRWYWx1ZUhhc2ggb2YgZmllbGRWYWx1ZUhhc2hlcykge1xuICAgICAgXy5mb3JPd24oZmllbGRWYWx1ZUhhc2gsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGlmICghYWxsQXR0cmlidXRlcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgYWxsQXR0cmlidXRlcy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkTWFwcGVkQXR0cmlidXRlc1trZXldICYmIGZpZWxkTWFwcGVkQXR0cmlidXRlc1trZXldLmF1dG9JbmNyZW1lbnQgPT09IHRydWUpIHtcbiAgICAgICAgICBzZXJpYWxzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBmaWVsZFZhbHVlSGFzaCBvZiBmaWVsZFZhbHVlSGFzaGVzKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBhbGxBdHRyaWJ1dGVzLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmJ1bGtEZWZhdWx0ICYmIHNlcmlhbHNba2V5XSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlSGFzaFtrZXldICE9IG51bGwgPyBmaWVsZFZhbHVlSGFzaFtrZXldIDogXCJERUZBVUxUXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXNjYXBlKGZpZWxkVmFsdWVIYXNoW2tleV0sIGZpZWxkTWFwcGVkQXR0cmlidXRlc1trZXldLCB7IGNvbnRleHQ6IFwiSU5TRVJUXCIgfSk7XG4gICAgICB9KTtcbiAgICAgIHR1cGxlcy5wdXNoKGAoJHt2YWx1ZXMuam9pbihcIixcIil9KWApO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLnVwZGF0ZU9uRHVwbGljYXRlICYmIG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUpIHtcbiAgICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMudXBkYXRlT25EdXBsaWNhdGUgPT0gXCIgT04gQ09ORkxJQ1QgRE8gVVBEQVRFIFNFVFwiKSB7XG4gICAgICAgIGNvbnN0IGNvbmZsaWN0S2V5cyA9IG9wdGlvbnMudXBzZXJ0S2V5cy5tYXAoKGF0dHIpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpKTtcbiAgICAgICAgY29uc3QgdXBkYXRlS2V5cyA9IG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUubWFwKChhdHRyKSA9PiBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX09RVhDTFVERUQuJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX1gKTtcbiAgICAgICAgbGV0IHdoZXJlQ2xhdXNlID0gZmFsc2U7XG4gICAgICAgIGlmIChvcHRpb25zLmNvbmZsaWN0V2hlcmUpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy5vbkNvbmZsaWN0V2hlcmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29uZmxpY3RXaGVyZSBub3Qgc3VwcG9ydGVkIGZvciBkaWFsZWN0ICR7dGhpcy5fZGlhbGVjdC5uYW1lfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGVyZUNsYXVzZSA9IHRoaXMud2hlcmVRdWVyeShvcHRpb25zLmNvbmZsaWN0V2hlcmUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIG9uRHVwbGljYXRlS2V5VXBkYXRlID0gW1xuICAgICAgICAgIFwiT04gQ09ORkxJQ1RcIixcbiAgICAgICAgICBcIihcIixcbiAgICAgICAgICBjb25mbGljdEtleXMuam9pbihcIixcIiksXG4gICAgICAgICAgXCIpXCIsXG4gICAgICAgICAgd2hlcmVDbGF1c2UsXG4gICAgICAgICAgXCJETyBVUERBVEUgU0VUXCIsXG4gICAgICAgICAgdXBkYXRlS2V5cy5qb2luKFwiLFwiKVxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29uZmxpY3RXaGVyZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29uZmxpY3RXaGVyZSBub3Qgc3VwcG9ydGVkIGZvciBkaWFsZWN0ICR7dGhpcy5fZGlhbGVjdC5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlS2V5cyA9IG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUubWFwKChhdHRyKSA9PiBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX09VkFMVUVTKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9KWApO1xuICAgICAgICBvbkR1cGxpY2F0ZUtleVVwZGF0ZSA9IGAke3RoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy51cGRhdGVPbkR1cGxpY2F0ZX0gJHt2YWx1ZUtleXMuam9pbihcIixcIil9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaWdub3JlRHVwbGljYXRlcyA9IG9wdGlvbnMuaWdub3JlRHVwbGljYXRlcyA/IHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy5pZ25vcmVEdXBsaWNhdGVzIDogXCJcIjtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gYWxsQXR0cmlidXRlcy5tYXAoKGF0dHIpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpKS5qb2luKFwiLFwiKTtcbiAgICBjb25zdCBvbkNvbmZsaWN0RG9Ob3RoaW5nID0gb3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVzID8gdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLm9uQ29uZmxpY3REb05vdGhpbmcgOiBcIlwiO1xuICAgIGxldCByZXR1cm5pbmcgPSBcIlwiO1xuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnJldHVyblZhbHVlcyAmJiBvcHRpb25zLnJldHVybmluZykge1xuICAgICAgY29uc3QgcmV0dXJuVmFsdWVzID0gdGhpcy5nZW5lcmF0ZVJldHVyblZhbHVlcyhmaWVsZE1hcHBlZEF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuaW5nICs9IHJldHVyblZhbHVlcy5yZXR1cm5pbmdGcmFnbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJJTlNFUlRcIixcbiAgICAgIGlnbm9yZUR1cGxpY2F0ZXMsXG4gICAgICBcIklOVE9cIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgYCgke2F0dHJpYnV0ZXN9KWAsXG4gICAgICBcIlZBTFVFU1wiLFxuICAgICAgdHVwbGVzLmpvaW4oXCIsXCIpLFxuICAgICAgb25EdXBsaWNhdGVLZXlVcGRhdGUsXG4gICAgICBvbkNvbmZsaWN0RG9Ob3RoaW5nLFxuICAgICAgcmV0dXJuaW5nLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICB1cGRhdGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJWYWx1ZUhhc2gsIHdoZXJlLCBvcHRpb25zLCBhdHRyaWJ1dGVzKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgXy5kZWZhdWx0cyhvcHRpb25zLCB0aGlzLm9wdGlvbnMpO1xuICAgIGF0dHJWYWx1ZUhhc2ggPSBVdGlscy5yZW1vdmVOdWxsVmFsdWVzRnJvbUhhc2goYXR0clZhbHVlSGFzaCwgb3B0aW9ucy5vbWl0TnVsbCwgb3B0aW9ucyk7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgY29uc3QgYmluZCA9IFtdO1xuICAgIGNvbnN0IG1vZGVsQXR0cmlidXRlTWFwID0ge307XG4gICAgbGV0IG91dHB1dEZyYWdtZW50ID0gXCJcIjtcbiAgICBsZXQgdG1wVGFibGUgPSBcIlwiO1xuICAgIGxldCBzdWZmaXggPSBcIlwiO1xuICAgIGlmIChfLmdldCh0aGlzLCBbXCJzZXF1ZWxpemVcIiwgXCJvcHRpb25zXCIsIFwiZGlhbGVjdE9wdGlvbnNcIiwgXCJwcmVwZW5kU2VhcmNoUGF0aFwiXSkgfHwgb3B0aW9ucy5zZWFyY2hQYXRoKSB7XG4gICAgICBvcHRpb25zLmJpbmRQYXJhbSA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBiaW5kUGFyYW0gPSBvcHRpb25zLmJpbmRQYXJhbSA9PT0gdm9pZCAwID8gdGhpcy5iaW5kUGFyYW0oYmluZCkgOiBvcHRpb25zLmJpbmRQYXJhbTtcbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0c1tcIkxJTUlUIE9OIFVQREFURVwiXSAmJiBvcHRpb25zLmxpbWl0KSB7XG4gICAgICBpZiAoIVtcIm1zc3FsXCIsIFwiZGIyXCIsIFwib3JhY2xlXCJdLmluY2x1ZGVzKHRoaXMuZGlhbGVjdCkpIHtcbiAgICAgICAgc3VmZml4ID0gYCBMSU1JVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpfSBgO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmRpYWxlY3QgPT09IFwib3JhY2xlXCIpIHtcbiAgICAgICAgaWYgKHdoZXJlICYmICh3aGVyZS5sZW5ndGggJiYgd2hlcmUubGVuZ3RoID4gMCB8fCBPYmplY3Qua2V5cyh3aGVyZSkubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICBzdWZmaXggKz0gXCIgQU5EIFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1ZmZpeCArPSBcIiBXSEVSRSBcIjtcbiAgICAgICAgfVxuICAgICAgICBzdWZmaXggKz0gYHJvd251bSA8PSAke3RoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpfSBgO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5yZXR1cm5WYWx1ZXMgJiYgb3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgIGNvbnN0IHJldHVyblZhbHVlcyA9IHRoaXMuZ2VuZXJhdGVSZXR1cm5WYWx1ZXMoYXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgICBzdWZmaXggKz0gcmV0dXJuVmFsdWVzLnJldHVybmluZ0ZyYWdtZW50O1xuICAgICAgdG1wVGFibGUgPSByZXR1cm5WYWx1ZXMudG1wVGFibGUgfHwgXCJcIjtcbiAgICAgIG91dHB1dEZyYWdtZW50ID0gcmV0dXJuVmFsdWVzLm91dHB1dEZyYWdtZW50IHx8IFwiXCI7XG4gICAgICBpZiAoIXRoaXMuX2RpYWxlY3Quc3VwcG9ydHMucmV0dXJuVmFsdWVzLm91dHB1dCAmJiBvcHRpb25zLnJldHVybmluZykge1xuICAgICAgICBvcHRpb25zLm1hcFRvTW9kZWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgXy5lYWNoKGF0dHJpYnV0ZXMsIChhdHRyaWJ1dGUsIGtleSkgPT4ge1xuICAgICAgICBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldID0gYXR0cmlidXRlO1xuICAgICAgICBpZiAoYXR0cmlidXRlLmZpZWxkKSB7XG4gICAgICAgICAgbW9kZWxBdHRyaWJ1dGVNYXBbYXR0cmlidXRlLmZpZWxkXSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJWYWx1ZUhhc2gpIHtcbiAgICAgIGlmIChtb2RlbEF0dHJpYnV0ZU1hcCAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0uYXV0b0luY3JlbWVudCA9PT0gdHJ1ZSAmJiAhdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5hdXRvSW5jcmVtZW50LnVwZGF0ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gYXR0clZhbHVlSGFzaFtrZXldO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kIHx8IG9wdGlvbnMuYmluZFBhcmFtID09PSBmYWxzZSkge1xuICAgICAgICB2YWx1ZXMucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpfT0ke3RoaXMuZXNjYXBlKHZhbHVlLCBtb2RlbEF0dHJpYnV0ZU1hcCAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldIHx8IHZvaWQgMCwgeyBjb250ZXh0OiBcIlVQREFURVwiIH0pfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KX09JHt0aGlzLmZvcm1hdCh2YWx1ZSwgbW9kZWxBdHRyaWJ1dGVNYXAgJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSB8fCB2b2lkIDAsIHsgY29udGV4dDogXCJVUERBVEVcIiB9LCBiaW5kUGFyYW0pfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB3aGVyZU9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyBiaW5kUGFyYW0gfSk7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdCBxdWVyeSA9IGAke3RtcFRhYmxlfVVQREFURSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSBTRVQgJHt2YWx1ZXMuam9pbihcIixcIil9JHtvdXRwdXRGcmFnbWVudH0gJHt0aGlzLndoZXJlUXVlcnkod2hlcmUsIHdoZXJlT3B0aW9ucyl9JHtzdWZmaXh9YC50cmltKCk7XG4gICAgY29uc3QgcmVzdWx0ID0geyBxdWVyeSB9O1xuICAgIGlmIChvcHRpb25zLmJpbmRQYXJhbSAhPT0gZmFsc2UpIHtcbiAgICAgIHJlc3VsdC5iaW5kID0gYmluZDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhcml0aG1ldGljUXVlcnkob3BlcmF0b3IsIHRhYmxlTmFtZSwgd2hlcmUsIGluY3JlbWVudEFtb3VudHNCeUZpZWxkLCBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIF8uZGVmYXVsdHMob3B0aW9ucywgeyByZXR1cm5pbmc6IHRydWUgfSk7XG4gICAgZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQgPSBVdGlscy5yZW1vdmVOdWxsVmFsdWVzRnJvbUhhc2goZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQsIHRoaXMub3B0aW9ucy5vbWl0TnVsbCk7XG4gICAgbGV0IG91dHB1dEZyYWdtZW50ID0gXCJcIjtcbiAgICBsZXQgcmV0dXJuaW5nRnJhZ21lbnQgPSBcIlwiO1xuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnJldHVyblZhbHVlcyAmJiBvcHRpb25zLnJldHVybmluZykge1xuICAgICAgY29uc3QgcmV0dXJuVmFsdWVzID0gdGhpcy5nZW5lcmF0ZVJldHVyblZhbHVlcyhudWxsLCBvcHRpb25zKTtcbiAgICAgIG91dHB1dEZyYWdtZW50ID0gcmV0dXJuVmFsdWVzLm91dHB1dEZyYWdtZW50O1xuICAgICAgcmV0dXJuaW5nRnJhZ21lbnQgPSByZXR1cm5WYWx1ZXMucmV0dXJuaW5nRnJhZ21lbnQ7XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZVNldFNxbEZyYWdtZW50cyA9IFtdO1xuICAgIGZvciAoY29uc3QgZmllbGQgaW4gaW5jcmVtZW50QW1vdW50c0J5RmllbGQpIHtcbiAgICAgIGNvbnN0IGluY3JlbWVudEFtb3VudCA9IGluY3JlbWVudEFtb3VudHNCeUZpZWxkW2ZpZWxkXTtcbiAgICAgIGNvbnN0IHF1b3RlZEZpZWxkID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQpO1xuICAgICAgY29uc3QgZXNjYXBlZEFtb3VudCA9IHRoaXMuZXNjYXBlKGluY3JlbWVudEFtb3VudCk7XG4gICAgICB1cGRhdGVTZXRTcWxGcmFnbWVudHMucHVzaChgJHtxdW90ZWRGaWVsZH09JHtxdW90ZWRGaWVsZH0ke29wZXJhdG9yfSAke2VzY2FwZWRBbW91bnR9YCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmllbGQgaW4gZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQpIHtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWRbZmllbGRdO1xuICAgICAgY29uc3QgcXVvdGVkRmllbGQgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZCk7XG4gICAgICBjb25zdCBlc2NhcGVkVmFsdWUgPSB0aGlzLmVzY2FwZShuZXdWYWx1ZSk7XG4gICAgICB1cGRhdGVTZXRTcWxGcmFnbWVudHMucHVzaChgJHtxdW90ZWRGaWVsZH09JHtlc2NhcGVkVmFsdWV9YCk7XG4gICAgfVxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiVVBEQVRFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIFwiU0VUXCIsXG4gICAgICB1cGRhdGVTZXRTcWxGcmFnbWVudHMuam9pbihcIixcIiksXG4gICAgICBvdXRwdXRGcmFnbWVudCxcbiAgICAgIHRoaXMud2hlcmVRdWVyeSh3aGVyZSksXG4gICAgICByZXR1cm5pbmdGcmFnbWVudFxuICAgIF0pO1xuICB9XG4gIGFkZEluZGV4UXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zLCByYXdUYWJsZW5hbWUpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXR0cmlidXRlcykpIHtcbiAgICAgIG9wdGlvbnMgPSBhdHRyaWJ1dGVzO1xuICAgICAgYXR0cmlidXRlcyA9IHZvaWQgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5maWVsZHMgPSBhdHRyaWJ1dGVzO1xuICAgIH1cbiAgICBvcHRpb25zLnByZWZpeCA9IG9wdGlvbnMucHJlZml4IHx8IHJhd1RhYmxlbmFtZSB8fCB0YWJsZU5hbWU7XG4gICAgaWYgKG9wdGlvbnMucHJlZml4ICYmIHR5cGVvZiBvcHRpb25zLnByZWZpeCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgb3B0aW9ucy5wcmVmaXggPSBvcHRpb25zLnByZWZpeC5yZXBsYWNlKC9cXC4vZywgXCJfXCIpO1xuICAgICAgb3B0aW9ucy5wcmVmaXggPSBvcHRpb25zLnByZWZpeC5yZXBsYWNlKC8oXCJ8JykvZywgXCJcIik7XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkc1NxbCA9IG9wdGlvbnMuZmllbGRzLm1hcCgoZmllbGQpID0+IHtcbiAgICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2QoZmllbGQpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBmaWVsZCA9IHtcbiAgICAgICAgICBuYW1lOiBmaWVsZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICBpZiAoZmllbGQuYXR0cmlidXRlKSB7XG4gICAgICAgIGZpZWxkLm5hbWUgPSBmaWVsZC5hdHRyaWJ1dGU7XG4gICAgICB9XG4gICAgICBpZiAoIWZpZWxkLm5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZm9sbG93aW5nIGluZGV4IGZpZWxkIGhhcyBubyBuYW1lOiAke3V0aWwuaW5zcGVjdChmaWVsZCl9YCk7XG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQubmFtZSk7XG4gICAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleC5jb2xsYXRlICYmIGZpZWxkLmNvbGxhdGUpIHtcbiAgICAgICAgcmVzdWx0ICs9IGAgQ09MTEFURSAke3RoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkLmNvbGxhdGUpfWA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleC5vcGVyYXRvcikge1xuICAgICAgICBjb25zdCBvcGVyYXRvciA9IGZpZWxkLm9wZXJhdG9yIHx8IG9wdGlvbnMub3BlcmF0b3I7XG4gICAgICAgIGlmIChvcGVyYXRvcikge1xuICAgICAgICAgIHJlc3VsdCArPSBgICR7b3BlcmF0b3J9YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXgubGVuZ3RoICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgKz0gYCgke2ZpZWxkLmxlbmd0aH0pYDtcbiAgICAgIH1cbiAgICAgIGlmIChmaWVsZC5vcmRlcikge1xuICAgICAgICByZXN1bHQgKz0gYCAke2ZpZWxkLm9yZGVyfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICBvcHRpb25zID0gVXRpbHMubmFtZUluZGV4KG9wdGlvbnMsIG9wdGlvbnMucHJlZml4KTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IE1vZGVsLl9jb25mb3JtSW5kZXgob3B0aW9ucyk7XG4gICAgaWYgKCF0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4LnR5cGUpIHtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLnR5cGU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLndoZXJlKSB7XG4gICAgICBvcHRpb25zLndoZXJlID0gdGhpcy53aGVyZVF1ZXJ5KG9wdGlvbnMud2hlcmUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGFibGVOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXJzKHRhYmxlTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBjb25jdXJyZW50bHkgPSB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4LmNvbmN1cnJlbnRseSAmJiBvcHRpb25zLmNvbmN1cnJlbnRseSA/IFwiQ09OQ1VSUkVOVExZXCIgOiB2b2lkIDA7XG4gICAgbGV0IGluZDtcbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleFZpYUFsdGVyKSB7XG4gICAgICBpbmQgPSBbXG4gICAgICAgIFwiQUxURVIgVEFCTEVcIixcbiAgICAgICAgdGFibGVOYW1lLFxuICAgICAgICBjb25jdXJyZW50bHksXG4gICAgICAgIFwiQUREXCJcbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZCA9IFtcIkNSRUFURVwiXTtcbiAgICB9XG4gICAgaW5kID0gaW5kLmNvbmNhdChvcHRpb25zLnVuaXF1ZSA/IFwiVU5JUVVFXCIgOiBcIlwiLCBvcHRpb25zLnR5cGUsIFwiSU5ERVhcIiwgIXRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXhWaWFBbHRlciA/IGNvbmN1cnJlbnRseSA6IHZvaWQgMCwgdGhpcy5xdW90ZUlkZW50aWZpZXJzKG9wdGlvbnMubmFtZSksIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXgudXNpbmcgPT09IDEgJiYgb3B0aW9ucy51c2luZyA/IGBVU0lORyAke29wdGlvbnMudXNpbmd9YCA6IFwiXCIsICF0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4VmlhQWx0ZXIgPyBgT04gJHt0YWJsZU5hbWV9YCA6IHZvaWQgMCwgdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleC51c2luZyA9PT0gMiAmJiBvcHRpb25zLnVzaW5nID8gYFVTSU5HICR7b3B0aW9ucy51c2luZ31gIDogXCJcIiwgYCgke2ZpZWxkc1NxbC5qb2luKFwiLCBcIil9KWAsIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXgucGFyc2VyICYmIG9wdGlvbnMucGFyc2VyID8gYFdJVEggUEFSU0VSICR7b3B0aW9ucy5wYXJzZXJ9YCA6IHZvaWQgMCwgdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleC53aGVyZSAmJiBvcHRpb25zLndoZXJlID8gb3B0aW9ucy53aGVyZSA6IHZvaWQgMCk7XG4gICAgcmV0dXJuIF8uY29tcGFjdChpbmQpLmpvaW4oXCIgXCIpO1xuICB9XG4gIGFkZENvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGFibGVOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXJzKHRhYmxlTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICB0YWJsZU5hbWUsXG4gICAgICBcIkFERFwiLFxuICAgICAgdGhpcy5nZXRDb25zdHJhaW50U25pcHBldCh0YWJsZU5hbWUsIG9wdGlvbnMgfHwge30pLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBnZXRDb25zdHJhaW50U25pcHBldCh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBsZXQgY29uc3RyYWludFNuaXBwZXQsIGNvbnN0cmFpbnROYW1lO1xuICAgIGNvbnN0IGZpZWxkc1NxbCA9IG9wdGlvbnMuZmllbGRzLm1hcCgoZmllbGQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2QoZmllbGQpO1xuICAgICAgfVxuICAgICAgaWYgKGZpZWxkLmF0dHJpYnV0ZSkge1xuICAgICAgICBmaWVsZC5uYW1lID0gZmllbGQuYXR0cmlidXRlO1xuICAgICAgfVxuICAgICAgaWYgKCFmaWVsZC5uYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZvbGxvd2luZyBpbmRleCBmaWVsZCBoYXMgbm8gbmFtZTogJHtmaWVsZH1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZC5uYW1lKTtcbiAgICB9KTtcbiAgICBjb25zdCBmaWVsZHNTcWxRdW90ZWRTdHJpbmcgPSBmaWVsZHNTcWwuam9pbihcIiwgXCIpO1xuICAgIGNvbnN0IGZpZWxkc1NxbFN0cmluZyA9IGZpZWxkc1NxbC5qb2luKFwiX1wiKTtcbiAgICBzd2l0Y2ggKG9wdGlvbnMudHlwZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBjYXNlIFwiVU5JUVVFXCI6XG4gICAgICAgIGNvbnN0cmFpbnROYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIob3B0aW9ucy5uYW1lIHx8IGAke3RhYmxlTmFtZX1fJHtmaWVsZHNTcWxTdHJpbmd9X3VrYCk7XG4gICAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ID0gYENPTlNUUkFJTlQgJHtjb25zdHJhaW50TmFtZX0gVU5JUVVFICgke2ZpZWxkc1NxbFF1b3RlZFN0cmluZ30pYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQ0hFQ0tcIjpcbiAgICAgICAgb3B0aW9ucy53aGVyZSA9IHRoaXMud2hlcmVJdGVtc1F1ZXJ5KG9wdGlvbnMud2hlcmUpO1xuICAgICAgICBjb25zdHJhaW50TmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMubmFtZSB8fCBgJHt0YWJsZU5hbWV9XyR7ZmllbGRzU3FsU3RyaW5nfV9ja2ApO1xuICAgICAgICBjb25zdHJhaW50U25pcHBldCA9IGBDT05TVFJBSU5UICR7Y29uc3RyYWludE5hbWV9IENIRUNLICgke29wdGlvbnMud2hlcmV9KWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkRFRkFVTFRcIjpcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWZhdWx0IHZhbHVlIG11c3QgYmUgc3BlY2lmaWVkIGZvciBERUZBVUxUIENPTlNUUkFJTlRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RpYWxlY3QubmFtZSAhPT0gXCJtc3NxbFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVmYXVsdCBjb25zdHJhaW50cyBhcmUgc3VwcG9ydGVkIG9ubHkgZm9yIE1TU1FMIGRpYWxlY3QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0cmFpbnROYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIob3B0aW9ucy5uYW1lIHx8IGAke3RhYmxlTmFtZX1fJHtmaWVsZHNTcWxTdHJpbmd9X2RmYCk7XG4gICAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ID0gYENPTlNUUkFJTlQgJHtjb25zdHJhaW50TmFtZX0gREVGQVVMVCAoJHt0aGlzLmVzY2FwZShvcHRpb25zLmRlZmF1bHRWYWx1ZSl9KSBGT1IgJHtmaWVsZHNTcWxbMF19YDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiUFJJTUFSWSBLRVlcIjpcbiAgICAgICAgY29uc3RyYWludE5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLm5hbWUgfHwgYCR7dGFibGVOYW1lfV8ke2ZpZWxkc1NxbFN0cmluZ31fcGtgKTtcbiAgICAgICAgY29uc3RyYWludFNuaXBwZXQgPSBgQ09OU1RSQUlOVCAke2NvbnN0cmFpbnROYW1lfSBQUklNQVJZIEtFWSAoJHtmaWVsZHNTcWxRdW90ZWRTdHJpbmd9KWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkZPUkVJR04gS0VZXCI6XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZXMgPSBvcHRpb25zLnJlZmVyZW5jZXM7XG4gICAgICAgIGlmICghcmVmZXJlbmNlcyB8fCAhcmVmZXJlbmNlcy50YWJsZSB8fCAhKHJlZmVyZW5jZXMuZmllbGQgfHwgcmVmZXJlbmNlcy5maWVsZHMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVmZXJlbmNlcyBvYmplY3Qgd2l0aCB0YWJsZSBhbmQgZmllbGQgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RyYWludE5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLm5hbWUgfHwgYCR7dGFibGVOYW1lfV8ke2ZpZWxkc1NxbFN0cmluZ31fJHtyZWZlcmVuY2VzLnRhYmxlfV9ma2ApO1xuICAgICAgICBjb25zdCBxdW90ZWRSZWZlcmVuY2VzID0gdHlwZW9mIHJlZmVyZW5jZXMuZmllbGQgIT09IFwidW5kZWZpbmVkXCIgPyB0aGlzLnF1b3RlSWRlbnRpZmllcihyZWZlcmVuY2VzLmZpZWxkKSA6IHJlZmVyZW5jZXMuZmllbGRzLm1hcCgoZikgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoZikpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlc1NuaXBwZXQgPSBgJHt0aGlzLnF1b3RlVGFibGUocmVmZXJlbmNlcy50YWJsZSl9ICgke3F1b3RlZFJlZmVyZW5jZXN9KWA7XG4gICAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ID0gYENPTlNUUkFJTlQgJHtjb25zdHJhaW50TmFtZX0gYDtcbiAgICAgICAgY29uc3RyYWludFNuaXBwZXQgKz0gYEZPUkVJR04gS0VZICgke2ZpZWxkc1NxbFF1b3RlZFN0cmluZ30pIFJFRkVSRU5DRVMgJHtyZWZlcmVuY2VzU25pcHBldH1gO1xuICAgICAgICBpZiAob3B0aW9ucy5vblVwZGF0ZSkge1xuICAgICAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ICs9IGAgT04gVVBEQVRFICR7b3B0aW9ucy5vblVwZGF0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMub25EZWxldGUpIHtcbiAgICAgICAgICBjb25zdHJhaW50U25pcHBldCArPSBgIE9OIERFTEVURSAke29wdGlvbnMub25EZWxldGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke29wdGlvbnMudHlwZX0gaXMgaW52YWxpZC5gKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZGVmZXJyYWJsZSAmJiBbXCJVTklRVUVcIiwgXCJQUklNQVJZIEtFWVwiLCBcIkZPUkVJR04gS0VZXCJdLmluY2x1ZGVzKG9wdGlvbnMudHlwZS50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgY29uc3RyYWludFNuaXBwZXQgKz0gYCAke3RoaXMuZGVmZXJDb25zdHJhaW50c1F1ZXJ5KG9wdGlvbnMpfWA7XG4gICAgfVxuICAgIHJldHVybiBjb25zdHJhaW50U25pcHBldDtcbiAgfVxuICByZW1vdmVDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSkge1xuICAgIGlmICh0eXBlb2YgdGFibGVOYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0YWJsZU5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcnModGFibGVOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQUxURVIgVEFCTEVcIixcbiAgICAgIHRhYmxlTmFtZSxcbiAgICAgIFwiRFJPUCBDT05TVFJBSU5UXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcnMoY29uc3RyYWludE5hbWUpXG4gICAgXSk7XG4gIH1cbiAgcXVvdGUoY29sbGVjdGlvbiwgcGFyZW50LCBjb25uZWN0b3IpIHtcbiAgICBjb25zdCB2YWxpZE9yZGVyT3B0aW9ucyA9IFtcbiAgICAgIFwiQVNDXCIsXG4gICAgICBcIkRFU0NcIixcbiAgICAgIFwiQVNDIE5VTExTIExBU1RcIixcbiAgICAgIFwiREVTQyBOVUxMUyBMQVNUXCIsXG4gICAgICBcIkFTQyBOVUxMUyBGSVJTVFwiLFxuICAgICAgXCJERVNDIE5VTExTIEZJUlNUXCIsXG4gICAgICBcIk5VTExTIEZJUlNUXCIsXG4gICAgICBcIk5VTExTIExBU1RcIlxuICAgIF07XG4gICAgY29ubmVjdG9yID0gY29ubmVjdG9yIHx8IFwiLlwiO1xuICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRoaXMucXVvdGVJZGVudGlmaWVycyhjb2xsZWN0aW9uKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgIGNvbGxlY3Rpb24uZm9yRWFjaCgoaXRlbTIsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzID0gY29sbGVjdGlvbltpbmRleCAtIDFdO1xuICAgICAgICBsZXQgcHJldmlvdXNBc3NvY2lhdGlvbjtcbiAgICAgICAgbGV0IHByZXZpb3VzTW9kZWw7XG4gICAgICAgIGlmICghcHJldmlvdXMgJiYgcGFyZW50ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBwcmV2aW91c01vZGVsID0gcGFyZW50O1xuICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzICYmIHByZXZpb3VzIGluc3RhbmNlb2YgQXNzb2NpYXRpb24pIHtcbiAgICAgICAgICBwcmV2aW91c0Fzc29jaWF0aW9uID0gcHJldmlvdXM7XG4gICAgICAgICAgcHJldmlvdXNNb2RlbCA9IHByZXZpb3VzLnRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldmlvdXNNb2RlbCAmJiBwcmV2aW91c01vZGVsLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgbGV0IG1vZGVsO1xuICAgICAgICAgIGxldCBhcztcbiAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0yID09PSBcImZ1bmN0aW9uXCIgJiYgaXRlbTIucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgICAgIG1vZGVsID0gaXRlbTI7XG4gICAgICAgICAgfSBlbHNlIGlmIChfLmlzUGxhaW5PYmplY3QoaXRlbTIpICYmIGl0ZW0yLm1vZGVsICYmIGl0ZW0yLm1vZGVsLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgICBtb2RlbCA9IGl0ZW0yLm1vZGVsO1xuICAgICAgICAgICAgYXMgPSBpdGVtMi5hcztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgICAgICBpZiAoIWFzICYmIHByZXZpb3VzQXNzb2NpYXRpb24gJiYgcHJldmlvdXNBc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEFzc29jaWF0aW9uICYmIHByZXZpb3VzQXNzb2NpYXRpb24udGhyb3VnaCAmJiBwcmV2aW91c0Fzc29jaWF0aW9uLnRocm91Z2gubW9kZWwgPT09IG1vZGVsKSB7XG4gICAgICAgICAgICAgIGl0ZW0yID0gbmV3IEFzc29jaWF0aW9uKHByZXZpb3VzTW9kZWwsIG1vZGVsLCB7XG4gICAgICAgICAgICAgICAgYXM6IG1vZGVsLm5hbWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpdGVtMiA9IHByZXZpb3VzTW9kZWwuZ2V0QXNzb2NpYXRpb25Gb3JBbGlhcyhtb2RlbCwgYXMpO1xuICAgICAgICAgICAgICBpZiAoIWl0ZW0yKSB7XG4gICAgICAgICAgICAgICAgaXRlbTIgPSBwcmV2aW91c01vZGVsLmdldEFzc29jaWF0aW9uRm9yQWxpYXMobW9kZWwsIG1vZGVsLm5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShpdGVtMiBpbnN0YW5jZW9mIEFzc29jaWF0aW9uKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbC5mb3JtYXQoXCJVbmFibGUgdG8gZmluZCBhIHZhbGlkIGFzc29jaWF0aW9uIGZvciBtb2RlbCwgJyVzJ1wiLCBtb2RlbC5uYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbTIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCBvcmRlckluZGV4ID0gdmFsaWRPcmRlck9wdGlvbnMuaW5kZXhPZihpdGVtMi50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICBpZiAoaW5kZXggPiAwICYmIG9yZGVySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBpdGVtMiA9IHRoaXMuc2VxdWVsaXplLmxpdGVyYWwoYCAke3ZhbGlkT3JkZXJPcHRpb25zW29yZGVySW5kZXhdfWApO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNNb2RlbCAmJiBwcmV2aW91c01vZGVsLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNNb2RlbC5hc3NvY2lhdGlvbnMgIT09IHZvaWQgMCAmJiBwcmV2aW91c01vZGVsLmFzc29jaWF0aW9uc1tpdGVtMl0pIHtcbiAgICAgICAgICAgICAgaXRlbTIgPSBwcmV2aW91c01vZGVsLmFzc29jaWF0aW9uc1tpdGVtMl07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzTW9kZWwucmF3QXR0cmlidXRlcyAhPT0gdm9pZCAwICYmIHByZXZpb3VzTW9kZWwucmF3QXR0cmlidXRlc1tpdGVtMl0gJiYgaXRlbTIgIT09IHByZXZpb3VzTW9kZWwucmF3QXR0cmlidXRlc1tpdGVtMl0uZmllbGQpIHtcbiAgICAgICAgICAgICAgaXRlbTIgPSBwcmV2aW91c01vZGVsLnJhd0F0dHJpYnV0ZXNbaXRlbTJdLmZpZWxkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtMi5pbmNsdWRlcyhcIi5cIikgJiYgcHJldmlvdXNNb2RlbC5yYXdBdHRyaWJ1dGVzICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgY29uc3QgaXRlbVNwbGl0ID0gaXRlbTIuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICBpZiAocHJldmlvdXNNb2RlbC5yYXdBdHRyaWJ1dGVzW2l0ZW1TcGxpdFswXV0udHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5KU09OKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IHRoaXMucXVvdGVJZGVudGlmaWVycyhgJHtwcmV2aW91c01vZGVsLm5hbWV9LiR7cHJldmlvdXNNb2RlbC5yYXdBdHRyaWJ1dGVzW2l0ZW1TcGxpdFswXV0uZmllbGR9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGl0ZW1TcGxpdC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBpdGVtMiA9IHRoaXMuanNvblBhdGhFeHRyYWN0aW9uUXVlcnkoaWRlbnRpZmllciwgcGF0aCk7XG4gICAgICAgICAgICAgICAgaXRlbTIgPSB0aGlzLnNlcXVlbGl6ZS5saXRlcmFsKGl0ZW0yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb2xsZWN0aW9uW2luZGV4XSA9IGl0ZW0yO1xuICAgICAgfSwgdGhpcyk7XG4gICAgICBjb25zdCBjb2xsZWN0aW9uTGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICBjb25zdCB0YWJsZU5hbWVzID0gW107XG4gICAgICBsZXQgaXRlbTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2xsZWN0aW9uTGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBjb2xsZWN0aW9uW2ldO1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIgfHwgaXRlbS5fbW9kZWxBdHRyaWJ1dGUgfHwgaXRlbSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBBc3NvY2lhdGlvbikge1xuICAgICAgICAgIHRhYmxlTmFtZXNbaV0gPSBpdGVtLmFzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgc3FsID0gXCJcIjtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBzcWwgKz0gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIodGFibGVOYW1lcy5qb2luKGNvbm5lY3RvcikpfS5gO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29sbGVjdGlvblswXSA9PT0gXCJzdHJpbmdcIiAmJiBwYXJlbnQpIHtcbiAgICAgICAgc3FsICs9IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKHBhcmVudC5uYW1lKX0uYDtcbiAgICAgIH1cbiAgICAgIGNvbGxlY3Rpb24uc2xpY2UoaSkuZm9yRWFjaCgoY29sbGVjdGlvbkl0ZW0pID0+IHtcbiAgICAgICAgc3FsICs9IHRoaXMucXVvdGUoY29sbGVjdGlvbkl0ZW0sIHBhcmVudCwgY29ubmVjdG9yKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgcmV0dXJuIHNxbDtcbiAgICB9XG4gICAgaWYgKGNvbGxlY3Rpb24uX21vZGVsQXR0cmlidXRlKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5xdW90ZVRhYmxlKGNvbGxlY3Rpb24uTW9kZWwubmFtZSl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoY29sbGVjdGlvbi5maWVsZE5hbWUpfWA7XG4gICAgfVxuICAgIGlmIChjb2xsZWN0aW9uIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2QoY29sbGVjdGlvbik7XG4gICAgfVxuICAgIGlmIChfLmlzUGxhaW5PYmplY3QoY29sbGVjdGlvbikgJiYgY29sbGVjdGlvbi5yYXcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGB7cmF3OiBcIi4uLlwifWAgc3ludGF4IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuICBVc2UgYHNlcXVlbGl6ZS5saXRlcmFsYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3RydWN0dXJlIHBhc3NlZCB0byBvcmRlciAvIGdyb3VwOiAke3V0aWwuaW5zcGVjdChjb2xsZWN0aW9uKX1gKTtcbiAgfVxuICBfaW5pdFF1b3RlSWRlbnRpZmllcigpIHtcbiAgICB0aGlzLl9xdW90ZUlkZW50aWZpZXIgPSB0aGlzLnF1b3RlSWRlbnRpZmllcjtcbiAgICB0aGlzLnF1b3RlSWRlbnRpZmllciA9IGZ1bmN0aW9uKGlkZW50aWZpZXIsIGZvcmNlKSB7XG4gICAgICBpZiAoaWRlbnRpZmllciA9PT0gXCIqXCIpXG4gICAgICAgIHJldHVybiBpZGVudGlmaWVyO1xuICAgICAgcmV0dXJuIHRoaXMuX3F1b3RlSWRlbnRpZmllcihpZGVudGlmaWVyLCBmb3JjZSk7XG4gICAgfTtcbiAgfVxuICBxdW90ZUlkZW50aWZpZXIoaWRlbnRpZmllciwgZm9yY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHF1b3RlSWRlbnRpZmllciBmb3IgRGlhbGVjdCBcIiR7dGhpcy5kaWFsZWN0fVwiIGlzIG5vdCBpbXBsZW1lbnRlZGApO1xuICB9XG4gIHF1b3RlSWRlbnRpZmllcnMoaWRlbnRpZmllcnMpIHtcbiAgICBpZiAoaWRlbnRpZmllcnMuaW5jbHVkZXMoXCIuXCIpKSB7XG4gICAgICBpZGVudGlmaWVycyA9IGlkZW50aWZpZXJzLnNwbGl0KFwiLlwiKTtcbiAgICAgIGNvbnN0IGhlYWQgPSBpZGVudGlmaWVycy5zbGljZSgwLCBpZGVudGlmaWVycy5sZW5ndGggLSAxKS5qb2luKFwiLT5cIik7XG4gICAgICBjb25zdCB0YWlsID0gaWRlbnRpZmllcnNbaWRlbnRpZmllcnMubGVuZ3RoIC0gMV07XG4gICAgICByZXR1cm4gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaGVhZCl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIodGFpbCl9YDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucXVvdGVJZGVudGlmaWVyKGlkZW50aWZpZXJzKTtcbiAgfVxuICBxdW90ZUF0dHJpYnV0ZShhdHRyaWJ1dGUsIG1vZGVsKSB7XG4gICAgaWYgKG1vZGVsICYmIGF0dHJpYnV0ZSBpbiBtb2RlbC5yYXdBdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucXVvdGVJZGVudGlmaWVycyhhdHRyaWJ1dGUpO1xuICB9XG4gIGdldEFsaWFzVG9rZW4oKSB7XG4gICAgcmV0dXJuIFwiQVNcIjtcbiAgfVxuICBxdW90ZVRhYmxlKHBhcmFtLCBhbGlhcykge1xuICAgIGxldCB0YWJsZSA9IFwiXCI7XG4gICAgaWYgKGFsaWFzID09PSB0cnVlKSB7XG4gICAgICBhbGlhcyA9IHBhcmFtLmFzIHx8IHBhcmFtLm5hbWUgfHwgcGFyYW07XG4gICAgfVxuICAgIGlmIChfLmlzT2JqZWN0KHBhcmFtKSkge1xuICAgICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuc2NoZW1hcykge1xuICAgICAgICBpZiAocGFyYW0uc2NoZW1hKSB7XG4gICAgICAgICAgdGFibGUgKz0gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIocGFyYW0uc2NoZW1hKX0uYDtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZSArPSB0aGlzLnF1b3RlSWRlbnRpZmllcihwYXJhbS50YWJsZU5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhcmFtLnNjaGVtYSkge1xuICAgICAgICAgIHRhYmxlICs9IHBhcmFtLnNjaGVtYSArIChwYXJhbS5kZWxpbWl0ZXIgfHwgXCIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlICs9IHBhcmFtLnRhYmxlTmFtZTtcbiAgICAgICAgdGFibGUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcih0YWJsZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhYmxlID0gdGhpcy5xdW90ZUlkZW50aWZpZXIocGFyYW0pO1xuICAgIH1cbiAgICBpZiAoYWxpYXMpIHtcbiAgICAgIHRhYmxlICs9IGAgJHt0aGlzLmdldEFsaWFzVG9rZW4oKX0gJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhbGlhcyl9YDtcbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlO1xuICB9XG4gIGVzY2FwZSh2YWx1ZSwgZmllbGQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoZmllbGQgJiYgZmllbGQudHlwZSkge1xuICAgICAgICBpZiAoZmllbGQudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5TVFJJTkcgJiYgW1wibXlzcWxcIiwgXCJtYXJpYWRiXCJdLmluY2x1ZGVzKHRoaXMuZGlhbGVjdCkgJiYgW1wibnVtYmVyXCIsIFwiYm9vbGVhblwiXS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSBTdHJpbmcoTnVtYmVyKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWx1ZSwgZmllbGQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoZmllbGQudHlwZS5zdHJpbmdpZnkpIHtcbiAgICAgICAgICBjb25zdCBzaW1wbGVFc2NhcGUgPSAoZXNjVmFsKSA9PiBTcWxTdHJpbmcuZXNjYXBlKGVzY1ZhbCwgdGhpcy5vcHRpb25zLnRpbWV6b25lLCB0aGlzLmRpYWxlY3QpO1xuICAgICAgICAgIHZhbHVlID0gZmllbGQudHlwZS5zdHJpbmdpZnkodmFsdWUsIHsgZXNjYXBlOiBzaW1wbGVFc2NhcGUsIGZpZWxkLCB0aW1lem9uZTogdGhpcy5vcHRpb25zLnRpbWV6b25lLCBvcGVyYXRpb246IG9wdGlvbnMub3BlcmF0aW9uIH0pO1xuICAgICAgICAgIGlmIChmaWVsZC50eXBlLmVzY2FwZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFNxbFN0cmluZy5lc2NhcGUodmFsdWUsIHRoaXMub3B0aW9ucy50aW1lem9uZSwgdGhpcy5kaWFsZWN0KTtcbiAgfVxuICBiaW5kUGFyYW0oYmluZCkge1xuICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgIGJpbmQucHVzaCh2YWx1ZSk7XG4gICAgICByZXR1cm4gYCQke2JpbmQubGVuZ3RofWA7XG4gICAgfTtcbiAgfVxuICBmb3JtYXQodmFsdWUsIGZpZWxkLCBvcHRpb25zLCBiaW5kUGFyYW0pIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwYXNzIFNlcXVlbGl6ZU1ldGhvZCBhcyBhIGJpbmQgcGFyYW1ldGVyIC0gdXNlIGVzY2FwZSBpbnN0ZWFkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLnR5cGUpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWx1ZSwgZmllbGQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoZmllbGQudHlwZS5iaW5kUGFyYW0pIHtcbiAgICAgICAgICByZXR1cm4gZmllbGQudHlwZS5iaW5kUGFyYW0odmFsdWUsIHsgZXNjYXBlOiBfLmlkZW50aXR5LCBmaWVsZCwgdGltZXpvbmU6IHRoaXMub3B0aW9ucy50aW1lem9uZSwgb3BlcmF0aW9uOiBvcHRpb25zLm9wZXJhdGlvbiwgYmluZFBhcmFtIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiaW5kUGFyYW0odmFsdWUpO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlLCBmaWVsZCwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzLnR5cGVWYWxpZGF0aW9uICYmIGZpZWxkLnR5cGUudmFsaWRhdGUgJiYgdmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChvcHRpb25zLmlzTGlzdCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgZmllbGQudHlwZS52YWxpZGF0ZShpdGVtLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmllbGQudHlwZS52YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHNlcXVlbGl6ZUVycm9yLlZhbGlkYXRpb25FcnJvcikge1xuICAgICAgICAgIGVycm9yLmVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtKGVycm9yLm1lc3NhZ2UsIFwiVmFsaWRhdGlvbiBlcnJvclwiLCBmaWVsZC5maWVsZE5hbWUsIHZhbHVlLCBudWxsLCBgJHtmaWVsZC50eXBlLmtleX0gdmFsaWRhdG9yYCkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpc0lkZW50aWZpZXJRdW90ZWQoaWRlbnRpZmllcikge1xuICAgIHJldHVybiAvXlxccyooPzooW2BcIiddKSg/Oig/IVxcMSkufFxcMXsyfSkqXFwxXFwuPykrXFxzKiQvaS50ZXN0KGlkZW50aWZpZXIpO1xuICB9XG4gIGpzb25QYXRoRXh0cmFjdGlvblF1ZXJ5KGNvbHVtbiwgcGF0aCwgaXNKc29uKSB7XG4gICAgbGV0IHBhdGhzID0gXy50b1BhdGgocGF0aCk7XG4gICAgbGV0IHBhdGhTdHI7XG4gICAgY29uc3QgcXVvdGVkQ29sdW1uID0gdGhpcy5pc0lkZW50aWZpZXJRdW90ZWQoY29sdW1uKSA/IGNvbHVtbiA6IHRoaXMucXVvdGVJZGVudGlmaWVyKGNvbHVtbik7XG4gICAgc3dpdGNoICh0aGlzLmRpYWxlY3QpIHtcbiAgICAgIGNhc2UgXCJteXNxbFwiOlxuICAgICAgY2FzZSBcIm1hcmlhZGJcIjpcbiAgICAgIGNhc2UgXCJzcWxpdGVcIjpcbiAgICAgICAgaWYgKHRoaXMuZGlhbGVjdCA9PT0gXCJteXNxbFwiKSB7XG4gICAgICAgICAgcGF0aHMgPSBwYXRocy5tYXAoKHN1YlBhdGgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAvXFxELy50ZXN0KHN1YlBhdGgpID8gVXRpbHMuYWRkVGlja3Moc3ViUGF0aCwgJ1wiJykgOiBzdWJQYXRoO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHBhdGhTdHIgPSB0aGlzLmVzY2FwZShbXCIkXCJdLmNvbmNhdChwYXRocykuam9pbihcIi5cIikucmVwbGFjZSgvXFwuKFxcZCspKD86KD89XFwuKXwkKS9nLCAoX18sIGRpZ2l0KSA9PiBgWyR7ZGlnaXR9XWApKTtcbiAgICAgICAgaWYgKHRoaXMuZGlhbGVjdCA9PT0gXCJzcWxpdGVcIikge1xuICAgICAgICAgIHJldHVybiBganNvbl9leHRyYWN0KCR7cXVvdGVkQ29sdW1ufSwke3BhdGhTdHJ9KWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBqc29uX3VucXVvdGUoanNvbl9leHRyYWN0KCR7cXVvdGVkQ29sdW1ufSwke3BhdGhTdHJ9KSlgO1xuICAgICAgY2FzZSBcInBvc3RncmVzXCI6XG4gICAgICAgIGNvbnN0IGpvaW4gPSBpc0pzb24gPyBcIiM+XCIgOiBcIiM+PlwiO1xuICAgICAgICBwYXRoU3RyID0gdGhpcy5lc2NhcGUoYHske3BhdGhzLmpvaW4oXCIsXCIpfX1gKTtcbiAgICAgICAgcmV0dXJuIGAoJHtxdW90ZWRDb2x1bW59JHtqb2lufSR7cGF0aFN0cn0pYDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgJHt0aGlzLmRpYWxlY3R9IGZvciBKU09OIG9wZXJhdGlvbnNgKTtcbiAgICB9XG4gIH1cbiAgc2VsZWN0UXVlcnkodGFibGVOYW1lLCBvcHRpb25zLCBtb2RlbCkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGxpbWl0ID0gb3B0aW9ucy5saW1pdDtcbiAgICBjb25zdCBtYWluUXVlcnlJdGVtcyA9IFtdO1xuICAgIGNvbnN0IHN1YlF1ZXJ5SXRlbXMgPSBbXTtcbiAgICBjb25zdCBzdWJRdWVyeSA9IG9wdGlvbnMuc3ViUXVlcnkgPT09IHZvaWQgMCA/IGxpbWl0ICYmIG9wdGlvbnMuaGFzTXVsdGlBc3NvY2lhdGlvbiA6IG9wdGlvbnMuc3ViUXVlcnk7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAgIG1haW46IG9wdGlvbnMuYXR0cmlidXRlcyAmJiBvcHRpb25zLmF0dHJpYnV0ZXMuc2xpY2UoKSxcbiAgICAgIHN1YlF1ZXJ5OiBudWxsXG4gICAgfTtcbiAgICBjb25zdCBtYWluVGFibGUgPSB7XG4gICAgICBuYW1lOiB0YWJsZU5hbWUsXG4gICAgICBxdW90ZWROYW1lOiBudWxsLFxuICAgICAgYXM6IG51bGwsXG4gICAgICBtb2RlbFxuICAgIH07XG4gICAgY29uc3QgdG9wTGV2ZWxJbmZvID0ge1xuICAgICAgbmFtZXM6IG1haW5UYWJsZSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBzdWJRdWVyeVxuICAgIH07XG4gICAgbGV0IG1haW5Kb2luUXVlcmllcyA9IFtdO1xuICAgIGxldCBzdWJKb2luUXVlcmllcyA9IFtdO1xuICAgIGxldCBxdWVyeTtcbiAgICBpZiAodGhpcy5vcHRpb25zLm1pbmlmeUFsaWFzZXMgJiYgIW9wdGlvbnMuYWxpYXNlc01hcHBpbmcpIHtcbiAgICAgIG9wdGlvbnMuYWxpYXNlc01hcHBpbmcgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgb3B0aW9ucy5hbGlhc2VzQnlUYWJsZSA9IHt9O1xuICAgICAgb3B0aW9ucy5pbmNsdWRlQWxpYXNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRhYmxlQXMpIHtcbiAgICAgIG1haW5UYWJsZS5hcyA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMudGFibGVBcyk7XG4gICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtYWluVGFibGUubmFtZSkgJiYgbWFpblRhYmxlLm1vZGVsKSB7XG4gICAgICBtYWluVGFibGUuYXMgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihtYWluVGFibGUubW9kZWwubmFtZSk7XG4gICAgfVxuICAgIG1haW5UYWJsZS5xdW90ZWROYW1lID0gIUFycmF5LmlzQXJyYXkobWFpblRhYmxlLm5hbWUpID8gdGhpcy5xdW90ZVRhYmxlKG1haW5UYWJsZS5uYW1lKSA6IHRhYmxlTmFtZS5tYXAoKHQpID0+IHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHQpID8gdGhpcy5xdW90ZVRhYmxlKHRbMF0sIHRbMV0pIDogdGhpcy5xdW90ZVRhYmxlKHQsIHRydWUpO1xuICAgIH0pLmpvaW4oXCIsIFwiKTtcbiAgICBpZiAoc3ViUXVlcnkgJiYgYXR0cmlidXRlcy5tYWluKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleUF0dCBvZiBtYWluVGFibGUubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLm1haW4uc29tZSgoYXR0cikgPT4ga2V5QXR0ID09PSBhdHRyIHx8IGtleUF0dCA9PT0gYXR0clswXSB8fCBrZXlBdHQgPT09IGF0dHJbMV0pKSB7XG4gICAgICAgICAgYXR0cmlidXRlcy5tYWluLnB1c2gobWFpblRhYmxlLm1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5QXR0XS5maWVsZCA/IFtrZXlBdHQsIG1haW5UYWJsZS5tb2RlbC5yYXdBdHRyaWJ1dGVzW2tleUF0dF0uZmllbGRdIDoga2V5QXR0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBhdHRyaWJ1dGVzLm1haW4gPSB0aGlzLmVzY2FwZUF0dHJpYnV0ZXMoYXR0cmlidXRlcy5tYWluLCBvcHRpb25zLCBtYWluVGFibGUuYXMpO1xuICAgIGF0dHJpYnV0ZXMubWFpbiA9IGF0dHJpYnV0ZXMubWFpbiB8fCAob3B0aW9ucy5pbmNsdWRlID8gW2Ake21haW5UYWJsZS5hc30uKmBdIDogW1wiKlwiXSk7XG4gICAgaWYgKHN1YlF1ZXJ5IHx8IG9wdGlvbnMuZ3JvdXBlZExpbWl0KSB7XG4gICAgICBhdHRyaWJ1dGVzLnN1YlF1ZXJ5ID0gYXR0cmlidXRlcy5tYWluO1xuICAgICAgYXR0cmlidXRlcy5tYWluID0gW2Ake21haW5UYWJsZS5hcyB8fCBtYWluVGFibGUucXVvdGVkTmFtZX0uKmBdO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICBmb3IgKGNvbnN0IGluY2x1ZGUgb2Ygb3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICAgIGlmIChpbmNsdWRlLnNlcGFyYXRlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgam9pblF1ZXJpZXMgPSB0aGlzLmdlbmVyYXRlSW5jbHVkZShpbmNsdWRlLCB7IGV4dGVybmFsQXM6IG1haW5UYWJsZS5hcywgaW50ZXJuYWxBczogbWFpblRhYmxlLmFzIH0sIHRvcExldmVsSW5mbyk7XG4gICAgICAgIHN1YkpvaW5RdWVyaWVzID0gc3ViSm9pblF1ZXJpZXMuY29uY2F0KGpvaW5RdWVyaWVzLnN1YlF1ZXJ5KTtcbiAgICAgICAgbWFpbkpvaW5RdWVyaWVzID0gbWFpbkpvaW5RdWVyaWVzLmNvbmNhdChqb2luUXVlcmllcy5tYWluUXVlcnkpO1xuICAgICAgICBpZiAoam9pblF1ZXJpZXMuYXR0cmlidXRlcy5tYWluLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzLm1haW4gPSBfLnVuaXEoYXR0cmlidXRlcy5tYWluLmNvbmNhdChqb2luUXVlcmllcy5hdHRyaWJ1dGVzLm1haW4pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoam9pblF1ZXJpZXMuYXR0cmlidXRlcy5zdWJRdWVyeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYXR0cmlidXRlcy5zdWJRdWVyeSA9IF8udW5pcShhdHRyaWJ1dGVzLnN1YlF1ZXJ5LmNvbmNhdChqb2luUXVlcmllcy5hdHRyaWJ1dGVzLnN1YlF1ZXJ5KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN1YlF1ZXJ5KSB7XG4gICAgICBzdWJRdWVyeUl0ZW1zLnB1c2godGhpcy5zZWxlY3RGcm9tVGFibGVGcmFnbWVudChvcHRpb25zLCBtYWluVGFibGUubW9kZWwsIGF0dHJpYnV0ZXMuc3ViUXVlcnksIG1haW5UYWJsZS5xdW90ZWROYW1lLCBtYWluVGFibGUuYXMpKTtcbiAgICAgIHN1YlF1ZXJ5SXRlbXMucHVzaChzdWJKb2luUXVlcmllcy5qb2luKFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMuZ3JvdXBlZExpbWl0KSB7XG4gICAgICAgIGlmICghbWFpblRhYmxlLmFzKSB7XG4gICAgICAgICAgbWFpblRhYmxlLmFzID0gbWFpblRhYmxlLnF1b3RlZE5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2hlcmUgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucy53aGVyZSk7XG4gICAgICAgIGxldCBncm91cGVkTGltaXRPcmRlciwgd2hlcmVLZXksIGluY2x1ZGUsIGdyb3VwZWRUYWJsZU5hbWUgPSBtYWluVGFibGUuYXM7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5ncm91cGVkTGltaXQub24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB3aGVyZUtleSA9IG9wdGlvbnMuZ3JvdXBlZExpbWl0Lm9uO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZ3JvdXBlZExpbWl0Lm9uIGluc3RhbmNlb2YgSGFzTWFueSkge1xuICAgICAgICAgIHdoZXJlS2V5ID0gb3B0aW9ucy5ncm91cGVkTGltaXQub24uZm9yZWlnbktleUZpZWxkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmdyb3VwZWRMaW1pdC5vbiBpbnN0YW5jZW9mIEJlbG9uZ3NUb01hbnkpIHtcbiAgICAgICAgICBncm91cGVkVGFibGVOYW1lID0gb3B0aW9ucy5ncm91cGVkTGltaXQub24ubWFueUZyb21Tb3VyY2UuYXM7XG4gICAgICAgICAgY29uc3QgZ3JvdXBlZExpbWl0T3B0aW9ucyA9IE1vZGVsLl92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHMoe1xuICAgICAgICAgICAgaW5jbHVkZTogW3tcbiAgICAgICAgICAgICAgYXNzb2NpYXRpb246IG9wdGlvbnMuZ3JvdXBlZExpbWl0Lm9uLm1hbnlGcm9tU291cmNlLFxuICAgICAgICAgICAgICBkdXBsaWNhdGluZzogZmFsc2UsXG4gICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgICAgICB3aGVyZTogX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICAgICAgICAgIFtPcC5wbGFjZWhvbGRlcl06IHRydWVcbiAgICAgICAgICAgICAgfSwgb3B0aW9ucy5ncm91cGVkTGltaXQudGhyb3VnaCAmJiBvcHRpb25zLmdyb3VwZWRMaW1pdC50aHJvdWdoLndoZXJlKVxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBtb2RlbFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG9wdGlvbnMuaGFzSm9pbiA9IHRydWU7XG4gICAgICAgICAgb3B0aW9ucy5oYXNNdWx0aUFzc29jaWF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBvcHRpb25zLmluY2x1ZGVNYXAgPSBPYmplY3QuYXNzaWduKGdyb3VwZWRMaW1pdE9wdGlvbnMuaW5jbHVkZU1hcCwgb3B0aW9ucy5pbmNsdWRlTWFwKTtcbiAgICAgICAgICBvcHRpb25zLmluY2x1ZGVOYW1lcyA9IGdyb3VwZWRMaW1pdE9wdGlvbnMuaW5jbHVkZU5hbWVzLmNvbmNhdChvcHRpb25zLmluY2x1ZGVOYW1lcyB8fCBbXSk7XG4gICAgICAgICAgaW5jbHVkZSA9IGdyb3VwZWRMaW1pdE9wdGlvbnMuaW5jbHVkZTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLm9yZGVyKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5vcmRlci5mb3JFYWNoKChvcmRlciwgaSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcmRlcikpIHtcbiAgICAgICAgICAgICAgICBvcmRlciA9IG9yZGVyWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBhbGlhcyA9IGBzdWJxdWVyeV9vcmRlcl8ke2l9YDtcbiAgICAgICAgICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzLnB1c2goW29yZGVyLCBhbGlhc10pO1xuICAgICAgICAgICAgICBhbGlhcyA9IHRoaXMuc2VxdWVsaXplLmxpdGVyYWwodGhpcy5xdW90ZShhbGlhcykpO1xuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLm9yZGVyW2ldKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub3JkZXJbaV1bMF0gPSBhbGlhcztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9yZGVyW2ldID0gYWxpYXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JvdXBlZExpbWl0T3JkZXIgPSBvcHRpb25zLm9yZGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncm91cGVkTGltaXRPcmRlciA9IG9wdGlvbnMub3JkZXI7XG4gICAgICAgICAgaWYgKCF0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnRvcExldmVsT3JkZXJCeVJlcXVpcmVkKSB7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5vcmRlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hlcmVbT3AucGxhY2Vob2xkZXJdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXNlUXVlcnkgPSBgU0VMRUNUICogRlJPTSAoJHt0aGlzLnNlbGVjdFF1ZXJ5KHRhYmxlTmFtZSwge1xuICAgICAgICAgIGF0dHJpYnV0ZXM6IG9wdGlvbnMuYXR0cmlidXRlcyxcbiAgICAgICAgICBvZmZzZXQ6IG9wdGlvbnMub2Zmc2V0LFxuICAgICAgICAgIGxpbWl0OiBvcHRpb25zLmdyb3VwZWRMaW1pdC5saW1pdCxcbiAgICAgICAgICBvcmRlcjogZ3JvdXBlZExpbWl0T3JkZXIsXG4gICAgICAgICAgYWxpYXNlc01hcHBpbmc6IG9wdGlvbnMuYWxpYXNlc01hcHBpbmcsXG4gICAgICAgICAgYWxpYXNlc0J5VGFibGU6IG9wdGlvbnMuYWxpYXNlc0J5VGFibGUsXG4gICAgICAgICAgd2hlcmUsXG4gICAgICAgICAgaW5jbHVkZSxcbiAgICAgICAgICBtb2RlbFxuICAgICAgICB9LCBtb2RlbCkucmVwbGFjZSgvOyQvLCBcIlwiKX0pICR7dGhpcy5nZXRBbGlhc1Rva2VuKCl9IHN1YmA7XG4gICAgICAgIGNvbnN0IHBsYWNlSG9sZGVyID0gdGhpcy53aGVyZUl0ZW1RdWVyeShPcC5wbGFjZWhvbGRlciwgdHJ1ZSwgeyBtb2RlbCB9KTtcbiAgICAgICAgY29uc3Qgc3BsaWNlUG9zID0gYmFzZVF1ZXJ5LmluZGV4T2YocGxhY2VIb2xkZXIpO1xuICAgICAgICBtYWluUXVlcnlJdGVtcy5wdXNoKHRoaXMuc2VsZWN0RnJvbVRhYmxlRnJhZ21lbnQob3B0aW9ucywgbWFpblRhYmxlLm1vZGVsLCBhdHRyaWJ1dGVzLm1haW4sIGAoJHtvcHRpb25zLmdyb3VwZWRMaW1pdC52YWx1ZXMubWFwKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIGxldCBncm91cFdoZXJlO1xuICAgICAgICAgIGlmICh3aGVyZUtleSkge1xuICAgICAgICAgICAgZ3JvdXBXaGVyZSA9IHtcbiAgICAgICAgICAgICAgW3doZXJlS2V5XTogdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmNsdWRlKSB7XG4gICAgICAgICAgICBncm91cFdoZXJlID0ge1xuICAgICAgICAgICAgICBbb3B0aW9ucy5ncm91cGVkTGltaXQub24uZm9yZWlnbklkZW50aWZpZXJGaWVsZF06IHZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gVXRpbHMuc3BsaWNlU3RyKGJhc2VRdWVyeSwgc3BsaWNlUG9zLCBwbGFjZUhvbGRlci5sZW5ndGgsIHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKGdyb3VwV2hlcmUsIGdyb3VwZWRUYWJsZU5hbWUpKTtcbiAgICAgICAgfSkuam9pbih0aGlzLl9kaWFsZWN0LnN1cHBvcnRzW1wiVU5JT04gQUxMXCJdID8gXCIgVU5JT04gQUxMIFwiIDogXCIgVU5JT04gXCIpfSlgLCBtYWluVGFibGUuYXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1haW5RdWVyeUl0ZW1zLnB1c2godGhpcy5zZWxlY3RGcm9tVGFibGVGcmFnbWVudChvcHRpb25zLCBtYWluVGFibGUubW9kZWwsIGF0dHJpYnV0ZXMubWFpbiwgbWFpblRhYmxlLnF1b3RlZE5hbWUsIG1haW5UYWJsZS5hcykpO1xuICAgICAgfVxuICAgICAgbWFpblF1ZXJ5SXRlbXMucHVzaChtYWluSm9pblF1ZXJpZXMuam9pbihcIlwiKSk7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJ3aGVyZVwiKSAmJiAhb3B0aW9ucy5ncm91cGVkTGltaXQpIHtcbiAgICAgIG9wdGlvbnMud2hlcmUgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyhvcHRpb25zLndoZXJlLCBtYWluVGFibGUuYXMgfHwgdGFibGVOYW1lLCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy53aGVyZSkge1xuICAgICAgICBpZiAoc3ViUXVlcnkpIHtcbiAgICAgICAgICBzdWJRdWVyeUl0ZW1zLnB1c2goYCBXSEVSRSAke29wdGlvbnMud2hlcmV9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFpblF1ZXJ5SXRlbXMucHVzaChgIFdIRVJFICR7b3B0aW9ucy53aGVyZX1gKTtcbiAgICAgICAgICBtYWluUXVlcnlJdGVtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aChcIlNFTEVDVFwiKSkge1xuICAgICAgICAgICAgICBtYWluUXVlcnlJdGVtc1trZXldID0gdGhpcy5zZWxlY3RGcm9tVGFibGVGcmFnbWVudChvcHRpb25zLCBtb2RlbCwgYXR0cmlidXRlcy5tYWluLCBtYWluVGFibGUucXVvdGVkTmFtZSwgbWFpblRhYmxlLmFzLCBvcHRpb25zLndoZXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ncm91cCkge1xuICAgICAgb3B0aW9ucy5ncm91cCA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5ncm91cCkgPyBvcHRpb25zLmdyb3VwLm1hcCgodCkgPT4gdGhpcy5hbGlhc0dyb3VwaW5nKHQsIG1vZGVsLCBtYWluVGFibGUuYXMsIG9wdGlvbnMpKS5qb2luKFwiLCBcIikgOiB0aGlzLmFsaWFzR3JvdXBpbmcob3B0aW9ucy5ncm91cCwgbW9kZWwsIG1haW5UYWJsZS5hcywgb3B0aW9ucyk7XG4gICAgICBpZiAoc3ViUXVlcnkgJiYgb3B0aW9ucy5ncm91cCkge1xuICAgICAgICBzdWJRdWVyeUl0ZW1zLnB1c2goYCBHUk9VUCBCWSAke29wdGlvbnMuZ3JvdXB9YCk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZ3JvdXApIHtcbiAgICAgICAgbWFpblF1ZXJ5SXRlbXMucHVzaChgIEdST1VQIEJZICR7b3B0aW9ucy5ncm91cH1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcImhhdmluZ1wiKSkge1xuICAgICAgb3B0aW9ucy5oYXZpbmcgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyhvcHRpb25zLmhhdmluZywgdGFibGVOYW1lLCBtb2RlbCwgb3B0aW9ucywgZmFsc2UpO1xuICAgICAgaWYgKG9wdGlvbnMuaGF2aW5nKSB7XG4gICAgICAgIGlmIChzdWJRdWVyeSkge1xuICAgICAgICAgIHN1YlF1ZXJ5SXRlbXMucHVzaChgIEhBVklORyAke29wdGlvbnMuaGF2aW5nfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1haW5RdWVyeUl0ZW1zLnB1c2goYCBIQVZJTkcgJHtvcHRpb25zLmhhdmluZ31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5vcmRlcikge1xuICAgICAgY29uc3Qgb3JkZXJzID0gdGhpcy5nZXRRdWVyeU9yZGVycyhvcHRpb25zLCBtb2RlbCwgc3ViUXVlcnkpO1xuICAgICAgaWYgKG9yZGVycy5tYWluUXVlcnlPcmRlci5sZW5ndGgpIHtcbiAgICAgICAgbWFpblF1ZXJ5SXRlbXMucHVzaChgIE9SREVSIEJZICR7b3JkZXJzLm1haW5RdWVyeU9yZGVyLmpvaW4oXCIsIFwiKX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcmRlcnMuc3ViUXVlcnlPcmRlci5sZW5ndGgpIHtcbiAgICAgICAgc3ViUXVlcnlJdGVtcy5wdXNoKGAgT1JERVIgQlkgJHtvcmRlcnMuc3ViUXVlcnlPcmRlci5qb2luKFwiLCBcIil9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0T3JkZXIgPSB0aGlzLmFkZExpbWl0QW5kT2Zmc2V0KG9wdGlvbnMsIG1haW5UYWJsZS5tb2RlbCk7XG4gICAgaWYgKGxpbWl0T3JkZXIgJiYgIW9wdGlvbnMuZ3JvdXBlZExpbWl0KSB7XG4gICAgICBpZiAoc3ViUXVlcnkpIHtcbiAgICAgICAgc3ViUXVlcnlJdGVtcy5wdXNoKGxpbWl0T3JkZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFpblF1ZXJ5SXRlbXMucHVzaChsaW1pdE9yZGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN1YlF1ZXJ5KSB7XG4gICAgICB0aGlzLl90aHJvd09uRW1wdHlBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMubWFpbiwgeyBtb2RlbE5hbWU6IG1vZGVsICYmIG1vZGVsLm5hbWUsIGFzOiBtYWluVGFibGUuYXMgfSk7XG4gICAgICBxdWVyeSA9IGBTRUxFQ1QgJHthdHRyaWJ1dGVzLm1haW4uam9pbihcIiwgXCIpfSBGUk9NICgke3N1YlF1ZXJ5SXRlbXMuam9pbihcIlwiKX0pICR7dGhpcy5nZXRBbGlhc1Rva2VuKCl9ICR7bWFpblRhYmxlLmFzfSR7bWFpbkpvaW5RdWVyaWVzLmpvaW4oXCJcIil9JHttYWluUXVlcnlJdGVtcy5qb2luKFwiXCIpfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5ID0gbWFpblF1ZXJ5SXRlbXMuam9pbihcIlwiKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubG9jayAmJiB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmxvY2spIHtcbiAgICAgIGxldCBsb2NrID0gb3B0aW9ucy5sb2NrO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2sgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbG9jayA9IG9wdGlvbnMubG9jay5sZXZlbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmxvY2tLZXkgJiYgW1wiS0VZIFNIQVJFXCIsIFwiTk8gS0VZIFVQREFURVwiXS5pbmNsdWRlcyhsb2NrKSkge1xuICAgICAgICBxdWVyeSArPSBgIEZPUiAke2xvY2t9YDtcbiAgICAgIH0gZWxzZSBpZiAobG9jayA9PT0gXCJTSEFSRVwiKSB7XG4gICAgICAgIHF1ZXJ5ICs9IGAgJHt0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmZvclNoYXJlfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeSArPSBcIiBGT1IgVVBEQVRFXCI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5sb2NrT2YgJiYgb3B0aW9ucy5sb2NrLm9mICYmIG9wdGlvbnMubG9jay5vZi5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICBxdWVyeSArPSBgIE9GICR7dGhpcy5xdW90ZVRhYmxlKG9wdGlvbnMubG9jay5vZi5uYW1lKX1gO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuc2tpcExvY2tlZCAmJiBvcHRpb25zLnNraXBMb2NrZWQpIHtcbiAgICAgICAgcXVlcnkgKz0gXCIgU0tJUCBMT0NLRURcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGAke3F1ZXJ5fTtgO1xuICB9XG4gIGFsaWFzR3JvdXBpbmcoZmllbGQsIG1vZGVsLCB0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcmMgPSBBcnJheS5pc0FycmF5KGZpZWxkKSA/IGZpZWxkWzBdIDogZmllbGQ7XG4gICAgcmV0dXJuIHRoaXMucXVvdGUodGhpcy5fZ2V0QWxpYXNGb3JGaWVsZCh0YWJsZU5hbWUsIHNyYywgb3B0aW9ucykgfHwgc3JjLCBtb2RlbCk7XG4gIH1cbiAgZXNjYXBlQXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBvcHRpb25zLCBtYWluVGFibGVBcykge1xuICAgIHJldHVybiBhdHRyaWJ1dGVzICYmIGF0dHJpYnV0ZXMubWFwKChhdHRyKSA9PiB7XG4gICAgICBsZXQgYWRkVGFibGUgPSB0cnVlO1xuICAgICAgaWYgKGF0dHIgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKGF0dHIpO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cikpIHtcbiAgICAgICAgaWYgKGF0dHIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke0pTT04uc3RyaW5naWZ5KGF0dHIpfSBpcyBub3QgYSB2YWxpZCBhdHRyaWJ1dGUgZGVmaW5pdGlvbi4gUGxlYXNlIHVzZSB0aGUgZm9sbG93aW5nIGZvcm1hdDogWydhdHRyaWJ1dGUgZGVmaW5pdGlvbicsICdhbGlhcyddYCk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0ciA9IGF0dHIuc2xpY2UoKTtcbiAgICAgICAgaWYgKGF0dHJbMF0gaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgICBhdHRyWzBdID0gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2QoYXR0clswXSk7XG4gICAgICAgICAgYWRkVGFibGUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuYXR0cmlidXRlQmVoYXZpb3IgPT09IFwiZXNjYXBlXCIgfHwgIWF0dHJbMF0uaW5jbHVkZXMoXCIoXCIpICYmICFhdHRyWzBdLmluY2x1ZGVzKFwiKVwiKSkge1xuICAgICAgICAgIGF0dHJbMF0gPSB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyWzBdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuYXR0cmlidXRlQmVoYXZpb3IgIT09IFwidW5zYWZlLWxlZ2FjeVwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRyaWJ1dGVzIGNhbm5vdCBpbmNsdWRlIHBhcmVudGhlc2VzIGluIFNlcXVlbGl6ZSA2OlxuSW4gb3JkZXIgdG8gZml4IHRoZSB2dWxuZXJhYmlsaXR5IENWRS0yMDIzLTIyNTc4LCB3ZSBoYWQgdG8gcmVtb3ZlIHN1cHBvcnQgZm9yIHRyZWF0aW5nIGF0dHJpYnV0ZXMgYXMgcmF3IFNRTCBpZiB0aGV5IGluY2x1ZGVkIHBhcmVudGhlc2VzLlxuU2VxdWVsaXplIDcgZXNjYXBlcyBhbGwgYXR0cmlidXRlcywgZXZlbiBpZiB0aGV5IGluY2x1ZGUgcGFyZW50aGVzZXMuXG5Gb3IgU2VxdWVsaXplIDYsIGJlY2F1c2Ugd2UncmUgaW50cm9kdWNpbmcgdGhpcyBjaGFuZ2UgaW4gYSBtaW5vciByZWxlYXNlLCB3ZSd2ZSBvcHRlZCBmb3IgdGhyb3dpbmcgYW4gZXJyb3IgaW5zdGVhZCBvZiBzaWxlbnRseSBlc2NhcGluZyB0aGUgYXR0cmlidXRlIGFzIGEgd2F5IHRvIHdhcm4geW91IGFib3V0IHRoaXMgY2hhbmdlLlxuXG5IZXJlIGlzIHdoYXQgeW91IGNhbiBkbyB0byBmaXggdGhpcyBlcnJvcjpcbi0gV3JhcCB0aGUgYXR0cmlidXRlIGluIGEgbGl0ZXJhbCgpIGNhbGwuIFRoaXMgd2lsbCBtYWtlIFNlcXVlbGl6ZSB0cmVhdCBpdCBhcyByYXcgU1FMLlxuLSBTZXQgdGhlIFwiYXR0cmlidXRlQmVoYXZpb3JcIiBzZXF1ZWxpemUgb3B0aW9uIHRvIFwiZXNjYXBlXCIgdG8gbWFrZSBTZXF1ZWxpemUgZXNjYXBlIHRoZSBhdHRyaWJ1dGUsIGxpa2UgaW4gU2VxdWVsaXplIHY3LiBXZSBoaWdobHkgcmVjb21tZW5kIHRoaXMgb3B0aW9uLlxuLSBTZXQgdGhlIFwiYXR0cmlidXRlQmVoYXZpb3JcIiBzZXF1ZWxpemUgb3B0aW9uIHRvIFwidW5zYWZlLWxlZ2FjeVwiIHRvIG1ha2UgU2VxdWVsaXplIGVzY2FwZSB0aGUgYXR0cmlidXRlLCBsaWtlIGluIFNlcXVlbGl6ZSB2NS5cblxuV2Ugc2luY2VyZWx5IGFwb2xvZ2l6ZSBmb3IgdGhlIGluY29udmVuaWVuY2UgdGhpcyBtYXkgY2F1c2UgeW91LiBZb3UgY2FuIGZpbmQgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgZm9sbG93aW5nIHRocmVhZHM6XG5odHRwczovL2dpdGh1Yi5jb20vc2VxdWVsaXplL3NlcXVlbGl6ZS9zZWN1cml0eS9hZHZpc29yaWVzL0dIU0EtZjU5OC1tZnB2LWdtZnhcbmh0dHBzOi8vZ2l0aHViLmNvbS9zZXF1ZWxpemUvc2VxdWVsaXplL2Rpc2N1c3Npb25zLzE1Njk0YCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFsaWFzID0gYXR0clsxXTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5taW5pZnlBbGlhc2VzKSB7XG4gICAgICAgICAgYWxpYXMgPSB0aGlzLl9nZXRNaW5pZmllZEFsaWFzKGFsaWFzLCBtYWluVGFibGVBcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0ciA9IFthdHRyWzBdLCB0aGlzLnF1b3RlSWRlbnRpZmllcihhbGlhcyldLmpvaW4oXCIgQVMgXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0ciA9ICFhdHRyLmluY2x1ZGVzKFV0aWxzLlRJQ0tfQ0hBUikgJiYgIWF0dHIuaW5jbHVkZXMoJ1wiJykgPyB0aGlzLnF1b3RlQXR0cmlidXRlKGF0dHIsIG9wdGlvbnMubW9kZWwpIDogdGhpcy5lc2NhcGUoYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoIV8uaXNFbXB0eShvcHRpb25zLmluY2x1ZGUpICYmICghYXR0ci5pbmNsdWRlcyhcIi5cIikgfHwgb3B0aW9ucy5kb3ROb3RhdGlvbikgJiYgYWRkVGFibGUpIHtcbiAgICAgICAgYXR0ciA9IGAke21haW5UYWJsZUFzfS4ke2F0dHJ9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyO1xuICAgIH0pO1xuICB9XG4gIGdlbmVyYXRlSW5jbHVkZShpbmNsdWRlLCBwYXJlbnRUYWJsZU5hbWUsIHRvcExldmVsSW5mbykge1xuICAgIGNvbnN0IGpvaW5RdWVyaWVzID0ge1xuICAgICAgbWFpblF1ZXJ5OiBbXSxcbiAgICAgIHN1YlF1ZXJ5OiBbXVxuICAgIH07XG4gICAgY29uc3QgbWFpbkNoaWxkSW5jbHVkZXMgPSBbXTtcbiAgICBjb25zdCBzdWJDaGlsZEluY2x1ZGVzID0gW107XG4gICAgbGV0IHJlcXVpcmVkTWlzbWF0Y2ggPSBmYWxzZTtcbiAgICBjb25zdCBpbmNsdWRlQXMgPSB7XG4gICAgICBpbnRlcm5hbEFzOiBpbmNsdWRlLmFzLFxuICAgICAgZXh0ZXJuYWxBczogaW5jbHVkZS5hc1xuICAgIH07XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAgIG1haW46IFtdLFxuICAgICAgc3ViUXVlcnk6IFtdXG4gICAgfTtcbiAgICBsZXQgam9pblF1ZXJ5O1xuICAgIHRvcExldmVsSW5mby5vcHRpb25zLmtleXNFc2NhcGVkID0gdHJ1ZTtcbiAgICBpZiAodG9wTGV2ZWxJbmZvLm5hbWVzLm5hbWUgIT09IHBhcmVudFRhYmxlTmFtZS5leHRlcm5hbEFzICYmIHRvcExldmVsSW5mby5uYW1lcy5hcyAhPT0gcGFyZW50VGFibGVOYW1lLmV4dGVybmFsQXMpIHtcbiAgICAgIGluY2x1ZGVBcy5pbnRlcm5hbEFzID0gYCR7cGFyZW50VGFibGVOYW1lLmludGVybmFsQXN9LT4ke2luY2x1ZGUuYXN9YDtcbiAgICAgIGluY2x1ZGVBcy5leHRlcm5hbEFzID0gYCR7cGFyZW50VGFibGVOYW1lLmV4dGVybmFsQXN9LiR7aW5jbHVkZS5hc31gO1xuICAgIH1cbiAgICBpZiAodG9wTGV2ZWxJbmZvLm9wdGlvbnMuaW5jbHVkZUlnbm9yZUF0dHJpYnV0ZXMgIT09IGZhbHNlKSB7XG4gICAgICBpbmNsdWRlLm1vZGVsLl9leHBhbmRBdHRyaWJ1dGVzKGluY2x1ZGUpO1xuICAgICAgVXRpbHMubWFwRmluZGVyT3B0aW9ucyhpbmNsdWRlLCBpbmNsdWRlLm1vZGVsKTtcbiAgICAgIGNvbnN0IGluY2x1ZGVBdHRyaWJ1dGVzID0gaW5jbHVkZS5hdHRyaWJ1dGVzLm1hcCgoYXR0cikgPT4ge1xuICAgICAgICBsZXQgYXR0ckFzID0gYXR0cjtcbiAgICAgICAgbGV0IHZlcmJhdGltID0gZmFsc2U7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGF0dHIpICYmIGF0dHIubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgaWYgKGF0dHJbMF0gaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QgJiYgKGF0dHJbMF0gaW5zdGFuY2VvZiBVdGlscy5MaXRlcmFsIHx8IGF0dHJbMF0gaW5zdGFuY2VvZiBVdGlscy5DYXN0IHx8IGF0dHJbMF0gaW5zdGFuY2VvZiBVdGlscy5GbikpIHtcbiAgICAgICAgICAgIHZlcmJhdGltID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0ciA9IGF0dHIubWFwKChhdHRyMikgPT4gYXR0cjIgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QgPyB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChhdHRyMikgOiBhdHRyMik7XG4gICAgICAgICAgYXR0ckFzID0gYXR0clsxXTtcbiAgICAgICAgICBhdHRyID0gYXR0clswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0ciBpbnN0YW5jZW9mIFV0aWxzLkxpdGVyYWwpIHtcbiAgICAgICAgICByZXR1cm4gYXR0ci52YWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHIgaW5zdGFuY2VvZiBVdGlscy5DYXN0IHx8IGF0dHIgaW5zdGFuY2VvZiBVdGlscy5Gbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIHNlbGVjdCBhdHRyaWJ1dGVzIHVzaW5nIFNlcXVlbGl6ZS5jYXN0IG9yIFNlcXVlbGl6ZS5mbiB3aXRob3V0IHNwZWNpZnlpbmcgYW4gYWxpYXMgZm9yIHRoZSByZXN1bHQsIGR1cmluZyBlYWdlciBsb2FkaW5nLiBUaGlzIG1lYW5zIHRoZSBhdHRyaWJ1dGUgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIHJldHVybmVkIGluc3RhbmNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmVmaXg7XG4gICAgICAgIGlmICh2ZXJiYXRpbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHByZWZpeCA9IGF0dHI7XG4gICAgICAgIH0gZWxzZSBpZiAoLyM+PnwtPj4vLnRlc3QoYXR0cikpIHtcbiAgICAgICAgICBwcmVmaXggPSBgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaW5jbHVkZUFzLmludGVybmFsQXMpfS4ke2F0dHIucmVwbGFjZSgvXFwofFxcKS9nLCBcIlwiKX0pYDtcbiAgICAgICAgfSBlbHNlIGlmICgvanNvbl9leHRyYWN0XFwoLy50ZXN0KGF0dHIpKSB7XG4gICAgICAgICAgcHJlZml4ID0gYXR0ci5yZXBsYWNlKC9qc29uX2V4dHJhY3RcXCgvaSwgYGpzb25fZXh0cmFjdCgke3RoaXMucXVvdGVJZGVudGlmaWVyKGluY2x1ZGVBcy5pbnRlcm5hbEFzKX0uYCk7XG4gICAgICAgIH0gZWxzZSBpZiAoL2pzb25fdmFsdWVcXCgvLnRlc3QoYXR0cikpIHtcbiAgICAgICAgICBwcmVmaXggPSBhdHRyLnJlcGxhY2UoL2pzb25fdmFsdWVcXCgvaSwgYGpzb25fdmFsdWUoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihpbmNsdWRlQXMuaW50ZXJuYWxBcyl9LmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZWZpeCA9IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGluY2x1ZGVBcy5pbnRlcm5hbEFzKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX1gO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbGlhcyA9IGAke2luY2x1ZGVBcy5leHRlcm5hbEFzfS4ke2F0dHJBc31gO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1pbmlmeUFsaWFzZXMpIHtcbiAgICAgICAgICBhbGlhcyA9IHRoaXMuX2dldE1pbmlmaWVkQWxpYXMoYWxpYXMsIGluY2x1ZGVBcy5pbnRlcm5hbEFzLCB0b3BMZXZlbEluZm8ub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICBcIkFTXCIsXG4gICAgICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoYWxpYXMsIHRydWUpXG4gICAgICAgIF0pO1xuICAgICAgfSk7XG4gICAgICBpZiAoaW5jbHVkZS5zdWJRdWVyeSAmJiB0b3BMZXZlbEluZm8uc3ViUXVlcnkpIHtcbiAgICAgICAgZm9yIChjb25zdCBhdHRyIG9mIGluY2x1ZGVBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgYXR0cmlidXRlcy5zdWJRdWVyeS5wdXNoKGF0dHIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgaW5jbHVkZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzLm1haW4ucHVzaChhdHRyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5jbHVkZS50aHJvdWdoKSB7XG4gICAgICBqb2luUXVlcnkgPSB0aGlzLmdlbmVyYXRlVGhyb3VnaEpvaW4oaW5jbHVkZSwgaW5jbHVkZUFzLCBwYXJlbnRUYWJsZU5hbWUuaW50ZXJuYWxBcywgdG9wTGV2ZWxJbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZ2VuZXJhdGVTdWJRdWVyeUZpbHRlcihpbmNsdWRlLCBpbmNsdWRlQXMsIHRvcExldmVsSW5mbyk7XG4gICAgICBqb2luUXVlcnkgPSB0aGlzLmdlbmVyYXRlSm9pbihpbmNsdWRlLCB0b3BMZXZlbEluZm8pO1xuICAgIH1cbiAgICBpZiAoam9pblF1ZXJ5LmF0dHJpYnV0ZXMubWFpbi5sZW5ndGggPiAwKSB7XG4gICAgICBhdHRyaWJ1dGVzLm1haW4gPSBhdHRyaWJ1dGVzLm1haW4uY29uY2F0KGpvaW5RdWVyeS5hdHRyaWJ1dGVzLm1haW4pO1xuICAgIH1cbiAgICBpZiAoam9pblF1ZXJ5LmF0dHJpYnV0ZXMuc3ViUXVlcnkubGVuZ3RoID4gMCkge1xuICAgICAgYXR0cmlidXRlcy5zdWJRdWVyeSA9IGF0dHJpYnV0ZXMuc3ViUXVlcnkuY29uY2F0KGpvaW5RdWVyeS5hdHRyaWJ1dGVzLnN1YlF1ZXJ5KTtcbiAgICB9XG4gICAgaWYgKGluY2x1ZGUuaW5jbHVkZSkge1xuICAgICAgZm9yIChjb25zdCBjaGlsZEluY2x1ZGUgb2YgaW5jbHVkZS5pbmNsdWRlKSB7XG4gICAgICAgIGlmIChjaGlsZEluY2x1ZGUuc2VwYXJhdGUgfHwgY2hpbGRJbmNsdWRlLl9wc2V1ZG8pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZEpvaW5RdWVyaWVzID0gdGhpcy5nZW5lcmF0ZUluY2x1ZGUoY2hpbGRJbmNsdWRlLCBpbmNsdWRlQXMsIHRvcExldmVsSW5mbyk7XG4gICAgICAgIGlmIChpbmNsdWRlLnJlcXVpcmVkID09PSBmYWxzZSAmJiBjaGlsZEluY2x1ZGUucmVxdWlyZWQgPT09IHRydWUpIHtcbiAgICAgICAgICByZXF1aXJlZE1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRJbmNsdWRlLnN1YlF1ZXJ5ICYmIHRvcExldmVsSW5mby5zdWJRdWVyeSkge1xuICAgICAgICAgIHN1YkNoaWxkSW5jbHVkZXMucHVzaChjaGlsZEpvaW5RdWVyaWVzLnN1YlF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRKb2luUXVlcmllcy5tYWluUXVlcnkpIHtcbiAgICAgICAgICBtYWluQ2hpbGRJbmNsdWRlcy5wdXNoKGNoaWxkSm9pblF1ZXJpZXMubWFpblF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRKb2luUXVlcmllcy5hdHRyaWJ1dGVzLm1haW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGF0dHJpYnV0ZXMubWFpbiA9IGF0dHJpYnV0ZXMubWFpbi5jb25jYXQoY2hpbGRKb2luUXVlcmllcy5hdHRyaWJ1dGVzLm1haW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEpvaW5RdWVyaWVzLmF0dHJpYnV0ZXMuc3ViUXVlcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGF0dHJpYnV0ZXMuc3ViUXVlcnkgPSBhdHRyaWJ1dGVzLnN1YlF1ZXJ5LmNvbmNhdChjaGlsZEpvaW5RdWVyaWVzLmF0dHJpYnV0ZXMuc3ViUXVlcnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbmNsdWRlLnN1YlF1ZXJ5ICYmIHRvcExldmVsSW5mby5zdWJRdWVyeSkge1xuICAgICAgaWYgKHJlcXVpcmVkTWlzbWF0Y2ggJiYgc3ViQ2hpbGRJbmNsdWRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGpvaW5RdWVyaWVzLnN1YlF1ZXJ5LnB1c2goYCAke2pvaW5RdWVyeS5qb2lufSAoICR7am9pblF1ZXJ5LmJvZHl9JHtzdWJDaGlsZEluY2x1ZGVzLmpvaW4oXCJcIil9ICkgT04gJHtqb2luUXVlcnkuY29uZGl0aW9ufWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgam9pblF1ZXJpZXMuc3ViUXVlcnkucHVzaChgICR7am9pblF1ZXJ5LmpvaW59ICR7am9pblF1ZXJ5LmJvZHl9IE9OICR7am9pblF1ZXJ5LmNvbmRpdGlvbn1gKTtcbiAgICAgICAgaWYgKHN1YkNoaWxkSW5jbHVkZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGpvaW5RdWVyaWVzLnN1YlF1ZXJ5LnB1c2goc3ViQ2hpbGRJbmNsdWRlcy5qb2luKFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgam9pblF1ZXJpZXMubWFpblF1ZXJ5LnB1c2gobWFpbkNoaWxkSW5jbHVkZXMuam9pbihcIlwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZXF1aXJlZE1pc21hdGNoICYmIG1haW5DaGlsZEluY2x1ZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgam9pblF1ZXJpZXMubWFpblF1ZXJ5LnB1c2goYCAke2pvaW5RdWVyeS5qb2lufSAoICR7am9pblF1ZXJ5LmJvZHl9JHttYWluQ2hpbGRJbmNsdWRlcy5qb2luKFwiXCIpfSApIE9OICR7am9pblF1ZXJ5LmNvbmRpdGlvbn1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpvaW5RdWVyaWVzLm1haW5RdWVyeS5wdXNoKGAgJHtqb2luUXVlcnkuam9pbn0gJHtqb2luUXVlcnkuYm9keX0gT04gJHtqb2luUXVlcnkuY29uZGl0aW9ufWApO1xuICAgICAgICBpZiAobWFpbkNoaWxkSW5jbHVkZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGpvaW5RdWVyaWVzLm1haW5RdWVyeS5wdXNoKG1haW5DaGlsZEluY2x1ZGVzLmpvaW4oXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBqb2luUXVlcmllcy5zdWJRdWVyeS5wdXNoKHN1YkNoaWxkSW5jbHVkZXMuam9pbihcIlwiKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtYWluUXVlcnk6IGpvaW5RdWVyaWVzLm1haW5RdWVyeS5qb2luKFwiXCIpLFxuICAgICAgc3ViUXVlcnk6IGpvaW5RdWVyaWVzLnN1YlF1ZXJ5LmpvaW4oXCJcIiksXG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfTtcbiAgfVxuICBfZ2V0TWluaWZpZWRBbGlhcyhhbGlhcywgdGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuYWxpYXNlc0J5VGFibGVbYCR7dGFibGVOYW1lfSR7YWxpYXN9YF0pIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmFsaWFzZXNCeVRhYmxlW2Ake3RhYmxlTmFtZX0ke2FsaWFzfWBdO1xuICAgIH1cbiAgICBpZiAoYWxpYXMubWF0Y2goL3N1YnF1ZXJ5X29yZGVyX1swLTldLykpIHtcbiAgICAgIHJldHVybiBhbGlhcztcbiAgICB9XG4gICAgY29uc3QgbWluaWZpZWRBbGlhcyA9IGBfJHtvcHRpb25zLmFsaWFzZXNNYXBwaW5nLnNpemV9YDtcbiAgICBvcHRpb25zLmFsaWFzZXNNYXBwaW5nLnNldChtaW5pZmllZEFsaWFzLCBhbGlhcyk7XG4gICAgb3B0aW9ucy5hbGlhc2VzQnlUYWJsZVtgJHt0YWJsZU5hbWV9JHthbGlhc31gXSA9IG1pbmlmaWVkQWxpYXM7XG4gICAgcmV0dXJuIG1pbmlmaWVkQWxpYXM7XG4gIH1cbiAgX2dldEFsaWFzRm9yRmllbGQodGFibGVOYW1lLCBmaWVsZCwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubWluaWZ5QWxpYXNlcykge1xuICAgICAgaWYgKG9wdGlvbnMuYWxpYXNlc0J5VGFibGVbYCR7dGFibGVOYW1lfSR7ZmllbGR9YF0pIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuYWxpYXNlc0J5VGFibGVbYCR7dGFibGVOYW1lfSR7ZmllbGR9YF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdlbmVyYXRlSm9pbihpbmNsdWRlLCB0b3BMZXZlbEluZm8pIHtcbiAgICBjb25zdCBhc3NvY2lhdGlvbiA9IGluY2x1ZGUuYXNzb2NpYXRpb247XG4gICAgY29uc3QgcGFyZW50ID0gaW5jbHVkZS5wYXJlbnQ7XG4gICAgY29uc3QgcGFyZW50SXNUb3AgPSAhIXBhcmVudCAmJiAhaW5jbHVkZS5wYXJlbnQuYXNzb2NpYXRpb24gJiYgaW5jbHVkZS5wYXJlbnQubW9kZWwubmFtZSA9PT0gdG9wTGV2ZWxJbmZvLm9wdGlvbnMubW9kZWwubmFtZTtcbiAgICBsZXQgJHBhcmVudDtcbiAgICBsZXQgam9pbldoZXJlO1xuICAgIGNvbnN0IGxlZnQgPSBhc3NvY2lhdGlvbi5zb3VyY2U7XG4gICAgY29uc3QgYXR0ckxlZnQgPSBhc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUbyA/IGFzc29jaWF0aW9uLmlkZW50aWZpZXIgOiBhc3NvY2lhdGlvbi5zb3VyY2VLZXlBdHRyaWJ1dGUgfHwgbGVmdC5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgIGNvbnN0IGZpZWxkTGVmdCA9IGFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvID8gYXNzb2NpYXRpb24uaWRlbnRpZmllckZpZWxkIDogbGVmdC5yYXdBdHRyaWJ1dGVzW2Fzc29jaWF0aW9uLnNvdXJjZUtleUF0dHJpYnV0ZSB8fCBsZWZ0LnByaW1hcnlLZXlBdHRyaWJ1dGVdLmZpZWxkO1xuICAgIGxldCBhc0xlZnQ7XG4gICAgY29uc3QgcmlnaHQgPSBpbmNsdWRlLm1vZGVsO1xuICAgIGNvbnN0IHRhYmxlUmlnaHQgPSByaWdodC5nZXRUYWJsZU5hbWUoKTtcbiAgICBjb25zdCBmaWVsZFJpZ2h0ID0gYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG8gPyByaWdodC5yYXdBdHRyaWJ1dGVzW2Fzc29jaWF0aW9uLnRhcmdldElkZW50aWZpZXIgfHwgcmlnaHQucHJpbWFyeUtleUF0dHJpYnV0ZV0uZmllbGQgOiBhc3NvY2lhdGlvbi5pZGVudGlmaWVyRmllbGQ7XG4gICAgbGV0IGFzUmlnaHQgPSBpbmNsdWRlLmFzO1xuICAgIHdoaWxlICgoJHBhcmVudCA9ICRwYXJlbnQgJiYgJHBhcmVudC5wYXJlbnQgfHwgaW5jbHVkZS5wYXJlbnQpICYmICRwYXJlbnQuYXNzb2NpYXRpb24pIHtcbiAgICAgIGlmIChhc0xlZnQpIHtcbiAgICAgICAgYXNMZWZ0ID0gYCR7JHBhcmVudC5hc30tPiR7YXNMZWZ0fWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc0xlZnQgPSAkcGFyZW50LmFzO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWFzTGVmdClcbiAgICAgIGFzTGVmdCA9IHBhcmVudC5hcyB8fCBwYXJlbnQubW9kZWwubmFtZTtcbiAgICBlbHNlXG4gICAgICBhc1JpZ2h0ID0gYCR7YXNMZWZ0fS0+JHthc1JpZ2h0fWA7XG4gICAgbGV0IGpvaW5PbiA9IGAke3RoaXMucXVvdGVUYWJsZShhc0xlZnQpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkTGVmdCl9YDtcbiAgICBjb25zdCBzdWJxdWVyeUF0dHJpYnV0ZXMgPSBbXTtcbiAgICBpZiAodG9wTGV2ZWxJbmZvLm9wdGlvbnMuZ3JvdXBlZExpbWl0ICYmIHBhcmVudElzVG9wIHx8IHRvcExldmVsSW5mby5zdWJRdWVyeSAmJiBpbmNsdWRlLnBhcmVudC5zdWJRdWVyeSAmJiAhaW5jbHVkZS5zdWJRdWVyeSkge1xuICAgICAgaWYgKHBhcmVudElzVG9wKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZShwYXJlbnQuYXMgfHwgcGFyZW50Lm1vZGVsLm5hbWUpO1xuICAgICAgICBqb2luT24gPSB0aGlzLl9nZXRBbGlhc0ZvckZpZWxkKHRhYmxlTmFtZSwgYXR0ckxlZnQsIHRvcExldmVsSW5mby5vcHRpb25zKSB8fCBgJHt0YWJsZU5hbWV9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0ckxlZnQpfWA7XG4gICAgICAgIGlmICh0b3BMZXZlbEluZm8uc3ViUXVlcnkpIHtcbiAgICAgICAgICBjb25zdCBkYklkZW50aWZpZXIgPSBgJHt0YWJsZU5hbWV9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGRMZWZ0KX1gO1xuICAgICAgICAgIHN1YnF1ZXJ5QXR0cmlidXRlcy5wdXNoKGRiSWRlbnRpZmllciAhPT0gam9pbk9uID8gYCR7ZGJJZGVudGlmaWVyfSBBUyAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJMZWZ0KX1gIDogZGJJZGVudGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgam9pblNvdXJjZSA9IGAke2FzTGVmdC5yZXBsYWNlKC8tPi9nLCBcIi5cIil9LiR7YXR0ckxlZnR9YDtcbiAgICAgICAgam9pbk9uID0gdGhpcy5fZ2V0QWxpYXNGb3JGaWVsZChhc0xlZnQsIGpvaW5Tb3VyY2UsIHRvcExldmVsSW5mby5vcHRpb25zKSB8fCB0aGlzLnF1b3RlSWRlbnRpZmllcihqb2luU291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgam9pbk9uICs9IGAgPSAke3RoaXMucXVvdGVJZGVudGlmaWVyKGFzUmlnaHQpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkUmlnaHQpfWA7XG4gICAgaWYgKGluY2x1ZGUub24pIHtcbiAgICAgIGpvaW5PbiA9IHRoaXMud2hlcmVJdGVtc1F1ZXJ5KGluY2x1ZGUub24sIHtcbiAgICAgICAgcHJlZml4OiB0aGlzLnNlcXVlbGl6ZS5saXRlcmFsKHRoaXMucXVvdGVJZGVudGlmaWVyKGFzUmlnaHQpKSxcbiAgICAgICAgbW9kZWw6IGluY2x1ZGUubW9kZWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaW5jbHVkZS53aGVyZSkge1xuICAgICAgam9pbldoZXJlID0gdGhpcy53aGVyZUl0ZW1zUXVlcnkoaW5jbHVkZS53aGVyZSwge1xuICAgICAgICBwcmVmaXg6IHRoaXMuc2VxdWVsaXplLmxpdGVyYWwodGhpcy5xdW90ZUlkZW50aWZpZXIoYXNSaWdodCkpLFxuICAgICAgICBtb2RlbDogaW5jbHVkZS5tb2RlbFxuICAgICAgfSk7XG4gICAgICBpZiAoam9pbldoZXJlKSB7XG4gICAgICAgIGlmIChpbmNsdWRlLm9yKSB7XG4gICAgICAgICAgam9pbk9uICs9IGAgT1IgJHtqb2luV2hlcmV9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBqb2luT24gKz0gYCBBTkQgJHtqb2luV2hlcmV9YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFsaWFzQXMoYXNSaWdodCwgdG9wTGV2ZWxJbmZvKTtcbiAgICByZXR1cm4ge1xuICAgICAgam9pbjogaW5jbHVkZS5yZXF1aXJlZCA/IFwiSU5ORVIgSk9JTlwiIDogaW5jbHVkZS5yaWdodCAmJiB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzW1wiUklHSFQgSk9JTlwiXSA/IFwiUklHSFQgT1VURVIgSk9JTlwiIDogXCJMRUZUIE9VVEVSIEpPSU5cIixcbiAgICAgIGJvZHk6IHRoaXMucXVvdGVUYWJsZSh0YWJsZVJpZ2h0LCBhc1JpZ2h0KSxcbiAgICAgIGNvbmRpdGlvbjogam9pbk9uLFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICBtYWluOiBbXSxcbiAgICAgICAgc3ViUXVlcnk6IHN1YnF1ZXJ5QXR0cmlidXRlc1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2VuZXJhdGVSZXR1cm5WYWx1ZXMobW9kZWxBdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmV0dXJuRmllbGRzID0gW107XG4gICAgY29uc3QgcmV0dXJuVHlwZXMgPSBbXTtcbiAgICBsZXQgb3V0cHV0RnJhZ21lbnQgPSBcIlwiO1xuICAgIGxldCByZXR1cm5pbmdGcmFnbWVudCA9IFwiXCI7XG4gICAgbGV0IHRtcFRhYmxlID0gXCJcIjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnJldHVybmluZykpIHtcbiAgICAgIHJldHVybkZpZWxkcy5wdXNoKC4uLm9wdGlvbnMucmV0dXJuaW5nLm1hcCgoZmllbGQpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKSkpO1xuICAgIH0gZWxzZSBpZiAobW9kZWxBdHRyaWJ1dGVzKSB7XG4gICAgICBfLmVhY2gobW9kZWxBdHRyaWJ1dGVzLCAoYXR0cmlidXRlKSA9PiB7XG4gICAgICAgIGlmICghKGF0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLlZJUlRVQUwpKSB7XG4gICAgICAgICAgcmV0dXJuRmllbGRzLnB1c2godGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlLmZpZWxkKSk7XG4gICAgICAgICAgcmV0dXJuVHlwZXMucHVzaChhdHRyaWJ1dGUudHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoXy5pc0VtcHR5KHJldHVybkZpZWxkcykpIHtcbiAgICAgIHJldHVybkZpZWxkcy5wdXNoKFwiKlwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMucmV0dXJuVmFsdWVzLnJldHVybmluZykge1xuICAgICAgcmV0dXJuaW5nRnJhZ21lbnQgPSBgIFJFVFVSTklORyAke3JldHVybkZpZWxkcy5qb2luKFwiLFwiKX1gO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5yZXR1cm5JbnRvVmFsdWVzKSB7XG4gICAgICByZXR1cm5pbmdGcmFnbWVudCA9IGAgUkVUVVJOSU5HICR7cmV0dXJuRmllbGRzLmpvaW4oXCIsXCIpfSBJTlRPIGA7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnJldHVyblZhbHVlcy5vdXRwdXQpIHtcbiAgICAgIG91dHB1dEZyYWdtZW50ID0gYCBPVVRQVVQgJHtyZXR1cm5GaWVsZHMubWFwKChmaWVsZCkgPT4gYElOU0VSVEVELiR7ZmllbGR9YCkuam9pbihcIixcIil9YDtcbiAgICAgIGlmIChvcHRpb25zLmhhc1RyaWdnZXIgJiYgdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy50bXBUYWJsZVRyaWdnZXIpIHtcbiAgICAgICAgY29uc3QgdG1wQ29sdW1ucyA9IHJldHVybkZpZWxkcy5tYXAoKGZpZWxkLCBpKSA9PiBgJHtmaWVsZH0gJHtyZXR1cm5UeXBlc1tpXS50b1NxbCgpfWApO1xuICAgICAgICB0bXBUYWJsZSA9IGBERUNMQVJFIEB0bXAgVEFCTEUgKCR7dG1wQ29sdW1ucy5qb2luKFwiLFwiKX0pOyBgO1xuICAgICAgICBvdXRwdXRGcmFnbWVudCArPSBcIiBJTlRPIEB0bXBcIjtcbiAgICAgICAgcmV0dXJuaW5nRnJhZ21lbnQgPSBcIjsgU0VMRUNUICogRlJPTSBAdG1wXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG91dHB1dEZyYWdtZW50LCByZXR1cm5GaWVsZHMsIHJldHVyblR5cGVzLCByZXR1cm5pbmdGcmFnbWVudCwgdG1wVGFibGUgfTtcbiAgfVxuICBnZW5lcmF0ZVRocm91Z2hKb2luKGluY2x1ZGUsIGluY2x1ZGVBcywgcGFyZW50VGFibGVOYW1lLCB0b3BMZXZlbEluZm8pIHtcbiAgICBjb25zdCB0aHJvdWdoID0gaW5jbHVkZS50aHJvdWdoO1xuICAgIGNvbnN0IHRocm91Z2hUYWJsZSA9IHRocm91Z2gubW9kZWwuZ2V0VGFibGVOYW1lKCk7XG4gICAgY29uc3QgdGhyb3VnaEFzID0gYCR7aW5jbHVkZUFzLmludGVybmFsQXN9LT4ke3Rocm91Z2guYXN9YDtcbiAgICBjb25zdCBleHRlcm5hbFRocm91Z2hBcyA9IGAke2luY2x1ZGVBcy5leHRlcm5hbEFzfS4ke3Rocm91Z2guYXN9YDtcbiAgICBjb25zdCB0aHJvdWdoQXR0cmlidXRlcyA9IHRocm91Z2guYXR0cmlidXRlcy5tYXAoKGF0dHIpID0+IHtcbiAgICAgIGxldCBhbGlhcyA9IGAke2V4dGVybmFsVGhyb3VnaEFzfS4ke0FycmF5LmlzQXJyYXkoYXR0cikgPyBhdHRyWzFdIDogYXR0cn1gO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5taW5pZnlBbGlhc2VzKSB7XG4gICAgICAgIGFsaWFzID0gdGhpcy5fZ2V0TWluaWZpZWRBbGlhcyhhbGlhcywgdGhyb3VnaEFzLCB0b3BMZXZlbEluZm8ub3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAgIGAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRocm91Z2hBcyl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoQXJyYXkuaXNBcnJheShhdHRyKSA/IGF0dHJbMF0gOiBhdHRyKX1gLFxuICAgICAgICBcIkFTXCIsXG4gICAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGFsaWFzKVxuICAgICAgXSk7XG4gICAgfSk7XG4gICAgY29uc3QgYXNzb2NpYXRpb24gPSBpbmNsdWRlLmFzc29jaWF0aW9uO1xuICAgIGNvbnN0IHBhcmVudElzVG9wID0gIWluY2x1ZGUucGFyZW50LmFzc29jaWF0aW9uICYmIGluY2x1ZGUucGFyZW50Lm1vZGVsLm5hbWUgPT09IHRvcExldmVsSW5mby5vcHRpb25zLm1vZGVsLm5hbWU7XG4gICAgY29uc3QgdGFibGVTb3VyY2UgPSBwYXJlbnRUYWJsZU5hbWU7XG4gICAgY29uc3QgaWRlbnRTb3VyY2UgPSBhc3NvY2lhdGlvbi5pZGVudGlmaWVyRmllbGQ7XG4gICAgY29uc3QgdGFibGVUYXJnZXQgPSBpbmNsdWRlQXMuaW50ZXJuYWxBcztcbiAgICBjb25zdCBpZGVudFRhcmdldCA9IGFzc29jaWF0aW9uLmZvcmVpZ25JZGVudGlmaWVyRmllbGQ7XG4gICAgY29uc3QgYXR0clRhcmdldCA9IGFzc29jaWF0aW9uLnRhcmdldEtleUZpZWxkO1xuICAgIGNvbnN0IGpvaW5UeXBlID0gaW5jbHVkZS5yZXF1aXJlZCA/IFwiSU5ORVIgSk9JTlwiIDogaW5jbHVkZS5yaWdodCAmJiB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzW1wiUklHSFQgSk9JTlwiXSA/IFwiUklHSFQgT1VURVIgSk9JTlwiIDogXCJMRUZUIE9VVEVSIEpPSU5cIjtcbiAgICBsZXQgam9pbkJvZHk7XG4gICAgbGV0IGpvaW5Db25kaXRpb247XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAgIG1haW46IFtdLFxuICAgICAgc3ViUXVlcnk6IFtdXG4gICAgfTtcbiAgICBsZXQgYXR0clNvdXJjZSA9IGFzc29jaWF0aW9uLnNvdXJjZUtleTtcbiAgICBsZXQgc291cmNlSm9pbk9uO1xuICAgIGxldCB0YXJnZXRKb2luT247XG4gICAgbGV0IHRocm91Z2hXaGVyZTtcbiAgICBsZXQgdGFyZ2V0V2hlcmU7XG4gICAgaWYgKHRvcExldmVsSW5mby5vcHRpb25zLmluY2x1ZGVJZ25vcmVBdHRyaWJ1dGVzICE9PSBmYWxzZSkge1xuICAgICAgZm9yIChjb25zdCBhdHRyIG9mIHRocm91Z2hBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMubWFpbi5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRvcExldmVsSW5mby5zdWJRdWVyeSkge1xuICAgICAgYXR0clNvdXJjZSA9IGFzc29jaWF0aW9uLnNvdXJjZUtleUZpZWxkO1xuICAgIH1cbiAgICBpZiAodG9wTGV2ZWxJbmZvLnN1YlF1ZXJ5ICYmICFpbmNsdWRlLnN1YlF1ZXJ5ICYmICFpbmNsdWRlLnBhcmVudC5zdWJRdWVyeSAmJiBpbmNsdWRlLnBhcmVudC5tb2RlbCAhPT0gdG9wTGV2ZWxJbmZvLm9wdGlvbnMubWFpbk1vZGVsKSB7XG4gICAgICBhdHRyU291cmNlID0gYXNzb2NpYXRpb24uc291cmNlS2V5RmllbGQ7XG4gICAgfVxuICAgIGlmICh0b3BMZXZlbEluZm8uc3ViUXVlcnkgJiYgIWluY2x1ZGUuc3ViUXVlcnkgJiYgaW5jbHVkZS5wYXJlbnQuc3ViUXVlcnkgJiYgIXBhcmVudElzVG9wKSB7XG4gICAgICBjb25zdCBqb2luU291cmNlID0gdGhpcy5fZ2V0QWxpYXNGb3JGaWVsZCh0YWJsZVNvdXJjZSwgYCR7dGFibGVTb3VyY2V9LiR7YXR0clNvdXJjZX1gLCB0b3BMZXZlbEluZm8ub3B0aW9ucykgfHwgYCR7dGFibGVTb3VyY2V9LiR7YXR0clNvdXJjZX1gO1xuICAgICAgc291cmNlSm9pbk9uID0gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoam9pblNvdXJjZSl9ID0gYDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYWxpYXNlZFNvdXJjZSA9IHRoaXMuX2dldEFsaWFzRm9yRmllbGQodGFibGVTb3VyY2UsIGF0dHJTb3VyY2UsIHRvcExldmVsSW5mby5vcHRpb25zKSB8fCBhdHRyU291cmNlO1xuICAgICAgc291cmNlSm9pbk9uID0gYCR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlU291cmNlKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhbGlhc2VkU291cmNlKX0gPSBgO1xuICAgIH1cbiAgICBzb3VyY2VKb2luT24gKz0gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIodGhyb3VnaEFzKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihpZGVudFNvdXJjZSl9YDtcbiAgICB0YXJnZXRKb2luT24gPSBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0YWJsZVRhcmdldCl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0clRhcmdldCl9ID0gYDtcbiAgICB0YXJnZXRKb2luT24gKz0gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIodGhyb3VnaEFzKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihpZGVudFRhcmdldCl9YDtcbiAgICBpZiAodGhyb3VnaC53aGVyZSkge1xuICAgICAgdGhyb3VnaFdoZXJlID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnModGhyb3VnaC53aGVyZSwgdGhpcy5zZXF1ZWxpemUubGl0ZXJhbCh0aGlzLnF1b3RlSWRlbnRpZmllcih0aHJvdWdoQXMpKSwgdGhyb3VnaC5tb2RlbCk7XG4gICAgfVxuICAgIHRoaXMuYWxpYXNBcyhpbmNsdWRlQXMuaW50ZXJuYWxBcywgdG9wTGV2ZWxJbmZvKTtcbiAgICBqb2luQm9keSA9IGAoICR7dGhpcy5xdW90ZVRhYmxlKHRocm91Z2hUYWJsZSwgdGhyb3VnaEFzKX0gSU5ORVIgSk9JTiAke3RoaXMucXVvdGVUYWJsZShpbmNsdWRlLm1vZGVsLmdldFRhYmxlTmFtZSgpLCBpbmNsdWRlQXMuaW50ZXJuYWxBcyl9IE9OICR7dGFyZ2V0Sm9pbk9ufWA7XG4gICAgaWYgKHRocm91Z2hXaGVyZSkge1xuICAgICAgam9pbkJvZHkgKz0gYCBBTkQgJHt0aHJvdWdoV2hlcmV9YDtcbiAgICB9XG4gICAgam9pbkJvZHkgKz0gXCIpXCI7XG4gICAgam9pbkNvbmRpdGlvbiA9IHNvdXJjZUpvaW5PbjtcbiAgICBpZiAoaW5jbHVkZS53aGVyZSB8fCBpbmNsdWRlLnRocm91Z2gud2hlcmUpIHtcbiAgICAgIGlmIChpbmNsdWRlLndoZXJlKSB7XG4gICAgICAgIHRhcmdldFdoZXJlID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnMoaW5jbHVkZS53aGVyZSwgdGhpcy5zZXF1ZWxpemUubGl0ZXJhbCh0aGlzLnF1b3RlSWRlbnRpZmllcihpbmNsdWRlQXMuaW50ZXJuYWxBcykpLCBpbmNsdWRlLm1vZGVsLCB0b3BMZXZlbEluZm8ub3B0aW9ucyk7XG4gICAgICAgIGlmICh0YXJnZXRXaGVyZSkge1xuICAgICAgICAgIGpvaW5Db25kaXRpb24gKz0gYCBBTkQgJHt0YXJnZXRXaGVyZX1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2dlbmVyYXRlU3ViUXVlcnlGaWx0ZXIoaW5jbHVkZSwgaW5jbHVkZUFzLCB0b3BMZXZlbEluZm8pO1xuICAgIHJldHVybiB7XG4gICAgICBqb2luOiBqb2luVHlwZSxcbiAgICAgIGJvZHk6IGpvaW5Cb2R5LFxuICAgICAgY29uZGl0aW9uOiBqb2luQ29uZGl0aW9uLFxuICAgICAgYXR0cmlidXRlc1xuICAgIH07XG4gIH1cbiAgYWxpYXNBcyhhcywgdG9wTGV2ZWxJbmZvKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5taW5pZnlBbGlhc2VzICYmIGFzLmxlbmd0aCA+PSA2NCkge1xuICAgICAgY29uc3QgYWxpYXMgPSBgJSR7dG9wTGV2ZWxJbmZvLm9wdGlvbnMuaW5jbHVkZUFsaWFzZXMuc2l6ZX1gO1xuICAgICAgdG9wTGV2ZWxJbmZvLm9wdGlvbnMuaW5jbHVkZUFsaWFzZXMuc2V0KGFsaWFzLCBhcyk7XG4gICAgfVxuICB9XG4gIF9nZW5lcmF0ZVN1YlF1ZXJ5RmlsdGVyKGluY2x1ZGUsIGluY2x1ZGVBcywgdG9wTGV2ZWxJbmZvKSB7XG4gICAgaWYgKCF0b3BMZXZlbEluZm8uc3ViUXVlcnkgfHwgIWluY2x1ZGUuc3ViUXVlcnlGaWx0ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0b3BMZXZlbEluZm8ub3B0aW9ucy53aGVyZSkge1xuICAgICAgdG9wTGV2ZWxJbmZvLm9wdGlvbnMud2hlcmUgPSB7fTtcbiAgICB9XG4gICAgbGV0IHBhcmVudCA9IGluY2x1ZGU7XG4gICAgbGV0IGNoaWxkID0gaW5jbHVkZTtcbiAgICBsZXQgbmVzdGVkSW5jbHVkZXMgPSB0aGlzLl9nZXRSZXF1aXJlZENsb3N1cmUoaW5jbHVkZSkuaW5jbHVkZTtcbiAgICBsZXQgcXVlcnk7XG4gICAgd2hpbGUgKHBhcmVudCA9IHBhcmVudC5wYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQucGFyZW50ICYmICFwYXJlbnQucmVxdWlyZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudC5zdWJRdWVyeUZpbHRlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuZXN0ZWRJbmNsdWRlcyA9IFtfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBjaGlsZCksIHsgaW5jbHVkZTogbmVzdGVkSW5jbHVkZXMsIGF0dHJpYnV0ZXM6IFtdIH0pXTtcbiAgICAgIGNoaWxkID0gcGFyZW50O1xuICAgIH1cbiAgICBjb25zdCB0b3BJbmNsdWRlID0gbmVzdGVkSW5jbHVkZXNbMF07XG4gICAgY29uc3QgdG9wUGFyZW50ID0gdG9wSW5jbHVkZS5wYXJlbnQ7XG4gICAgY29uc3QgdG9wQXNzb2NpYXRpb24gPSB0b3BJbmNsdWRlLmFzc29jaWF0aW9uO1xuICAgIHRvcEluY2x1ZGUuYXNzb2NpYXRpb24gPSB2b2lkIDA7XG4gICAgaWYgKHRvcEluY2x1ZGUudGhyb3VnaCAmJiBPYmplY3QodG9wSW5jbHVkZS50aHJvdWdoLm1vZGVsKSA9PT0gdG9wSW5jbHVkZS50aHJvdWdoLm1vZGVsKSB7XG4gICAgICBxdWVyeSA9IHRoaXMuc2VsZWN0UXVlcnkodG9wSW5jbHVkZS50aHJvdWdoLm1vZGVsLmdldFRhYmxlTmFtZSgpLCB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IFt0b3BJbmNsdWRlLnRocm91Z2gubW9kZWwucHJpbWFyeUtleUZpZWxkXSxcbiAgICAgICAgaW5jbHVkZTogTW9kZWwuX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cyh7XG4gICAgICAgICAgbW9kZWw6IHRvcEluY2x1ZGUudGhyb3VnaC5tb2RlbCxcbiAgICAgICAgICBpbmNsdWRlOiBbe1xuICAgICAgICAgICAgYXNzb2NpYXRpb246IHRvcEFzc29jaWF0aW9uLnRvVGFyZ2V0LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgICB3aGVyZTogdG9wSW5jbHVkZS53aGVyZSxcbiAgICAgICAgICAgIGluY2x1ZGU6IHRvcEluY2x1ZGUuaW5jbHVkZVxuICAgICAgICAgIH1dXG4gICAgICAgIH0pLmluY2x1ZGUsXG4gICAgICAgIG1vZGVsOiB0b3BJbmNsdWRlLnRocm91Z2gubW9kZWwsXG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgW09wLmFuZF06IFtcbiAgICAgICAgICAgIHRoaXMuc2VxdWVsaXplLmxpdGVyYWwoW1xuICAgICAgICAgICAgICBgJHt0aGlzLnF1b3RlVGFibGUodG9wUGFyZW50Lm1vZGVsLm5hbWUpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKHRvcFBhcmVudC5tb2RlbC5wcmltYXJ5S2V5RmllbGQpfWAsXG4gICAgICAgICAgICAgIGAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRvcEluY2x1ZGUudGhyb3VnaC5tb2RlbC5uYW1lKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0b3BBc3NvY2lhdGlvbi5pZGVudGlmaWVyRmllbGQpfWBcbiAgICAgICAgICAgIF0uam9pbihcIiA9IFwiKSksXG4gICAgICAgICAgICB0b3BJbmNsdWRlLnRocm91Z2gud2hlcmVcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIGxpbWl0OiAxLFxuICAgICAgICBpbmNsdWRlSWdub3JlQXR0cmlidXRlczogZmFsc2VcbiAgICAgIH0sIHRvcEluY2x1ZGUudGhyb3VnaC5tb2RlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlzQmVsb25nc1RvID0gdG9wQXNzb2NpYXRpb24uYXNzb2NpYXRpb25UeXBlID09PSBcIkJlbG9uZ3NUb1wiO1xuICAgICAgY29uc3Qgc291cmNlRmllbGQgPSBpc0JlbG9uZ3NUbyA/IHRvcEFzc29jaWF0aW9uLmlkZW50aWZpZXJGaWVsZCA6IHRvcEFzc29jaWF0aW9uLnNvdXJjZUtleUZpZWxkIHx8IHRvcFBhcmVudC5tb2RlbC5wcmltYXJ5S2V5RmllbGQ7XG4gICAgICBjb25zdCB0YXJnZXRGaWVsZCA9IGlzQmVsb25nc1RvID8gdG9wQXNzb2NpYXRpb24uc291cmNlS2V5RmllbGQgfHwgdG9wSW5jbHVkZS5tb2RlbC5wcmltYXJ5S2V5RmllbGQgOiB0b3BBc3NvY2lhdGlvbi5pZGVudGlmaWVyRmllbGQ7XG4gICAgICBjb25zdCBqb2luID0gW1xuICAgICAgICBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0b3BJbmNsdWRlLmFzKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0YXJnZXRGaWVsZCl9YCxcbiAgICAgICAgYCR7dGhpcy5xdW90ZVRhYmxlKHRvcFBhcmVudC5hcyB8fCB0b3BQYXJlbnQubW9kZWwubmFtZSl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoc291cmNlRmllbGQpfWBcbiAgICAgIF0uam9pbihcIiA9IFwiKTtcbiAgICAgIHF1ZXJ5ID0gdGhpcy5zZWxlY3RRdWVyeSh0b3BJbmNsdWRlLm1vZGVsLmdldFRhYmxlTmFtZSgpLCB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IFt0YXJnZXRGaWVsZF0sXG4gICAgICAgIGluY2x1ZGU6IE1vZGVsLl92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHModG9wSW5jbHVkZSkuaW5jbHVkZSxcbiAgICAgICAgbW9kZWw6IHRvcEluY2x1ZGUubW9kZWwsXG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgW09wLmFuZF06IFtcbiAgICAgICAgICAgIHRvcEluY2x1ZGUud2hlcmUsXG4gICAgICAgICAgICB7IFtPcC5qb2luXTogdGhpcy5zZXF1ZWxpemUubGl0ZXJhbChqb2luKSB9XG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBsaW1pdDogMSxcbiAgICAgICAgdGFibGVBczogdG9wSW5jbHVkZS5hcyxcbiAgICAgICAgaW5jbHVkZUlnbm9yZUF0dHJpYnV0ZXM6IGZhbHNlXG4gICAgICB9LCB0b3BJbmNsdWRlLm1vZGVsKTtcbiAgICB9XG4gICAgaWYgKCF0b3BMZXZlbEluZm8ub3B0aW9ucy53aGVyZVtPcC5hbmRdKSB7XG4gICAgICB0b3BMZXZlbEluZm8ub3B0aW9ucy53aGVyZVtPcC5hbmRdID0gW107XG4gICAgfVxuICAgIHRvcExldmVsSW5mby5vcHRpb25zLndoZXJlW2BfXyR7aW5jbHVkZUFzLmludGVybmFsQXN9YF0gPSB0aGlzLnNlcXVlbGl6ZS5saXRlcmFsKFtcbiAgICAgIFwiKFwiLFxuICAgICAgcXVlcnkucmVwbGFjZSgvOyQvLCBcIlwiKSxcbiAgICAgIFwiKVwiLFxuICAgICAgXCJJUyBOT1QgTlVMTFwiXG4gICAgXS5qb2luKFwiIFwiKSk7XG4gIH1cbiAgX2dldFJlcXVpcmVkQ2xvc3VyZShpbmNsdWRlKSB7XG4gICAgY29uc3QgY29weSA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGluY2x1ZGUpLCB7IGF0dHJpYnV0ZXM6IFtdLCBpbmNsdWRlOiBbXSB9KTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbmNsdWRlLmluY2x1ZGUpKSB7XG4gICAgICBjb3B5LmluY2x1ZGUgPSBpbmNsdWRlLmluY2x1ZGUuZmlsdGVyKChpKSA9PiBpLnJlcXVpcmVkKS5tYXAoKGluYykgPT4gdGhpcy5fZ2V0UmVxdWlyZWRDbG9zdXJlKGluYykpO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbiAgfVxuICBnZXRRdWVyeU9yZGVycyhvcHRpb25zLCBtb2RlbCwgc3ViUXVlcnkpIHtcbiAgICBjb25zdCBtYWluUXVlcnlPcmRlciA9IFtdO1xuICAgIGNvbnN0IHN1YlF1ZXJ5T3JkZXIgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLm9yZGVyKSkge1xuICAgICAgZm9yIChsZXQgb3JkZXIgb2Ygb3B0aW9ucy5vcmRlcikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3JkZXIpKSB7XG4gICAgICAgICAgb3JkZXIgPSBbb3JkZXJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWJRdWVyeSAmJiBBcnJheS5pc0FycmF5KG9yZGVyKSAmJiBvcmRlclswXSAmJiAhKG9yZGVyWzBdIGluc3RhbmNlb2YgQXNzb2NpYXRpb24pICYmICEodHlwZW9mIG9yZGVyWzBdID09PSBcImZ1bmN0aW9uXCIgJiYgb3JkZXJbMF0ucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpICYmICEodHlwZW9mIG9yZGVyWzBdLm1vZGVsID09PSBcImZ1bmN0aW9uXCIgJiYgb3JkZXJbMF0ubW9kZWwucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpICYmICEodHlwZW9mIG9yZGVyWzBdID09PSBcInN0cmluZ1wiICYmIG1vZGVsICYmIG1vZGVsLmFzc29jaWF0aW9ucyAhPT0gdm9pZCAwICYmIG1vZGVsLmFzc29jaWF0aW9uc1tvcmRlclswXV0pKSB7XG4gICAgICAgICAgY29uc3QgZmllbGQgPSBtb2RlbC5yYXdBdHRyaWJ1dGVzW29yZGVyWzBdXSA/IG1vZGVsLnJhd0F0dHJpYnV0ZXNbb3JkZXJbMF1dLmZpZWxkIDogb3JkZXJbMF07XG4gICAgICAgICAgY29uc3Qgc3ViUXVlcnlBbGlhcyA9IHRoaXMuX2dldEFsaWFzRm9yRmllbGQodGhpcy5xdW90ZUlkZW50aWZpZXIobW9kZWwubmFtZSksIGZpZWxkLCBvcHRpb25zKTtcbiAgICAgICAgICBsZXQgcGFyZW50ID0gbnVsbDtcbiAgICAgICAgICBsZXQgb3JkZXJUb1F1b3RlID0gW107XG4gICAgICAgICAgaWYgKHN1YlF1ZXJ5QWxpYXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG9yZGVyVG9RdW90ZSA9IG9yZGVyO1xuICAgICAgICAgICAgcGFyZW50ID0gbW9kZWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9yZGVyVG9RdW90ZSA9IFtzdWJRdWVyeUFsaWFzLCBvcmRlci5sZW5ndGggPiAxID8gb3JkZXJbMV0gOiBcIkFTQ1wiXTtcbiAgICAgICAgICAgIHBhcmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN1YlF1ZXJ5T3JkZXIucHVzaCh0aGlzLnF1b3RlKG9yZGVyVG9RdW90ZSwgcGFyZW50LCBcIi0+XCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzICYmIG1vZGVsKSB7XG4gICAgICAgICAgY29uc3QgYWxpYXNlZEF0dHJpYnV0ZSA9IG9wdGlvbnMuYXR0cmlidXRlcy5maW5kKChhdHRyKSA9PiBBcnJheS5pc0FycmF5KGF0dHIpICYmIGF0dHJbMV0gJiYgKGF0dHJbMF0gPT09IG9yZGVyWzBdIHx8IGF0dHJbMV0gPT09IG9yZGVyWzBdKSk7XG4gICAgICAgICAgaWYgKGFsaWFzZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG1vZGVsLm5hbWUpO1xuICAgICAgICAgICAgY29uc3QgYWxpYXMgPSB0aGlzLl9nZXRBbGlhc0ZvckZpZWxkKG1vZGVsTmFtZSwgYWxpYXNlZEF0dHJpYnV0ZVsxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBvcmRlclswXSA9IG5ldyBVdGlscy5Db2woYWxpYXMgfHwgYWxpYXNlZEF0dHJpYnV0ZVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1haW5RdWVyeU9yZGVyLnB1c2godGhpcy5xdW90ZShvcmRlciwgbW9kZWwsIFwiLT5cIikpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5vcmRlciBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgY29uc3Qgc3FsID0gdGhpcy5xdW90ZShvcHRpb25zLm9yZGVyLCBtb2RlbCwgXCItPlwiKTtcbiAgICAgIGlmIChzdWJRdWVyeSkge1xuICAgICAgICBzdWJRdWVyeU9yZGVyLnB1c2goc3FsKTtcbiAgICAgIH1cbiAgICAgIG1haW5RdWVyeU9yZGVyLnB1c2goc3FsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3JkZXIgbXVzdCBiZSB0eXBlIG9mIGFycmF5IG9yIGluc3RhbmNlIG9mIGEgdmFsaWQgc2VxdWVsaXplIG1ldGhvZC5cIik7XG4gICAgfVxuICAgIHJldHVybiB7IG1haW5RdWVyeU9yZGVyLCBzdWJRdWVyeU9yZGVyIH07XG4gIH1cbiAgX3Rocm93T25FbXB0eUF0dHJpYnV0ZXMoYXR0cmlidXRlcywgZXh0cmFJbmZvID0ge30pIHtcbiAgICBpZiAoYXR0cmlidXRlcy5sZW5ndGggPiAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGFzUGFydCA9IGV4dHJhSW5mby5hcyAmJiBgYXMgJHtleHRyYUluZm8uYXN9YCB8fCBcIlwiO1xuICAgIGNvbnN0IG5hbWVQYXJ0ID0gZXh0cmFJbmZvLm1vZGVsTmFtZSAmJiBgZm9yIG1vZGVsICcke2V4dHJhSW5mby5tb2RlbE5hbWV9J2AgfHwgXCJcIjtcbiAgICBjb25zdCBtZXNzYWdlID0gYEF0dGVtcHRlZCBhIFNFTEVDVCBxdWVyeSAke25hbWVQYXJ0fSAke2FzUGFydH0gd2l0aG91dCBzZWxlY3RpbmcgYW55IGNvbHVtbnNgO1xuICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvci5RdWVyeUVycm9yKG1lc3NhZ2UucmVwbGFjZSgvICsvZywgXCIgXCIpKTtcbiAgfVxuICBzZWxlY3RGcm9tVGFibGVGcmFnbWVudChvcHRpb25zLCBtb2RlbCwgYXR0cmlidXRlcywgdGFibGVzLCBtYWluVGFibGVBcykge1xuICAgIHRoaXMuX3Rocm93T25FbXB0eUF0dHJpYnV0ZXMoYXR0cmlidXRlcywgeyBtb2RlbE5hbWU6IG1vZGVsICYmIG1vZGVsLm5hbWUsIGFzOiBtYWluVGFibGVBcyB9KTtcbiAgICBsZXQgZnJhZ21lbnQgPSBgU0VMRUNUICR7YXR0cmlidXRlcy5qb2luKFwiLCBcIil9IEZST00gJHt0YWJsZXN9YDtcbiAgICBpZiAobWFpblRhYmxlQXMpIHtcbiAgICAgIGZyYWdtZW50ICs9IGAgJHt0aGlzLmdldEFsaWFzVG9rZW4oKX0gJHttYWluVGFibGVBc31gO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pbmRleEhpbnRzICYmIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXhIaW50cykge1xuICAgICAgZm9yIChjb25zdCBoaW50IG9mIG9wdGlvbnMuaW5kZXhIaW50cykge1xuICAgICAgICBpZiAoSW5kZXhIaW50c1toaW50LnR5cGVdKSB7XG4gICAgICAgICAgZnJhZ21lbnQgKz0gYCAke0luZGV4SGludHNbaGludC50eXBlXX0gSU5ERVggKCR7aGludC52YWx1ZXMubWFwKChpbmRleE5hbWUpID0+IHRoaXMucXVvdGVJZGVudGlmaWVycyhpbmRleE5hbWUpKS5qb2luKFwiLFwiKX0pYDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cbiAgYWRkTGltaXRBbmRPZmZzZXQob3B0aW9ucykge1xuICAgIGxldCBmcmFnbWVudCA9IFwiXCI7XG4gICAgaWYgKG9wdGlvbnMub2Zmc2V0ICE9IG51bGwgJiYgb3B0aW9ucy5saW1pdCA9PSBudWxsKSB7XG4gICAgICBmcmFnbWVudCArPSBcIiBMSU1JVCBcIiArIHRoaXMuZXNjYXBlKG9wdGlvbnMub2Zmc2V0KSArIFwiLCBcIiArIDFlMTM7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmxpbWl0ICE9IG51bGwpIHtcbiAgICAgIGlmIChvcHRpb25zLm9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIGZyYWdtZW50ICs9IFwiIExJTUlUIFwiICsgdGhpcy5lc2NhcGUob3B0aW9ucy5vZmZzZXQpICsgXCIsIFwiICsgdGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnbWVudCArPSBcIiBMSU1JVCBcIiArIHRoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cbiAgaGFuZGxlU2VxdWVsaXplTWV0aG9kKHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLk9wZXJhdG9yTWFwLCBzbXRoLmNvbXBhcmF0b3IpKSB7XG4gICAgICBzbXRoLmNvbXBhcmF0b3IgPSB0aGlzLk9wZXJhdG9yTWFwW3NtdGguY29tcGFyYXRvcl07XG4gICAgfVxuICAgIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuV2hlcmUpIHtcbiAgICAgIGxldCB2YWx1ZSA9IHNtdGgubG9naWM7XG4gICAgICBsZXQga2V5O1xuICAgICAgaWYgKHNtdGguYXR0cmlidXRlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIGtleSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKHNtdGguYXR0cmlidXRlLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5ID0gYCR7dGhpcy5xdW90ZVRhYmxlKHNtdGguYXR0cmlidXRlLk1vZGVsLm5hbWUpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKHNtdGguYXR0cmlidXRlLmZpZWxkIHx8IHNtdGguYXR0cmlidXRlLmZpZWxkTmFtZSl9YDtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKHZhbHVlLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICAgICAgICBpZiAodmFsdWUgPT09IFwiTlVMTFwiKSB7XG4gICAgICAgICAgaWYgKHNtdGguY29tcGFyYXRvciA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgIHNtdGguY29tcGFyYXRvciA9IFwiSVNcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNtdGguY29tcGFyYXRvciA9PT0gXCIhPVwiKSB7XG4gICAgICAgICAgICBzbXRoLmNvbXBhcmF0b3IgPSBcIklTIE5PVFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdLmpvaW4oYCAke3NtdGguY29tcGFyYXRvcn0gYCk7XG4gICAgICB9XG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aGVyZUl0ZW1RdWVyeShzbXRoLmF0dHJpYnV0ZSwgdmFsdWUsIHtcbiAgICAgICAgICBtb2RlbDogZmFjdG9yeVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChbdGhpcy5PcGVyYXRvck1hcFtPcC5iZXR3ZWVuXSwgdGhpcy5PcGVyYXRvck1hcFtPcC5ub3RCZXR3ZWVuXV0uaW5jbHVkZXMoc210aC5jb21wYXJhdG9yKSkge1xuICAgICAgICB2YWx1ZSA9IGAke3RoaXMuZXNjYXBlKHZhbHVlWzBdKX0gQU5EICR7dGhpcy5lc2NhcGUodmFsdWVbMV0pfWA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmJvb2xlYW5WYWx1ZSh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuZXNjYXBlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gXCJOVUxMXCIpIHtcbiAgICAgICAgaWYgKHNtdGguY29tcGFyYXRvciA9PT0gXCI9XCIpIHtcbiAgICAgICAgICBzbXRoLmNvbXBhcmF0b3IgPSBcIklTXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNtdGguY29tcGFyYXRvciA9PT0gXCIhPVwiKSB7XG4gICAgICAgICAgc210aC5jb21wYXJhdG9yID0gXCJJUyBOT1RcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtrZXksIHZhbHVlXS5qb2luKGAgJHtzbXRoLmNvbXBhcmF0b3J9IGApO1xuICAgIH1cbiAgICBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkxpdGVyYWwpIHtcbiAgICAgIHJldHVybiBzbXRoLnZhbDtcbiAgICB9XG4gICAgaWYgKHNtdGggaW5zdGFuY2VvZiBVdGlscy5DYXN0KSB7XG4gICAgICBpZiAoc210aC52YWwgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2Qoc210aC52YWwsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gICAgICB9IGVsc2UgaWYgKF8uaXNQbGFpbk9iamVjdChzbXRoLnZhbCkpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy53aGVyZUl0ZW1zUXVlcnkoc210aC52YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5lc2NhcGUoc210aC52YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGBDQVNUKCR7cmVzdWx0fSBBUyAke3NtdGgudHlwZS50b1VwcGVyQ2FzZSgpfSlgO1xuICAgIH1cbiAgICBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkZuKSB7XG4gICAgICByZXR1cm4gYCR7c210aC5mbn0oJHtzbXRoLmFyZ3MubWFwKChhcmcpID0+IHtcbiAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChhcmcsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChhcmcpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2hlcmVJdGVtc1F1ZXJ5KGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXNjYXBlKHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIgPyBhcmcucmVwbGFjZSgvXFwkL2csIFwiJCQkXCIpIDogYXJnKTtcbiAgICAgIH0pLmpvaW4oXCIsIFwiKX0pYDtcbiAgICB9XG4gICAgaWYgKHNtdGggaW5zdGFuY2VvZiBVdGlscy5Db2wpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNtdGguY29sKSAmJiAhZmFjdG9yeSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBTZXF1ZWxpemUuY29sKCkgd2l0aCBhcnJheSBvdXRzaWRlIG9mIG9yZGVyIC8gZ3JvdXAgY2xhdXNlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHNtdGguY29sLnN0YXJ0c1dpdGgoXCIqXCIpKSB7XG4gICAgICAgIHJldHVybiBcIipcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnF1b3RlKHNtdGguY29sLCBmYWN0b3J5KTtcbiAgICB9XG4gICAgcmV0dXJuIHNtdGgudG9TdHJpbmcodGhpcywgZmFjdG9yeSk7XG4gIH1cbiAgd2hlcmVRdWVyeSh3aGVyZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy53aGVyZUl0ZW1zUXVlcnkod2hlcmUsIG9wdGlvbnMpO1xuICAgIGlmIChxdWVyeSAmJiBxdWVyeS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBgV0hFUkUgJHtxdWVyeX1gO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICB3aGVyZUl0ZW1zUXVlcnkod2hlcmUsIG9wdGlvbnMsIGJpbmRpbmcpIHtcbiAgICBpZiAod2hlcmUgPT09IG51bGwgfHwgd2hlcmUgPT09IHZvaWQgMCB8fCBVdGlscy5nZXRDb21wbGV4U2l6ZSh3aGVyZSkgPT09IDApIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdoZXJlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdXBwb3J0IGZvciBge3doZXJlOiAncmF3IHF1ZXJ5J31gIGhhcyBiZWVuIHJlbW92ZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGJpbmRpbmcgPSBiaW5kaW5nIHx8IFwiQU5EXCI7XG4gICAgaWYgKGJpbmRpbmdbMF0gIT09IFwiIFwiKVxuICAgICAgYmluZGluZyA9IGAgJHtiaW5kaW5nfSBgO1xuICAgIGlmIChfLmlzUGxhaW5PYmplY3Qod2hlcmUpKSB7XG4gICAgICBVdGlscy5nZXRDb21wbGV4S2V5cyh3aGVyZSkuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICBjb25zdCBpdGVtID0gd2hlcmVbcHJvcF07XG4gICAgICAgIGl0ZW1zLnB1c2godGhpcy53aGVyZUl0ZW1RdWVyeShwcm9wLCBpdGVtLCBvcHRpb25zKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbXMucHVzaCh0aGlzLndoZXJlSXRlbVF1ZXJ5KHZvaWQgMCwgd2hlcmUsIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1zLmxlbmd0aCAmJiBpdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0gJiYgaXRlbS5sZW5ndGgpLmpvaW4oYmluZGluZykgfHwgXCJcIjtcbiAgfVxuICB3aGVyZUl0ZW1RdWVyeShrZXksIHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBXSEVSRSBwYXJhbWV0ZXIgXCIke2tleX1cIiBoYXMgaW52YWxpZCBcInVuZGVmaW5lZFwiIHZhbHVlYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIGtleS5pbmNsdWRlcyhcIi5cIikgJiYgb3B0aW9ucy5tb2RlbCkge1xuICAgICAgY29uc3Qga2V5UGFydHMgPSBrZXkuc3BsaXQoXCIuXCIpO1xuICAgICAgaWYgKG9wdGlvbnMubW9kZWwucmF3QXR0cmlidXRlc1trZXlQYXJ0c1swXV0gJiYgb3B0aW9ucy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2tleVBhcnRzWzBdXS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkpTT04pIHtcbiAgICAgICAgY29uc3QgdG1wID0ge307XG4gICAgICAgIGNvbnN0IGZpZWxkMiA9IG9wdGlvbnMubW9kZWwucmF3QXR0cmlidXRlc1trZXlQYXJ0c1swXV07XG4gICAgICAgIF8uc2V0KHRtcCwga2V5UGFydHMuc2xpY2UoMSksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2hlcmVJdGVtUXVlcnkoZmllbGQyLmZpZWxkIHx8IGtleVBhcnRzWzBdLCB0bXAsIF9fc3ByZWFkVmFsdWVzKHsgZmllbGQ6IGZpZWxkMiB9LCBvcHRpb25zKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkID0gdGhpcy5fZmluZEZpZWxkKGtleSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZmllbGRUeXBlID0gZmllbGQgJiYgZmllbGQudHlwZSB8fCBvcHRpb25zLnR5cGU7XG4gICAgY29uc3QgaXNQbGFpbk9iamVjdCA9IF8uaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgY29uc3QgaXNBcnJheSA9ICFpc1BsYWluT2JqZWN0ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgIGtleSA9IHRoaXMuT3BlcmF0b3JzQWxpYXNNYXAgJiYgdGhpcy5PcGVyYXRvcnNBbGlhc01hcFtrZXldIHx8IGtleTtcbiAgICBpZiAoaXNQbGFpbk9iamVjdCkge1xuICAgICAgdmFsdWUgPSB0aGlzLl9yZXBsYWNlQWxpYXNlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlS2V5cyA9IGlzUGxhaW5PYmplY3QgJiYgVXRpbHMuZ2V0Q29tcGxleEtleXModmFsdWUpO1xuICAgIGlmIChrZXkgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdCAmJiB2YWx1ZUtleXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndoZXJlSXRlbVF1ZXJ5KHZhbHVlS2V5c1swXSwgdmFsdWVbdmFsdWVLZXlzWzBdXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgY29uc3Qgb3BWYWx1ZTIgPSBvcHRpb25zLmJpbmRQYXJhbSA/IFwiTlVMTFwiIDogdGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkKTtcbiAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBvcFZhbHVlMiwgdGhpcy5PcGVyYXRvck1hcFtPcC5pc10sIG9wdGlvbnMucHJlZml4KTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgY29uc3Qgb3BWYWx1ZTIgPSBvcHRpb25zLmJpbmRQYXJhbSA/IHRoaXMuZm9ybWF0KHZhbHVlLCBmaWVsZCwgb3B0aW9ucywgb3B0aW9ucy5iaW5kUGFyYW0pIDogdGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkKTtcbiAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBvcFZhbHVlMiwgdGhpcy5PcGVyYXRvck1hcFtPcC5lcV0sIG9wdGlvbnMucHJlZml4KTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kICYmICEoa2V5ICE9PSB2b2lkIDAgJiYgdmFsdWUgaW5zdGFuY2VvZiBVdGlscy5GbikpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZCh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChrZXkgPT09IHZvaWQgMCAmJiBpc0FycmF5KSB7XG4gICAgICBpZiAoVXRpbHMuY2FuVHJlYXRBcnJheUFzQW5kKHZhbHVlKSkge1xuICAgICAgICBrZXkgPSBPcC5hbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdXBwb3J0IGZvciBsaXRlcmFsIHJlcGxhY2VtZW50cyBpbiB0aGUgYHdoZXJlYCBvYmplY3QgaGFzIGJlZW4gcmVtb3ZlZC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXkgPT09IE9wLm9yIHx8IGtleSA9PT0gT3AuYW5kIHx8IGtleSA9PT0gT3Aubm90KSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2hlcmVHcm91cEJpbmQoa2V5LCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZVtPcC5vcl0pIHtcbiAgICAgIHJldHVybiB0aGlzLl93aGVyZUJpbmQodGhpcy5PcGVyYXRvck1hcFtPcC5vcl0sIGtleSwgdmFsdWVbT3Aub3JdLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlW09wLmFuZF0pIHtcbiAgICAgIHJldHVybiB0aGlzLl93aGVyZUJpbmQodGhpcy5PcGVyYXRvck1hcFtPcC5hbmRdLCBrZXksIHZhbHVlW09wLmFuZF0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheSAmJiBmaWVsZFR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQVJSQVkpIHtcbiAgICAgIGNvbnN0IG9wVmFsdWUyID0gb3B0aW9ucy5iaW5kUGFyYW0gPyB0aGlzLmZvcm1hdCh2YWx1ZSwgZmllbGQsIG9wdGlvbnMsIG9wdGlvbnMuYmluZFBhcmFtKSA6IHRoaXMuZXNjYXBlKHZhbHVlLCBmaWVsZCk7XG4gICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgb3BWYWx1ZTIsIHRoaXMuT3BlcmF0b3JNYXBbT3AuZXFdLCBvcHRpb25zLnByZWZpeCk7XG4gICAgfVxuICAgIGlmIChpc1BsYWluT2JqZWN0ICYmIGZpZWxkVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5KU09OICYmIG9wdGlvbnMuanNvbiAhPT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aGVyZUpTT04oa2V5LCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChpc1BsYWluT2JqZWN0ICYmIHZhbHVlS2V5cy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2hlcmVCaW5kKHRoaXMuT3BlcmF0b3JNYXBbT3AuYW5kXSwga2V5LCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChpc0FycmF5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2hlcmVQYXJzZVNpbmdsZVZhbHVlT2JqZWN0KGtleSwgZmllbGQsIE9wLmluLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChpc1BsYWluT2JqZWN0KSB7XG4gICAgICBpZiAodGhpcy5PcGVyYXRvck1hcFt2YWx1ZUtleXNbMF1dKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aGVyZVBhcnNlU2luZ2xlVmFsdWVPYmplY3Qoa2V5LCBmaWVsZCwgdmFsdWVLZXlzWzBdLCB2YWx1ZVt2YWx1ZUtleXNbMF1dLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl93aGVyZVBhcnNlU2luZ2xlVmFsdWVPYmplY3Qoa2V5LCBmaWVsZCwgdGhpcy5PcGVyYXRvck1hcFtPcC5lcV0sIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gT3AucGxhY2Vob2xkZXIpIHtcbiAgICAgIGNvbnN0IG9wVmFsdWUyID0gb3B0aW9ucy5iaW5kUGFyYW0gPyB0aGlzLmZvcm1hdCh2YWx1ZSwgZmllbGQsIG9wdGlvbnMsIG9wdGlvbnMuYmluZFBhcmFtKSA6IHRoaXMuZXNjYXBlKHZhbHVlLCBmaWVsZCk7XG4gICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKHRoaXMuT3BlcmF0b3JNYXBba2V5XSwgb3BWYWx1ZTIsIHRoaXMuT3BlcmF0b3JNYXBbT3AuZXFdLCBvcHRpb25zLnByZWZpeCk7XG4gICAgfVxuICAgIGNvbnN0IG9wVmFsdWUgPSBvcHRpb25zLmJpbmRQYXJhbSA/IHRoaXMuZm9ybWF0KHZhbHVlLCBmaWVsZCwgb3B0aW9ucywgb3B0aW9ucy5iaW5kUGFyYW0pIDogdGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkKTtcbiAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgb3BWYWx1ZSwgdGhpcy5PcGVyYXRvck1hcFtPcC5lcV0sIG9wdGlvbnMucHJlZml4KTtcbiAgfVxuICBfZmluZEZpZWxkKGtleSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmZpZWxkKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5maWVsZDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5yYXdBdHRyaWJ1dGVzICYmIG9wdGlvbnMubW9kZWwucmF3QXR0cmlidXRlc1trZXldKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV07XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZmllbGRSYXdBdHRyaWJ1dGVzTWFwICYmIG9wdGlvbnMubW9kZWwuZmllbGRSYXdBdHRyaWJ1dGVzTWFwW2tleV0pIHtcbiAgICAgIHJldHVybiBvcHRpb25zLm1vZGVsLmZpZWxkUmF3QXR0cmlidXRlc01hcFtrZXldO1xuICAgIH1cbiAgfVxuICBfd2hlcmVHcm91cEJpbmQoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJpbmRpbmcgPSBrZXkgPT09IE9wLm9yID8gdGhpcy5PcGVyYXRvck1hcFtPcC5vcl0gOiB0aGlzLk9wZXJhdG9yTWFwW09wLmFuZF07XG4gICAgY29uc3Qgb3V0ZXJCaW5kaW5nID0ga2V5ID09PSBPcC5ub3QgPyBcIk5PVCBcIiA6IFwiXCI7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICBsZXQgaXRlbVF1ZXJ5ID0gdGhpcy53aGVyZUl0ZW1zUXVlcnkoaXRlbSwgb3B0aW9ucywgdGhpcy5PcGVyYXRvck1hcFtPcC5hbmRdKTtcbiAgICAgICAgaWYgKGl0ZW1RdWVyeSAmJiBpdGVtUXVlcnkubGVuZ3RoICYmIChBcnJheS5pc0FycmF5KGl0ZW0pIHx8IF8uaXNQbGFpbk9iamVjdChpdGVtKSkgJiYgVXRpbHMuZ2V0Q29tcGxleFNpemUoaXRlbSkgPiAxKSB7XG4gICAgICAgICAgaXRlbVF1ZXJ5ID0gYCgke2l0ZW1RdWVyeX0pYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbVF1ZXJ5O1xuICAgICAgfSkuZmlsdGVyKChpdGVtKSA9PiBpdGVtICYmIGl0ZW0ubGVuZ3RoKTtcbiAgICAgIHZhbHVlID0gdmFsdWUubGVuZ3RoICYmIHZhbHVlLmpvaW4oYmluZGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gdGhpcy53aGVyZUl0ZW1zUXVlcnkodmFsdWUsIG9wdGlvbnMsIGJpbmRpbmcpO1xuICAgIH1cbiAgICBpZiAoKGtleSA9PT0gT3Aub3IgfHwga2V5ID09PSBPcC5ub3QpICYmICF2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwiMCA9IDFcIjtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID8gYCR7b3V0ZXJCaW5kaW5nfSgke3ZhbHVlfSlgIDogdm9pZCAwO1xuICB9XG4gIF93aGVyZUJpbmQoYmluZGluZywga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmIChfLmlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IFV0aWxzLmdldENvbXBsZXhLZXlzKHZhbHVlKS5tYXAoKHByb3ApID0+IHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW3Byb3BdO1xuICAgICAgICByZXR1cm4gdGhpcy53aGVyZUl0ZW1RdWVyeShrZXksIHsgW3Byb3BdOiBpdGVtIH0sIG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gdmFsdWUubWFwKChpdGVtKSA9PiB0aGlzLndoZXJlSXRlbVF1ZXJ5KGtleSwgaXRlbSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICB2YWx1ZSA9IHZhbHVlLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAmJiBpdGVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA/IGAoJHt2YWx1ZS5qb2luKGJpbmRpbmcpfSlgIDogdm9pZCAwO1xuICB9XG4gIF93aGVyZUpTT04oa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgbGV0IGJhc2VLZXkgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpO1xuICAgIGlmIChvcHRpb25zLnByZWZpeCkge1xuICAgICAgaWYgKG9wdGlvbnMucHJlZml4IGluc3RhbmNlb2YgVXRpbHMuTGl0ZXJhbCkge1xuICAgICAgICBiYXNlS2V5ID0gYCR7dGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2Qob3B0aW9ucy5wcmVmaXgpfS4ke2Jhc2VLZXl9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VLZXkgPSBgJHt0aGlzLnF1b3RlVGFibGUob3B0aW9ucy5wcmVmaXgpfS4ke2Jhc2VLZXl9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgVXRpbHMuZ2V0T3BlcmF0b3JzKHZhbHVlKS5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgY29uc3Qgd2hlcmUgPSB7XG4gICAgICAgIFtvcF06IHZhbHVlW29wXVxuICAgICAgfTtcbiAgICAgIGl0ZW1zLnB1c2godGhpcy53aGVyZUl0ZW1RdWVyeShrZXksIHdoZXJlLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyBqc29uOiBmYWxzZSB9KSkpO1xuICAgIH0pO1xuICAgIF8uZm9yT3duKHZhbHVlLCAoaXRlbSwgcHJvcCkgPT4ge1xuICAgICAgdGhpcy5fdHJhdmVyc2VKU09OKGl0ZW1zLCBiYXNlS2V5LCBwcm9wLCBpdGVtLCBbcHJvcF0pO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGl0ZW1zLmpvaW4odGhpcy5PcGVyYXRvck1hcFtPcC5hbmRdKTtcbiAgICByZXR1cm4gaXRlbXMubGVuZ3RoID4gMSA/IGAoJHtyZXN1bHR9KWAgOiByZXN1bHQ7XG4gIH1cbiAgX3RyYXZlcnNlSlNPTihpdGVtcywgYmFzZUtleSwgcHJvcCwgaXRlbSwgcGF0aCkge1xuICAgIGxldCBjYXN0O1xuICAgIGlmIChwYXRoW3BhdGgubGVuZ3RoIC0gMV0uaW5jbHVkZXMoXCI6OlwiKSkge1xuICAgICAgY29uc3QgdG1wID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdLnNwbGl0KFwiOjpcIik7XG4gICAgICBjYXN0ID0gdG1wWzFdO1xuICAgICAgcGF0aFtwYXRoLmxlbmd0aCAtIDFdID0gdG1wWzBdO1xuICAgIH1cbiAgICBsZXQgcGF0aEtleSA9IHRoaXMuanNvblBhdGhFeHRyYWN0aW9uUXVlcnkoYmFzZUtleSwgcGF0aCk7XG4gICAgaWYgKF8uaXNQbGFpbk9iamVjdChpdGVtKSkge1xuICAgICAgVXRpbHMuZ2V0T3BlcmF0b3JzKGl0ZW0pLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fdG9KU09OVmFsdWUoaXRlbVtvcF0pO1xuICAgICAgICBsZXQgaXNKc29uID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgb3AgPT09IE9wLmNvbnRhaW5zKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgIGlzSnNvbiA9IHRydWU7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXRoS2V5ID0gdGhpcy5qc29uUGF0aEV4dHJhY3Rpb25RdWVyeShiYXNlS2V5LCBwYXRoLCBpc0pzb24pO1xuICAgICAgICBpdGVtcy5wdXNoKHRoaXMud2hlcmVJdGVtUXVlcnkodGhpcy5fY2FzdEtleShwYXRoS2V5LCB2YWx1ZSwgY2FzdCksIHsgW29wXTogdmFsdWUgfSkpO1xuICAgICAgfSk7XG4gICAgICBfLmZvck93bihpdGVtLCAodmFsdWUsIGl0ZW1Qcm9wKSA9PiB7XG4gICAgICAgIHRoaXMuX3RyYXZlcnNlSlNPTihpdGVtcywgYmFzZUtleSwgaXRlbVByb3AsIHZhbHVlLCBwYXRoLmNvbmNhdChbaXRlbVByb3BdKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXRlbSA9IHRoaXMuX3RvSlNPTlZhbHVlKGl0ZW0pO1xuICAgIGl0ZW1zLnB1c2godGhpcy53aGVyZUl0ZW1RdWVyeSh0aGlzLl9jYXN0S2V5KHBhdGhLZXksIGl0ZW0sIGNhc3QpLCB7IFtPcC5lcV06IGl0ZW0gfSkpO1xuICB9XG4gIF90b0pTT05WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBfY2FzdEtleShrZXksIHZhbHVlLCBjYXN0LCBqc29uKSB7XG4gICAgY2FzdCA9IGNhc3QgfHwgdGhpcy5fZ2V0SnNvbkNhc3QoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZVswXSA6IHZhbHVlKTtcbiAgICBpZiAoY2FzdCkge1xuICAgICAgcmV0dXJuIG5ldyBVdGlscy5MaXRlcmFsKHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKG5ldyBVdGlscy5DYXN0KG5ldyBVdGlscy5MaXRlcmFsKGtleSksIGNhc3QsIGpzb24pKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVXRpbHMuTGl0ZXJhbChrZXkpO1xuICB9XG4gIF9nZXRKc29uQ2FzdCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBcImRvdWJsZSBwcmVjaXNpb25cIjtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIFwidGltZXN0YW1wdHpcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBcImJvb2xlYW5cIjtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIF9qb2luS2V5VmFsdWUoa2V5LCB2YWx1ZSwgY29tcGFyYXRvciwgcHJlZml4KSB7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmF0b3IgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2tleX0gYW5kICR7dmFsdWV9IGhhcyBubyBjb21wYXJhdG9yYCk7XG4gICAgfVxuICAgIGtleSA9IHRoaXMuX2dldFNhZmVLZXkoa2V5LCBwcmVmaXgpO1xuICAgIHJldHVybiBba2V5LCB2YWx1ZV0uam9pbihgICR7Y29tcGFyYXRvcn0gYCk7XG4gIH1cbiAgX2dldFNhZmVLZXkoa2V5LCBwcmVmaXgpIHtcbiAgICBpZiAoa2V5IGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICBrZXkgPSB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChrZXkpO1xuICAgICAgcmV0dXJuIHRoaXMuX3ByZWZpeEtleSh0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChrZXkpLCBwcmVmaXgpO1xuICAgIH1cbiAgICBpZiAoVXRpbHMuaXNDb2xTdHJpbmcoa2V5KSkge1xuICAgICAga2V5ID0ga2V5LnN1YnN0cigxLCBrZXkubGVuZ3RoIC0gMikuc3BsaXQoXCIuXCIpO1xuICAgICAgaWYgKGtleS5sZW5ndGggPiAyKSB7XG4gICAgICAgIGtleSA9IFtcbiAgICAgICAgICBrZXkuc2xpY2UoMCwgLTEpLmpvaW4oXCItPlwiKSxcbiAgICAgICAgICBrZXlba2V5Lmxlbmd0aCAtIDFdXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5Lm1hcCgoaWRlbnRpZmllcikgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoaWRlbnRpZmllcikpLmpvaW4oXCIuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHJlZml4S2V5KHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSksIHByZWZpeCk7XG4gIH1cbiAgX3ByZWZpeEtleShrZXksIHByZWZpeCkge1xuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgIGlmIChwcmVmaXggaW5zdGFuY2VvZiBVdGlscy5MaXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2QocHJlZml4KSwga2V5XS5qb2luKFwiLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdGhpcy5xdW90ZVRhYmxlKHByZWZpeCksIGtleV0uam9pbihcIi5cIik7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH1cbiAgX3doZXJlUGFyc2VTaW5nbGVWYWx1ZU9iamVjdChrZXksIGZpZWxkLCBwcm9wLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmIChwcm9wID09PSBPcC5ub3QpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBwcm9wID0gT3Aubm90SW47XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB0cnVlICYmIHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgICBwcm9wID0gT3AubmU7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBjb21wYXJhdG9yID0gdGhpcy5PcGVyYXRvck1hcFtwcm9wXSB8fCB0aGlzLk9wZXJhdG9yTWFwW09wLmVxXTtcbiAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgIGNhc2UgT3AuaW46XG4gICAgICBjYXNlIE9wLm5vdEluOlxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5MaXRlcmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIHZhbHVlLnZhbCwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgYCgke3ZhbHVlLm1hcCgoaXRlbSkgPT4gdGhpcy5lc2NhcGUoaXRlbSwgZmllbGQpKS5qb2luKFwiLCBcIil9KWAsIGNvbXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcGFyYXRvciA9PT0gdGhpcy5PcGVyYXRvck1hcFtPcC5pbl0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgXCIoTlVMTClcIiwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgY2FzZSBPcC5hbnk6XG4gICAgICBjYXNlIE9wLmFsbDpcbiAgICAgICAgY29tcGFyYXRvciA9IGAke3RoaXMuT3BlcmF0b3JNYXBbT3AuZXFdfSAke2NvbXBhcmF0b3J9YDtcbiAgICAgICAgaWYgKHZhbHVlW09wLnZhbHVlc10pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgYChWQUxVRVMgJHt2YWx1ZVtPcC52YWx1ZXNdLm1hcCgoaXRlbSkgPT4gYCgke3RoaXMuZXNjYXBlKGl0ZW0pfSlgKS5qb2luKFwiLCBcIil9KWAsIGNvbXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgYCgke3RoaXMuZXNjYXBlKHZhbHVlLCBmaWVsZCl9KWAsIGNvbXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICAgIGNhc2UgT3AuYmV0d2VlbjpcbiAgICAgIGNhc2UgT3Aubm90QmV0d2VlbjpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIGAke3RoaXMuZXNjYXBlKHZhbHVlWzBdLCBmaWVsZCl9IEFORCAke3RoaXMuZXNjYXBlKHZhbHVlWzFdLCBmaWVsZCl9YCwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgICAgY2FzZSBPcC5yYXc6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgJHJhd2Agd2hlcmUgcHJvcGVydHkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gIFVzZSBgc2VxdWVsaXplLmxpdGVyYWxgIGluc3RlYWQuXCIpO1xuICAgICAgY2FzZSBPcC5jb2w6XG4gICAgICAgIGNvbXBhcmF0b3IgPSB0aGlzLk9wZXJhdG9yTWFwW09wLmVxXTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdChcIi5cIik7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgdmFsdWUgPSBbXG4gICAgICAgICAgICB2YWx1ZS5zbGljZSgwLCAtMSkuam9pbihcIi0+XCIpLFxuICAgICAgICAgICAgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV1cbiAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCB2YWx1ZS5tYXAoKGlkZW50aWZpZXIpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGlkZW50aWZpZXIpKS5qb2luKFwiLlwiKSwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgICAgY2FzZSBPcC5zdGFydHNXaXRoOlxuICAgICAgY2FzZSBPcC5lbmRzV2l0aDpcbiAgICAgIGNhc2UgT3Auc3Vic3RyaW5nOlxuICAgICAgICBjb21wYXJhdG9yID0gdGhpcy5PcGVyYXRvck1hcFtPcC5saWtlXTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuTGl0ZXJhbCkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUudmFsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXR0ZXJuID0gYCR7dmFsdWV9JWA7XG4gICAgICAgIGlmIChwcm9wID09PSBPcC5lbmRzV2l0aClcbiAgICAgICAgICBwYXR0ZXJuID0gYCUke3ZhbHVlfWA7XG4gICAgICAgIGlmIChwcm9wID09PSBPcC5zdWJzdHJpbmcpXG4gICAgICAgICAgcGF0dGVybiA9IGAlJHt2YWx1ZX0lYDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIHRoaXMuZXNjYXBlKHBhdHRlcm4pLCBjb21wYXJhdG9yLCBvcHRpb25zLnByZWZpeCk7XG4gICAgfVxuICAgIGNvbnN0IGVzY2FwZU9wdGlvbnMgPSB7XG4gICAgICBhY2NlcHRTdHJpbmdzOiBjb21wYXJhdG9yLmluY2x1ZGVzKHRoaXMuT3BlcmF0b3JNYXBbT3AubGlrZV0pXG4gICAgfTtcbiAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgaWYgKHZhbHVlW09wLmNvbF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIHRoaXMud2hlcmVJdGVtUXVlcnkobnVsbCwgdmFsdWUpLCBjb21wYXJhdG9yLCBvcHRpb25zLnByZWZpeCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVbT3AuYW55XSkge1xuICAgICAgICBlc2NhcGVPcHRpb25zLmlzTGlzdCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBgKCR7dGhpcy5lc2NhcGUodmFsdWVbT3AuYW55XSwgZmllbGQsIGVzY2FwZU9wdGlvbnMpfSlgLCBgJHtjb21wYXJhdG9yfSAke3RoaXMuT3BlcmF0b3JNYXBbT3AuYW55XX1gLCBvcHRpb25zLnByZWZpeCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVbT3AuYWxsXSkge1xuICAgICAgICBlc2NhcGVPcHRpb25zLmlzTGlzdCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBgKCR7dGhpcy5lc2NhcGUodmFsdWVbT3AuYWxsXSwgZmllbGQsIGVzY2FwZU9wdGlvbnMpfSlgLCBgJHtjb21wYXJhdG9yfSAke3RoaXMuT3BlcmF0b3JNYXBbT3AuYWxsXX1gLCBvcHRpb25zLnByZWZpeCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiBjb21wYXJhdG9yID09PSB0aGlzLk9wZXJhdG9yTWFwW09wLmVxXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIHRoaXMuZXNjYXBlKHZhbHVlLCBmaWVsZCwgZXNjYXBlT3B0aW9ucyksIHRoaXMuT3BlcmF0b3JNYXBbT3AuaXNdLCBvcHRpb25zLnByZWZpeCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiBjb21wYXJhdG9yID09PSB0aGlzLk9wZXJhdG9yTWFwW09wLm5lXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIHRoaXMuZXNjYXBlKHZhbHVlLCBmaWVsZCwgZXNjYXBlT3B0aW9ucyksIHRoaXMuT3BlcmF0b3JNYXBbT3Aubm90XSwgb3B0aW9ucy5wcmVmaXgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgdGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkLCBlc2NhcGVPcHRpb25zKSwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICB9XG4gIGdldFdoZXJlQ29uZGl0aW9ucyhzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpIHtcbiAgICBjb25zdCB3aGVyZSA9IHt9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRhYmxlTmFtZSkpIHtcbiAgICAgIHRhYmxlTmFtZSA9IHRhYmxlTmFtZVswXTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRhYmxlTmFtZSkpIHtcbiAgICAgICAgdGFibGVOYW1lID0gdGFibGVOYW1lWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAocHJlcGVuZCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcmVwZW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHNtdGggJiYgc210aCBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gICAgfVxuICAgIGlmIChfLmlzUGxhaW5PYmplY3Qoc210aCkpIHtcbiAgICAgIHJldHVybiB0aGlzLndoZXJlSXRlbXNRdWVyeShzbXRoLCB7XG4gICAgICAgIG1vZGVsOiBmYWN0b3J5LFxuICAgICAgICBwcmVmaXg6IHByZXBlbmQgJiYgdGFibGVOYW1lLFxuICAgICAgICB0eXBlOiBvcHRpb25zLnR5cGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNtdGggPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHNtdGggPT09IFwiYmlnaW50XCIpIHtcbiAgICAgIGxldCBwcmltYXJ5S2V5cyA9IGZhY3RvcnkgPyBPYmplY3Qua2V5cyhmYWN0b3J5LnByaW1hcnlLZXlzKSA6IFtdO1xuICAgICAgaWYgKHByaW1hcnlLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcHJpbWFyeUtleXMgPSBwcmltYXJ5S2V5c1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByaW1hcnlLZXlzID0gXCJpZFwiO1xuICAgICAgfVxuICAgICAgd2hlcmVbcHJpbWFyeUtleXNdID0gc210aDtcbiAgICAgIHJldHVybiB0aGlzLndoZXJlSXRlbXNRdWVyeSh3aGVyZSwge1xuICAgICAgICBtb2RlbDogZmFjdG9yeSxcbiAgICAgICAgcHJlZml4OiBwcmVwZW5kICYmIHRhYmxlTmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc210aCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRoaXMud2hlcmVJdGVtc1F1ZXJ5KHNtdGgsIHtcbiAgICAgICAgbW9kZWw6IGZhY3RvcnksXG4gICAgICAgIHByZWZpeDogcHJlcGVuZCAmJiB0YWJsZU5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHNtdGgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lc2NhcGUoc210aCk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHNtdGgpKSB7XG4gICAgICBpZiAoc210aC5sZW5ndGggPT09IDAgfHwgc210aC5sZW5ndGggPiAwICYmIHNtdGhbMF0ubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gXCIxPTFcIjtcbiAgICAgIGlmIChVdGlscy5jYW5UcmVhdEFycmF5QXNBbmQoc210aCkpIHtcbiAgICAgICAgY29uc3QgX3NtdGggPSB7IFtPcC5hbmRdOiBzbXRoIH07XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyhfc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1cHBvcnQgZm9yIGxpdGVyYWwgcmVwbGFjZW1lbnRzIGluIHRoZSBgd2hlcmVgIG9iamVjdCBoYXMgYmVlbiByZW1vdmVkLlwiKTtcbiAgICB9XG4gICAgaWYgKHNtdGggPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMud2hlcmVJdGVtc1F1ZXJ5KHNtdGgsIHtcbiAgICAgICAgbW9kZWw6IGZhY3RvcnksXG4gICAgICAgIHByZWZpeDogcHJlcGVuZCAmJiB0YWJsZU5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHdoZXJlIG9wdGlvbiB2YWx1ZTogJHt1dGlsLmluc3BlY3Qoc210aCl9LiBQbGVhc2UgcmVmZXIgdG8gdGhlIFNlcXVlbGl6ZSBkb2N1bWVudGF0aW9uIHRvIGxlYXJuIG1vcmUgYWJvdXQgd2hpY2ggdmFsdWVzIGFyZSBhY2NlcHRlZCBhcyBwYXJ0IG9mIHRoZSB3aGVyZSBvcHRpb24uYCk7XG4gIH1cbiAgcGFyc2VDb25kaXRpb25PYmplY3QoY29uZGl0aW9ucywgcGF0aCkge1xuICAgIHBhdGggPSBwYXRoIHx8IFtdO1xuICAgIHJldHVybiBfLnJlZHVjZShjb25kaXRpb25zLCAocmVzdWx0LCB2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb25jYXQodGhpcy5wYXJzZUNvbmRpdGlvbk9iamVjdCh2YWx1ZSwgcGF0aC5jb25jYXQoa2V5KSkpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goeyBwYXRoOiBwYXRoLmNvbmNhdChrZXkpLCB2YWx1ZSB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuICB9XG4gIGJvb2xlYW5WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBhdXRoVGVzdFF1ZXJ5KCkge1xuICAgIHJldHVybiBcIlNFTEVDVCAxKzEgQVMgcmVzdWx0XCI7XG4gIH1cbn1cbk9iamVjdC5hc3NpZ24oUXVlcnlHZW5lcmF0b3IucHJvdG90eXBlLCByZXF1aXJlKFwiLi9xdWVyeS1nZW5lcmF0b3Ivb3BlcmF0b3JzXCIpKTtcbk9iamVjdC5hc3NpZ24oUXVlcnlHZW5lcmF0b3IucHJvdG90eXBlLCByZXF1aXJlKFwiLi9xdWVyeS1nZW5lcmF0b3IvdHJhbnNhY3Rpb25cIikpO1xubW9kdWxlLmV4cG9ydHMgPSBRdWVyeUdlbmVyYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWdlbmVyYXRvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-generator.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js":
/*!************************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst Op = __webpack_require__(/*! ../../../operators */ \"(action-browser)/../node_modules/sequelize/lib/operators.js\");\nconst Utils = __webpack_require__(/*! ../../../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst OperatorHelpers = {\n  OperatorMap: {\n    [Op.eq]: \"=\",\n    [Op.ne]: \"!=\",\n    [Op.gte]: \">=\",\n    [Op.gt]: \">\",\n    [Op.lte]: \"<=\",\n    [Op.lt]: \"<\",\n    [Op.not]: \"IS NOT\",\n    [Op.is]: \"IS\",\n    [Op.in]: \"IN\",\n    [Op.notIn]: \"NOT IN\",\n    [Op.like]: \"LIKE\",\n    [Op.notLike]: \"NOT LIKE\",\n    [Op.iLike]: \"ILIKE\",\n    [Op.notILike]: \"NOT ILIKE\",\n    [Op.startsWith]: \"LIKE\",\n    [Op.endsWith]: \"LIKE\",\n    [Op.substring]: \"LIKE\",\n    [Op.regexp]: \"~\",\n    [Op.notRegexp]: \"!~\",\n    [Op.iRegexp]: \"~*\",\n    [Op.notIRegexp]: \"!~*\",\n    [Op.between]: \"BETWEEN\",\n    [Op.notBetween]: \"NOT BETWEEN\",\n    [Op.overlap]: \"&&\",\n    [Op.contains]: \"@>\",\n    [Op.contained]: \"<@\",\n    [Op.adjacent]: \"-|-\",\n    [Op.strictLeft]: \"<<\",\n    [Op.strictRight]: \">>\",\n    [Op.noExtendRight]: \"&<\",\n    [Op.noExtendLeft]: \"&>\",\n    [Op.any]: \"ANY\",\n    [Op.all]: \"ALL\",\n    [Op.and]: \" AND \",\n    [Op.or]: \" OR \",\n    [Op.col]: \"COL\",\n    [Op.placeholder]: \"$$PLACEHOLDER$$\",\n    [Op.match]: \"@@\"\n  },\n  OperatorsAliasMap: {},\n  setOperatorsAliases(aliases) {\n    if (!aliases || _.isEmpty(aliases)) {\n      this.OperatorsAliasMap = false;\n    } else {\n      this.OperatorsAliasMap = __spreadValues({}, aliases);\n    }\n  },\n  _replaceAliases(orig) {\n    const obj = {};\n    if (!this.OperatorsAliasMap) {\n      return orig;\n    }\n    Utils.getOperators(orig).forEach((op) => {\n      const item = orig[op];\n      if (_.isPlainObject(item)) {\n        obj[op] = this._replaceAliases(item);\n      } else {\n        obj[op] = item;\n      }\n    });\n    _.forOwn(orig, (item, prop) => {\n      prop = this.OperatorsAliasMap[prop] || prop;\n      if (_.isPlainObject(item)) {\n        item = this._replaceAliases(item);\n      }\n      obj[prop] = item;\n    });\n    return obj;\n  }\n};\nmodule.exports = OperatorHelpers;\n//# sourceMappingURL=operators.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3Ivb3BlcmF0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMxQixXQUFXLG1CQUFPLENBQUMsdUZBQW9CO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQywrRUFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixnREFBZ0Q7QUFDaEQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvYWJzdHJhY3QvcXVlcnktZ2VuZXJhdG9yL29wZXJhdG9ycy5qcz9lZDUwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBPcCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9vcGVyYXRvcnNcIik7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsc1wiKTtcbmNvbnN0IE9wZXJhdG9ySGVscGVycyA9IHtcbiAgT3BlcmF0b3JNYXA6IHtcbiAgICBbT3AuZXFdOiBcIj1cIixcbiAgICBbT3AubmVdOiBcIiE9XCIsXG4gICAgW09wLmd0ZV06IFwiPj1cIixcbiAgICBbT3AuZ3RdOiBcIj5cIixcbiAgICBbT3AubHRlXTogXCI8PVwiLFxuICAgIFtPcC5sdF06IFwiPFwiLFxuICAgIFtPcC5ub3RdOiBcIklTIE5PVFwiLFxuICAgIFtPcC5pc106IFwiSVNcIixcbiAgICBbT3AuaW5dOiBcIklOXCIsXG4gICAgW09wLm5vdEluXTogXCJOT1QgSU5cIixcbiAgICBbT3AubGlrZV06IFwiTElLRVwiLFxuICAgIFtPcC5ub3RMaWtlXTogXCJOT1QgTElLRVwiLFxuICAgIFtPcC5pTGlrZV06IFwiSUxJS0VcIixcbiAgICBbT3Aubm90SUxpa2VdOiBcIk5PVCBJTElLRVwiLFxuICAgIFtPcC5zdGFydHNXaXRoXTogXCJMSUtFXCIsXG4gICAgW09wLmVuZHNXaXRoXTogXCJMSUtFXCIsXG4gICAgW09wLnN1YnN0cmluZ106IFwiTElLRVwiLFxuICAgIFtPcC5yZWdleHBdOiBcIn5cIixcbiAgICBbT3Aubm90UmVnZXhwXTogXCIhflwiLFxuICAgIFtPcC5pUmVnZXhwXTogXCJ+KlwiLFxuICAgIFtPcC5ub3RJUmVnZXhwXTogXCIhfipcIixcbiAgICBbT3AuYmV0d2Vlbl06IFwiQkVUV0VFTlwiLFxuICAgIFtPcC5ub3RCZXR3ZWVuXTogXCJOT1QgQkVUV0VFTlwiLFxuICAgIFtPcC5vdmVybGFwXTogXCImJlwiLFxuICAgIFtPcC5jb250YWluc106IFwiQD5cIixcbiAgICBbT3AuY29udGFpbmVkXTogXCI8QFwiLFxuICAgIFtPcC5hZGphY2VudF06IFwiLXwtXCIsXG4gICAgW09wLnN0cmljdExlZnRdOiBcIjw8XCIsXG4gICAgW09wLnN0cmljdFJpZ2h0XTogXCI+PlwiLFxuICAgIFtPcC5ub0V4dGVuZFJpZ2h0XTogXCImPFwiLFxuICAgIFtPcC5ub0V4dGVuZExlZnRdOiBcIiY+XCIsXG4gICAgW09wLmFueV06IFwiQU5ZXCIsXG4gICAgW09wLmFsbF06IFwiQUxMXCIsXG4gICAgW09wLmFuZF06IFwiIEFORCBcIixcbiAgICBbT3Aub3JdOiBcIiBPUiBcIixcbiAgICBbT3AuY29sXTogXCJDT0xcIixcbiAgICBbT3AucGxhY2Vob2xkZXJdOiBcIiQkUExBQ0VIT0xERVIkJFwiLFxuICAgIFtPcC5tYXRjaF06IFwiQEBcIlxuICB9LFxuICBPcGVyYXRvcnNBbGlhc01hcDoge30sXG4gIHNldE9wZXJhdG9yc0FsaWFzZXMoYWxpYXNlcykge1xuICAgIGlmICghYWxpYXNlcyB8fCBfLmlzRW1wdHkoYWxpYXNlcykpIHtcbiAgICAgIHRoaXMuT3BlcmF0b3JzQWxpYXNNYXAgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5PcGVyYXRvcnNBbGlhc01hcCA9IF9fc3ByZWFkVmFsdWVzKHt9LCBhbGlhc2VzKTtcbiAgICB9XG4gIH0sXG4gIF9yZXBsYWNlQWxpYXNlcyhvcmlnKSB7XG4gICAgY29uc3Qgb2JqID0ge307XG4gICAgaWYgKCF0aGlzLk9wZXJhdG9yc0FsaWFzTWFwKSB7XG4gICAgICByZXR1cm4gb3JpZztcbiAgICB9XG4gICAgVXRpbHMuZ2V0T3BlcmF0b3JzKG9yaWcpLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICBjb25zdCBpdGVtID0gb3JpZ1tvcF07XG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIG9ialtvcF0gPSB0aGlzLl9yZXBsYWNlQWxpYXNlcyhpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtvcF0gPSBpdGVtO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF8uZm9yT3duKG9yaWcsIChpdGVtLCBwcm9wKSA9PiB7XG4gICAgICBwcm9wID0gdGhpcy5PcGVyYXRvcnNBbGlhc01hcFtwcm9wXSB8fCBwcm9wO1xuICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChpdGVtKSkge1xuICAgICAgICBpdGVtID0gdGhpcy5fcmVwbGFjZUFsaWFzZXMoaXRlbSk7XG4gICAgICB9XG4gICAgICBvYmpbcHJvcF0gPSBpdGVtO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IE9wZXJhdG9ySGVscGVycztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZXJhdG9ycy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst uuidv4 = (__webpack_require__(/*! uuid */ \"(action-browser)/../node_modules/uuid/dist/esm-node/index.js\").v4);\nconst TransactionQueries = {\n  setIsolationLevelQuery(value, options) {\n    if (options.parent) {\n      return;\n    }\n    return `SET TRANSACTION ISOLATION LEVEL ${value};`;\n  },\n  generateTransactionId() {\n    return uuidv4();\n  },\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name, true)};`;\n    }\n    return \"START TRANSACTION;\";\n  },\n  deferConstraintsQuery() {\n  },\n  setConstraintQuery() {\n  },\n  setDeferredQuery() {\n  },\n  setImmediateQuery() {\n  },\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n    return \"COMMIT;\";\n  },\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TO SAVEPOINT ${this.quoteIdentifier(transaction.name, true)};`;\n    }\n    return \"ROLLBACK;\";\n  }\n};\nmodule.exports = TransactionQueries;\n//# sourceMappingURL=transaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3IvdHJhbnNhY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLG9HQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBOEM7QUFDeEU7QUFDQSw4QkFBOEI7QUFDOUIsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0NBQXNDLDhDQUE4QztBQUNwRjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3IvdHJhbnNhY3Rpb24uanM/ZmQ0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHV1aWR2NCA9IHJlcXVpcmUoXCJ1dWlkXCIpLnY0O1xuY29uc3QgVHJhbnNhY3Rpb25RdWVyaWVzID0ge1xuICBzZXRJc29sYXRpb25MZXZlbFF1ZXJ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBgU0VUIFRSQU5TQUNUSU9OIElTT0xBVElPTiBMRVZFTCAke3ZhbHVlfTtgO1xuICB9LFxuICBnZW5lcmF0ZVRyYW5zYWN0aW9uSWQoKSB7XG4gICAgcmV0dXJuIHV1aWR2NCgpO1xuICB9LFxuICBzdGFydFRyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICByZXR1cm4gYFNBVkVQT0lOVCAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRyYW5zYWN0aW9uLm5hbWUsIHRydWUpfTtgO1xuICAgIH1cbiAgICByZXR1cm4gXCJTVEFSVCBUUkFOU0FDVElPTjtcIjtcbiAgfSxcbiAgZGVmZXJDb25zdHJhaW50c1F1ZXJ5KCkge1xuICB9LFxuICBzZXRDb25zdHJhaW50UXVlcnkoKSB7XG4gIH0sXG4gIHNldERlZmVycmVkUXVlcnkoKSB7XG4gIH0sXG4gIHNldEltbWVkaWF0ZVF1ZXJ5KCkge1xuICB9LFxuICBjb21taXRUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gXCJDT01NSVQ7XCI7XG4gIH0sXG4gIHJvbGxiYWNrVHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIHJldHVybiBgUk9MTEJBQ0sgVE8gU0FWRVBPSU5UICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodHJhbnNhY3Rpb24ubmFtZSwgdHJ1ZSl9O2A7XG4gICAgfVxuICAgIHJldHVybiBcIlJPTExCQUNLO1wiO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2FjdGlvblF1ZXJpZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2FjdGlvbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-interface.js":
/*!**************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/abstract/query-interface.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\");\nconst Transaction = __webpack_require__(/*! ../../transaction */ \"(action-browser)/../node_modules/sequelize/lib/transaction.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(action-browser)/../node_modules/sequelize/lib/query-types.js\");\nclass QueryInterface {\n  constructor(sequelize, queryGenerator) {\n    this.sequelize = sequelize;\n    this.queryGenerator = queryGenerator;\n  }\n  async createDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createDatabaseQuery(database, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async dropDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropDatabaseQuery(database);\n    return await this.sequelize.query(sql, options);\n  }\n  async createSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n  async dropSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n  async dropAllSchemas(options) {\n    options = options || {};\n    if (!this.queryGenerator._dialect.supports.schemas) {\n      return this.sequelize.drop(options);\n    }\n    const schemas = await this.showAllSchemas(options);\n    return Promise.all(schemas.map((schemaName) => this.dropSchema(schemaName, options)));\n  }\n  async showAllSchemas(options) {\n    options = __spreadProps(__spreadValues({}, options), {\n      raw: true,\n      type: this.sequelize.QueryTypes.SELECT\n    });\n    const showSchemasSql = this.queryGenerator.showSchemasQuery(options);\n    const schemaNames = await this.sequelize.query(showSchemasSql, options);\n    return _.flatten(schemaNames.map((value) => value.schema_name ? value.schema_name : value));\n  }\n  async databaseVersion(options) {\n    return await this.sequelize.query(this.queryGenerator.versionQuery(), __spreadProps(__spreadValues({}, options), { type: QueryTypes.VERSION }));\n  }\n  async createTable(tableName, attributes, options, model) {\n    let sql = \"\";\n    options = __spreadValues({}, options);\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, (uniqueKey) => {\n        if (uniqueKey.customIndex === void 0) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n    attributes = _.mapValues(attributes, (attribute) => this.sequelize.normalizeAttribute(attribute));\n    await this.ensureEnums(tableName, attributes, options, model);\n    if (!tableName.schema && (options.schema || !!model && model._schema)) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n    attributes = this.queryGenerator.attributesToSQL(attributes, {\n      table: tableName,\n      context: \"createTable\",\n      withoutForeignKeyConstraints: options.withoutForeignKeyConstraints\n    });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async tableExists(tableName, options) {\n    const sql = this.queryGenerator.tableExistsQuery(tableName);\n    const out = await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.SHOWTABLES\n    }));\n    return out.length === 1;\n  }\n  async dropTable(tableName, options) {\n    options = __spreadValues({}, options);\n    options.cascade = options.cascade || options.force || false;\n    const sql = this.queryGenerator.dropTableQuery(tableName, options);\n    await this.sequelize.query(sql, options);\n  }\n  async _dropAllTables(tableNames, skip, options) {\n    for (const tableName of tableNames) {\n      if (!skip.includes(tableName.tableName || tableName)) {\n        await this.dropTable(tableName, __spreadProps(__spreadValues({}, options), { cascade: true }));\n      }\n    }\n  }\n  async dropAllTables(options) {\n    options = options || {};\n    const skip = options.skip || [];\n    const tableNames = await this.showAllTables(options);\n    const foreignKeys = await this.getForeignKeysForTables(tableNames, options);\n    for (const tableName of tableNames) {\n      let normalizedTableName = tableName;\n      if (_.isObject(tableName)) {\n        normalizedTableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n      for (const foreignKey of foreignKeys[normalizedTableName]) {\n        await this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, foreignKey));\n      }\n    }\n    await this._dropAllTables(tableNames, skip, options);\n  }\n  async renameTable(before, after, options) {\n    options = options || {};\n    const sql = this.queryGenerator.renameTableQuery(before, after);\n    return await this.sequelize.query(sql, options);\n  }\n  async showAllTables(options) {\n    options = __spreadProps(__spreadValues({}, options), {\n      raw: true,\n      type: QueryTypes.SHOWTABLES\n    });\n    const showTablesSql = this.queryGenerator.showTablesQuery(this.sequelize.config.database);\n    const tableNames = await this.sequelize.query(showTablesSql, options);\n    return _.flatten(tableNames);\n  }\n  async describeTable(tableName, options) {\n    let schema = null;\n    let schemaDelimiter = null;\n    if (typeof options === \"string\") {\n      schema = options;\n    } else if (typeof options === \"object\" && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n    if (typeof tableName === \"object\" && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n    options = __spreadProps(__spreadValues({}, options), { type: QueryTypes.DESCRIBE });\n    try {\n      const data = await this.sequelize.query(sql, options);\n      if (_.isEmpty(data)) {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n      return data;\n    } catch (e) {\n      if (e.original && e.original.code === \"ER_NO_SUCH_TABLE\") {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n      throw e;\n    }\n  }\n  async addColumn(table, key, attribute, options) {\n    if (!table || !key || !attribute) {\n      throw new Error(\"addColumn takes at least 3 arguments (table, attribute name, attribute definition)\");\n    }\n    options = options || {};\n    attribute = this.sequelize.normalizeAttribute(attribute);\n    return await this.sequelize.query(this.queryGenerator.addColumnQuery(table, key, attribute), options);\n  }\n  async removeColumn(tableName, attributeName, options) {\n    return this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, attributeName), options);\n  }\n  normalizeAttribute(dataTypeOrOptions) {\n    let attribute;\n    if (Object.values(DataTypes).includes(dataTypeOrOptions)) {\n      attribute = { type: dataTypeOrOptions, allowNull: true };\n    } else {\n      attribute = dataTypeOrOptions;\n    }\n    return this.sequelize.normalizeAttribute(attribute);\n  }\n  quoteIdentifier(identifier2, force) {\n    return this.queryGenerator.quoteIdentifier(identifier2, force);\n  }\n  quoteIdentifiers(identifiers) {\n    return this.queryGenerator.quoteIdentifiers(identifiers);\n  }\n  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    options = options || {};\n    const query = this.queryGenerator.attributesToSQL({\n      [attributeName]: this.normalizeAttribute(dataTypeOrOptions)\n    }, {\n      context: \"changeColumn\",\n      table: tableName\n    });\n    const sql = this.queryGenerator.changeColumnQuery(tableName, query);\n    return this.sequelize.query(sql, options);\n  }\n  async assertTableHasColumn(tableName, columnName, options) {\n    const description = await this.describeTable(tableName, options);\n    if (description[columnName]) {\n      return description;\n    }\n    throw new Error(`Table ${tableName} doesn't have the column ${columnName}`);\n  }\n  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    const data = (await this.assertTableHasColumn(tableName, attrNameBefore, options))[attrNameBefore];\n    const _options = {};\n    _options[attrNameAfter] = {\n      attribute: attrNameAfter,\n      type: data.type,\n      allowNull: data.allowNull,\n      defaultValue: data.defaultValue\n    };\n    if (data.defaultValue === null && !data.allowNull) {\n      delete _options[attrNameAfter].defaultValue;\n    }\n    const sql = this.queryGenerator.renameColumnQuery(tableName, attrNameBefore, this.queryGenerator.attributesToSQL(_options));\n    return await this.sequelize.query(sql, options);\n  }\n  async addIndex(tableName, attributes, options, rawTablename) {\n    if (!Array.isArray(attributes)) {\n      rawTablename = options;\n      options = attributes;\n      attributes = options.fields;\n    }\n    if (!rawTablename) {\n      rawTablename = tableName;\n    }\n    options = Utils.cloneDeep(options);\n    options.fields = attributes;\n    const sql = this.queryGenerator.addIndexQuery(tableName, options, rawTablename);\n    return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { supportsSearchPath: false }));\n  }\n  async showIndex(tableName, options) {\n    const sql = this.queryGenerator.showIndexesQuery(tableName, options);\n    return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { type: QueryTypes.SHOWINDEXES }));\n  }\n  async getForeignKeysForTables(tableNames, options) {\n    if (tableNames.length === 0) {\n      return {};\n    }\n    options = __spreadProps(__spreadValues({}, options), { type: QueryTypes.FOREIGNKEYS });\n    const results = await Promise.all(tableNames.map((tableName) => this.sequelize.query(this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database), options)));\n    const result = {};\n    tableNames.forEach((tableName, i) => {\n      if (_.isObject(tableName)) {\n        tableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n      result[tableName] = Array.isArray(results[i]) ? results[i].map((r) => r.constraint_name) : [results[i] && results[i].constraint_name];\n      result[tableName] = result[tableName].filter(_.identity);\n    });\n    return result;\n  }\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database);\n    return this.sequelize.query(query, queryOptions);\n  }\n  async removeIndex(tableName, indexNameOrAttributes, options) {\n    options = options || {};\n    const sql = this.queryGenerator.removeIndexQuery(tableName, indexNameOrAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async addConstraint(tableName, options) {\n    if (!options.fields) {\n      throw new Error(\"Fields must be specified through options.fields\");\n    }\n    if (!options.type) {\n      throw new Error(\"Constraint type must be specified through options.type\");\n    }\n    options = Utils.cloneDeep(options);\n    const sql = this.queryGenerator.addConstraintQuery(tableName, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async showConstraint(tableName, constraintName, options) {\n    const sql = this.queryGenerator.showConstraintsQuery(tableName, constraintName);\n    return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { type: QueryTypes.SHOWCONSTRAINTS }));\n  }\n  async removeConstraint(tableName, constraintName, options) {\n    return this.sequelize.query(this.queryGenerator.removeConstraintQuery(tableName, constraintName), options);\n  }\n  async insert(instance, tableName, values, options) {\n    options = Utils.cloneDeep(options);\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n    const sql = this.queryGenerator.insertQuery(tableName, values, instance && instance.constructor.rawAttributes, options);\n    options.type = QueryTypes.INSERT;\n    options.instance = instance;\n    const results = await this.sequelize.query(sql, options);\n    if (instance)\n      results[0].isNewRecord = false;\n    return results;\n  }\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    const model = options.model;\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = options.conflictFields || [];\n    if (options.upsertKeys.length === 0) {\n      const primaryKeys = Object.values(model.primaryKeys).map((item) => item.field);\n      const uniqueKeys = Object.values(model.uniqueKeys).filter((c) => c.fields.length > 0).map((c) => c.fields);\n      const indexKeys = Object.values(model._indexes).filter((c) => c.unique && c.fields.length > 0).map((c) => c.fields);\n      for (const field of options.updateOnDuplicate) {\n        const uniqueKey = uniqueKeys.find((fields) => fields.includes(field));\n        if (uniqueKey) {\n          options.upsertKeys = uniqueKey;\n          break;\n        }\n        const indexKey = indexKeys.find((fields) => fields.includes(field));\n        if (indexKey) {\n          options.upsertKeys = indexKey;\n          break;\n        }\n      }\n      if (options.upsertKeys.length === 0 || _.intersection(options.updateOnDuplicate, primaryKeys).length) {\n        options.upsertKeys = primaryKeys;\n      }\n      options.upsertKeys = _.uniq(options.upsertKeys);\n    }\n    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async bulkInsert(tableName, records, options, attributes) {\n    options = __spreadValues({}, options);\n    options.type = QueryTypes.INSERT;\n    const results = await this.sequelize.query(this.queryGenerator.bulkInsertQuery(tableName, records, options, attributes), options);\n    return results[0];\n  }\n  async update(instance, tableName, values, identifier2, options) {\n    options = __spreadValues({}, options);\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier2, options, instance.constructor.rawAttributes);\n    options.type = QueryTypes.UPDATE;\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n  async bulkUpdate(tableName, values, identifier2, options, attributes) {\n    options = Utils.cloneDeep(options);\n    if (typeof identifier2 === \"object\")\n      identifier2 = Utils.cloneDeep(identifier2);\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier2, options, attributes);\n    const table = _.isObject(tableName) ? tableName : { tableName };\n    const model = options.model ? options.model : _.find(this.sequelize.modelManager.models, { tableName: table.tableName });\n    options.type = QueryTypes.BULKUPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n  async delete(instance, tableName, identifier2, options) {\n    const cascades = [];\n    const sql = this.queryGenerator.deleteQuery(tableName, identifier2, {}, instance.constructor);\n    options = __spreadValues({}, options);\n    if (!!instance.constructor && !!instance.constructor.associations) {\n      const keys = Object.keys(instance.constructor.associations);\n      const length = keys.length;\n      let association;\n      for (let i = 0; i < length; i++) {\n        association = instance.constructor.associations[keys[i]];\n        if (association.options && association.options.onDelete && association.options.onDelete.toLowerCase() === \"cascade\" && association.options.useHooks === true) {\n          cascades.push(association.accessors.get);\n        }\n      }\n    }\n    for (const cascade of cascades) {\n      let instances = await instance[cascade](options);\n      if (!instances)\n        continue;\n      if (!Array.isArray(instances))\n        instances = [instances];\n      for (const _instance of instances)\n        await _instance.destroy(options);\n    }\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n  async bulkDelete(tableName, where, options, model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, { limit: null });\n    if (options.truncate === true) {\n      return this.sequelize.query(this.queryGenerator.truncateTableQuery(tableName, options), options);\n    }\n    if (typeof identifier === \"object\")\n      where = Utils.cloneDeep(where);\n    return await this.sequelize.query(this.queryGenerator.deleteQuery(tableName, where, options, model), options);\n  }\n  async select(model, tableName, optionsArg) {\n    const options = __spreadProps(__spreadValues({}, optionsArg), { type: QueryTypes.SELECT, model });\n    return await this.sequelize.query(this.queryGenerator.selectQuery(tableName, options, model), options);\n  }\n  async increment(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n    const sql = this.queryGenerator.arithmeticQuery(\"+\", tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n  async decrement(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n    const sql = this.queryGenerator.arithmeticQuery(\"-\", tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n  async rawSelect(tableName, options, attributeSelector, Model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      raw: true,\n      plain: true,\n      type: QueryTypes.SELECT\n    });\n    const sql = this.queryGenerator.selectQuery(tableName, options, Model);\n    if (attributeSelector === void 0) {\n      throw new Error(\"Please pass an attribute selector!\");\n    }\n    const data = await this.sequelize.query(sql, options);\n    if (!options.plain) {\n      return data;\n    }\n    const result = data ? data[attributeSelector] : null;\n    if (!options || !options.dataType) {\n      return result;\n    }\n    const dataType = options.dataType;\n    if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {\n      if (result !== null) {\n        return parseFloat(result);\n      }\n    }\n    if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {\n      if (result !== null) {\n        return parseInt(result, 10);\n      }\n    }\n    if (dataType instanceof DataTypes.DATE) {\n      if (result !== null && !(result instanceof Date)) {\n        return new Date(result);\n      }\n    }\n    return result;\n  }\n  async createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray, options) {\n    const sql = this.queryGenerator.createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async dropTrigger(tableName, triggerName, options) {\n    const sql = this.queryGenerator.dropTrigger(tableName, triggerName);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async renameTrigger(tableName, oldTriggerName, newTriggerName, options) {\n    const sql = this.queryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    const sql = this.queryGenerator.createFunction(functionName, params, returnType, language, body, optionsArray, options);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async dropFunction(functionName, params, options) {\n    const sql = this.queryGenerator.dropFunction(functionName, params);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async renameFunction(oldFunctionName, params, newFunctionName, options) {\n    const sql = this.queryGenerator.renameFunction(oldFunctionName, params, newFunctionName);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  ensureEnums() {\n  }\n  async setIsolationLevel(transaction, value, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to set isolation level for a transaction without transaction object!\");\n    }\n    if (transaction.parent || !value) {\n      return;\n    }\n    options = __spreadProps(__spreadValues({}, options), { transaction: transaction.parent || transaction });\n    const sql = this.queryGenerator.setIsolationLevelQuery(value, {\n      parent: transaction.parent\n    });\n    if (!sql)\n      return;\n    return await this.sequelize.query(sql, options);\n  }\n  async startTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to start a transaction without transaction object!\");\n    }\n    options = __spreadProps(__spreadValues({}, options), { transaction: transaction.parent || transaction });\n    options.transaction.name = transaction.parent ? transaction.name : void 0;\n    const sql = this.queryGenerator.startTransactionQuery(transaction);\n    return await this.sequelize.query(sql, options);\n  }\n  async deferConstraints(transaction, options) {\n    options = __spreadProps(__spreadValues({}, options), { transaction: transaction.parent || transaction });\n    const sql = this.queryGenerator.deferConstraintsQuery(options);\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async commitTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to commit a transaction without transaction object!\");\n    }\n    if (transaction.parent) {\n      return;\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    });\n    const sql = this.queryGenerator.commitTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n    transaction.finished = \"commit\";\n    return await promise;\n  }\n  async rollbackTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to rollback a transaction without transaction object!\");\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    });\n    options.transaction.name = transaction.parent ? transaction.name : void 0;\n    const sql = this.queryGenerator.rollbackTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n    transaction.finished = \"rollback\";\n    return await promise;\n  }\n}\nexports.QueryInterface = QueryInterface;\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLGlFQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyw0RUFBYTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBa0I7QUFDNUMsb0JBQW9CLG1CQUFPLENBQUMsd0ZBQW1CO0FBQy9DLG1CQUFtQixtQkFBTyxDQUFDLHdGQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsY0FBYywwQkFBMEI7QUFDako7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxjQUFjLGVBQWU7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUIsR0FBRyxvQkFBb0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjLDJCQUEyQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsVUFBVSwwQ0FBMEM7QUFDekc7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHFEQUFxRCxVQUFVLDBDQUEwQztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVcsMEJBQTBCLFdBQVc7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxjQUFjLDJCQUEyQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsY0FBYyw4QkFBOEI7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjLDhCQUE4QjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUIsR0FBRyxvQkFBb0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsY0FBYyxrQ0FBa0M7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsK0ZBQStGLDRCQUE0QjtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUUsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsaUJBQWlCLGdDQUFnQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYyxnREFBZ0Q7QUFDM0c7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWMsZ0RBQWdEO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYyxnREFBZ0Q7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL2Fic3RyYWN0L3F1ZXJ5LWludGVyZmFjZS5qcz85Njc5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIik7XG5jb25zdCBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoXCIuLi8uLi90cmFuc2FjdGlvblwiKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vcXVlcnktdHlwZXNcIik7XG5jbGFzcyBRdWVyeUludGVyZmFjZSB7XG4gIGNvbnN0cnVjdG9yKHNlcXVlbGl6ZSwgcXVlcnlHZW5lcmF0b3IpIHtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yID0gcXVlcnlHZW5lcmF0b3I7XG4gIH1cbiAgYXN5bmMgY3JlYXRlRGF0YWJhc2UoZGF0YWJhc2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmNyZWF0ZURhdGFiYXNlUXVlcnkoZGF0YWJhc2UsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGRyb3BEYXRhYmFzZShkYXRhYmFzZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcERhdGFiYXNlUXVlcnkoZGF0YWJhc2UpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGNyZWF0ZVNjaGVtYShzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmNyZWF0ZVNjaGVtYShzY2hlbWEpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGRyb3BTY2hlbWEoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wU2NoZW1hKHNjaGVtYSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgZHJvcEFsbFNjaGVtYXMob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghdGhpcy5xdWVyeUdlbmVyYXRvci5fZGlhbGVjdC5zdXBwb3J0cy5zY2hlbWFzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUuZHJvcChvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3Qgc2NoZW1hcyA9IGF3YWl0IHRoaXMuc2hvd0FsbFNjaGVtYXMob3B0aW9ucyk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHNjaGVtYXMubWFwKChzY2hlbWFOYW1lKSA9PiB0aGlzLmRyb3BTY2hlbWEoc2NoZW1hTmFtZSwgb3B0aW9ucykpKTtcbiAgfVxuICBhc3luYyBzaG93QWxsU2NoZW1hcyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICByYXc6IHRydWUsXG4gICAgICB0eXBlOiB0aGlzLnNlcXVlbGl6ZS5RdWVyeVR5cGVzLlNFTEVDVFxuICAgIH0pO1xuICAgIGNvbnN0IHNob3dTY2hlbWFzU3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5zaG93U2NoZW1hc1F1ZXJ5KG9wdGlvbnMpO1xuICAgIGNvbnN0IHNjaGVtYU5hbWVzID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc2hvd1NjaGVtYXNTcWwsIG9wdGlvbnMpO1xuICAgIHJldHVybiBfLmZsYXR0ZW4oc2NoZW1hTmFtZXMubWFwKCh2YWx1ZSkgPT4gdmFsdWUuc2NoZW1hX25hbWUgPyB2YWx1ZS5zY2hlbWFfbmFtZSA6IHZhbHVlKSk7XG4gIH1cbiAgYXN5bmMgZGF0YWJhc2VWZXJzaW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci52ZXJzaW9uUXVlcnkoKSwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgdHlwZTogUXVlcnlUeXBlcy5WRVJTSU9OIH0pKTtcbiAgfVxuICBhc3luYyBjcmVhdGVUYWJsZSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMsIG1vZGVsKSB7XG4gICAgbGV0IHNxbCA9IFwiXCI7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnVuaXF1ZUtleXMpIHtcbiAgICAgIF8uZm9yT3duKG9wdGlvbnMudW5pcXVlS2V5cywgKHVuaXF1ZUtleSkgPT4ge1xuICAgICAgICBpZiAodW5pcXVlS2V5LmN1c3RvbUluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICB1bmlxdWVLZXkuY3VzdG9tSW5kZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1vZGVsKSB7XG4gICAgICBvcHRpb25zLnVuaXF1ZUtleXMgPSBvcHRpb25zLnVuaXF1ZUtleXMgfHwgbW9kZWwudW5pcXVlS2V5cztcbiAgICB9XG4gICAgYXR0cmlidXRlcyA9IF8ubWFwVmFsdWVzKGF0dHJpYnV0ZXMsIChhdHRyaWJ1dGUpID0+IHRoaXMuc2VxdWVsaXplLm5vcm1hbGl6ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpKTtcbiAgICBhd2FpdCB0aGlzLmVuc3VyZUVudW1zKHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucywgbW9kZWwpO1xuICAgIGlmICghdGFibGVOYW1lLnNjaGVtYSAmJiAob3B0aW9ucy5zY2hlbWEgfHwgISFtb2RlbCAmJiBtb2RlbC5fc2NoZW1hKSkge1xuICAgICAgdGFibGVOYW1lID0gdGhpcy5xdWVyeUdlbmVyYXRvci5hZGRTY2hlbWEoe1xuICAgICAgICB0YWJsZU5hbWUsXG4gICAgICAgIF9zY2hlbWE6ICEhbW9kZWwgJiYgbW9kZWwuX3NjaGVtYSB8fCBvcHRpb25zLnNjaGVtYVxuICAgICAgfSk7XG4gICAgfVxuICAgIGF0dHJpYnV0ZXMgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmF0dHJpYnV0ZXNUb1NRTChhdHRyaWJ1dGVzLCB7XG4gICAgICB0YWJsZTogdGFibGVOYW1lLFxuICAgICAgY29udGV4dDogXCJjcmVhdGVUYWJsZVwiLFxuICAgICAgd2l0aG91dEZvcmVpZ25LZXlDb25zdHJhaW50czogb3B0aW9ucy53aXRob3V0Rm9yZWlnbktleUNvbnN0cmFpbnRzXG4gICAgfSk7XG4gICAgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5jcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgdGFibGVFeGlzdHModGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci50YWJsZUV4aXN0c1F1ZXJ5KHRhYmxlTmFtZSk7XG4gICAgY29uc3Qgb3V0ID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwge1xuICAgICAgdHlwZTogUXVlcnlUeXBlcy5TSE9XVEFCTEVTXG4gICAgfSkpO1xuICAgIHJldHVybiBvdXQubGVuZ3RoID09PSAxO1xuICB9XG4gIGFzeW5jIGRyb3BUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xuICAgIG9wdGlvbnMuY2FzY2FkZSA9IG9wdGlvbnMuY2FzY2FkZSB8fCBvcHRpb25zLmZvcmNlIHx8IGZhbHNlO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcFRhYmxlUXVlcnkodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIF9kcm9wQWxsVGFibGVzKHRhYmxlTmFtZXMsIHNraXAsIG9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IHRhYmxlTmFtZSBvZiB0YWJsZU5hbWVzKSB7XG4gICAgICBpZiAoIXNraXAuaW5jbHVkZXModGFibGVOYW1lLnRhYmxlTmFtZSB8fCB0YWJsZU5hbWUpKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZHJvcFRhYmxlKHRhYmxlTmFtZSwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgY2FzY2FkZTogdHJ1ZSB9KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGRyb3BBbGxUYWJsZXMob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHNraXAgPSBvcHRpb25zLnNraXAgfHwgW107XG4gICAgY29uc3QgdGFibGVOYW1lcyA9IGF3YWl0IHRoaXMuc2hvd0FsbFRhYmxlcyhvcHRpb25zKTtcbiAgICBjb25zdCBmb3JlaWduS2V5cyA9IGF3YWl0IHRoaXMuZ2V0Rm9yZWlnbktleXNGb3JUYWJsZXModGFibGVOYW1lcywgb3B0aW9ucyk7XG4gICAgZm9yIChjb25zdCB0YWJsZU5hbWUgb2YgdGFibGVOYW1lcykge1xuICAgICAgbGV0IG5vcm1hbGl6ZWRUYWJsZU5hbWUgPSB0YWJsZU5hbWU7XG4gICAgICBpZiAoXy5pc09iamVjdCh0YWJsZU5hbWUpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRUYWJsZU5hbWUgPSBgJHt0YWJsZU5hbWUuc2NoZW1hfS4ke3RhYmxlTmFtZS50YWJsZU5hbWV9YDtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgZm9yZWlnbktleSBvZiBmb3JlaWduS2V5c1tub3JtYWxpemVkVGFibGVOYW1lXSkge1xuICAgICAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLCBmb3JlaWduS2V5KSk7XG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuX2Ryb3BBbGxUYWJsZXModGFibGVOYW1lcywgc2tpcCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgcmVuYW1lVGFibGUoYmVmb3JlLCBhZnRlciwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucmVuYW1lVGFibGVRdWVyeShiZWZvcmUsIGFmdGVyKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBzaG93QWxsVGFibGVzKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgIHJhdzogdHJ1ZSxcbiAgICAgIHR5cGU6IFF1ZXJ5VHlwZXMuU0hPV1RBQkxFU1xuICAgIH0pO1xuICAgIGNvbnN0IHNob3dUYWJsZXNTcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnNob3dUYWJsZXNRdWVyeSh0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGF0YWJhc2UpO1xuICAgIGNvbnN0IHRhYmxlTmFtZXMgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzaG93VGFibGVzU3FsLCBvcHRpb25zKTtcbiAgICByZXR1cm4gXy5mbGF0dGVuKHRhYmxlTmFtZXMpO1xuICB9XG4gIGFzeW5jIGRlc2NyaWJlVGFibGUodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgbGV0IHNjaGVtYSA9IG51bGw7XG4gICAgbGV0IHNjaGVtYURlbGltaXRlciA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBzY2hlbWEgPSBvcHRpb25zO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgc2NoZW1hID0gb3B0aW9ucy5zY2hlbWEgfHwgbnVsbDtcbiAgICAgIHNjaGVtYURlbGltaXRlciA9IG9wdGlvbnMuc2NoZW1hRGVsaW1pdGVyIHx8IG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGFibGVOYW1lID09PSBcIm9iamVjdFwiICYmIHRhYmxlTmFtZSAhPT0gbnVsbCkge1xuICAgICAgc2NoZW1hID0gdGFibGVOYW1lLnNjaGVtYTtcbiAgICAgIHRhYmxlTmFtZSA9IHRhYmxlTmFtZS50YWJsZU5hbWU7XG4gICAgfVxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZGVzY3JpYmVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgc2NoZW1hLCBzY2hlbWFEZWxpbWl0ZXIpO1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyB0eXBlOiBRdWVyeVR5cGVzLkRFU0NSSUJFIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICAgIGlmIChfLmlzRW1wdHkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZXNjcmlwdGlvbiBmb3VuZCBmb3IgXCIke3RhYmxlTmFtZX1cIiB0YWJsZS4gQ2hlY2sgdGhlIHRhYmxlIG5hbWUgYW5kIHNjaGVtYTsgcmVtZW1iZXIsIHRoZXkgX2FyZV8gY2FzZSBzZW5zaXRpdmUuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5vcmlnaW5hbCAmJiBlLm9yaWdpbmFsLmNvZGUgPT09IFwiRVJfTk9fU1VDSF9UQUJMRVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGVzY3JpcHRpb24gZm91bmQgZm9yIFwiJHt0YWJsZU5hbWV9XCIgdGFibGUuIENoZWNrIHRoZSB0YWJsZSBuYW1lIGFuZCBzY2hlbWE7IHJlbWVtYmVyLCB0aGV5IF9hcmVfIGNhc2Ugc2Vuc2l0aXZlLmApO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYWRkQ29sdW1uKHRhYmxlLCBrZXksIGF0dHJpYnV0ZSwgb3B0aW9ucykge1xuICAgIGlmICghdGFibGUgfHwgIWtleSB8fCAhYXR0cmlidXRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRDb2x1bW4gdGFrZXMgYXQgbGVhc3QgMyBhcmd1bWVudHMgKHRhYmxlLCBhdHRyaWJ1dGUgbmFtZSwgYXR0cmlidXRlIGRlZmluaXRpb24pXCIpO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBhdHRyaWJ1dGUgPSB0aGlzLnNlcXVlbGl6ZS5ub3JtYWxpemVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5hZGRDb2x1bW5RdWVyeSh0YWJsZSwga2V5LCBhdHRyaWJ1dGUpLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyByZW1vdmVDb2x1bW4odGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IucmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKSwgb3B0aW9ucyk7XG4gIH1cbiAgbm9ybWFsaXplQXR0cmlidXRlKGRhdGFUeXBlT3JPcHRpb25zKSB7XG4gICAgbGV0IGF0dHJpYnV0ZTtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhEYXRhVHlwZXMpLmluY2x1ZGVzKGRhdGFUeXBlT3JPcHRpb25zKSkge1xuICAgICAgYXR0cmlidXRlID0geyB0eXBlOiBkYXRhVHlwZU9yT3B0aW9ucywgYWxsb3dOdWxsOiB0cnVlIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHJpYnV0ZSA9IGRhdGFUeXBlT3JPcHRpb25zO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUubm9ybWFsaXplQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gIH1cbiAgcXVvdGVJZGVudGlmaWVyKGlkZW50aWZpZXIyLCBmb3JjZSkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnF1b3RlSWRlbnRpZmllcihpZGVudGlmaWVyMiwgZm9yY2UpO1xuICB9XG4gIHF1b3RlSWRlbnRpZmllcnMoaWRlbnRpZmllcnMpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeUdlbmVyYXRvci5xdW90ZUlkZW50aWZpZXJzKGlkZW50aWZpZXJzKTtcbiAgfVxuICBhc3luYyBjaGFuZ2VDb2x1bW4odGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lLCBkYXRhVHlwZU9yT3B0aW9ucywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeUdlbmVyYXRvci5hdHRyaWJ1dGVzVG9TUUwoe1xuICAgICAgW2F0dHJpYnV0ZU5hbWVdOiB0aGlzLm5vcm1hbGl6ZUF0dHJpYnV0ZShkYXRhVHlwZU9yT3B0aW9ucylcbiAgICB9LCB7XG4gICAgICBjb250ZXh0OiBcImNoYW5nZUNvbHVtblwiLFxuICAgICAgdGFibGU6IHRhYmxlTmFtZVxuICAgIH0pO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuY2hhbmdlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBxdWVyeSk7XG4gICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgYXNzZXJ0VGFibGVIYXNDb2x1bW4odGFibGVOYW1lLCBjb2x1bW5OYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBhd2FpdCB0aGlzLmRlc2NyaWJlVGFibGUodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICBpZiAoZGVzY3JpcHRpb25bY29sdW1uTmFtZV0pIHtcbiAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUYWJsZSAke3RhYmxlTmFtZX0gZG9lc24ndCBoYXZlIHRoZSBjb2x1bW4gJHtjb2x1bW5OYW1lfWApO1xuICB9XG4gIGFzeW5jIHJlbmFtZUNvbHVtbih0YWJsZU5hbWUsIGF0dHJOYW1lQmVmb3JlLCBhdHRyTmFtZUFmdGVyLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgZGF0YSA9IChhd2FpdCB0aGlzLmFzc2VydFRhYmxlSGFzQ29sdW1uKHRhYmxlTmFtZSwgYXR0ck5hbWVCZWZvcmUsIG9wdGlvbnMpKVthdHRyTmFtZUJlZm9yZV07XG4gICAgY29uc3QgX29wdGlvbnMgPSB7fTtcbiAgICBfb3B0aW9uc1thdHRyTmFtZUFmdGVyXSA9IHtcbiAgICAgIGF0dHJpYnV0ZTogYXR0ck5hbWVBZnRlcixcbiAgICAgIHR5cGU6IGRhdGEudHlwZSxcbiAgICAgIGFsbG93TnVsbDogZGF0YS5hbGxvd051bGwsXG4gICAgICBkZWZhdWx0VmFsdWU6IGRhdGEuZGVmYXVsdFZhbHVlXG4gICAgfTtcbiAgICBpZiAoZGF0YS5kZWZhdWx0VmFsdWUgPT09IG51bGwgJiYgIWRhdGEuYWxsb3dOdWxsKSB7XG4gICAgICBkZWxldGUgX29wdGlvbnNbYXR0ck5hbWVBZnRlcl0uZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbmFtZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0ck5hbWVCZWZvcmUsIHRoaXMucXVlcnlHZW5lcmF0b3IuYXR0cmlidXRlc1RvU1FMKF9vcHRpb25zKSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgYWRkSW5kZXgodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zLCByYXdUYWJsZW5hbWUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXR0cmlidXRlcykpIHtcbiAgICAgIHJhd1RhYmxlbmFtZSA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0gYXR0cmlidXRlcztcbiAgICAgIGF0dHJpYnV0ZXMgPSBvcHRpb25zLmZpZWxkcztcbiAgICB9XG4gICAgaWYgKCFyYXdUYWJsZW5hbWUpIHtcbiAgICAgIHJhd1RhYmxlbmFtZSA9IHRhYmxlTmFtZTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBvcHRpb25zLmZpZWxkcyA9IGF0dHJpYnV0ZXM7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5hZGRJbmRleFF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucywgcmF3VGFibGVuYW1lKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyBzdXBwb3J0c1NlYXJjaFBhdGg6IGZhbHNlIH0pKTtcbiAgfVxuICBhc3luYyBzaG93SW5kZXgodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5zaG93SW5kZXhlc1F1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgdHlwZTogUXVlcnlUeXBlcy5TSE9XSU5ERVhFUyB9KSk7XG4gIH1cbiAgYXN5bmMgZ2V0Rm9yZWlnbktleXNGb3JUYWJsZXModGFibGVOYW1lcywgb3B0aW9ucykge1xuICAgIGlmICh0YWJsZU5hbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBvcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgdHlwZTogUXVlcnlUeXBlcy5GT1JFSUdOS0VZUyB9KTtcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwodGFibGVOYW1lcy5tYXAoKHRhYmxlTmFtZSkgPT4gdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5nZXRGb3JlaWduS2V5c1F1ZXJ5KHRhYmxlTmFtZSwgdGhpcy5zZXF1ZWxpemUuY29uZmlnLmRhdGFiYXNlKSwgb3B0aW9ucykpKTtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICB0YWJsZU5hbWVzLmZvckVhY2goKHRhYmxlTmFtZSwgaSkgPT4ge1xuICAgICAgaWYgKF8uaXNPYmplY3QodGFibGVOYW1lKSkge1xuICAgICAgICB0YWJsZU5hbWUgPSBgJHt0YWJsZU5hbWUuc2NoZW1hfS4ke3RhYmxlTmFtZS50YWJsZU5hbWV9YDtcbiAgICAgIH1cbiAgICAgIHJlc3VsdFt0YWJsZU5hbWVdID0gQXJyYXkuaXNBcnJheShyZXN1bHRzW2ldKSA/IHJlc3VsdHNbaV0ubWFwKChyKSA9PiByLmNvbnN0cmFpbnRfbmFtZSkgOiBbcmVzdWx0c1tpXSAmJiByZXN1bHRzW2ldLmNvbnN0cmFpbnRfbmFtZV07XG4gICAgICByZXN1bHRbdGFibGVOYW1lXSA9IHJlc3VsdFt0YWJsZU5hbWVdLmZpbHRlcihfLmlkZW50aXR5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIGdldEZvcmVpZ25LZXlSZWZlcmVuY2VzRm9yVGFibGUodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcXVlcnlPcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgIHR5cGU6IFF1ZXJ5VHlwZXMuRk9SRUlHTktFWVNcbiAgICB9KTtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZ2V0Rm9yZWlnbktleXNRdWVyeSh0YWJsZU5hbWUsIHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kYXRhYmFzZSk7XG4gICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHF1ZXJ5LCBxdWVyeU9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIHJlbW92ZUluZGV4KHRhYmxlTmFtZSwgaW5kZXhOYW1lT3JBdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yZW1vdmVJbmRleFF1ZXJ5KHRhYmxlTmFtZSwgaW5kZXhOYW1lT3JBdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBhZGRDb25zdHJhaW50KHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5maWVsZHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkcyBtdXN0IGJlIHNwZWNpZmllZCB0aHJvdWdoIG9wdGlvbnMuZmllbGRzXCIpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMudHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uc3RyYWludCB0eXBlIG11c3QgYmUgc3BlY2lmaWVkIHRocm91Z2ggb3B0aW9ucy50eXBlXCIpO1xuICAgIH1cbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuYWRkQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgc2hvd0NvbnN0cmFpbnQodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3Iuc2hvd0NvbnN0cmFpbnRzUXVlcnkodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgdHlwZTogUXVlcnlUeXBlcy5TSE9XQ09OU1RSQUlOVFMgfSkpO1xuICB9XG4gIGFzeW5jIHJlbW92ZUNvbnN0cmFpbnQodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbW92ZUNvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lKSwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgaW5zZXJ0KGluc3RhbmNlLCB0YWJsZU5hbWUsIHZhbHVlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgb3B0aW9ucy5oYXNUcmlnZ2VyID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuY29uc3RydWN0b3Iub3B0aW9ucy5oYXNUcmlnZ2VyO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuaW5zZXJ0UXVlcnkodGFibGVOYW1lLCB2YWx1ZXMsIGluc3RhbmNlICYmIGluc3RhbmNlLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuSU5TRVJUO1xuICAgIG9wdGlvbnMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICBpZiAoaW5zdGFuY2UpXG4gICAgICByZXN1bHRzWzBdLmlzTmV3UmVjb3JkID0gZmFsc2U7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgYXN5bmMgdXBzZXJ0KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCB1cGRhdGVWYWx1ZXMsIHdoZXJlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKTtcbiAgICBjb25zdCBtb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5VUFNFUlQ7XG4gICAgb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSA9IE9iamVjdC5rZXlzKHVwZGF0ZVZhbHVlcyk7XG4gICAgb3B0aW9ucy51cHNlcnRLZXlzID0gb3B0aW9ucy5jb25mbGljdEZpZWxkcyB8fCBbXTtcbiAgICBpZiAob3B0aW9ucy51cHNlcnRLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgcHJpbWFyeUtleXMgPSBPYmplY3QudmFsdWVzKG1vZGVsLnByaW1hcnlLZXlzKS5tYXAoKGl0ZW0pID0+IGl0ZW0uZmllbGQpO1xuICAgICAgY29uc3QgdW5pcXVlS2V5cyA9IE9iamVjdC52YWx1ZXMobW9kZWwudW5pcXVlS2V5cykuZmlsdGVyKChjKSA9PiBjLmZpZWxkcy5sZW5ndGggPiAwKS5tYXAoKGMpID0+IGMuZmllbGRzKTtcbiAgICAgIGNvbnN0IGluZGV4S2V5cyA9IE9iamVjdC52YWx1ZXMobW9kZWwuX2luZGV4ZXMpLmZpbHRlcigoYykgPT4gYy51bmlxdWUgJiYgYy5maWVsZHMubGVuZ3RoID4gMCkubWFwKChjKSA9PiBjLmZpZWxkcyk7XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUpIHtcbiAgICAgICAgY29uc3QgdW5pcXVlS2V5ID0gdW5pcXVlS2V5cy5maW5kKChmaWVsZHMpID0+IGZpZWxkcy5pbmNsdWRlcyhmaWVsZCkpO1xuICAgICAgICBpZiAodW5pcXVlS2V5KSB7XG4gICAgICAgICAgb3B0aW9ucy51cHNlcnRLZXlzID0gdW5pcXVlS2V5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4S2V5ID0gaW5kZXhLZXlzLmZpbmQoKGZpZWxkcykgPT4gZmllbGRzLmluY2x1ZGVzKGZpZWxkKSk7XG4gICAgICAgIGlmIChpbmRleEtleSkge1xuICAgICAgICAgIG9wdGlvbnMudXBzZXJ0S2V5cyA9IGluZGV4S2V5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy51cHNlcnRLZXlzLmxlbmd0aCA9PT0gMCB8fCBfLmludGVyc2VjdGlvbihvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlLCBwcmltYXJ5S2V5cykubGVuZ3RoKSB7XG4gICAgICAgIG9wdGlvbnMudXBzZXJ0S2V5cyA9IHByaW1hcnlLZXlzO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy51cHNlcnRLZXlzID0gXy51bmlxKG9wdGlvbnMudXBzZXJ0S2V5cyk7XG4gICAgfVxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuaW5zZXJ0UXVlcnkodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIG1vZGVsLnJhd0F0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGJ1bGtJbnNlcnQodGFibGVOYW1lLCByZWNvcmRzLCBvcHRpb25zLCBhdHRyaWJ1dGVzKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKTtcbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLklOU0VSVDtcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5idWxrSW5zZXJ0UXVlcnkodGFibGVOYW1lLCByZWNvcmRzLCBvcHRpb25zLCBhdHRyaWJ1dGVzKSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlc3VsdHNbMF07XG4gIH1cbiAgYXN5bmMgdXBkYXRlKGluc3RhbmNlLCB0YWJsZU5hbWUsIHZhbHVlcywgaWRlbnRpZmllcjIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xuICAgIG9wdGlvbnMuaGFzVHJpZ2dlciA9IGluc3RhbmNlICYmIGluc3RhbmNlLmNvbnN0cnVjdG9yLm9wdGlvbnMuaGFzVHJpZ2dlcjtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnVwZGF0ZVF1ZXJ5KHRhYmxlTmFtZSwgdmFsdWVzLCBpZGVudGlmaWVyMiwgb3B0aW9ucywgaW5zdGFuY2UuY29uc3RydWN0b3IucmF3QXR0cmlidXRlcyk7XG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5VUERBVEU7XG4gICAgb3B0aW9ucy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGJ1bGtVcGRhdGUodGFibGVOYW1lLCB2YWx1ZXMsIGlkZW50aWZpZXIyLCBvcHRpb25zLCBhdHRyaWJ1dGVzKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBpZiAodHlwZW9mIGlkZW50aWZpZXIyID09PSBcIm9iamVjdFwiKVxuICAgICAgaWRlbnRpZmllcjIgPSBVdGlscy5jbG9uZURlZXAoaWRlbnRpZmllcjIpO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IudXBkYXRlUXVlcnkodGFibGVOYW1lLCB2YWx1ZXMsIGlkZW50aWZpZXIyLCBvcHRpb25zLCBhdHRyaWJ1dGVzKTtcbiAgICBjb25zdCB0YWJsZSA9IF8uaXNPYmplY3QodGFibGVOYW1lKSA/IHRhYmxlTmFtZSA6IHsgdGFibGVOYW1lIH07XG4gICAgY29uc3QgbW9kZWwgPSBvcHRpb25zLm1vZGVsID8gb3B0aW9ucy5tb2RlbCA6IF8uZmluZCh0aGlzLnNlcXVlbGl6ZS5tb2RlbE1hbmFnZXIubW9kZWxzLCB7IHRhYmxlTmFtZTogdGFibGUudGFibGVOYW1lIH0pO1xuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuQlVMS1VQREFURTtcbiAgICBvcHRpb25zLm1vZGVsID0gbW9kZWw7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgZGVsZXRlKGluc3RhbmNlLCB0YWJsZU5hbWUsIGlkZW50aWZpZXIyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2FzY2FkZXMgPSBbXTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRlbGV0ZVF1ZXJ5KHRhYmxlTmFtZSwgaWRlbnRpZmllcjIsIHt9LCBpbnN0YW5jZS5jb25zdHJ1Y3Rvcik7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKTtcbiAgICBpZiAoISFpbnN0YW5jZS5jb25zdHJ1Y3RvciAmJiAhIWluc3RhbmNlLmNvbnN0cnVjdG9yLmFzc29jaWF0aW9ucykge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGluc3RhbmNlLmNvbnN0cnVjdG9yLmFzc29jaWF0aW9ucyk7XG4gICAgICBjb25zdCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgIGxldCBhc3NvY2lhdGlvbjtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXNzb2NpYXRpb24gPSBpbnN0YW5jZS5jb25zdHJ1Y3Rvci5hc3NvY2lhdGlvbnNba2V5c1tpXV07XG4gICAgICAgIGlmIChhc3NvY2lhdGlvbi5vcHRpb25zICYmIGFzc29jaWF0aW9uLm9wdGlvbnMub25EZWxldGUgJiYgYXNzb2NpYXRpb24ub3B0aW9ucy5vbkRlbGV0ZS50b0xvd2VyQ2FzZSgpID09PSBcImNhc2NhZGVcIiAmJiBhc3NvY2lhdGlvbi5vcHRpb25zLnVzZUhvb2tzID09PSB0cnVlKSB7XG4gICAgICAgICAgY2FzY2FkZXMucHVzaChhc3NvY2lhdGlvbi5hY2Nlc3NvcnMuZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNhc2NhZGUgb2YgY2FzY2FkZXMpIHtcbiAgICAgIGxldCBpbnN0YW5jZXMgPSBhd2FpdCBpbnN0YW5jZVtjYXNjYWRlXShvcHRpb25zKTtcbiAgICAgIGlmICghaW5zdGFuY2VzKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnN0YW5jZXMpKVxuICAgICAgICBpbnN0YW5jZXMgPSBbaW5zdGFuY2VzXTtcbiAgICAgIGZvciAoY29uc3QgX2luc3RhbmNlIG9mIGluc3RhbmNlcylcbiAgICAgICAgYXdhaXQgX2luc3RhbmNlLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgfVxuICAgIG9wdGlvbnMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBidWxrRGVsZXRlKHRhYmxlTmFtZSwgd2hlcmUsIG9wdGlvbnMsIG1vZGVsKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBvcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zLCB7IGxpbWl0OiBudWxsIH0pO1xuICAgIGlmIChvcHRpb25zLnRydW5jYXRlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci50cnVuY2F0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaWRlbnRpZmllciA9PT0gXCJvYmplY3RcIilcbiAgICAgIHdoZXJlID0gVXRpbHMuY2xvbmVEZWVwKHdoZXJlKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5kZWxldGVRdWVyeSh0YWJsZU5hbWUsIHdoZXJlLCBvcHRpb25zLCBtb2RlbCksIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIHNlbGVjdChtb2RlbCwgdGFibGVOYW1lLCBvcHRpb25zQXJnKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnNBcmcpLCB7IHR5cGU6IFF1ZXJ5VHlwZXMuU0VMRUNULCBtb2RlbCB9KTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5zZWxlY3RRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMsIG1vZGVsKSwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgaW5jcmVtZW50KG1vZGVsLCB0YWJsZU5hbWUsIHdoZXJlLCBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCwgZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuYXJpdGhtZXRpY1F1ZXJ5KFwiK1wiLCB0YWJsZU5hbWUsIHdoZXJlLCBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCwgZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQsIG9wdGlvbnMpO1xuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuVVBEQVRFO1xuICAgIG9wdGlvbnMubW9kZWwgPSBtb2RlbDtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBkZWNyZW1lbnQobW9kZWwsIHRhYmxlTmFtZSwgd2hlcmUsIGluY3JlbWVudEFtb3VudHNCeUZpZWxkLCBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5hcml0aG1ldGljUXVlcnkoXCItXCIsIHRhYmxlTmFtZSwgd2hlcmUsIGluY3JlbWVudEFtb3VudHNCeUZpZWxkLCBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCwgb3B0aW9ucyk7XG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5VUERBVEU7XG4gICAgb3B0aW9ucy5tb2RlbCA9IG1vZGVsO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIHJhd1NlbGVjdCh0YWJsZU5hbWUsIG9wdGlvbnMsIGF0dHJpYnV0ZVNlbGVjdG9yLCBNb2RlbCkge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgcmF3OiB0cnVlLFxuICAgICAgcGxhaW46IHRydWUsXG4gICAgICB0eXBlOiBRdWVyeVR5cGVzLlNFTEVDVFxuICAgIH0pO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3Iuc2VsZWN0UXVlcnkodGFibGVOYW1lLCBvcHRpb25zLCBNb2RlbCk7XG4gICAgaWYgKGF0dHJpYnV0ZVNlbGVjdG9yID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwYXNzIGFuIGF0dHJpYnV0ZSBzZWxlY3RvciFcIik7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgIGlmICghb3B0aW9ucy5wbGFpbikge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGRhdGEgPyBkYXRhW2F0dHJpYnV0ZVNlbGVjdG9yXSA6IG51bGw7XG4gICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLmRhdGFUeXBlKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBkYXRhVHlwZSA9IG9wdGlvbnMuZGF0YVR5cGU7XG4gICAgaWYgKGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkRFQ0lNQUwgfHwgZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRkxPQVQpIHtcbiAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLklOVEVHRVIgfHwgZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQklHSU5UKSB7XG4gICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChyZXN1bHQsIDEwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkRBVEUpIHtcbiAgICAgIGlmIChyZXN1bHQgIT09IG51bGwgJiYgIShyZXN1bHQgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyBjcmVhdGVUcmlnZ2VyKHRhYmxlTmFtZSwgdHJpZ2dlck5hbWUsIHRpbWluZ1R5cGUsIGZpcmVPbkFycmF5LCBmdW5jdGlvbk5hbWUsIGZ1bmN0aW9uUGFyYW1zLCBvcHRpb25zQXJyYXksIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmNyZWF0ZVRyaWdnZXIodGFibGVOYW1lLCB0cmlnZ2VyTmFtZSwgdGltaW5nVHlwZSwgZmlyZU9uQXJyYXksIGZ1bmN0aW9uTmFtZSwgZnVuY3Rpb25QYXJhbXMsIG9wdGlvbnNBcnJheSk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHNxbCkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGRyb3BUcmlnZ2VyKHRhYmxlTmFtZSwgdHJpZ2dlck5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BUcmlnZ2VyKHRhYmxlTmFtZSwgdHJpZ2dlck5hbWUpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChzcWwpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBhc3luYyByZW5hbWVUcmlnZ2VyKHRhYmxlTmFtZSwgb2xkVHJpZ2dlck5hbWUsIG5ld1RyaWdnZXJOYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yZW5hbWVUcmlnZ2VyKHRhYmxlTmFtZSwgb2xkVHJpZ2dlck5hbWUsIG5ld1RyaWdnZXJOYW1lKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoc3FsKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY3JlYXRlRnVuY3Rpb24oZnVuY3Rpb25OYW1lLCBwYXJhbXMsIHJldHVyblR5cGUsIGxhbmd1YWdlLCBib2R5LCBvcHRpb25zQXJyYXksIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmNyZWF0ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgcGFyYW1zLCByZXR1cm5UeXBlLCBsYW5ndWFnZSwgYm9keSwgb3B0aW9uc0FycmF5LCBvcHRpb25zKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoc3FsKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZHJvcEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wRnVuY3Rpb24oZnVuY3Rpb25OYW1lLCBwYXJhbXMpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChzcWwpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBhc3luYyByZW5hbWVGdW5jdGlvbihvbGRGdW5jdGlvbk5hbWUsIHBhcmFtcywgbmV3RnVuY3Rpb25OYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yZW5hbWVGdW5jdGlvbihvbGRGdW5jdGlvbk5hbWUsIHBhcmFtcywgbmV3RnVuY3Rpb25OYW1lKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoc3FsKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgZW5zdXJlRW51bXMoKSB7XG4gIH1cbiAgYXN5bmMgc2V0SXNvbGF0aW9uTGV2ZWwodHJhbnNhY3Rpb24sIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0cmFuc2FjdGlvbiB8fCAhKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gc2V0IGlzb2xhdGlvbiBsZXZlbCBmb3IgYSB0cmFuc2FjdGlvbiB3aXRob3V0IHRyYW5zYWN0aW9uIG9iamVjdCFcIik7XG4gICAgfVxuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQgfHwgIXZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24ucGFyZW50IHx8IHRyYW5zYWN0aW9uIH0pO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3Iuc2V0SXNvbGF0aW9uTGV2ZWxRdWVyeSh2YWx1ZSwge1xuICAgICAgcGFyZW50OiB0cmFuc2FjdGlvbi5wYXJlbnRcbiAgICB9KTtcbiAgICBpZiAoIXNxbClcbiAgICAgIHJldHVybjtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBzdGFydFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0cmFuc2FjdGlvbiB8fCAhKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gc3RhcnQgYSB0cmFuc2FjdGlvbiB3aXRob3V0IHRyYW5zYWN0aW9uIG9iamVjdCFcIik7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24ucGFyZW50IHx8IHRyYW5zYWN0aW9uIH0pO1xuICAgIG9wdGlvbnMudHJhbnNhY3Rpb24ubmFtZSA9IHRyYW5zYWN0aW9uLnBhcmVudCA/IHRyYW5zYWN0aW9uLm5hbWUgOiB2b2lkIDA7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5zdGFydFRyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGRlZmVyQ29uc3RyYWludHModHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLnBhcmVudCB8fCB0cmFuc2FjdGlvbiB9KTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRlZmVyQ29uc3RyYWludHNRdWVyeShvcHRpb25zKTtcbiAgICBpZiAoc3FsKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY29tbWl0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRyYW5zYWN0aW9uIHx8ICEodHJhbnNhY3Rpb24gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjb21taXQgYSB0cmFuc2FjdGlvbiB3aXRob3V0IHRyYW5zYWN0aW9uIG9iamVjdCFcIik7XG4gICAgfVxuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24ucGFyZW50IHx8IHRyYW5zYWN0aW9uLFxuICAgICAgc3VwcG9ydHNTZWFyY2hQYXRoOiBmYWxzZSxcbiAgICAgIGNvbXBsZXRlc1RyYW5zYWN0aW9uOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5jb21taXRUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKTtcbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICB0cmFuc2FjdGlvbi5maW5pc2hlZCA9IFwiY29tbWl0XCI7XG4gICAgcmV0dXJuIGF3YWl0IHByb21pc2U7XG4gIH1cbiAgYXN5bmMgcm9sbGJhY2tUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGlmICghdHJhbnNhY3Rpb24gfHwgISh0cmFuc2FjdGlvbiBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJvbGxiYWNrIGEgdHJhbnNhY3Rpb24gd2l0aG91dCB0cmFuc2FjdGlvbiBvYmplY3QhXCIpO1xuICAgIH1cbiAgICBvcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbi5wYXJlbnQgfHwgdHJhbnNhY3Rpb24sXG4gICAgICBzdXBwb3J0c1NlYXJjaFBhdGg6IGZhbHNlLFxuICAgICAgY29tcGxldGVzVHJhbnNhY3Rpb246IHRydWVcbiAgICB9KTtcbiAgICBvcHRpb25zLnRyYW5zYWN0aW9uLm5hbWUgPSB0cmFuc2FjdGlvbi5wYXJlbnQgPyB0cmFuc2FjdGlvbi5uYW1lIDogdm9pZCAwO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3Iucm9sbGJhY2tUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKTtcbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICB0cmFuc2FjdGlvbi5maW5pc2hlZCA9IFwicm9sbGJhY2tcIjtcbiAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcbiAgfVxufVxuZXhwb3J0cy5RdWVyeUludGVyZmFjZSA9IFF1ZXJ5SW50ZXJmYWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnktaW50ZXJmYWNlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-interface.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query.js":
/*!****************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/abstract/query.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst SqlString = __webpack_require__(/*! ../../sql-string */ \"(action-browser)/../node_modules/sequelize/lib/sql-string.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(action-browser)/../node_modules/sequelize/lib/query-types.js\");\nconst Dot = __webpack_require__(/*! dottie */ \"(action-browser)/../node_modules/dottie/dottie.js\");\nconst deprecations = __webpack_require__(/*! ../../utils/deprecations */ \"(action-browser)/../node_modules/sequelize/lib/utils/deprecations.js\");\nconst uuid = (__webpack_require__(/*! uuid */ \"(action-browser)/../node_modules/uuid/dist/esm-node/index.js\").v4);\nconst { safeStringifyJson } = __webpack_require__(/*! ../../utils.js */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nclass AbstractQuery {\n  constructor(connection, sequelize, options) {\n    this.uuid = uuid();\n    this.connection = connection;\n    this.instance = options.instance;\n    this.model = options.model;\n    this.sequelize = sequelize;\n    this.options = __spreadValues({\n      plain: false,\n      raw: false,\n      logging: console.log\n    }, options);\n    this.checkLoggingOption();\n    if (options.rawErrors) {\n      this.formatError = AbstractQuery.prototype.formatError;\n    }\n  }\n  static formatBindParameters(sql, values, dialect, replacementFunc, options) {\n    if (!values) {\n      return [sql, []];\n    }\n    options = options || {};\n    if (typeof replacementFunc !== \"function\") {\n      options = replacementFunc || {};\n      replacementFunc = void 0;\n    }\n    if (!replacementFunc) {\n      if (options.skipValueReplace) {\n        replacementFunc = (match, key, values2) => {\n          if (values2[key] !== void 0) {\n            return match;\n          }\n          return void 0;\n        };\n      } else {\n        replacementFunc = (match, key, values2, timeZone2, dialect2) => {\n          if (values2[key] !== void 0) {\n            return SqlString.escape(values2[key], timeZone2, dialect2);\n          }\n          return void 0;\n        };\n      }\n    } else if (options.skipValueReplace) {\n      const origReplacementFunc = replacementFunc;\n      replacementFunc = (match, key, values2, timeZone2, dialect2, options2) => {\n        if (origReplacementFunc(match, key, values2, timeZone2, dialect2, options2) !== void 0) {\n          return match;\n        }\n        return void 0;\n      };\n    }\n    const timeZone = null;\n    const list = Array.isArray(values);\n    sql = sql.replace(/\\B\\$(\\$|\\w+)/g, (match, key) => {\n      if (key === \"$\") {\n        return options.skipUnescape ? match : key;\n      }\n      let replVal;\n      if (list) {\n        if (key.match(/^[1-9]\\d*$/)) {\n          key = key - 1;\n          replVal = replacementFunc(match, key, values, timeZone, dialect, options);\n        }\n      } else if (!key.match(/^\\d*$/)) {\n        replVal = replacementFunc(match, key, values, timeZone, dialect, options);\n      }\n      if (replVal === void 0) {\n        throw new Error(`Named bind parameter \"${match}\" has no value in the given object.`);\n      }\n      return replVal;\n    });\n    return [sql, []];\n  }\n  formatError(error, errStack) {\n    error.stack = errStack;\n    return error;\n  }\n  run() {\n    throw new Error(\"The run method wasn't overwritten!\");\n  }\n  checkLoggingOption() {\n    if (this.options.logging === true) {\n      deprecations.noTrueLogging();\n      this.options.logging = console.log;\n    }\n  }\n  getInsertIdField() {\n    return \"insertId\";\n  }\n  getUniqueConstraintErrorMessage(field) {\n    let message = field ? `${field} must be unique` : \"Must be unique\";\n    if (field && this.model) {\n      for (const key of Object.keys(this.model.uniqueKeys)) {\n        if (this.model.uniqueKeys[key].fields.includes(field.replace(/\"/g, \"\"))) {\n          if (this.model.uniqueKeys[key].msg) {\n            message = this.model.uniqueKeys[key].msg;\n          }\n        }\n      }\n    }\n    return message;\n  }\n  isRawQuery() {\n    return this.options.type === QueryTypes.RAW;\n  }\n  isVersionQuery() {\n    return this.options.type === QueryTypes.VERSION;\n  }\n  isUpsertQuery() {\n    return this.options.type === QueryTypes.UPSERT;\n  }\n  isInsertQuery(results, metaData) {\n    let result = true;\n    if (this.options.type === QueryTypes.INSERT) {\n      return true;\n    }\n    result = result && this.sql.toLowerCase().startsWith(\"insert into\");\n    result = result && (!results || Object.prototype.hasOwnProperty.call(results, this.getInsertIdField()));\n    result = result && (!metaData || Object.prototype.hasOwnProperty.call(metaData, this.getInsertIdField()));\n    return result;\n  }\n  handleInsertQuery(results, metaData) {\n    if (this.instance) {\n      const autoIncrementAttribute = this.model.autoIncrementAttribute;\n      let id = null;\n      id = id || results && results[this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      this.instance[autoIncrementAttribute] = id;\n    }\n  }\n  isShowTablesQuery() {\n    return this.options.type === QueryTypes.SHOWTABLES;\n  }\n  handleShowTablesQuery(results) {\n    return _.flatten(results.map((resultSet) => Object.values(resultSet)));\n  }\n  isShowIndexesQuery() {\n    return this.options.type === QueryTypes.SHOWINDEXES;\n  }\n  isShowConstraintsQuery() {\n    return this.options.type === QueryTypes.SHOWCONSTRAINTS;\n  }\n  isDescribeQuery() {\n    return this.options.type === QueryTypes.DESCRIBE;\n  }\n  isSelectQuery() {\n    return this.options.type === QueryTypes.SELECT;\n  }\n  isBulkUpdateQuery() {\n    return this.options.type === QueryTypes.BULKUPDATE;\n  }\n  isBulkDeleteQuery() {\n    return this.options.type === QueryTypes.BULKDELETE;\n  }\n  isForeignKeysQuery() {\n    return this.options.type === QueryTypes.FOREIGNKEYS;\n  }\n  isUpdateQuery() {\n    return this.options.type === QueryTypes.UPDATE;\n  }\n  handleSelectQuery(results) {\n    let result = null;\n    if (this.options.fieldMap) {\n      const fieldMap = this.options.fieldMap;\n      results = results.map((result2) => _.reduce(fieldMap, (result3, name, field) => {\n        if (result3[field] !== void 0 && name !== field) {\n          result3[name] = result3[field];\n          delete result3[field];\n        }\n        return result3;\n      }, result2));\n    }\n    if (this.options.raw) {\n      result = results.map((result2) => {\n        let o = {};\n        for (const key in result2) {\n          if (Object.prototype.hasOwnProperty.call(result2, key)) {\n            o[key] = result2[key];\n          }\n        }\n        if (this.options.nest) {\n          o = Dot.transform(o);\n        }\n        return o;\n      });\n    } else if (this.options.hasJoin === true) {\n      results = AbstractQuery._groupJoinData(results, {\n        model: this.model,\n        includeMap: this.options.includeMap,\n        includeNames: this.options.includeNames\n      }, {\n        checkExisting: this.options.hasMultiAssociation\n      });\n      result = this.model.bulkBuild(results, {\n        isNewRecord: false,\n        include: this.options.include,\n        includeNames: this.options.includeNames,\n        includeMap: this.options.includeMap,\n        includeValidated: true,\n        attributes: this.options.originalAttributes || this.options.attributes,\n        raw: true\n      });\n    } else {\n      result = this.model.bulkBuild(results, {\n        isNewRecord: false,\n        raw: true,\n        attributes: this.options.originalAttributes || this.options.attributes\n      });\n    }\n    if (this.options.plain) {\n      result = result.length === 0 ? null : result[0];\n    }\n    return result;\n  }\n  isShowOrDescribeQuery() {\n    let result = false;\n    result = result || this.sql.toLowerCase().startsWith(\"show\");\n    result = result || this.sql.toLowerCase().startsWith(\"describe\");\n    return result;\n  }\n  isCallQuery() {\n    return this.sql.toLowerCase().startsWith(\"call\");\n  }\n  _logQuery(sql, debugContext, parameters) {\n    const { connection, options } = this;\n    const benchmark = this.sequelize.options.benchmark || options.benchmark;\n    const logQueryParameters = this.sequelize.options.logQueryParameters || options.logQueryParameters;\n    const startTime = Date.now();\n    let logParameter = \"\";\n    if (logQueryParameters && parameters) {\n      const delimiter = sql.endsWith(\";\") ? \"\" : \";\";\n      let paramStr;\n      if (Array.isArray(parameters)) {\n        paramStr = parameters.map((p) => safeStringifyJson(p)).join(\", \");\n      } else {\n        paramStr = safeStringifyJson(parameters);\n      }\n      logParameter = `${delimiter} ${paramStr}`;\n    }\n    const fmt = `(${connection.uuid || \"default\"}): ${sql}${logParameter}`;\n    const msg = `Executing ${fmt}`;\n    debugContext(msg);\n    if (!benchmark) {\n      this.sequelize.log(`Executing ${fmt}`, options);\n    }\n    return () => {\n      const afterMsg = `Executed ${fmt}`;\n      debugContext(afterMsg);\n      if (benchmark) {\n        this.sequelize.log(afterMsg, Date.now() - startTime, options);\n      }\n    };\n  }\n  static _groupJoinData(rows, includeOptions, options) {\n    if (!rows.length) {\n      return [];\n    }\n    let i;\n    let length;\n    let $i;\n    let $length;\n    let rowsI;\n    let row;\n    const rowsLength = rows.length;\n    let keys;\n    let key;\n    let keyI;\n    let keyLength;\n    let prevKey;\n    let values;\n    let topValues;\n    let topExists;\n    const checkExisting = options.checkExisting;\n    let itemHash;\n    let parentHash;\n    let topHash;\n    const results = checkExisting ? [] : new Array(rowsLength);\n    const resultMap = {};\n    const includeMap = {};\n    let $keyPrefix;\n    let $keyPrefixString;\n    let $prevKeyPrefixString;\n    let $prevKeyPrefix;\n    let $lastKeyPrefix;\n    let $current;\n    let $parent;\n    let previousPiece;\n    const buildIncludeMap = (piece) => {\n      if (Object.prototype.hasOwnProperty.call($current.includeMap, piece)) {\n        includeMap[key] = $current = $current.includeMap[piece];\n        if (previousPiece) {\n          previousPiece = `${previousPiece}.${piece}`;\n        } else {\n          previousPiece = piece;\n        }\n        includeMap[previousPiece] = $current;\n      }\n    };\n    const keyPrefixStringMemo = {};\n    const keyPrefixString = (key2, memo) => {\n      if (!Object.prototype.hasOwnProperty.call(memo, key2)) {\n        memo[key2] = key2.substr(0, key2.lastIndexOf(\".\"));\n      }\n      return memo[key2];\n    };\n    const removeKeyPrefixMemo = {};\n    const removeKeyPrefix = (key2) => {\n      if (!Object.prototype.hasOwnProperty.call(removeKeyPrefixMemo, key2)) {\n        const index = key2.lastIndexOf(\".\");\n        removeKeyPrefixMemo[key2] = key2.substr(index === -1 ? 0 : index + 1);\n      }\n      return removeKeyPrefixMemo[key2];\n    };\n    const keyPrefixMemo = {};\n    const keyPrefix = (key2) => {\n      if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, key2)) {\n        const prefixString = keyPrefixString(key2, keyPrefixStringMemo);\n        if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, prefixString)) {\n          keyPrefixMemo[prefixString] = prefixString ? prefixString.split(\".\") : [];\n        }\n        keyPrefixMemo[key2] = keyPrefixMemo[prefixString];\n      }\n      return keyPrefixMemo[key2];\n    };\n    const lastKeyPrefixMemo = {};\n    const lastKeyPrefix = (key2) => {\n      if (!Object.prototype.hasOwnProperty.call(lastKeyPrefixMemo, key2)) {\n        const prefix2 = keyPrefix(key2);\n        const length2 = prefix2.length;\n        lastKeyPrefixMemo[key2] = !length2 ? \"\" : prefix2[length2 - 1];\n      }\n      return lastKeyPrefixMemo[key2];\n    };\n    const getUniqueKeyAttributes = (model) => {\n      let uniqueKeyAttributes2 = _.chain(model.uniqueKeys);\n      uniqueKeyAttributes2 = uniqueKeyAttributes2.result(`${uniqueKeyAttributes2.findKey()}.fields`).map((field) => _.findKey(model.attributes, (chr) => chr.field === field)).value();\n      return uniqueKeyAttributes2;\n    };\n    const stringify = (obj) => obj instanceof Buffer ? obj.toString(\"hex\") : obj;\n    let primaryKeyAttributes;\n    let uniqueKeyAttributes;\n    let prefix;\n    for (rowsI = 0; rowsI < rowsLength; rowsI++) {\n      row = rows[rowsI];\n      if (rowsI === 0) {\n        keys = _.sortBy(Object.keys(row), (item) => [item.split(\".\").length]);\n        keyLength = keys.length;\n      }\n      if (checkExisting) {\n        topExists = false;\n        $length = includeOptions.model.primaryKeyAttributes.length;\n        topHash = \"\";\n        if ($length === 1) {\n          topHash = stringify(row[includeOptions.model.primaryKeyAttributes[0]]);\n        } else if ($length > 1) {\n          for ($i = 0; $i < $length; $i++) {\n            topHash += stringify(row[includeOptions.model.primaryKeyAttributes[$i]]);\n          }\n        } else if (!_.isEmpty(includeOptions.model.uniqueKeys)) {\n          uniqueKeyAttributes = getUniqueKeyAttributes(includeOptions.model);\n          for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n            topHash += row[uniqueKeyAttributes[$i]];\n          }\n        }\n      }\n      topValues = values = {};\n      $prevKeyPrefix = void 0;\n      for (keyI = 0; keyI < keyLength; keyI++) {\n        key = keys[keyI];\n        $keyPrefixString = keyPrefixString(key, keyPrefixStringMemo);\n        $keyPrefix = keyPrefix(key);\n        if (rowsI === 0 && !Object.prototype.hasOwnProperty.call(includeMap, key)) {\n          if (!$keyPrefix.length) {\n            includeMap[key] = includeMap[\"\"] = includeOptions;\n          } else {\n            $current = includeOptions;\n            previousPiece = void 0;\n            $keyPrefix.forEach(buildIncludeMap);\n          }\n        }\n        if ($prevKeyPrefix !== void 0 && $prevKeyPrefix !== $keyPrefix) {\n          if (checkExisting) {\n            length = $prevKeyPrefix.length;\n            $parent = null;\n            parentHash = null;\n            if (length) {\n              for (i = 0; i < length; i++) {\n                prefix = $parent ? `${$parent}.${$prevKeyPrefix[i]}` : $prevKeyPrefix[i];\n                primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;\n                $length = primaryKeyAttributes.length;\n                itemHash = prefix;\n                if ($length === 1) {\n                  itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[0]}`]);\n                } else if ($length > 1) {\n                  for ($i = 0; $i < $length; $i++) {\n                    itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[$i]}`]);\n                  }\n                } else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {\n                  uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);\n                  for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n                    itemHash += row[`${prefix}.${uniqueKeyAttributes[$i]}`];\n                  }\n                }\n                if (!parentHash) {\n                  parentHash = topHash;\n                }\n                itemHash = parentHash + itemHash;\n                $parent = prefix;\n                if (i < length - 1) {\n                  parentHash = itemHash;\n                }\n              }\n            } else {\n              itemHash = topHash;\n            }\n            if (itemHash === topHash) {\n              if (!resultMap[itemHash]) {\n                resultMap[itemHash] = values;\n              } else {\n                topExists = true;\n              }\n            } else if (!resultMap[itemHash]) {\n              $parent = resultMap[parentHash];\n              $lastKeyPrefix = lastKeyPrefix(prevKey);\n              if (includeMap[prevKey].association.isSingleAssociation) {\n                if ($parent) {\n                  $parent[$lastKeyPrefix] = resultMap[itemHash] = values;\n                }\n              } else {\n                if (!$parent[$lastKeyPrefix]) {\n                  $parent[$lastKeyPrefix] = [];\n                }\n                $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);\n              }\n            }\n            values = {};\n          } else {\n            $current = topValues;\n            length = $keyPrefix.length;\n            if (length) {\n              for (i = 0; i < length; i++) {\n                if (i === length - 1) {\n                  values = $current[$keyPrefix[i]] = {};\n                }\n                $current = $current[$keyPrefix[i]] || {};\n              }\n            }\n          }\n        }\n        values[removeKeyPrefix(key)] = row[key];\n        prevKey = key;\n        $prevKeyPrefix = $keyPrefix;\n        $prevKeyPrefixString = $keyPrefixString;\n      }\n      if (checkExisting) {\n        length = $prevKeyPrefix.length;\n        $parent = null;\n        parentHash = null;\n        if (length) {\n          for (i = 0; i < length; i++) {\n            prefix = $parent ? `${$parent}.${$prevKeyPrefix[i]}` : $prevKeyPrefix[i];\n            primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;\n            $length = primaryKeyAttributes.length;\n            itemHash = prefix;\n            if ($length === 1) {\n              itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[0]}`]);\n            } else if ($length > 0) {\n              for ($i = 0; $i < $length; $i++) {\n                itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[$i]}`]);\n              }\n            } else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {\n              uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);\n              for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n                itemHash += row[`${prefix}.${uniqueKeyAttributes[$i]}`];\n              }\n            }\n            if (!parentHash) {\n              parentHash = topHash;\n            }\n            itemHash = parentHash + itemHash;\n            $parent = prefix;\n            if (i < length - 1) {\n              parentHash = itemHash;\n            }\n          }\n        } else {\n          itemHash = topHash;\n        }\n        if (itemHash === topHash) {\n          if (!resultMap[itemHash]) {\n            resultMap[itemHash] = values;\n          } else {\n            topExists = true;\n          }\n        } else if (!resultMap[itemHash]) {\n          $parent = resultMap[parentHash];\n          $lastKeyPrefix = lastKeyPrefix(prevKey);\n          if (includeMap[prevKey].association.isSingleAssociation) {\n            if ($parent) {\n              $parent[$lastKeyPrefix] = resultMap[itemHash] = values;\n            }\n          } else {\n            if (!$parent[$lastKeyPrefix]) {\n              $parent[$lastKeyPrefix] = [];\n            }\n            $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);\n          }\n        }\n        if (!topExists) {\n          results.push(topValues);\n        }\n      } else {\n        results[rowsI] = topValues;\n      }\n    }\n    return results;\n  }\n}\nmodule.exports = AbstractQuery;\nmodule.exports.AbstractQuery = AbstractQuery;\nmodule.exports[\"default\"] = AbstractQuery;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFPLENBQUMsaUVBQVE7QUFDMUIsa0JBQWtCLG1CQUFPLENBQUMsc0ZBQWtCO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLHdGQUFtQjtBQUM5QyxZQUFZLG1CQUFPLENBQUMsaUVBQVE7QUFDNUIscUJBQXFCLG1CQUFPLENBQUMsc0dBQTBCO0FBQ3ZELGFBQWEsb0dBQWtCO0FBQy9CLFFBQVEsb0JBQW9CLEVBQUUsbUJBQU8sQ0FBQywrRUFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVyxFQUFFLFNBQVM7QUFDOUM7QUFDQSxvQkFBb0IsNkJBQTZCLEtBQUssSUFBSSxFQUFFLGFBQWE7QUFDekUsNkJBQTZCLElBQUk7QUFDakM7QUFDQTtBQUNBLHNDQUFzQyxJQUFJO0FBQzFDO0FBQ0E7QUFDQSxtQ0FBbUMsSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWMsR0FBRyxNQUFNO0FBQ3BELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsK0JBQStCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVix1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsdUJBQXVCLGlDQUFpQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEMsc0NBQXNDLFFBQVEsR0FBRyxrQkFBa0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTyxHQUFHLHdCQUF3QjtBQUNqRixrQkFBa0I7QUFDbEIsK0JBQStCLGNBQWM7QUFDN0MsaURBQWlELE9BQU8sR0FBRyx5QkFBeUI7QUFDcEY7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSwrQkFBK0IsaUNBQWlDO0FBQ2hFLHVDQUF1QyxPQUFPLEdBQUcsd0JBQXdCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQyxrQ0FBa0MsUUFBUSxHQUFHLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPLEdBQUcsd0JBQXdCO0FBQzdFLGNBQWM7QUFDZCwyQkFBMkIsY0FBYztBQUN6Qyw2Q0FBNkMsT0FBTyxHQUFHLHlCQUF5QjtBQUNoRjtBQUNBLGNBQWM7QUFDZDtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQsbUNBQW1DLE9BQU8sR0FBRyx3QkFBd0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qix5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvYWJzdHJhY3QvcXVlcnkuanM/NDA2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgU3FsU3RyaW5nID0gcmVxdWlyZShcIi4uLy4uL3NxbC1zdHJpbmdcIik7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL3F1ZXJ5LXR5cGVzXCIpO1xuY29uc3QgRG90ID0gcmVxdWlyZShcImRvdHRpZVwiKTtcbmNvbnN0IGRlcHJlY2F0aW9ucyA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9kZXByZWNhdGlvbnNcIik7XG5jb25zdCB1dWlkID0gcmVxdWlyZShcInV1aWRcIikudjQ7XG5jb25zdCB7IHNhZmVTdHJpbmdpZnlKc29uIH0gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMuanNcIik7XG5jbGFzcyBBYnN0cmFjdFF1ZXJ5IHtcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbiwgc2VxdWVsaXplLCBvcHRpb25zKSB7XG4gICAgdGhpcy51dWlkID0gdXVpZCgpO1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgdGhpcy5pbnN0YW5jZSA9IG9wdGlvbnMuaW5zdGFuY2U7XG4gICAgdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5vcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgcGxhaW46IGZhbHNlLFxuICAgICAgcmF3OiBmYWxzZSxcbiAgICAgIGxvZ2dpbmc6IGNvbnNvbGUubG9nXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgdGhpcy5jaGVja0xvZ2dpbmdPcHRpb24oKTtcbiAgICBpZiAob3B0aW9ucy5yYXdFcnJvcnMpIHtcbiAgICAgIHRoaXMuZm9ybWF0RXJyb3IgPSBBYnN0cmFjdFF1ZXJ5LnByb3RvdHlwZS5mb3JtYXRFcnJvcjtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0LCByZXBsYWNlbWVudEZ1bmMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXZhbHVlcykge1xuICAgICAgcmV0dXJuIFtzcWwsIFtdXTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHR5cGVvZiByZXBsYWNlbWVudEZ1bmMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgb3B0aW9ucyA9IHJlcGxhY2VtZW50RnVuYyB8fCB7fTtcbiAgICAgIHJlcGxhY2VtZW50RnVuYyA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKCFyZXBsYWNlbWVudEZ1bmMpIHtcbiAgICAgIGlmIChvcHRpb25zLnNraXBWYWx1ZVJlcGxhY2UpIHtcbiAgICAgICAgcmVwbGFjZW1lbnRGdW5jID0gKG1hdGNoLCBrZXksIHZhbHVlczIpID0+IHtcbiAgICAgICAgICBpZiAodmFsdWVzMltrZXldICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcGxhY2VtZW50RnVuYyA9IChtYXRjaCwga2V5LCB2YWx1ZXMyLCB0aW1lWm9uZTIsIGRpYWxlY3QyKSA9PiB7XG4gICAgICAgICAgaWYgKHZhbHVlczJba2V5XSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gU3FsU3RyaW5nLmVzY2FwZSh2YWx1ZXMyW2tleV0sIHRpbWVab25lMiwgZGlhbGVjdDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5za2lwVmFsdWVSZXBsYWNlKSB7XG4gICAgICBjb25zdCBvcmlnUmVwbGFjZW1lbnRGdW5jID0gcmVwbGFjZW1lbnRGdW5jO1xuICAgICAgcmVwbGFjZW1lbnRGdW5jID0gKG1hdGNoLCBrZXksIHZhbHVlczIsIHRpbWVab25lMiwgZGlhbGVjdDIsIG9wdGlvbnMyKSA9PiB7XG4gICAgICAgIGlmIChvcmlnUmVwbGFjZW1lbnRGdW5jKG1hdGNoLCBrZXksIHZhbHVlczIsIHRpbWVab25lMiwgZGlhbGVjdDIsIG9wdGlvbnMyKSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB0aW1lWm9uZSA9IG51bGw7XG4gICAgY29uc3QgbGlzdCA9IEFycmF5LmlzQXJyYXkodmFsdWVzKTtcbiAgICBzcWwgPSBzcWwucmVwbGFjZSgvXFxCXFwkKFxcJHxcXHcrKS9nLCAobWF0Y2gsIGtleSkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gXCIkXCIpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuc2tpcFVuZXNjYXBlID8gbWF0Y2ggOiBrZXk7XG4gICAgICB9XG4gICAgICBsZXQgcmVwbFZhbDtcbiAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgIGlmIChrZXkubWF0Y2goL15bMS05XVxcZCokLykpIHtcbiAgICAgICAgICBrZXkgPSBrZXkgLSAxO1xuICAgICAgICAgIHJlcGxWYWwgPSByZXBsYWNlbWVudEZ1bmMobWF0Y2gsIGtleSwgdmFsdWVzLCB0aW1lWm9uZSwgZGlhbGVjdCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWtleS5tYXRjaCgvXlxcZCokLykpIHtcbiAgICAgICAgcmVwbFZhbCA9IHJlcGxhY2VtZW50RnVuYyhtYXRjaCwga2V5LCB2YWx1ZXMsIHRpbWVab25lLCBkaWFsZWN0LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXBsVmFsID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOYW1lZCBiaW5kIHBhcmFtZXRlciBcIiR7bWF0Y2h9XCIgaGFzIG5vIHZhbHVlIGluIHRoZSBnaXZlbiBvYmplY3QuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVwbFZhbDtcbiAgICB9KTtcbiAgICByZXR1cm4gW3NxbCwgW11dO1xuICB9XG4gIGZvcm1hdEVycm9yKGVycm9yLCBlcnJTdGFjaykge1xuICAgIGVycm9yLnN0YWNrID0gZXJyU3RhY2s7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIHJ1bigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcnVuIG1ldGhvZCB3YXNuJ3Qgb3ZlcndyaXR0ZW4hXCIpO1xuICB9XG4gIGNoZWNrTG9nZ2luZ09wdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvZ2dpbmcgPT09IHRydWUpIHtcbiAgICAgIGRlcHJlY2F0aW9ucy5ub1RydWVMb2dnaW5nKCk7XG4gICAgICB0aGlzLm9wdGlvbnMubG9nZ2luZyA9IGNvbnNvbGUubG9nO1xuICAgIH1cbiAgfVxuICBnZXRJbnNlcnRJZEZpZWxkKCkge1xuICAgIHJldHVybiBcImluc2VydElkXCI7XG4gIH1cbiAgZ2V0VW5pcXVlQ29uc3RyYWludEVycm9yTWVzc2FnZShmaWVsZCkge1xuICAgIGxldCBtZXNzYWdlID0gZmllbGQgPyBgJHtmaWVsZH0gbXVzdCBiZSB1bmlxdWVgIDogXCJNdXN0IGJlIHVuaXF1ZVwiO1xuICAgIGlmIChmaWVsZCAmJiB0aGlzLm1vZGVsKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLm1vZGVsLnVuaXF1ZUtleXMpKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnVuaXF1ZUtleXNba2V5XS5maWVsZHMuaW5jbHVkZXMoZmllbGQucmVwbGFjZSgvXCIvZywgXCJcIikpKSB7XG4gICAgICAgICAgaWYgKHRoaXMubW9kZWwudW5pcXVlS2V5c1trZXldLm1zZykge1xuICAgICAgICAgICAgbWVzc2FnZSA9IHRoaXMubW9kZWwudW5pcXVlS2V5c1trZXldLm1zZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaXNSYXdRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuUkFXO1xuICB9XG4gIGlzVmVyc2lvblF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5WRVJTSU9OO1xuICB9XG4gIGlzVXBzZXJ0UXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLlVQU0VSVDtcbiAgfVxuICBpc0luc2VydFF1ZXJ5KHJlc3VsdHMsIG1ldGFEYXRhKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRydWU7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLklOU0VSVCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJlc3VsdCA9IHJlc3VsdCAmJiB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJpbnNlcnQgaW50b1wiKTtcbiAgICByZXN1bHQgPSByZXN1bHQgJiYgKCFyZXN1bHRzIHx8IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHRzLCB0aGlzLmdldEluc2VydElkRmllbGQoKSkpO1xuICAgIHJlc3VsdCA9IHJlc3VsdCAmJiAoIW1ldGFEYXRhIHx8IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtZXRhRGF0YSwgdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCkpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGhhbmRsZUluc2VydFF1ZXJ5KHJlc3VsdHMsIG1ldGFEYXRhKSB7XG4gICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgIGNvbnN0IGF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUgPSB0aGlzLm1vZGVsLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGU7XG4gICAgICBsZXQgaWQgPSBudWxsO1xuICAgICAgaWQgPSBpZCB8fCByZXN1bHRzICYmIHJlc3VsdHNbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuICAgICAgaWQgPSBpZCB8fCBtZXRhRGF0YSAmJiBtZXRhRGF0YVt0aGlzLmdldEluc2VydElkRmllbGQoKV07XG4gICAgICB0aGlzLmluc3RhbmNlW2F1dG9JbmNyZW1lbnRBdHRyaWJ1dGVdID0gaWQ7XG4gICAgfVxuICB9XG4gIGlzU2hvd1RhYmxlc1F1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5TSE9XVEFCTEVTO1xuICB9XG4gIGhhbmRsZVNob3dUYWJsZXNRdWVyeShyZXN1bHRzKSB7XG4gICAgcmV0dXJuIF8uZmxhdHRlbihyZXN1bHRzLm1hcCgocmVzdWx0U2V0KSA9PiBPYmplY3QudmFsdWVzKHJlc3VsdFNldCkpKTtcbiAgfVxuICBpc1Nob3dJbmRleGVzUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLlNIT1dJTkRFWEVTO1xuICB9XG4gIGlzU2hvd0NvbnN0cmFpbnRzUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLlNIT1dDT05TVFJBSU5UUztcbiAgfVxuICBpc0Rlc2NyaWJlUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLkRFU0NSSUJFO1xuICB9XG4gIGlzU2VsZWN0UXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLlNFTEVDVDtcbiAgfVxuICBpc0J1bGtVcGRhdGVRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuQlVMS1VQREFURTtcbiAgfVxuICBpc0J1bGtEZWxldGVRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuQlVMS0RFTEVURTtcbiAgfVxuICBpc0ZvcmVpZ25LZXlzUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLkZPUkVJR05LRVlTO1xuICB9XG4gIGlzVXBkYXRlUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLlVQREFURTtcbiAgfVxuICBoYW5kbGVTZWxlY3RRdWVyeShyZXN1bHRzKSB7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5maWVsZE1hcCkge1xuICAgICAgY29uc3QgZmllbGRNYXAgPSB0aGlzLm9wdGlvbnMuZmllbGRNYXA7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cy5tYXAoKHJlc3VsdDIpID0+IF8ucmVkdWNlKGZpZWxkTWFwLCAocmVzdWx0MywgbmFtZSwgZmllbGQpID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdDNbZmllbGRdICE9PSB2b2lkIDAgJiYgbmFtZSAhPT0gZmllbGQpIHtcbiAgICAgICAgICByZXN1bHQzW25hbWVdID0gcmVzdWx0M1tmaWVsZF07XG4gICAgICAgICAgZGVsZXRlIHJlc3VsdDNbZmllbGRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQzO1xuICAgICAgfSwgcmVzdWx0MikpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnJhdykge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0cy5tYXAoKHJlc3VsdDIpID0+IHtcbiAgICAgICAgbGV0IG8gPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0Mikge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0Miwga2V5KSkge1xuICAgICAgICAgICAgb1trZXldID0gcmVzdWx0MltrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5lc3QpIHtcbiAgICAgICAgICBvID0gRG90LnRyYW5zZm9ybShvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmhhc0pvaW4gPT09IHRydWUpIHtcbiAgICAgIHJlc3VsdHMgPSBBYnN0cmFjdFF1ZXJ5Ll9ncm91cEpvaW5EYXRhKHJlc3VsdHMsIHtcbiAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgIGluY2x1ZGVNYXA6IHRoaXMub3B0aW9ucy5pbmNsdWRlTWFwLFxuICAgICAgICBpbmNsdWRlTmFtZXM6IHRoaXMub3B0aW9ucy5pbmNsdWRlTmFtZXNcbiAgICAgIH0sIHtcbiAgICAgICAgY2hlY2tFeGlzdGluZzogdGhpcy5vcHRpb25zLmhhc011bHRpQXNzb2NpYXRpb25cbiAgICAgIH0pO1xuICAgICAgcmVzdWx0ID0gdGhpcy5tb2RlbC5idWxrQnVpbGQocmVzdWx0cywge1xuICAgICAgICBpc05ld1JlY29yZDogZmFsc2UsXG4gICAgICAgIGluY2x1ZGU6IHRoaXMub3B0aW9ucy5pbmNsdWRlLFxuICAgICAgICBpbmNsdWRlTmFtZXM6IHRoaXMub3B0aW9ucy5pbmNsdWRlTmFtZXMsXG4gICAgICAgIGluY2x1ZGVNYXA6IHRoaXMub3B0aW9ucy5pbmNsdWRlTWFwLFxuICAgICAgICBpbmNsdWRlVmFsaWRhdGVkOiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVzOiB0aGlzLm9wdGlvbnMub3JpZ2luYWxBdHRyaWJ1dGVzIHx8IHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVzLFxuICAgICAgICByYXc6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSB0aGlzLm1vZGVsLmJ1bGtCdWlsZChyZXN1bHRzLCB7XG4gICAgICAgIGlzTmV3UmVjb3JkOiBmYWxzZSxcbiAgICAgICAgcmF3OiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVzOiB0aGlzLm9wdGlvbnMub3JpZ2luYWxBdHRyaWJ1dGVzIHx8IHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVzXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wbGFpbikge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0Lmxlbmd0aCA9PT0gMCA/IG51bGwgOiByZXN1bHRbMF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaXNTaG93T3JEZXNjcmliZVF1ZXJ5KCkge1xuICAgIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwic2hvd1wiKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwiZGVzY3JpYmVcIik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpc0NhbGxRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwiY2FsbFwiKTtcbiAgfVxuICBfbG9nUXVlcnkoc3FsLCBkZWJ1Z0NvbnRleHQsIHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb24sIG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgY29uc3QgYmVuY2htYXJrID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5iZW5jaG1hcmsgfHwgb3B0aW9ucy5iZW5jaG1hcms7XG4gICAgY29uc3QgbG9nUXVlcnlQYXJhbWV0ZXJzID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5sb2dRdWVyeVBhcmFtZXRlcnMgfHwgb3B0aW9ucy5sb2dRdWVyeVBhcmFtZXRlcnM7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgbG9nUGFyYW1ldGVyID0gXCJcIjtcbiAgICBpZiAobG9nUXVlcnlQYXJhbWV0ZXJzICYmIHBhcmFtZXRlcnMpIHtcbiAgICAgIGNvbnN0IGRlbGltaXRlciA9IHNxbC5lbmRzV2l0aChcIjtcIikgPyBcIlwiIDogXCI7XCI7XG4gICAgICBsZXQgcGFyYW1TdHI7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzKSkge1xuICAgICAgICBwYXJhbVN0ciA9IHBhcmFtZXRlcnMubWFwKChwKSA9PiBzYWZlU3RyaW5naWZ5SnNvbihwKSkuam9pbihcIiwgXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1TdHIgPSBzYWZlU3RyaW5naWZ5SnNvbihwYXJhbWV0ZXJzKTtcbiAgICAgIH1cbiAgICAgIGxvZ1BhcmFtZXRlciA9IGAke2RlbGltaXRlcn0gJHtwYXJhbVN0cn1gO1xuICAgIH1cbiAgICBjb25zdCBmbXQgPSBgKCR7Y29ubmVjdGlvbi51dWlkIHx8IFwiZGVmYXVsdFwifSk6ICR7c3FsfSR7bG9nUGFyYW1ldGVyfWA7XG4gICAgY29uc3QgbXNnID0gYEV4ZWN1dGluZyAke2ZtdH1gO1xuICAgIGRlYnVnQ29udGV4dChtc2cpO1xuICAgIGlmICghYmVuY2htYXJrKSB7XG4gICAgICB0aGlzLnNlcXVlbGl6ZS5sb2coYEV4ZWN1dGluZyAke2ZtdH1gLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGFmdGVyTXNnID0gYEV4ZWN1dGVkICR7Zm10fWA7XG4gICAgICBkZWJ1Z0NvbnRleHQoYWZ0ZXJNc2cpO1xuICAgICAgaWYgKGJlbmNobWFyaykge1xuICAgICAgICB0aGlzLnNlcXVlbGl6ZS5sb2coYWZ0ZXJNc2csIERhdGUubm93KCkgLSBzdGFydFRpbWUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgc3RhdGljIF9ncm91cEpvaW5EYXRhKHJvd3MsIGluY2x1ZGVPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgaWYgKCFyb3dzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBsZXQgaTtcbiAgICBsZXQgbGVuZ3RoO1xuICAgIGxldCAkaTtcbiAgICBsZXQgJGxlbmd0aDtcbiAgICBsZXQgcm93c0k7XG4gICAgbGV0IHJvdztcbiAgICBjb25zdCByb3dzTGVuZ3RoID0gcm93cy5sZW5ndGg7XG4gICAgbGV0IGtleXM7XG4gICAgbGV0IGtleTtcbiAgICBsZXQga2V5STtcbiAgICBsZXQga2V5TGVuZ3RoO1xuICAgIGxldCBwcmV2S2V5O1xuICAgIGxldCB2YWx1ZXM7XG4gICAgbGV0IHRvcFZhbHVlcztcbiAgICBsZXQgdG9wRXhpc3RzO1xuICAgIGNvbnN0IGNoZWNrRXhpc3RpbmcgPSBvcHRpb25zLmNoZWNrRXhpc3Rpbmc7XG4gICAgbGV0IGl0ZW1IYXNoO1xuICAgIGxldCBwYXJlbnRIYXNoO1xuICAgIGxldCB0b3BIYXNoO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBjaGVja0V4aXN0aW5nID8gW10gOiBuZXcgQXJyYXkocm93c0xlbmd0aCk7XG4gICAgY29uc3QgcmVzdWx0TWFwID0ge307XG4gICAgY29uc3QgaW5jbHVkZU1hcCA9IHt9O1xuICAgIGxldCAka2V5UHJlZml4O1xuICAgIGxldCAka2V5UHJlZml4U3RyaW5nO1xuICAgIGxldCAkcHJldktleVByZWZpeFN0cmluZztcbiAgICBsZXQgJHByZXZLZXlQcmVmaXg7XG4gICAgbGV0ICRsYXN0S2V5UHJlZml4O1xuICAgIGxldCAkY3VycmVudDtcbiAgICBsZXQgJHBhcmVudDtcbiAgICBsZXQgcHJldmlvdXNQaWVjZTtcbiAgICBjb25zdCBidWlsZEluY2x1ZGVNYXAgPSAocGllY2UpID0+IHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoJGN1cnJlbnQuaW5jbHVkZU1hcCwgcGllY2UpKSB7XG4gICAgICAgIGluY2x1ZGVNYXBba2V5XSA9ICRjdXJyZW50ID0gJGN1cnJlbnQuaW5jbHVkZU1hcFtwaWVjZV07XG4gICAgICAgIGlmIChwcmV2aW91c1BpZWNlKSB7XG4gICAgICAgICAgcHJldmlvdXNQaWVjZSA9IGAke3ByZXZpb3VzUGllY2V9LiR7cGllY2V9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c1BpZWNlID0gcGllY2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5jbHVkZU1hcFtwcmV2aW91c1BpZWNlXSA9ICRjdXJyZW50O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qga2V5UHJlZml4U3RyaW5nTWVtbyA9IHt9O1xuICAgIGNvbnN0IGtleVByZWZpeFN0cmluZyA9IChrZXkyLCBtZW1vKSA9PiB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtZW1vLCBrZXkyKSkge1xuICAgICAgICBtZW1vW2tleTJdID0ga2V5Mi5zdWJzdHIoMCwga2V5Mi5sYXN0SW5kZXhPZihcIi5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW9ba2V5Ml07XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVLZXlQcmVmaXhNZW1vID0ge307XG4gICAgY29uc3QgcmVtb3ZlS2V5UHJlZml4ID0gKGtleTIpID0+IHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlbW92ZUtleVByZWZpeE1lbW8sIGtleTIpKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0ga2V5Mi5sYXN0SW5kZXhPZihcIi5cIik7XG4gICAgICAgIHJlbW92ZUtleVByZWZpeE1lbW9ba2V5Ml0gPSBrZXkyLnN1YnN0cihpbmRleCA9PT0gLTEgPyAwIDogaW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVLZXlQcmVmaXhNZW1vW2tleTJdO1xuICAgIH07XG4gICAgY29uc3Qga2V5UHJlZml4TWVtbyA9IHt9O1xuICAgIGNvbnN0IGtleVByZWZpeCA9IChrZXkyKSA9PiB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChrZXlQcmVmaXhNZW1vLCBrZXkyKSkge1xuICAgICAgICBjb25zdCBwcmVmaXhTdHJpbmcgPSBrZXlQcmVmaXhTdHJpbmcoa2V5Miwga2V5UHJlZml4U3RyaW5nTWVtbyk7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGtleVByZWZpeE1lbW8sIHByZWZpeFN0cmluZykpIHtcbiAgICAgICAgICBrZXlQcmVmaXhNZW1vW3ByZWZpeFN0cmluZ10gPSBwcmVmaXhTdHJpbmcgPyBwcmVmaXhTdHJpbmcuc3BsaXQoXCIuXCIpIDogW107XG4gICAgICAgIH1cbiAgICAgICAga2V5UHJlZml4TWVtb1trZXkyXSA9IGtleVByZWZpeE1lbW9bcHJlZml4U3RyaW5nXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlQcmVmaXhNZW1vW2tleTJdO1xuICAgIH07XG4gICAgY29uc3QgbGFzdEtleVByZWZpeE1lbW8gPSB7fTtcbiAgICBjb25zdCBsYXN0S2V5UHJlZml4ID0gKGtleTIpID0+IHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxhc3RLZXlQcmVmaXhNZW1vLCBrZXkyKSkge1xuICAgICAgICBjb25zdCBwcmVmaXgyID0ga2V5UHJlZml4KGtleTIpO1xuICAgICAgICBjb25zdCBsZW5ndGgyID0gcHJlZml4Mi5sZW5ndGg7XG4gICAgICAgIGxhc3RLZXlQcmVmaXhNZW1vW2tleTJdID0gIWxlbmd0aDIgPyBcIlwiIDogcHJlZml4MltsZW5ndGgyIC0gMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFzdEtleVByZWZpeE1lbW9ba2V5Ml07XG4gICAgfTtcbiAgICBjb25zdCBnZXRVbmlxdWVLZXlBdHRyaWJ1dGVzID0gKG1vZGVsKSA9PiB7XG4gICAgICBsZXQgdW5pcXVlS2V5QXR0cmlidXRlczIgPSBfLmNoYWluKG1vZGVsLnVuaXF1ZUtleXMpO1xuICAgICAgdW5pcXVlS2V5QXR0cmlidXRlczIgPSB1bmlxdWVLZXlBdHRyaWJ1dGVzMi5yZXN1bHQoYCR7dW5pcXVlS2V5QXR0cmlidXRlczIuZmluZEtleSgpfS5maWVsZHNgKS5tYXAoKGZpZWxkKSA9PiBfLmZpbmRLZXkobW9kZWwuYXR0cmlidXRlcywgKGNocikgPT4gY2hyLmZpZWxkID09PSBmaWVsZCkpLnZhbHVlKCk7XG4gICAgICByZXR1cm4gdW5pcXVlS2V5QXR0cmlidXRlczI7XG4gICAgfTtcbiAgICBjb25zdCBzdHJpbmdpZnkgPSAob2JqKSA9PiBvYmogaW5zdGFuY2VvZiBCdWZmZXIgPyBvYmoudG9TdHJpbmcoXCJoZXhcIikgOiBvYmo7XG4gICAgbGV0IHByaW1hcnlLZXlBdHRyaWJ1dGVzO1xuICAgIGxldCB1bmlxdWVLZXlBdHRyaWJ1dGVzO1xuICAgIGxldCBwcmVmaXg7XG4gICAgZm9yIChyb3dzSSA9IDA7IHJvd3NJIDwgcm93c0xlbmd0aDsgcm93c0krKykge1xuICAgICAgcm93ID0gcm93c1tyb3dzSV07XG4gICAgICBpZiAocm93c0kgPT09IDApIHtcbiAgICAgICAga2V5cyA9IF8uc29ydEJ5KE9iamVjdC5rZXlzKHJvdyksIChpdGVtKSA9PiBbaXRlbS5zcGxpdChcIi5cIikubGVuZ3RoXSk7XG4gICAgICAgIGtleUxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrRXhpc3RpbmcpIHtcbiAgICAgICAgdG9wRXhpc3RzID0gZmFsc2U7XG4gICAgICAgICRsZW5ndGggPSBpbmNsdWRlT3B0aW9ucy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICAgIHRvcEhhc2ggPSBcIlwiO1xuICAgICAgICBpZiAoJGxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHRvcEhhc2ggPSBzdHJpbmdpZnkocm93W2luY2x1ZGVPcHRpb25zLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVzWzBdXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoJGxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBmb3IgKCRpID0gMDsgJGkgPCAkbGVuZ3RoOyAkaSsrKSB7XG4gICAgICAgICAgICB0b3BIYXNoICs9IHN0cmluZ2lmeShyb3dbaW5jbHVkZU9wdGlvbnMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZXNbJGldXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFfLmlzRW1wdHkoaW5jbHVkZU9wdGlvbnMubW9kZWwudW5pcXVlS2V5cykpIHtcbiAgICAgICAgICB1bmlxdWVLZXlBdHRyaWJ1dGVzID0gZ2V0VW5pcXVlS2V5QXR0cmlidXRlcyhpbmNsdWRlT3B0aW9ucy5tb2RlbCk7XG4gICAgICAgICAgZm9yICgkaSA9IDA7ICRpIDwgdW5pcXVlS2V5QXR0cmlidXRlcy5sZW5ndGg7ICRpKyspIHtcbiAgICAgICAgICAgIHRvcEhhc2ggKz0gcm93W3VuaXF1ZUtleUF0dHJpYnV0ZXNbJGldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRvcFZhbHVlcyA9IHZhbHVlcyA9IHt9O1xuICAgICAgJHByZXZLZXlQcmVmaXggPSB2b2lkIDA7XG4gICAgICBmb3IgKGtleUkgPSAwOyBrZXlJIDwga2V5TGVuZ3RoOyBrZXlJKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1trZXlJXTtcbiAgICAgICAgJGtleVByZWZpeFN0cmluZyA9IGtleVByZWZpeFN0cmluZyhrZXksIGtleVByZWZpeFN0cmluZ01lbW8pO1xuICAgICAgICAka2V5UHJlZml4ID0ga2V5UHJlZml4KGtleSk7XG4gICAgICAgIGlmIChyb3dzSSA9PT0gMCAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGluY2x1ZGVNYXAsIGtleSkpIHtcbiAgICAgICAgICBpZiAoISRrZXlQcmVmaXgubGVuZ3RoKSB7XG4gICAgICAgICAgICBpbmNsdWRlTWFwW2tleV0gPSBpbmNsdWRlTWFwW1wiXCJdID0gaW5jbHVkZU9wdGlvbnM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRjdXJyZW50ID0gaW5jbHVkZU9wdGlvbnM7XG4gICAgICAgICAgICBwcmV2aW91c1BpZWNlID0gdm9pZCAwO1xuICAgICAgICAgICAgJGtleVByZWZpeC5mb3JFYWNoKGJ1aWxkSW5jbHVkZU1hcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgkcHJldktleVByZWZpeCAhPT0gdm9pZCAwICYmICRwcmV2S2V5UHJlZml4ICE9PSAka2V5UHJlZml4KSB7XG4gICAgICAgICAgaWYgKGNoZWNrRXhpc3RpbmcpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9ICRwcmV2S2V5UHJlZml4Lmxlbmd0aDtcbiAgICAgICAgICAgICRwYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgcGFyZW50SGFzaCA9IG51bGw7XG4gICAgICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9ICRwYXJlbnQgPyBgJHskcGFyZW50fS4keyRwcmV2S2V5UHJlZml4W2ldfWAgOiAkcHJldktleVByZWZpeFtpXTtcbiAgICAgICAgICAgICAgICBwcmltYXJ5S2V5QXR0cmlidXRlcyA9IGluY2x1ZGVNYXBbcHJlZml4XS5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICAkbGVuZ3RoID0gcHJpbWFyeUtleUF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGl0ZW1IYXNoID0gcHJlZml4O1xuICAgICAgICAgICAgICAgIGlmICgkbGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICBpdGVtSGFzaCArPSBzdHJpbmdpZnkocm93W2Ake3ByZWZpeH0uJHtwcmltYXJ5S2V5QXR0cmlidXRlc1swXX1gXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkbGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgZm9yICgkaSA9IDA7ICRpIDwgJGxlbmd0aDsgJGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtSGFzaCArPSBzdHJpbmdpZnkocm93W2Ake3ByZWZpeH0uJHtwcmltYXJ5S2V5QXR0cmlidXRlc1skaV19YF0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIV8uaXNFbXB0eShpbmNsdWRlTWFwW3ByZWZpeF0ubW9kZWwudW5pcXVlS2V5cykpIHtcbiAgICAgICAgICAgICAgICAgIHVuaXF1ZUtleUF0dHJpYnV0ZXMgPSBnZXRVbmlxdWVLZXlBdHRyaWJ1dGVzKGluY2x1ZGVNYXBbcHJlZml4XS5tb2RlbCk7XG4gICAgICAgICAgICAgICAgICBmb3IgKCRpID0gMDsgJGkgPCB1bmlxdWVLZXlBdHRyaWJ1dGVzLmxlbmd0aDsgJGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtSGFzaCArPSByb3dbYCR7cHJlZml4fS4ke3VuaXF1ZUtleUF0dHJpYnV0ZXNbJGldfWBdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudEhhc2gpIHtcbiAgICAgICAgICAgICAgICAgIHBhcmVudEhhc2ggPSB0b3BIYXNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtSGFzaCA9IHBhcmVudEhhc2ggKyBpdGVtSGFzaDtcbiAgICAgICAgICAgICAgICAkcGFyZW50ID0gcHJlZml4O1xuICAgICAgICAgICAgICAgIGlmIChpIDwgbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgcGFyZW50SGFzaCA9IGl0ZW1IYXNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXRlbUhhc2ggPSB0b3BIYXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW1IYXNoID09PSB0b3BIYXNoKSB7XG4gICAgICAgICAgICAgIGlmICghcmVzdWx0TWFwW2l0ZW1IYXNoXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdE1hcFtpdGVtSGFzaF0gPSB2YWx1ZXM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9wRXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghcmVzdWx0TWFwW2l0ZW1IYXNoXSkge1xuICAgICAgICAgICAgICAkcGFyZW50ID0gcmVzdWx0TWFwW3BhcmVudEhhc2hdO1xuICAgICAgICAgICAgICAkbGFzdEtleVByZWZpeCA9IGxhc3RLZXlQcmVmaXgocHJldktleSk7XG4gICAgICAgICAgICAgIGlmIChpbmNsdWRlTWFwW3ByZXZLZXldLmFzc29jaWF0aW9uLmlzU2luZ2xlQXNzb2NpYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoJHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgJHBhcmVudFskbGFzdEtleVByZWZpeF0gPSByZXN1bHRNYXBbaXRlbUhhc2hdID0gdmFsdWVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoISRwYXJlbnRbJGxhc3RLZXlQcmVmaXhdKSB7XG4gICAgICAgICAgICAgICAgICAkcGFyZW50WyRsYXN0S2V5UHJlZml4XSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkcGFyZW50WyRsYXN0S2V5UHJlZml4XS5wdXNoKHJlc3VsdE1hcFtpdGVtSGFzaF0gPSB2YWx1ZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXMgPSB7fTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGN1cnJlbnQgPSB0b3BWYWx1ZXM7XG4gICAgICAgICAgICBsZW5ndGggPSAka2V5UHJlZml4Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlcyA9ICRjdXJyZW50WyRrZXlQcmVmaXhbaV1dID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRjdXJyZW50ID0gJGN1cnJlbnRbJGtleVByZWZpeFtpXV0gfHwge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzW3JlbW92ZUtleVByZWZpeChrZXkpXSA9IHJvd1trZXldO1xuICAgICAgICBwcmV2S2V5ID0ga2V5O1xuICAgICAgICAkcHJldktleVByZWZpeCA9ICRrZXlQcmVmaXg7XG4gICAgICAgICRwcmV2S2V5UHJlZml4U3RyaW5nID0gJGtleVByZWZpeFN0cmluZztcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0V4aXN0aW5nKSB7XG4gICAgICAgIGxlbmd0aCA9ICRwcmV2S2V5UHJlZml4Lmxlbmd0aDtcbiAgICAgICAgJHBhcmVudCA9IG51bGw7XG4gICAgICAgIHBhcmVudEhhc2ggPSBudWxsO1xuICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwcmVmaXggPSAkcGFyZW50ID8gYCR7JHBhcmVudH0uJHskcHJldktleVByZWZpeFtpXX1gIDogJHByZXZLZXlQcmVmaXhbaV07XG4gICAgICAgICAgICBwcmltYXJ5S2V5QXR0cmlidXRlcyA9IGluY2x1ZGVNYXBbcHJlZml4XS5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlcztcbiAgICAgICAgICAgICRsZW5ndGggPSBwcmltYXJ5S2V5QXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBpdGVtSGFzaCA9IHByZWZpeDtcbiAgICAgICAgICAgIGlmICgkbGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgIGl0ZW1IYXNoICs9IHN0cmluZ2lmeShyb3dbYCR7cHJlZml4fS4ke3ByaW1hcnlLZXlBdHRyaWJ1dGVzWzBdfWBdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZm9yICgkaSA9IDA7ICRpIDwgJGxlbmd0aDsgJGkrKykge1xuICAgICAgICAgICAgICAgIGl0ZW1IYXNoICs9IHN0cmluZ2lmeShyb3dbYCR7cHJlZml4fS4ke3ByaW1hcnlLZXlBdHRyaWJ1dGVzWyRpXX1gXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIV8uaXNFbXB0eShpbmNsdWRlTWFwW3ByZWZpeF0ubW9kZWwudW5pcXVlS2V5cykpIHtcbiAgICAgICAgICAgICAgdW5pcXVlS2V5QXR0cmlidXRlcyA9IGdldFVuaXF1ZUtleUF0dHJpYnV0ZXMoaW5jbHVkZU1hcFtwcmVmaXhdLm1vZGVsKTtcbiAgICAgICAgICAgICAgZm9yICgkaSA9IDA7ICRpIDwgdW5pcXVlS2V5QXR0cmlidXRlcy5sZW5ndGg7ICRpKyspIHtcbiAgICAgICAgICAgICAgICBpdGVtSGFzaCArPSByb3dbYCR7cHJlZml4fS4ke3VuaXF1ZUtleUF0dHJpYnV0ZXNbJGldfWBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhcmVudEhhc2gpIHtcbiAgICAgICAgICAgICAgcGFyZW50SGFzaCA9IHRvcEhhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtSGFzaCA9IHBhcmVudEhhc2ggKyBpdGVtSGFzaDtcbiAgICAgICAgICAgICRwYXJlbnQgPSBwcmVmaXg7XG4gICAgICAgICAgICBpZiAoaSA8IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgcGFyZW50SGFzaCA9IGl0ZW1IYXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtSGFzaCA9IHRvcEhhc2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW1IYXNoID09PSB0b3BIYXNoKSB7XG4gICAgICAgICAgaWYgKCFyZXN1bHRNYXBbaXRlbUhhc2hdKSB7XG4gICAgICAgICAgICByZXN1bHRNYXBbaXRlbUhhc2hdID0gdmFsdWVzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3BFeGlzdHMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghcmVzdWx0TWFwW2l0ZW1IYXNoXSkge1xuICAgICAgICAgICRwYXJlbnQgPSByZXN1bHRNYXBbcGFyZW50SGFzaF07XG4gICAgICAgICAgJGxhc3RLZXlQcmVmaXggPSBsYXN0S2V5UHJlZml4KHByZXZLZXkpO1xuICAgICAgICAgIGlmIChpbmNsdWRlTWFwW3ByZXZLZXldLmFzc29jaWF0aW9uLmlzU2luZ2xlQXNzb2NpYXRpb24pIHtcbiAgICAgICAgICAgIGlmICgkcGFyZW50KSB7XG4gICAgICAgICAgICAgICRwYXJlbnRbJGxhc3RLZXlQcmVmaXhdID0gcmVzdWx0TWFwW2l0ZW1IYXNoXSA9IHZhbHVlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEkcGFyZW50WyRsYXN0S2V5UHJlZml4XSkge1xuICAgICAgICAgICAgICAkcGFyZW50WyRsYXN0S2V5UHJlZml4XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHBhcmVudFskbGFzdEtleVByZWZpeF0ucHVzaChyZXN1bHRNYXBbaXRlbUhhc2hdID0gdmFsdWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0b3BFeGlzdHMpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2godG9wVmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0c1tyb3dzSV0gPSB0b3BWYWx1ZXM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IEFic3RyYWN0UXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5BYnN0cmFjdFF1ZXJ5ID0gQWJzdHJhY3RRdWVyeTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBBYnN0cmFjdFF1ZXJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnkuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/db2/connection-manager.js":
/*!************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/db2/connection-manager.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(action-browser)/../node_modules/sequelize/lib/utils/logger.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\").db2);\nconst debug = logger.debugContext(\"connection:db2\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(action-browser)/../node_modules/sequelize/lib/dialects/parserStore.js\")(\"db2\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"ibm_db\");\n    this.refreshTypeParser(DataTypes);\n  }\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  async connect(config) {\n    const connectionConfig = {\n      database: config.database,\n      hostname: config.host,\n      port: config.port,\n      uid: config.username,\n      pwd: config.password\n    };\n    if (config.ssl) {\n      connectionConfig[\"security\"] = config.ssl;\n    }\n    if (config.sslcertificate) {\n      connectionConfig[\"SSLServerCertificate\"] = config.sslcertificate;\n    }\n    if (config.dialectOptions) {\n      for (const key of Object.keys(config.dialectOptions)) {\n        connectionConfig[key] = config.dialectOptions[key];\n      }\n    }\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        const connection2 = new this.lib.Database();\n        connection2.lib = this.lib;\n        connection2.open(connectionConfig, (error) => {\n          if (error) {\n            if (error.message && error.message.includes(\"SQL30081N\")) {\n              return reject(new sequelizeErrors.ConnectionRefusedError(error));\n            }\n            return reject(new sequelizeErrors.ConnectionError(error));\n          }\n          return resolve(connection2);\n        });\n      });\n      return connection;\n    } catch (err) {\n      throw new sequelizeErrors.ConnectionError(err);\n    }\n  }\n  disconnect(connection) {\n    if (connection.connected) {\n      connection.close((error) => {\n        if (error) {\n          debug(error);\n        } else {\n          debug(\"connection closed\");\n        }\n      });\n    }\n    return Promise.resolve();\n  }\n  validate(connection) {\n    return connection && connection.connected;\n  }\n  _disconnect(connection) {\n    return this.dialect.connectionManager.disconnect(connection);\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvY29ubmVjdGlvbi1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2Isa0NBQWtDLG1CQUFPLENBQUMsOEhBQWdDO0FBQzFFLHdCQUF3QixtQkFBTyxDQUFDLG9GQUFjO0FBQzlDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsMEZBQW9CO0FBQy9DLGtCQUFrQixpSEFBK0I7QUFDakQ7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyw4RkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMseUJBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL2RiMi9jb25uZWN0aW9uLW1hbmFnZXIuanM/YjE5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvY29ubmVjdGlvbi1tYW5hZ2VyXCIpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc1wiKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvbG9nZ2VyXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIikuZGIyO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KFwiY29ubmVjdGlvbjpkYjJcIik7XG5jb25zdCBwYXJzZXJTdG9yZSA9IHJlcXVpcmUoXCIuLi9wYXJzZXJTdG9yZVwiKShcImRiMlwiKTtcbmNsYXNzIENvbm5lY3Rpb25NYW5hZ2VyIGV4dGVuZHMgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGRpYWxlY3QsIHNlcXVlbGl6ZSkge1xuICAgIHNlcXVlbGl6ZS5jb25maWcucG9ydCA9IHNlcXVlbGl6ZS5jb25maWcucG9ydCB8fCAzMzA2O1xuICAgIHN1cGVyKGRpYWxlY3QsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5saWIgPSB0aGlzLl9sb2FkRGlhbGVjdE1vZHVsZShcImlibV9kYlwiKTtcbiAgICB0aGlzLnJlZnJlc2hUeXBlUGFyc2VyKERhdGFUeXBlcyk7XG4gIH1cbiAgc3RhdGljIF90eXBlY2FzdChmaWVsZCwgbmV4dCkge1xuICAgIGlmIChwYXJzZXJTdG9yZS5nZXQoZmllbGQudHlwZSkpIHtcbiAgICAgIHJldHVybiBwYXJzZXJTdG9yZS5nZXQoZmllbGQudHlwZSkoZmllbGQsIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMsIG5leHQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dCgpO1xuICB9XG4gIF9yZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZSkge1xuICAgIHBhcnNlclN0b3JlLnJlZnJlc2goZGF0YVR5cGUpO1xuICB9XG4gIF9jbGVhclR5cGVQYXJzZXIoKSB7XG4gICAgcGFyc2VyU3RvcmUuY2xlYXIoKTtcbiAgfVxuICBhc3luYyBjb25uZWN0KGNvbmZpZykge1xuICAgIGNvbnN0IGNvbm5lY3Rpb25Db25maWcgPSB7XG4gICAgICBkYXRhYmFzZTogY29uZmlnLmRhdGFiYXNlLFxuICAgICAgaG9zdG5hbWU6IGNvbmZpZy5ob3N0LFxuICAgICAgcG9ydDogY29uZmlnLnBvcnQsXG4gICAgICB1aWQ6IGNvbmZpZy51c2VybmFtZSxcbiAgICAgIHB3ZDogY29uZmlnLnBhc3N3b3JkXG4gICAgfTtcbiAgICBpZiAoY29uZmlnLnNzbCkge1xuICAgICAgY29ubmVjdGlvbkNvbmZpZ1tcInNlY3VyaXR5XCJdID0gY29uZmlnLnNzbDtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5zc2xjZXJ0aWZpY2F0ZSkge1xuICAgICAgY29ubmVjdGlvbkNvbmZpZ1tcIlNTTFNlcnZlckNlcnRpZmljYXRlXCJdID0gY29uZmlnLnNzbGNlcnRpZmljYXRlO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmRpYWxlY3RPcHRpb25zKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjb25maWcuZGlhbGVjdE9wdGlvbnMpKSB7XG4gICAgICAgIGNvbm5lY3Rpb25Db25maWdba2V5XSA9IGNvbmZpZy5kaWFsZWN0T3B0aW9uc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbjIgPSBuZXcgdGhpcy5saWIuRGF0YWJhc2UoKTtcbiAgICAgICAgY29ubmVjdGlvbjIubGliID0gdGhpcy5saWI7XG4gICAgICAgIGNvbm5lY3Rpb24yLm9wZW4oY29ubmVjdGlvbkNvbmZpZywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiU1FMMzAwODFOXCIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IHNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uUmVmdXNlZEVycm9yKGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBzZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvbkVycm9yKGVycm9yKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXNvbHZlKGNvbm5lY3Rpb24yKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cbiAgZGlzY29ubmVjdChjb25uZWN0aW9uKSB7XG4gICAgaWYgKGNvbm5lY3Rpb24uY29ubmVjdGVkKSB7XG4gICAgICBjb25uZWN0aW9uLmNsb3NlKChlcnJvcikgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBkZWJ1ZyhlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoXCJjb25uZWN0aW9uIGNsb3NlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICB2YWxpZGF0ZShjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb24gJiYgY29ubmVjdGlvbi5jb25uZWN0ZWQ7XG4gIH1cbiAgX2Rpc2Nvbm5lY3QoY29ubmVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLmRpYWxlY3QuY29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdChjb25uZWN0aW9uKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25NYW5hZ2VyID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdGlvbk1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aW9uLW1hbmFnZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/db2/connection-manager.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/db2/data-types.js":
/*!****************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/db2/data-types.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(action-browser)/../node_modules/moment-timezone/index.js\");\nconst moment = __webpack_require__(/*! moment */ \"(action-browser)/../node_modules/moment/moment.js\");\nmodule.exports = (BaseTypes) => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"https://www.ibm.com/support/knowledgecenter/SSEPGG_11.1.0/com.ibm.db2.luw.sql.ref.doc/doc/r0008478.html\");\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {\n      warn(`Db2 does not support '${dataType.key}' with options. Plain '${dataType.key}' will be used instead.`);\n      dataType._length = void 0;\n      dataType.options.length = void 0;\n      dataType._unsigned = void 0;\n      dataType._zerofill = void 0;\n    }\n  }\n  BaseTypes.DATE.types.db2 = [\"TIMESTAMP\"];\n  BaseTypes.STRING.types.db2 = [\"VARCHAR\"];\n  BaseTypes.CHAR.types.db2 = [\"CHAR\"];\n  BaseTypes.TEXT.types.db2 = [\"VARCHAR\", \"CLOB\"];\n  BaseTypes.TINYINT.types.db2 = [\"SMALLINT\"];\n  BaseTypes.SMALLINT.types.db2 = [\"SMALLINT\"];\n  BaseTypes.MEDIUMINT.types.db2 = [\"INTEGER\"];\n  BaseTypes.INTEGER.types.db2 = [\"INTEGER\"];\n  BaseTypes.BIGINT.types.db2 = [\"BIGINT\"];\n  BaseTypes.FLOAT.types.db2 = [\"DOUBLE\", \"REAL\", \"FLOAT\"];\n  BaseTypes.TIME.types.db2 = [\"TIME\"];\n  BaseTypes.DATEONLY.types.db2 = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.db2 = [\"BOOLEAN\", \"BOOL\", \"SMALLINT\", \"BIT\"];\n  BaseTypes.BLOB.types.db2 = [\"BLOB\"];\n  BaseTypes.DECIMAL.types.db2 = [\"DECIMAL\"];\n  BaseTypes.UUID.types.db2 = [\"CHAR () FOR BIT DATA\"];\n  BaseTypes.ENUM.types.db2 = [\"VARCHAR\"];\n  BaseTypes.REAL.types.db2 = [\"REAL\"];\n  BaseTypes.DOUBLE.types.db2 = [\"DOUBLE\"];\n  BaseTypes.GEOMETRY.types.db2 = false;\n  class BLOB extends BaseTypes.BLOB {\n    toSql() {\n      if (this._length) {\n        if (this._length.toLowerCase() === \"tiny\") {\n          return \"BLOB(255)\";\n        }\n        if (this._length.toLowerCase() === \"medium\") {\n          return \"BLOB(16M)\";\n        }\n        if (this._length.toLowerCase() === \"long\") {\n          return \"BLOB(2G)\";\n        }\n        return `BLOB(${this._length})`;\n      }\n      return \"BLOB\";\n    }\n    escape(blob) {\n      return `BLOB('${blob.toString().replace(/'/g, \"''\")}')`;\n    }\n    _stringify(value) {\n      if (Buffer.isBuffer(value)) {\n        return `BLOB('${value.toString().replace(/'/g, \"''\")}')`;\n      }\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      } else {\n        value = Buffer.from(value.toString());\n      }\n      const hex = value.toString(\"hex\");\n      return this._hexify(hex);\n    }\n    _hexify(hex) {\n      return `x'${hex}'`;\n    }\n  }\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (!this._binary) {\n        if (this._length <= 4e3) {\n          return `VARCHAR(${this._length})`;\n        }\n        return `CLOB(${this._length})`;\n      }\n      if (this._length < 255) {\n        return `CHAR(${this._length}) FOR BIT DATA`;\n      }\n      if (this._length <= 4e3) {\n        return `VARCHAR(${this._length}) FOR BIT DATA`;\n      }\n      return `BLOB(${this._length})`;\n    }\n    _stringify(value, options) {\n      if (this._binary) {\n        return BLOB.prototype._hexify(value.toString(\"hex\"));\n      }\n      return options.escape(value);\n    }\n    _bindParam(value, options) {\n      return options.bindParam(this._binary ? Buffer.from(value) : value);\n    }\n  }\n  STRING.prototype.escape = false;\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      let len = 0;\n      if (this._length) {\n        switch (this._length.toLowerCase()) {\n          case \"tiny\":\n            len = 256;\n            break;\n          case \"medium\":\n            len = 8192;\n            break;\n          case \"long\":\n            len = 65536;\n            break;\n        }\n        if (isNaN(this._length)) {\n          this._length = 32672;\n        }\n        if (len > 0) {\n          this._length = len;\n        }\n      } else {\n        this._length = 32672;\n      }\n      if (this._length > 32672) {\n        len = `CLOB(${this._length})`;\n      } else {\n        len = `VARCHAR(${this._length})`;\n      }\n      warn(`Db2 does not support TEXT datatype. ${len} will be used instead.`);\n      return len;\n    }\n  }\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"BOOLEAN\";\n    }\n    _sanitize(value) {\n      if (value !== null && value !== void 0) {\n        if (Buffer.isBuffer(value) && value.length === 1) {\n          value = value[0];\n        }\n        if (typeof value === \"string\") {\n          value = value === \"true\" ? true : value === \"false\" ? false : value;\n          value = value === \"\u0001\" ? true : value === \"\\0\" ? false : value;\n        } else if (typeof value === \"number\") {\n          value = value === 1 ? true : value === 0 ? false : value;\n        }\n      }\n      return value;\n    }\n  }\n  BOOLEAN.parse = BOOLEAN.prototype._sanitize;\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"CHAR(36) FOR BIT DATA\";\n    }\n  }\n  class NOW extends BaseTypes.NOW {\n    toSql() {\n      return \"CURRENT TIME\";\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      if (this._length < 0) {\n        this._length = 0;\n      }\n      if (this._length > 6) {\n        this._length = 6;\n      }\n      return `TIMESTAMP${this._length ? `(${this._length})` : \"\"}`;\n    }\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n      if (this._length > 0) {\n        let msec = \".\";\n        for (let i = 0; i < this._length && i < 6; i++) {\n          msec += \"S\";\n        }\n        return date.format(`YYYY-MM-DD HH:mm:ss${msec}`);\n      }\n      return date.format(\"YYYY-MM-DD HH:mm:ss\");\n    }\n    static parse(value) {\n      if (typeof value !== \"string\") {\n        value = value.string();\n      }\n      if (value === null) {\n        return value;\n      }\n      value = new Date(momentTz.utc(value));\n      return value;\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return momentTz(value).format(\"YYYY-MM-DD\");\n    }\n  }\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class REAL extends BaseTypes.REAL {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (this._length || this.options.length || this._unsigned || this._zerofill) {\n        warn(\"Db2 does not support REAL with options. Plain `REAL` will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n    }\n  }\n  class FLOAT extends BaseTypes.FLOAT {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (this._decimals) {\n        warn(\"Db2 does not support Float with decimals. Plain `FLOAT` will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n      }\n      if (this._unsigned) {\n        warn(\"Db2 does not support Float unsigned. `UNSIGNED` was removed.\");\n        this._unsigned = void 0;\n      }\n      if (this._zerofill) {\n        warn(\"Db2 does not support Float zerofill. `ZEROFILL` was removed.\");\n        this._zerofill = void 0;\n      }\n    }\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return \"VARCHAR(255)\";\n    }\n  }\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (this._length || this.options.length || this._unsigned || this._zerofill) {\n        warn(\"db2 does not support DOUBLE with options. Plain DOUBLE will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n    }\n    toSql() {\n      return \"DOUBLE\";\n    }\n  }\n  DOUBLE.prototype.key = DOUBLE.key = \"DOUBLE\";\n  return {\n    BLOB,\n    BOOLEAN,\n    ENUM,\n    STRING,\n    UUID,\n    DATE,\n    DATEONLY,\n    NOW,\n    TINYINT,\n    SMALLINT,\n    INTEGER,\n    DOUBLE,\n    \"DOUBLE PRECISION\": DOUBLE,\n    BIGINT,\n    REAL,\n    FLOAT,\n    TEXT\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvZGF0YS10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGlCQUFpQixtQkFBTyxDQUFDLGtGQUFpQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMsaUVBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYSx5QkFBeUIsYUFBYTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0NBQW9DO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQ0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQyxRQUFRO0FBQ1IseUJBQXlCLGFBQWE7QUFDdEM7QUFDQSxrREFBa0QsS0FBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CLGFBQWEsUUFBUTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL2RiMi9kYXRhLXR5cGVzLmpzPzYyMmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBtb21lbnRUeiA9IHJlcXVpcmUoXCJtb21lbnQtdGltZXpvbmVcIik7XG5jb25zdCBtb21lbnQgPSByZXF1aXJlKFwibW9tZW50XCIpO1xubW9kdWxlLmV4cG9ydHMgPSAoQmFzZVR5cGVzKSA9PiB7XG4gIGNvbnN0IHdhcm4gPSBCYXNlVHlwZXMuQUJTVFJBQ1Qud2Fybi5iaW5kKHZvaWQgMCwgXCJodHRwczovL3d3dy5pYm0uY29tL3N1cHBvcnQva25vd2xlZGdlY2VudGVyL1NTRVBHR18xMS4xLjAvY29tLmlibS5kYjIubHV3LnNxbC5yZWYuZG9jL2RvYy9yMDAwODQ3OC5odG1sXCIpO1xuICBmdW5jdGlvbiByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKGRhdGFUeXBlKSB7XG4gICAgaWYgKGRhdGFUeXBlLl9sZW5ndGggfHwgZGF0YVR5cGUub3B0aW9ucy5sZW5ndGggfHwgZGF0YVR5cGUuX3Vuc2lnbmVkIHx8IGRhdGFUeXBlLl96ZXJvZmlsbCkge1xuICAgICAgd2FybihgRGIyIGRvZXMgbm90IHN1cHBvcnQgJyR7ZGF0YVR5cGUua2V5fScgd2l0aCBvcHRpb25zLiBQbGFpbiAnJHtkYXRhVHlwZS5rZXl9JyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5gKTtcbiAgICAgIGRhdGFUeXBlLl9sZW5ndGggPSB2b2lkIDA7XG4gICAgICBkYXRhVHlwZS5vcHRpb25zLmxlbmd0aCA9IHZvaWQgMDtcbiAgICAgIGRhdGFUeXBlLl91bnNpZ25lZCA9IHZvaWQgMDtcbiAgICAgIGRhdGFUeXBlLl96ZXJvZmlsbCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgQmFzZVR5cGVzLkRBVEUudHlwZXMuZGIyID0gW1wiVElNRVNUQU1QXCJdO1xuICBCYXNlVHlwZXMuU1RSSU5HLnR5cGVzLmRiMiA9IFtcIlZBUkNIQVJcIl07XG4gIEJhc2VUeXBlcy5DSEFSLnR5cGVzLmRiMiA9IFtcIkNIQVJcIl07XG4gIEJhc2VUeXBlcy5URVhULnR5cGVzLmRiMiA9IFtcIlZBUkNIQVJcIiwgXCJDTE9CXCJdO1xuICBCYXNlVHlwZXMuVElOWUlOVC50eXBlcy5kYjIgPSBbXCJTTUFMTElOVFwiXTtcbiAgQmFzZVR5cGVzLlNNQUxMSU5ULnR5cGVzLmRiMiA9IFtcIlNNQUxMSU5UXCJdO1xuICBCYXNlVHlwZXMuTUVESVVNSU5ULnR5cGVzLmRiMiA9IFtcIklOVEVHRVJcIl07XG4gIEJhc2VUeXBlcy5JTlRFR0VSLnR5cGVzLmRiMiA9IFtcIklOVEVHRVJcIl07XG4gIEJhc2VUeXBlcy5CSUdJTlQudHlwZXMuZGIyID0gW1wiQklHSU5UXCJdO1xuICBCYXNlVHlwZXMuRkxPQVQudHlwZXMuZGIyID0gW1wiRE9VQkxFXCIsIFwiUkVBTFwiLCBcIkZMT0FUXCJdO1xuICBCYXNlVHlwZXMuVElNRS50eXBlcy5kYjIgPSBbXCJUSU1FXCJdO1xuICBCYXNlVHlwZXMuREFURU9OTFkudHlwZXMuZGIyID0gW1wiREFURVwiXTtcbiAgQmFzZVR5cGVzLkJPT0xFQU4udHlwZXMuZGIyID0gW1wiQk9PTEVBTlwiLCBcIkJPT0xcIiwgXCJTTUFMTElOVFwiLCBcIkJJVFwiXTtcbiAgQmFzZVR5cGVzLkJMT0IudHlwZXMuZGIyID0gW1wiQkxPQlwiXTtcbiAgQmFzZVR5cGVzLkRFQ0lNQUwudHlwZXMuZGIyID0gW1wiREVDSU1BTFwiXTtcbiAgQmFzZVR5cGVzLlVVSUQudHlwZXMuZGIyID0gW1wiQ0hBUiAoKSBGT1IgQklUIERBVEFcIl07XG4gIEJhc2VUeXBlcy5FTlVNLnR5cGVzLmRiMiA9IFtcIlZBUkNIQVJcIl07XG4gIEJhc2VUeXBlcy5SRUFMLnR5cGVzLmRiMiA9IFtcIlJFQUxcIl07XG4gIEJhc2VUeXBlcy5ET1VCTEUudHlwZXMuZGIyID0gW1wiRE9VQkxFXCJdO1xuICBCYXNlVHlwZXMuR0VPTUVUUlkudHlwZXMuZGIyID0gZmFsc2U7XG4gIGNsYXNzIEJMT0IgZXh0ZW5kcyBCYXNlVHlwZXMuQkxPQiB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGgudG9Mb3dlckNhc2UoKSA9PT0gXCJ0aW55XCIpIHtcbiAgICAgICAgICByZXR1cm4gXCJCTE9CKDI1NSlcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoLnRvTG93ZXJDYXNlKCkgPT09IFwibWVkaXVtXCIpIHtcbiAgICAgICAgICByZXR1cm4gXCJCTE9CKDE2TSlcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoLnRvTG93ZXJDYXNlKCkgPT09IFwibG9uZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIFwiQkxPQigyRylcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYEJMT0IoJHt0aGlzLl9sZW5ndGh9KWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJCTE9CXCI7XG4gICAgfVxuICAgIGVzY2FwZShibG9iKSB7XG4gICAgICByZXR1cm4gYEJMT0IoJyR7YmxvYi50b1N0cmluZygpLnJlcGxhY2UoLycvZywgXCInJ1wiKX0nKWA7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkodmFsdWUpIHtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBgQkxPQignJHt2YWx1ZS50b1N0cmluZygpLnJlcGxhY2UoLycvZywgXCInJ1wiKX0nKWA7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgICAgY29uc3QgaGV4ID0gdmFsdWUudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgICByZXR1cm4gdGhpcy5faGV4aWZ5KGhleCk7XG4gICAgfVxuICAgIF9oZXhpZnkoaGV4KSB7XG4gICAgICByZXR1cm4gYHgnJHtoZXh9J2A7XG4gICAgfVxuICB9XG4gIGNsYXNzIFNUUklORyBleHRlbmRzIEJhc2VUeXBlcy5TVFJJTkcge1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKCF0aGlzLl9iaW5hcnkpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xlbmd0aCA8PSA0ZTMpIHtcbiAgICAgICAgICByZXR1cm4gYFZBUkNIQVIoJHt0aGlzLl9sZW5ndGh9KWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBDTE9CKCR7dGhpcy5fbGVuZ3RofSlgO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2xlbmd0aCA8IDI1NSkge1xuICAgICAgICByZXR1cm4gYENIQVIoJHt0aGlzLl9sZW5ndGh9KSBGT1IgQklUIERBVEFgO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2xlbmd0aCA8PSA0ZTMpIHtcbiAgICAgICAgcmV0dXJuIGBWQVJDSEFSKCR7dGhpcy5fbGVuZ3RofSkgRk9SIEJJVCBEQVRBYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgQkxPQigke3RoaXMuX2xlbmd0aH0pYDtcbiAgICB9XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuX2JpbmFyeSkge1xuICAgICAgICByZXR1cm4gQkxPQi5wcm90b3R5cGUuX2hleGlmeSh2YWx1ZS50b1N0cmluZyhcImhleFwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5lc2NhcGUodmFsdWUpO1xuICAgIH1cbiAgICBfYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5iaW5kUGFyYW0odGhpcy5fYmluYXJ5ID8gQnVmZmVyLmZyb20odmFsdWUpIDogdmFsdWUpO1xuICAgIH1cbiAgfVxuICBTVFJJTkcucHJvdG90eXBlLmVzY2FwZSA9IGZhbHNlO1xuICBjbGFzcyBURVhUIGV4dGVuZHMgQmFzZVR5cGVzLlRFWFQge1xuICAgIHRvU3FsKCkge1xuICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fbGVuZ3RoLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICBjYXNlIFwidGlueVwiOlxuICAgICAgICAgICAgbGVuID0gMjU2O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1lZGl1bVwiOlxuICAgICAgICAgICAgbGVuID0gODE5MjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICAgICAgICBsZW4gPSA2NTUzNjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05hTih0aGlzLl9sZW5ndGgpKSB7XG4gICAgICAgICAgdGhpcy5fbGVuZ3RoID0gMzI2NzI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICB0aGlzLl9sZW5ndGggPSBsZW47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IDMyNjcyO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2xlbmd0aCA+IDMyNjcyKSB7XG4gICAgICAgIGxlbiA9IGBDTE9CKCR7dGhpcy5fbGVuZ3RofSlgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gYFZBUkNIQVIoJHt0aGlzLl9sZW5ndGh9KWA7XG4gICAgICB9XG4gICAgICB3YXJuKGBEYjIgZG9lcyBub3Qgc3VwcG9ydCBURVhUIGRhdGF0eXBlLiAke2xlbn0gd2lsbCBiZSB1c2VkIGluc3RlYWQuYCk7XG4gICAgICByZXR1cm4gbGVuO1xuICAgIH1cbiAgfVxuICBjbGFzcyBCT09MRUFOIGV4dGVuZHMgQmFzZVR5cGVzLkJPT0xFQU4ge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiQk9PTEVBTlwiO1xuICAgIH1cbiAgICBfc2FuaXRpemUodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6IHZhbHVlID09PSBcImZhbHNlXCIgPyBmYWxzZSA6IHZhbHVlO1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUgPT09IFwiXHUwMDAxXCIgPyB0cnVlIDogdmFsdWUgPT09IFwiXFwwXCIgPyBmYWxzZSA6IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUgPT09IDEgPyB0cnVlIDogdmFsdWUgPT09IDAgPyBmYWxzZSA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIEJPT0xFQU4ucGFyc2UgPSBCT09MRUFOLnByb3RvdHlwZS5fc2FuaXRpemU7XG4gIGNsYXNzIFVVSUQgZXh0ZW5kcyBCYXNlVHlwZXMuVVVJRCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJDSEFSKDM2KSBGT1IgQklUIERBVEFcIjtcbiAgICB9XG4gIH1cbiAgY2xhc3MgTk9XIGV4dGVuZHMgQmFzZVR5cGVzLk5PVyB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJDVVJSRU5UIFRJTUVcIjtcbiAgICB9XG4gIH1cbiAgY2xhc3MgREFURSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGggPCAwKSB7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoID4gNikge1xuICAgICAgICB0aGlzLl9sZW5ndGggPSA2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGBUSU1FU1RBTVAke3RoaXMuX2xlbmd0aCA/IGAoJHt0aGlzLl9sZW5ndGh9KWAgOiBcIlwifWA7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkoZGF0ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFtb21lbnQuaXNNb21lbnQoZGF0ZSkpIHtcbiAgICAgICAgZGF0ZSA9IHRoaXMuX2FwcGx5VGltZXpvbmUoZGF0ZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgbXNlYyA9IFwiLlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2xlbmd0aCAmJiBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgbXNlYyArPSBcIlNcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZS5mb3JtYXQoYFlZWVktTU0tREQgSEg6bW06c3Mke21zZWN9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0ZS5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tOnNzXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IG5ldyBEYXRlKG1vbWVudFR6LnV0Yyh2YWx1ZSkpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICBjbGFzcyBEQVRFT05MWSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFT05MWSB7XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbW9tZW50VHoodmFsdWUpLmZvcm1hdChcIllZWVktTU0tRERcIik7XG4gICAgfVxuICB9XG4gIGNsYXNzIElOVEVHRVIgZXh0ZW5kcyBCYXNlVHlwZXMuSU5URUdFUiB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgVElOWUlOVCBleHRlbmRzIEJhc2VUeXBlcy5USU5ZSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBTTUFMTElOVCBleHRlbmRzIEJhc2VUeXBlcy5TTUFMTElOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgQklHSU5UIGV4dGVuZHMgQmFzZVR5cGVzLkJJR0lOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgUkVBTCBleHRlbmRzIEJhc2VUeXBlcy5SRUFMIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGRlY2ltYWxzKSB7XG4gICAgICBzdXBlcihsZW5ndGgsIGRlY2ltYWxzKTtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGggfHwgdGhpcy5vcHRpb25zLmxlbmd0aCB8fCB0aGlzLl91bnNpZ25lZCB8fCB0aGlzLl96ZXJvZmlsbCkge1xuICAgICAgICB3YXJuKFwiRGIyIGRvZXMgbm90IHN1cHBvcnQgUkVBTCB3aXRoIG9wdGlvbnMuIFBsYWluIGBSRUFMYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cIik7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxlbmd0aCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5fdW5zaWduZWQgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuX3plcm9maWxsID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjbGFzcyBGTE9BVCBleHRlbmRzIEJhc2VUeXBlcy5GTE9BVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBkZWNpbWFscykge1xuICAgICAgc3VwZXIobGVuZ3RoLCBkZWNpbWFscyk7XG4gICAgICBpZiAodGhpcy5fZGVjaW1hbHMpIHtcbiAgICAgICAgd2FybihcIkRiMiBkb2VzIG5vdCBzdXBwb3J0IEZsb2F0IHdpdGggZGVjaW1hbHMuIFBsYWluIGBGTE9BVGAgd2lsbCBiZSB1c2VkIGluc3RlYWQuXCIpO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSB2b2lkIDA7XG4gICAgICAgIHRoaXMub3B0aW9ucy5sZW5ndGggPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fdW5zaWduZWQpIHtcbiAgICAgICAgd2FybihcIkRiMiBkb2VzIG5vdCBzdXBwb3J0IEZsb2F0IHVuc2lnbmVkLiBgVU5TSUdORURgIHdhcyByZW1vdmVkLlwiKTtcbiAgICAgICAgdGhpcy5fdW5zaWduZWQgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5femVyb2ZpbGwpIHtcbiAgICAgICAgd2FybihcIkRiMiBkb2VzIG5vdCBzdXBwb3J0IEZsb2F0IHplcm9maWxsLiBgWkVST0ZJTExgIHdhcyByZW1vdmVkLlwiKTtcbiAgICAgICAgdGhpcy5femVyb2ZpbGwgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNsYXNzIEVOVU0gZXh0ZW5kcyBCYXNlVHlwZXMuRU5VTSB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJWQVJDSEFSKDI1NSlcIjtcbiAgICB9XG4gIH1cbiAgY2xhc3MgRE9VQkxFIGV4dGVuZHMgQmFzZVR5cGVzLkRPVUJMRSB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBkZWNpbWFscykge1xuICAgICAgc3VwZXIobGVuZ3RoLCBkZWNpbWFscyk7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoIHx8IHRoaXMub3B0aW9ucy5sZW5ndGggfHwgdGhpcy5fdW5zaWduZWQgfHwgdGhpcy5femVyb2ZpbGwpIHtcbiAgICAgICAgd2FybihcImRiMiBkb2VzIG5vdCBzdXBwb3J0IERPVUJMRSB3aXRoIG9wdGlvbnMuIFBsYWluIERPVUJMRSB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cIik7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxlbmd0aCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5fdW5zaWduZWQgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuX3plcm9maWxsID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIkRPVUJMRVwiO1xuICAgIH1cbiAgfVxuICBET1VCTEUucHJvdG90eXBlLmtleSA9IERPVUJMRS5rZXkgPSBcIkRPVUJMRVwiO1xuICByZXR1cm4ge1xuICAgIEJMT0IsXG4gICAgQk9PTEVBTixcbiAgICBFTlVNLFxuICAgIFNUUklORyxcbiAgICBVVUlELFxuICAgIERBVEUsXG4gICAgREFURU9OTFksXG4gICAgTk9XLFxuICAgIFRJTllJTlQsXG4gICAgU01BTExJTlQsXG4gICAgSU5URUdFUixcbiAgICBET1VCTEUsXG4gICAgXCJET1VCTEUgUFJFQ0lTSU9OXCI6IERPVUJMRSxcbiAgICBCSUdJTlQsXG4gICAgUkVBTCxcbiAgICBGTE9BVCxcbiAgICBURVhUXG4gIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS10eXBlcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/db2/data-types.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/db2/index.js":
/*!***********************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/db2/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst AbstractDialect = __webpack_require__(/*! ../abstract */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst ConnectionManager = __webpack_require__(/*! ./connection-manager */ \"(action-browser)/../node_modules/sequelize/lib/dialects/db2/connection-manager.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(action-browser)/../node_modules/sequelize/lib/dialects/db2/query.js\");\nconst QueryGenerator = __webpack_require__(/*! ./query-generator */ \"(action-browser)/../node_modules/sequelize/lib/dialects/db2/query-generator.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\").db2);\nconst { Db2QueryInterface } = __webpack_require__(/*! ./query-interface */ \"(action-browser)/../node_modules/sequelize/lib/dialects/db2/query-interface.js\");\nclass Db2Dialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new Db2QueryInterface(sequelize, this.queryGenerator);\n  }\n}\nDb2Dialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  \"DEFAULT\": true,\n  \"DEFAULT VALUES\": false,\n  \"VALUES ()\": false,\n  \"LIMIT ON UPDATE\": false,\n  \"ORDER NULLS\": false,\n  lock: false,\n  transactions: true,\n  migrations: false,\n  returnValues: false,\n  schemas: true,\n  finalTable: true,\n  autoIncrement: {\n    identityInsert: false,\n    defaultValue: false,\n    update: true\n  },\n  constraints: {\n    restrict: true,\n    default: false\n  },\n  index: {\n    collate: false,\n    length: false,\n    parser: false,\n    type: false,\n    using: false,\n    where: true\n  },\n  NUMERIC: true,\n  tmpTableTrigger: true\n});\nDb2Dialect.prototype.defaultVersion = \"1.0.0\";\nDb2Dialect.prototype.Query = Query;\nDb2Dialect.prototype.name = \"db2\";\nDb2Dialect.prototype.TICK_CHAR = '\"';\nDb2Dialect.prototype.TICK_CHAR_LEFT = '\"';\nDb2Dialect.prototype.TICK_CHAR_RIGHT = '\"';\nDb2Dialect.prototype.DataTypes = DataTypes;\nmodule.exports = Db2Dialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixVQUFVLG1CQUFPLENBQUMsaUVBQVE7QUFDMUIsd0JBQXdCLG1CQUFPLENBQUMsOEZBQWE7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMsK0dBQXNCO0FBQ3hELGNBQWMsbUJBQU8sQ0FBQyxxRkFBUztBQUMvQix1QkFBdUIsbUJBQU8sQ0FBQyx5R0FBbUI7QUFDbEQsa0JBQWtCLGlIQUErQjtBQUNqRCxRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMseUdBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL2RiMi9pbmRleC5qcz84ZWRmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBBYnN0cmFjdERpYWxlY3QgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3RcIik7XG5jb25zdCBDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24tbWFuYWdlclwiKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZShcIi4vcXVlcnlcIik7XG5jb25zdCBRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoXCIuL3F1ZXJ5LWdlbmVyYXRvclwiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpLmRiMjtcbmNvbnN0IHsgRGIyUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoXCIuL3F1ZXJ5LWludGVyZmFjZVwiKTtcbmNsYXNzIERiMkRpYWxlY3QgZXh0ZW5kcyBBYnN0cmFjdERpYWxlY3Qge1xuICBjb25zdHJ1Y3RvcihzZXF1ZWxpemUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgQ29ubmVjdGlvbk1hbmFnZXIodGhpcywgc2VxdWVsaXplKTtcbiAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yID0gbmV3IFF1ZXJ5R2VuZXJhdG9yKHtcbiAgICAgIF9kaWFsZWN0OiB0aGlzLFxuICAgICAgc2VxdWVsaXplXG4gICAgfSk7XG4gICAgdGhpcy5xdWVyeUludGVyZmFjZSA9IG5ldyBEYjJRdWVyeUludGVyZmFjZShzZXF1ZWxpemUsIHRoaXMucXVlcnlHZW5lcmF0b3IpO1xuICB9XG59XG5EYjJEaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyA9IF8ubWVyZ2UoXy5jbG9uZURlZXAoQWJzdHJhY3REaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyksIHtcbiAgXCJERUZBVUxUXCI6IHRydWUsXG4gIFwiREVGQVVMVCBWQUxVRVNcIjogZmFsc2UsXG4gIFwiVkFMVUVTICgpXCI6IGZhbHNlLFxuICBcIkxJTUlUIE9OIFVQREFURVwiOiBmYWxzZSxcbiAgXCJPUkRFUiBOVUxMU1wiOiBmYWxzZSxcbiAgbG9jazogZmFsc2UsXG4gIHRyYW5zYWN0aW9uczogdHJ1ZSxcbiAgbWlncmF0aW9uczogZmFsc2UsXG4gIHJldHVyblZhbHVlczogZmFsc2UsXG4gIHNjaGVtYXM6IHRydWUsXG4gIGZpbmFsVGFibGU6IHRydWUsXG4gIGF1dG9JbmNyZW1lbnQ6IHtcbiAgICBpZGVudGl0eUluc2VydDogZmFsc2UsXG4gICAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgICB1cGRhdGU6IHRydWVcbiAgfSxcbiAgY29uc3RyYWludHM6IHtcbiAgICByZXN0cmljdDogdHJ1ZSxcbiAgICBkZWZhdWx0OiBmYWxzZVxuICB9LFxuICBpbmRleDoge1xuICAgIGNvbGxhdGU6IGZhbHNlLFxuICAgIGxlbmd0aDogZmFsc2UsXG4gICAgcGFyc2VyOiBmYWxzZSxcbiAgICB0eXBlOiBmYWxzZSxcbiAgICB1c2luZzogZmFsc2UsXG4gICAgd2hlcmU6IHRydWVcbiAgfSxcbiAgTlVNRVJJQzogdHJ1ZSxcbiAgdG1wVGFibGVUcmlnZ2VyOiB0cnVlXG59KTtcbkRiMkRpYWxlY3QucHJvdG90eXBlLmRlZmF1bHRWZXJzaW9uID0gXCIxLjAuMFwiO1xuRGIyRGlhbGVjdC5wcm90b3R5cGUuUXVlcnkgPSBRdWVyeTtcbkRiMkRpYWxlY3QucHJvdG90eXBlLm5hbWUgPSBcImRiMlwiO1xuRGIyRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSID0gJ1wiJztcbkRiMkRpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9MRUZUID0gJ1wiJztcbkRiMkRpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9SSUdIVCA9ICdcIic7XG5EYjJEaWFsZWN0LnByb3RvdHlwZS5EYXRhVHlwZXMgPSBEYXRhVHlwZXM7XG5tb2R1bGUuZXhwb3J0cyA9IERiMkRpYWxlY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/db2/index.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/db2/query-generator.js":
/*!*********************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/db2/query-generator.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\");\nconst AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-generator.js\");\nconst randomBytes = (__webpack_require__(/*! crypto */ \"crypto\").randomBytes);\nconst Op = __webpack_require__(/*! ../../operators */ \"(action-browser)/../node_modules/sequelize/lib/operators.js\");\nconst throwMethodUndefined = function(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n};\nclass Db2QueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n    this.OperatorMap = __spreadProps(__spreadValues({}, this.OperatorMap), {\n      [Op.regexp]: \"REGEXP_LIKE\",\n      [Op.notRegexp]: \"NOT REGEXP_LIKE\"\n    });\n    this.autoGenValue = 1;\n  }\n  createSchema(schema) {\n    return [\n      \"CREATE SCHEMA\",\n      this.quoteIdentifier(schema),\n      \";\"\n    ].join(\" \");\n  }\n  dropSchema(schema) {\n    const query = `CALL SYSPROC.ADMIN_DROP_SCHEMA(${wrapSingleQuote(schema.trim())}, NULL, ? , ?)`;\n    const sql = { query };\n    sql.bind = [\n      { ParamType: \"INOUT\", Data: \"ERRORSCHEMA\" },\n      { ParamType: \"INOUT\", Data: \"ERRORTABLE\" }\n    ];\n    return sql;\n  }\n  showSchemasQuery() {\n    return `SELECT SCHEMANAME AS \"schema_name\" FROM SYSCAT.SCHEMATA WHERE (SCHEMANAME NOT LIKE 'SYS%') AND SCHEMANAME NOT IN ('NULLID', 'SQLJ', 'ERRORSCHEMA')`;\n  }\n  versionQuery() {\n    return \"select service_level as VERSION from TABLE (sysproc.env_get_inst_info()) as A\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    const query = \"CREATE TABLE <%= table %> (<%= attributes %>)\", primaryKeys = [], foreignKeys = {}, attrStr = [], commentTemplate = \" -- <%= comment %>, TableName = <%= table %>, ColumnName = <%= column %>;\";\n    let commentStr = \"\";\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        let dataType = attributes[attr];\n        let match;\n        if (dataType.includes(\"COMMENT \")) {\n          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n          if (commentMatch && commentMatch.length > 2) {\n            const commentText = commentMatch[2].replace(/COMMENT/, \"\").trim();\n            commentStr += _.template(commentTemplate, this._templateSettings)({\n              table: this.quoteIdentifier(tableName),\n              comment: this.escape(commentText),\n              column: this.quoteIdentifier(attr)\n            });\n            dataType = commentMatch[1];\n          }\n        }\n        if (_.includes(dataType, \"PRIMARY KEY\")) {\n          primaryKeys.push(attr);\n          if (_.includes(dataType, \"REFERENCES\")) {\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace(/PRIMARY KEY/, \"\")}`);\n            foreignKeys[attr] = match[2];\n          } else {\n            attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace(/PRIMARY KEY/, \"\")}`);\n          }\n        } else if (_.includes(dataType, \"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          if (options && options.uniqueKeys) {\n            for (const ukey in options.uniqueKeys) {\n              if (options.uniqueKeys[ukey].fields.includes(attr) && !_.includes(dataType, \"NOT NULL\")) {\n                dataType += \" NOT NULL\";\n                break;\n              }\n            }\n          }\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n        }\n      }\n    }\n    const values = {\n      table: this.quoteTable(tableName),\n      attributes: attrStr.join(\", \")\n    }, pkString = primaryKeys.map((pk) => {\n      return this.quoteIdentifier(pk);\n    }).join(\", \");\n    if (options && options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (!_.isString(indexName)) {\n            indexName = `uniq_${tableName}_${columns.fields.join(\"_\")}`;\n          }\n          values.attributes += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n    if (pkString.length > 0) {\n      values.attributes += `, PRIMARY KEY (${pkString})`;\n    }\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        values.attributes += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n    return `${_.template(query, this._templateSettings)(values).trim()};${commentStr}`;\n  }\n  describeTableQuery(tableName, schema) {\n    let sql = [\n      'SELECT NAME AS \"Name\", TBNAME AS \"Table\", TBCREATOR AS \"Schema\",',\n      'TRIM(COLTYPE) AS \"Type\", LENGTH AS \"Length\", SCALE AS \"Scale\",',\n      'NULLS AS \"IsNull\", DEFAULT AS \"Default\", COLNO AS \"Colno\",',\n      'IDENTITY AS \"IsIdentity\", KEYSEQ AS \"KeySeq\", REMARKS AS \"Comment\"',\n      \"FROM\",\n      \"SYSIBM.SYSCOLUMNS\",\n      \"WHERE TBNAME =\",\n      wrapSingleQuote(tableName)\n    ].join(\" \");\n    if (schema) {\n      sql += ` AND TBCREATOR =${wrapSingleQuote(schema)}`;\n    } else {\n      sql += \" AND TBCREATOR = USER\";\n    }\n    return `${sql};`;\n  }\n  renameTableQuery(before, after) {\n    const query = \"RENAME TABLE <%= before %> TO <%= after %>;\";\n    return _.template(query, this._templateSettings)({\n      before: this.quoteTable(before),\n      after: this.quoteTable(after)\n    });\n  }\n  showTablesQuery() {\n    return `SELECT TABNAME AS \"tableName\", TRIM(TABSCHEMA) AS \"tableSchema\" FROM SYSCAT.TABLES WHERE TABSCHEMA = USER AND TYPE = 'T' ORDER BY TABSCHEMA, TABNAME`;\n  }\n  tableExistsQuery(table) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema || this.sequelize.config.username.toUpperCase();\n    return `SELECT name FROM sysibm.systables WHERE NAME = ${wrapSingleQuote(tableName)} AND CREATOR = ${wrapSingleQuote(schemaName)}`;\n  }\n  dropTableQuery(tableName) {\n    const query = \"DROP TABLE <%= table %>\";\n    const values = {\n      table: this.quoteTable(tableName)\n    };\n    return `${_.template(query, this._templateSettings)(values).trim()};`;\n  }\n  addColumnQuery(table, key, dataType) {\n    dataType.field = key;\n    const query = \"ALTER TABLE <%= table %> ADD <%= attribute %>;\", attribute = _.template(\"<%= key %> <%= definition %>\", this._templateSettings)({\n      key: this.quoteIdentifier(key),\n      definition: this.attributeToSQL(dataType, {\n        context: \"addColumn\"\n      })\n    });\n    return _.template(query, this._templateSettings)({\n      table: this.quoteTable(table),\n      attribute\n    });\n  }\n  removeColumnQuery(tableName, attributeName) {\n    const query = \"ALTER TABLE <%= tableName %> DROP COLUMN <%= attributeName %>;\";\n    return _.template(query, this._templateSettings)({\n      tableName: this.quoteTable(tableName),\n      attributeName: this.quoteIdentifier(attributeName)\n    });\n  }\n  changeColumnQuery(tableName, attributes) {\n    const query = \"ALTER TABLE <%= tableName %> <%= query %>;\";\n    const attrString = [], constraintString = [];\n    for (const attributeName in attributes) {\n      const attrValue = attributes[attributeName];\n      let defs = [attrValue];\n      if (Array.isArray(attrValue)) {\n        defs = attrValue;\n      }\n      for (let i = 0; i < defs.length; i++) {\n        const definition = defs[i];\n        if (definition.match(/REFERENCES/)) {\n          constraintString.push(_.template(\"<%= fkName %> FOREIGN KEY (<%= attrName %>) <%= definition %>\", this._templateSettings)({\n            fkName: this.quoteIdentifier(`${attributeName}_foreign_idx`),\n            attrName: this.quoteIdentifier(attributeName),\n            definition: definition.replace(/.+?(?=REFERENCES)/, \"\")\n          }));\n        } else if (_.startsWith(definition, \"DROP \")) {\n          attrString.push(_.template(\"<%= attrName %> <%= definition %>\", this._templateSettings)({\n            attrName: this.quoteIdentifier(attributeName),\n            definition\n          }));\n        } else {\n          attrString.push(_.template(\"<%= attrName %> SET <%= definition %>\", this._templateSettings)({\n            attrName: this.quoteIdentifier(attributeName),\n            definition\n          }));\n        }\n      }\n    }\n    let finalQuery = \"\";\n    if (attrString.length) {\n      finalQuery += `ALTER COLUMN ${attrString.join(\" ALTER COLUMN \")}`;\n      finalQuery += constraintString.length ? \" \" : \"\";\n    }\n    if (constraintString.length) {\n      finalQuery += `ADD CONSTRAINT ${constraintString.join(\" ADD CONSTRAINT \")}`;\n    }\n    return _.template(query, this._templateSettings)({\n      tableName: this.quoteTable(tableName),\n      query: finalQuery\n    });\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const query = \"ALTER TABLE <%= tableName %> RENAME COLUMN <%= before %> TO <%= after %>;\", newName = Object.keys(attributes)[0];\n    return _.template(query, this._templateSettings)({\n      tableName: this.quoteTable(tableName),\n      before: this.quoteIdentifier(attrBefore),\n      after: this.quoteIdentifier(newName)\n    });\n  }\n  addConstraintQuery(tableName, options) {\n    options = options || {};\n    if (options.onUpdate && options.onUpdate.toUpperCase() === \"CASCADE\") {\n      delete options.onUpdate;\n    }\n    const constraintSnippet = this.getConstraintSnippet(tableName, options);\n    if (typeof tableName === \"string\") {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n    return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;\n  }\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    options = options || {};\n    attributes = attributes || {};\n    let query = \"INSERT INTO <%= table %> (<%= attributes %>)<%= output %> VALUES <%= tuples %>;\";\n    if (options.returning) {\n      query = \"SELECT * FROM FINAL TABLE( INSERT INTO <%= table %> (<%= attributes %>)<%= output %> VALUES <%= tuples %>);\";\n    }\n    const emptyQuery = \"INSERT INTO <%= table %>\", tuples = [], allAttributes = [], allQueries = [];\n    let outputFragment;\n    const valuesForEmptyQuery = [];\n    if (options.returning) {\n      outputFragment = \"\";\n    }\n    _.forEach(attrValueHashes, (attrValueHash) => {\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        valuesForEmptyQuery.push(`(${this.autoGenValue++})`);\n        return;\n      }\n      _.forOwn(attrValueHash, (value, key) => {\n        if (allAttributes.indexOf(key) === -1) {\n          if (value === null && attributes[key] && attributes[key].autoIncrement)\n            return;\n          allAttributes.push(key);\n        }\n      });\n    });\n    if (valuesForEmptyQuery.length > 0) {\n      allQueries.push(`${emptyQuery} VALUES ${valuesForEmptyQuery.join(\",\")}`);\n    }\n    if (allAttributes.length > 0) {\n      _.forEach(attrValueHashes, (attrValueHash) => {\n        tuples.push(`(${allAttributes.map((key) => this.escape(attrValueHash[key]), void 0, { context: \"INSERT\" }).join(\",\")})`);\n      });\n      allQueries.push(query);\n    }\n    const replacements = {\n      table: this.quoteTable(tableName),\n      attributes: allAttributes.map((attr) => this.quoteIdentifier(attr)).join(\",\"),\n      tuples,\n      output: outputFragment\n    };\n    const generatedQuery = _.template(allQueries.join(\";\"), this._templateSettings)(replacements);\n    return generatedQuery;\n  }\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n    options = options || {};\n    _.defaults(options, this.options);\n    if (!options.limit) {\n      sql.query = `SELECT * FROM FINAL TABLE (${sql.query});`;\n      return sql;\n    }\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"UPDATE\" })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"UPDATE\" }, bindParam)}`);\n      }\n    }\n    let query;\n    const whereOptions = _.defaults({ bindParam }, options);\n    query = `UPDATE (SELECT * FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} FETCH NEXT ${this.escape(options.limit)} ROWS ONLY) SET ${values.join(\",\")}`;\n    query = `SELECT * FROM FINAL TABLE (${query});`;\n    return { query, bind };\n  }\n  upsertQuery(tableName, insertValues, updateValues, where, model) {\n    const targetTableAlias = this.quoteTable(`${tableName}_target`);\n    const sourceTableAlias = this.quoteTable(`${tableName}_source`);\n    const primaryKeysAttrs = [];\n    const identityAttrs = [];\n    const uniqueAttrs = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n    for (const key in model.rawAttributes) {\n      if (model.rawAttributes[key].primaryKey) {\n        primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].unique) {\n        uniqueAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].autoIncrement) {\n        identityAttrs.push(model.rawAttributes[key].field || key);\n      }\n    }\n    for (const index of model._indexes) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const fieldName = typeof field === \"string\" ? field : field.name || field.attribute;\n          if (uniqueAttrs.indexOf(fieldName) === -1 && model.rawAttributes[fieldName]) {\n            uniqueAttrs.push(fieldName);\n          }\n        }\n      }\n    }\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map((key) => this.quoteIdentifier(key)).join(\", \");\n    const insertValuesEscaped = insertKeys.map((key) => this.escape(insertValues[key])).join(\", \");\n    const sourceTableQuery = `VALUES(${insertValuesEscaped})`;\n    let joinCondition;\n    const clauses = where[Op.or].filter((clause) => {\n      let valid = true;\n      for (const key in clause) {\n        if (!clause[key]) {\n          valid = false;\n          break;\n        }\n      }\n      return valid;\n    });\n    const getJoinSnippet = (array) => {\n      return array.map((key) => {\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;\n      });\n    };\n    if (clauses.length === 0) {\n      throw new Error(\"Primary Key or Unique key should be passed to upsert query\");\n    } else {\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n        if (primaryKeysAttrs.indexOf(keys[0]) !== -1) {\n          joinCondition = getJoinSnippet(primaryKeysAttrs).join(\" AND \");\n          break;\n        }\n      }\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueAttrs).join(\" AND \");\n      }\n    }\n    const filteredUpdateClauses = updateKeys.filter((key) => {\n      if (identityAttrs.indexOf(key) === -1) {\n        return true;\n      }\n      return false;\n    }).map((key) => {\n      const value = this.escape(updateValues[key]);\n      key = this.quoteIdentifier(key);\n      return `${targetTableAlias}.${key} = ${value}`;\n    }).join(\", \");\n    const updateSnippet = filteredUpdateClauses.length > 0 ? `WHEN MATCHED THEN UPDATE SET ${filteredUpdateClauses}` : \"\";\n    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;\n    let query = `MERGE INTO ${tableNameQuoted} AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;\n    query += ` ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet};`;\n    return query;\n  }\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)} IMMEDIATE`;\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    const query = \"DELETE FROM <%= table %><%= where %><%= limit %>\";\n    where = this.getWhereConditions(where, null, model, options);\n    let limit = \"\";\n    if (options.offset > 0) {\n      limit = ` OFFSET ${this.escape(options.offset)} ROWS`;\n    }\n    if (options.limit) {\n      limit += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n    }\n    const replacements = {\n      limit,\n      table,\n      where\n    };\n    if (replacements.where) {\n      replacements.where = ` WHERE ${replacements.where}`;\n    }\n    return _.template(query, this._templateSettings)(replacements);\n  }\n  showIndexesQuery(tableName) {\n    let sql = 'SELECT NAME AS \"name\", TBNAME AS \"tableName\", UNIQUERULE AS \"keyType\", COLNAMES, INDEXTYPE AS \"type\" FROM SYSIBM.SYSINDEXES WHERE TBNAME = <%= tableName %>';\n    let schema = void 0;\n    if (_.isObject(tableName)) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n    if (schema) {\n      sql = `${sql} AND TBCREATOR = <%= schemaName %>`;\n    }\n    sql = `${sql} ORDER BY NAME;`;\n    return _.template(sql, this._templateSettings)({\n      tableName: wrapSingleQuote(tableName),\n      schemaName: wrapSingleQuote(schema)\n    });\n  }\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT CONSTNAME AS \"constraintName\", TRIM(TABSCHEMA) AS \"schemaName\", TABNAME AS \"tableName\" FROM SYSCAT.TABCONST WHERE TABNAME = '${tableName}'`;\n    if (constraintName) {\n      sql += ` AND CONSTNAME LIKE '%${constraintName}%'`;\n    }\n    return `${sql} ORDER BY CONSTNAME;`;\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    const sql = \"DROP INDEX <%= indexName %>\";\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    const values = {\n      tableName: this.quoteIdentifiers(tableName),\n      indexName: this.quoteIdentifiers(indexName)\n    };\n    return _.template(sql, this._templateSettings)(values);\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    let template;\n    let changeNull = 1;\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values)\n        attribute.values = attribute.type.values;\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map((value) => {\n        return this.escape(value);\n      }).join(\", \")}))`;\n    } else {\n      template = attribute.type.toString();\n    }\n    if (options && options.context === \"changeColumn\" && attribute.type) {\n      template = `DATA TYPE ${template}`;\n    } else if (attribute.allowNull === false || attribute.primaryKey === true || attribute.unique) {\n      template += \" NOT NULL\";\n      changeNull = 0;\n    }\n    if (attribute.autoIncrement) {\n      let initialValue = 1;\n      if (attribute.initialAutoIncrement) {\n        initialValue = attribute.initialAutoIncrement;\n      }\n      template += ` GENERATED BY DEFAULT AS IDENTITY(START WITH ${initialValue}, INCREMENT BY 1)`;\n    }\n    if (attribute.type !== \"TEXT\" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.unique === true) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      if (options && options.context === \"addColumn\" && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = `${options.tableName}_${attrName}_fidx`;\n        template += `, CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n      if (attribute.onUpdate && attribute.onUpdate.toUpperCase() != \"CASCADE\") {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n    if (options && options.context === \"changeColumn\" && changeNull === 1 && attribute.allowNull !== void 0) {\n      template = [template];\n      if (attribute.allowNull) {\n        template.push(\"DROP NOT NULL\");\n      } else {\n        template.push(\"NOT NULL\");\n      }\n    }\n    if (attribute.comment && typeof attribute.comment === \"string\") {\n      template += ` COMMENT ${attribute.comment}`;\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {}, existingConstraints = [];\n    let key, attribute;\n    for (key in attributes) {\n      attribute = attributes[key];\n      if (attribute.references) {\n        if (existingConstraints.indexOf(attribute.references.model.toString()) !== -1) {\n          attribute.onDelete = \"\";\n          attribute.onUpdate = \"\";\n        } else if (attribute.unique && attribute.unique === true) {\n          attribute.onDelete = \"\";\n          attribute.onUpdate = \"\";\n        } else {\n          existingConstraints.push(attribute.references.model.toString());\n        }\n      }\n      if (key && !attribute.field && typeof attribute === \"object\")\n        attribute.field = key;\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n    return result;\n  }\n  createTrigger() {\n    throwMethodUndefined(\"createTrigger\");\n  }\n  dropTrigger() {\n    throwMethodUndefined(\"dropTrigger\");\n  }\n  renameTrigger() {\n    throwMethodUndefined(\"renameTrigger\");\n  }\n  createFunction() {\n    throwMethodUndefined(\"createFunction\");\n  }\n  dropFunction() {\n    throwMethodUndefined(\"dropFunction\");\n  }\n  renameFunction() {\n    throwMethodUndefined(\"renameFunction\");\n  }\n  _getForeignKeysQuerySQL(condition) {\n    return `SELECT R.CONSTNAME AS \"constraintName\", TRIM(R.TABSCHEMA) AS \"constraintSchema\", R.TABNAME AS \"tableName\", TRIM(R.TABSCHEMA) AS \"tableSchema\", LISTAGG(C.COLNAME,', ') WITHIN GROUP (ORDER BY C.COLNAME) AS \"columnName\", TRIM(R.REFTABSCHEMA) AS \"referencedTableSchema\", R.REFTABNAME AS \"referencedTableName\", TRIM(R.PK_COLNAMES) AS \"referencedColumnName\" FROM SYSCAT.REFERENCES R, SYSCAT.KEYCOLUSE C WHERE R.CONSTNAME = C.CONSTNAME AND R.TABSCHEMA = C.TABSCHEMA AND R.TABNAME = C.TABNAME${condition} GROUP BY R.REFTABSCHEMA, R.REFTABNAME, R.TABSCHEMA, R.TABNAME, R.CONSTNAME, R.PK_COLNAMES`;\n  }\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    schemaName = table.schema || schemaName;\n    let sql = \"\";\n    if (tableName) {\n      sql = ` AND R.TABNAME = ${wrapSingleQuote(tableName)}`;\n    }\n    if (schemaName) {\n      sql += ` AND R.TABSCHEMA = ${wrapSingleQuote(schemaName)}`;\n    }\n    return this._getForeignKeysQuerySQL(sql);\n  }\n  getForeignKeyQuery(table, columnName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    let sql = \"\";\n    if (tableName) {\n      sql = ` AND R.TABNAME = ${wrapSingleQuote(tableName)}`;\n    }\n    if (schemaName) {\n      sql += ` AND R.TABSCHEMA = ${wrapSingleQuote(schemaName)}`;\n    }\n    if (columnName) {\n      sql += ` AND C.COLNAME = ${wrapSingleQuote(columnName)}`;\n    }\n    return this._getForeignKeysQuerySQL(sql);\n  }\n  getPrimaryKeyConstraintQuery(table, attributeName) {\n    const tableName = wrapSingleQuote(table.tableName || table);\n    return [\n      'SELECT TABNAME AS \"tableName\",',\n      'COLNAME AS \"columnName\",',\n      'CONSTNAME AS \"constraintName\"',\n      \"FROM SYSCAT.KEYCOLUSE WHERE CONSTNAME LIKE 'PK_%'\",\n      `AND COLNAME = ${wrapSingleQuote(attributeName)}`,\n      `AND TABNAME = ${tableName};`\n    ].join(\" \");\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return _.template(\"ALTER TABLE <%= table %> DROP <%= key %>\", this._templateSettings)({\n      table: this.quoteTable(tableName),\n      key: this.quoteIdentifier(foreignKey)\n    });\n  }\n  dropConstraintQuery(tableName, constraintName) {\n    const sql = \"ALTER TABLE <%= table %> DROP CONSTRAINT <%= constraint %>;\";\n    return _.template(sql, this._templateSettings)({\n      table: this.quoteTable(tableName),\n      constraint: this.quoteIdentifier(constraintName)\n    });\n  }\n  setAutocommitQuery() {\n    return \"\";\n  }\n  setIsolationLevelQuery() {\n  }\n  generateTransactionId() {\n    return randomBytes(10).toString(\"hex\");\n  }\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return \"BEGIN TRANSACTION;\";\n  }\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n    return \"COMMIT TRANSACTION;\";\n  }\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return \"ROLLBACK TRANSACTION;\";\n  }\n  addLimitAndOffset(options) {\n    const offset = options.offset || 0;\n    let fragment = \"\";\n    if (offset > 0) {\n      fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n    }\n    if (options.limit) {\n      fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n    }\n    return fragment;\n  }\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n  addUniqueFields(dataValues, rawAttributes, uniqno) {\n    uniqno = uniqno === void 0 ? 1 : uniqno;\n    for (const key in rawAttributes) {\n      if (rawAttributes[key].unique && dataValues[key] === void 0) {\n        if (rawAttributes[key].type instanceof DataTypes.DATE) {\n          dataValues[key] = Utils.now(\"db2\");\n        } else if (rawAttributes[key].type instanceof DataTypes.STRING) {\n          dataValues[key] = `unique${uniqno++}`;\n        } else if (rawAttributes[key].type instanceof DataTypes.INTEGER) {\n          dataValues[key] = uniqno++;\n        } else if (rawAttributes[key].type instanceof DataTypes.BOOLEAN) {\n          dataValues[key] = new DataTypes.BOOLEAN(false);\n        }\n      }\n    }\n    return uniqno;\n  }\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, '\"'), '\"');\n  }\n}\nfunction wrapSingleQuote(identifier) {\n  if (identifier) {\n    return `'${identifier}'`;\n  }\n  return \"\";\n}\nmodule.exports = Db2QueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvcXVlcnktZ2VuZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMxQixjQUFjLG1CQUFPLENBQUMsNEVBQWE7QUFDbkMsa0JBQWtCLG1CQUFPLENBQUMsc0ZBQWtCO0FBQzVDLCtCQUErQixtQkFBTyxDQUFDLHdIQUE2QjtBQUNwRSxvQkFBb0IseURBQTZCO0FBQ2pELFdBQVcsbUJBQU8sQ0FBQyxvRkFBaUI7QUFDcEM7QUFDQSxpQ0FBaUMsV0FBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsK0JBQStCO0FBQ25GLGtCQUFrQjtBQUNsQjtBQUNBLFFBQVEseUNBQXlDO0FBQ2pELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyw0R0FBNEc7QUFDak47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEJBQTRCLEVBQUUsb0NBQW9DO0FBQzlGO0FBQ0EsWUFBWTtBQUNaLDRCQUE0Qiw0QkFBNEIsRUFBRSxvQ0FBb0M7QUFDOUY7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwwQkFBMEIsNEJBQTRCLEVBQUUsU0FBUztBQUNqRTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRCQUE0QixFQUFFLFNBQVM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsR0FBRyx5QkFBeUI7QUFDdEU7QUFDQSwrQ0FBK0MsaUNBQWlDLFVBQVUsc0VBQXNFO0FBQ2hLO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsMkJBQTJCLElBQUksa0JBQWtCO0FBQ2hHO0FBQ0E7QUFDQSxjQUFjLDBEQUEwRCxFQUFFLFdBQVc7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hELE1BQU07QUFDTjtBQUNBO0FBQ0EsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDRCQUE0QixnQkFBZ0IsNEJBQTRCO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMERBQTBEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtDQUFrQztBQUN0RTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMENBQTBDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVyxNQUFNLG1CQUFtQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG9CQUFvQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLHlCQUF5QixZQUFZLFNBQVMsOEJBQThCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzRUFBc0UsbUJBQW1CLFlBQVk7QUFDN0gsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVSxFQUFFO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBCQUEwQixHQUFHLDRFQUE0RSxtQkFBbUIsRUFBRTtBQUNySixRQUFRO0FBQ1IsdUJBQXVCLDBCQUEwQixHQUFHLDRFQUE0RSxtQkFBbUIsYUFBYTtBQUNoSztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRCxxQ0FBcUMsNEJBQTRCLEVBQUUsc0NBQXNDLGFBQWEsNEJBQTRCLGlCQUFpQixpQkFBaUI7QUFDcEwsMENBQTBDLE1BQU0sRUFBRTtBQUNsRCxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdEQUFnRCxVQUFVO0FBQzFELGdEQUFnRCxVQUFVO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0JBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUIsR0FBRyxLQUFLLElBQUksaUJBQWlCLEdBQUcsSUFBSTtBQUN2RSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCLEdBQUcsS0FBSyxJQUFJLE1BQU07QUFDbkQsS0FBSztBQUNMLDZGQUE2RixzQkFBc0I7QUFDbkgsOEJBQThCLGlCQUFpQixXQUFXLG9CQUFvQjtBQUM5RSw4QkFBOEIsaUJBQWlCLEtBQUssa0JBQWtCLFNBQVMsaUJBQWlCLE9BQU8saUJBQWlCLEdBQUcsaUJBQWlCLE9BQU8sY0FBYztBQUNqSyxpQkFBaUIsZUFBZSwrQkFBK0IsZUFBZTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEJBQTRCO0FBQ3pEO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkJBQTZCO0FBQ3REO0FBQ0E7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0EsYUFBYSxLQUFLLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxSkFBcUosVUFBVTtBQUMvSjtBQUNBLHNDQUFzQyxlQUFlO0FBQ3JEO0FBQ0EsY0FBYyxLQUFLLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsR0FBRyxnQ0FBZ0M7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUNBQXVDLEtBQUs7QUFDekU7QUFDQSxPQUFPLGFBQWE7QUFDcEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGFBQWE7QUFDL0U7QUFDQTtBQUNBLDhCQUE4QixvQ0FBb0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCLEdBQUcsU0FBUztBQUN4RCxvQ0FBb0MsUUFBUSxlQUFlLFNBQVM7QUFDcEU7QUFDQSxpQ0FBaUMsNENBQTRDO0FBQzdFO0FBQ0EseUJBQXlCLCtDQUErQztBQUN4RSxRQUFRO0FBQ1IseUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0Esa0NBQWtDLGlDQUFpQztBQUNuRTtBQUNBO0FBQ0Esa0NBQWtDLGlDQUFpQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0JBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrZkFBa2YsV0FBVztBQUM3ZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkJBQTJCO0FBQzNEO0FBQ0E7QUFDQSxtQ0FBbUMsNEJBQTRCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkJBQTJCO0FBQzNEO0FBQ0E7QUFDQSxtQ0FBbUMsNEJBQTRCO0FBQy9EO0FBQ0E7QUFDQSxpQ0FBaUMsNEJBQTRCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtCQUErQjtBQUN0RCx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3Q0FBd0M7QUFDekU7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0NBQXdDO0FBQzdFO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQSxpQ0FBaUMsNEJBQTRCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixxQ0FBcUMsU0FBUztBQUM5QyxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvZGIyL3F1ZXJ5LWdlbmVyYXRvci5qcz8xMGQ1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIik7XG5jb25zdCBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5LWdlbmVyYXRvclwiKTtcbmNvbnN0IHJhbmRvbUJ5dGVzID0gcmVxdWlyZShcImNyeXB0b1wiKS5yYW5kb21CeXRlcztcbmNvbnN0IE9wID0gcmVxdWlyZShcIi4uLy4uL29wZXJhdG9yc1wiKTtcbmNvbnN0IHRocm93TWV0aG9kVW5kZWZpbmVkID0gZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBtZXRob2QgXCIke21ldGhvZE5hbWV9XCIgaXMgbm90IGRlZmluZWQhIFBsZWFzZSBhZGQgaXQgdG8geW91ciBzcWwgZGlhbGVjdC5gKTtcbn07XG5jbGFzcyBEYjJRdWVyeUdlbmVyYXRvciBleHRlbmRzIEFic3RyYWN0UXVlcnlHZW5lcmF0b3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy5PcGVyYXRvck1hcCA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuT3BlcmF0b3JNYXApLCB7XG4gICAgICBbT3AucmVnZXhwXTogXCJSRUdFWFBfTElLRVwiLFxuICAgICAgW09wLm5vdFJlZ2V4cF06IFwiTk9UIFJFR0VYUF9MSUtFXCJcbiAgICB9KTtcbiAgICB0aGlzLmF1dG9HZW5WYWx1ZSA9IDE7XG4gIH1cbiAgY3JlYXRlU2NoZW1hKHNjaGVtYSkge1xuICAgIHJldHVybiBbXG4gICAgICBcIkNSRUFURSBTQ0hFTUFcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKHNjaGVtYSksXG4gICAgICBcIjtcIlxuICAgIF0uam9pbihcIiBcIik7XG4gIH1cbiAgZHJvcFNjaGVtYShzY2hlbWEpIHtcbiAgICBjb25zdCBxdWVyeSA9IGBDQUxMIFNZU1BST0MuQURNSU5fRFJPUF9TQ0hFTUEoJHt3cmFwU2luZ2xlUXVvdGUoc2NoZW1hLnRyaW0oKSl9LCBOVUxMLCA/ICwgPylgO1xuICAgIGNvbnN0IHNxbCA9IHsgcXVlcnkgfTtcbiAgICBzcWwuYmluZCA9IFtcbiAgICAgIHsgUGFyYW1UeXBlOiBcIklOT1VUXCIsIERhdGE6IFwiRVJST1JTQ0hFTUFcIiB9LFxuICAgICAgeyBQYXJhbVR5cGU6IFwiSU5PVVRcIiwgRGF0YTogXCJFUlJPUlRBQkxFXCIgfVxuICAgIF07XG4gICAgcmV0dXJuIHNxbDtcbiAgfVxuICBzaG93U2NoZW1hc1F1ZXJ5KCkge1xuICAgIHJldHVybiBgU0VMRUNUIFNDSEVNQU5BTUUgQVMgXCJzY2hlbWFfbmFtZVwiIEZST00gU1lTQ0FULlNDSEVNQVRBIFdIRVJFIChTQ0hFTUFOQU1FIE5PVCBMSUtFICdTWVMlJykgQU5EIFNDSEVNQU5BTUUgTk9UIElOICgnTlVMTElEJywgJ1NRTEonLCAnRVJST1JTQ0hFTUEnKWA7XG4gIH1cbiAgdmVyc2lvblF1ZXJ5KCkge1xuICAgIHJldHVybiBcInNlbGVjdCBzZXJ2aWNlX2xldmVsIGFzIFZFUlNJT04gZnJvbSBUQUJMRSAoc3lzcHJvYy5lbnZfZ2V0X2luc3RfaW5mbygpKSBhcyBBXCI7XG4gIH1cbiAgY3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBxdWVyeSA9IFwiQ1JFQVRFIFRBQkxFIDwlPSB0YWJsZSAlPiAoPCU9IGF0dHJpYnV0ZXMgJT4pXCIsIHByaW1hcnlLZXlzID0gW10sIGZvcmVpZ25LZXlzID0ge30sIGF0dHJTdHIgPSBbXSwgY29tbWVudFRlbXBsYXRlID0gXCIgLS0gPCU9IGNvbW1lbnQgJT4sIFRhYmxlTmFtZSA9IDwlPSB0YWJsZSAlPiwgQ29sdW1uTmFtZSA9IDwlPSBjb2x1bW4gJT47XCI7XG4gICAgbGV0IGNvbW1lbnRTdHIgPSBcIlwiO1xuICAgIGZvciAoY29uc3QgYXR0ciBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIGxldCBkYXRhVHlwZSA9IGF0dHJpYnV0ZXNbYXR0cl07XG4gICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiQ09NTUVOVCBcIikpIHtcbiAgICAgICAgICBjb25zdCBjb21tZW50TWF0Y2ggPSBkYXRhVHlwZS5tYXRjaCgvXiguKykgKENPTU1FTlQuKikkLyk7XG4gICAgICAgICAgaWYgKGNvbW1lbnRNYXRjaCAmJiBjb21tZW50TWF0Y2gubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgY29uc3QgY29tbWVudFRleHQgPSBjb21tZW50TWF0Y2hbMl0ucmVwbGFjZSgvQ09NTUVOVC8sIFwiXCIpLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbW1lbnRTdHIgKz0gXy50ZW1wbGF0ZShjb21tZW50VGVtcGxhdGUsIHRoaXMuX3RlbXBsYXRlU2V0dGluZ3MpKHtcbiAgICAgICAgICAgICAgdGFibGU6IHRoaXMucXVvdGVJZGVudGlmaWVyKHRhYmxlTmFtZSksXG4gICAgICAgICAgICAgIGNvbW1lbnQ6IHRoaXMuZXNjYXBlKGNvbW1lbnRUZXh0KSxcbiAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkYXRhVHlwZSA9IGNvbW1lbnRNYXRjaFsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF8uaW5jbHVkZXMoZGF0YVR5cGUsIFwiUFJJTUFSWSBLRVlcIikpIHtcbiAgICAgICAgICBwcmltYXJ5S2V5cy5wdXNoKGF0dHIpO1xuICAgICAgICAgIGlmIChfLmluY2x1ZGVzKGRhdGFUeXBlLCBcIlJFRkVSRU5DRVNcIikpIHtcbiAgICAgICAgICAgIG1hdGNoID0gZGF0YVR5cGUubWF0Y2goL14oLispIChSRUZFUkVOQ0VTLiopJC8pO1xuICAgICAgICAgICAgYXR0clN0ci5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke21hdGNoWzFdLnJlcGxhY2UoL1BSSU1BUlkgS0VZLywgXCJcIil9YCk7XG4gICAgICAgICAgICBmb3JlaWduS2V5c1thdHRyXSA9IG1hdGNoWzJdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRyU3RyLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7ZGF0YVR5cGUucmVwbGFjZSgvUFJJTUFSWSBLRVkvLCBcIlwiKX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyhkYXRhVHlwZSwgXCJSRUZFUkVOQ0VTXCIpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBkYXRhVHlwZS5tYXRjaCgvXiguKykgKFJFRkVSRU5DRVMuKikkLyk7XG4gICAgICAgICAgYXR0clN0ci5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke21hdGNoWzFdfWApO1xuICAgICAgICAgIGZvcmVpZ25LZXlzW2F0dHJdID0gbWF0Y2hbMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy51bmlxdWVLZXlzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHVrZXkgaW4gb3B0aW9ucy51bmlxdWVLZXlzKSB7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLnVuaXF1ZUtleXNbdWtleV0uZmllbGRzLmluY2x1ZGVzKGF0dHIpICYmICFfLmluY2x1ZGVzKGRhdGFUeXBlLCBcIk5PVCBOVUxMXCIpKSB7XG4gICAgICAgICAgICAgICAgZGF0YVR5cGUgKz0gXCIgTk9UIE5VTExcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyU3RyLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7ZGF0YVR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdmFsdWVzID0ge1xuICAgICAgdGFibGU6IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgYXR0cmlidXRlczogYXR0clN0ci5qb2luKFwiLCBcIilcbiAgICB9LCBwa1N0cmluZyA9IHByaW1hcnlLZXlzLm1hcCgocGspID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnF1b3RlSWRlbnRpZmllcihwayk7XG4gICAgfSkuam9pbihcIiwgXCIpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudW5pcXVlS2V5cykge1xuICAgICAgXy5lYWNoKG9wdGlvbnMudW5pcXVlS2V5cywgKGNvbHVtbnMsIGluZGV4TmFtZSkgPT4ge1xuICAgICAgICBpZiAoY29sdW1ucy5jdXN0b21JbmRleCkge1xuICAgICAgICAgIGlmICghXy5pc1N0cmluZyhpbmRleE5hbWUpKSB7XG4gICAgICAgICAgICBpbmRleE5hbWUgPSBgdW5pcV8ke3RhYmxlTmFtZX1fJHtjb2x1bW5zLmZpZWxkcy5qb2luKFwiX1wiKX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZXMuYXR0cmlidXRlcyArPSBgLCBDT05TVFJBSU5UICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaW5kZXhOYW1lKX0gVU5JUVVFICgke2NvbHVtbnMuZmllbGRzLm1hcCgoZmllbGQpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKSkuam9pbihcIiwgXCIpfSlgO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBrU3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhbHVlcy5hdHRyaWJ1dGVzICs9IGAsIFBSSU1BUlkgS0VZICgke3BrU3RyaW5nfSlgO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZrZXkgaW4gZm9yZWlnbktleXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZm9yZWlnbktleXMsIGZrZXkpKSB7XG4gICAgICAgIHZhbHVlcy5hdHRyaWJ1dGVzICs9IGAsIEZPUkVJR04gS0VZICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGZrZXkpfSkgJHtmb3JlaWduS2V5c1tma2V5XX1gO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYCR7Xy50ZW1wbGF0ZShxdWVyeSwgdGhpcy5fdGVtcGxhdGVTZXR0aW5ncykodmFsdWVzKS50cmltKCl9OyR7Y29tbWVudFN0cn1gO1xuICB9XG4gIGRlc2NyaWJlVGFibGVRdWVyeSh0YWJsZU5hbWUsIHNjaGVtYSkge1xuICAgIGxldCBzcWwgPSBbXG4gICAgICAnU0VMRUNUIE5BTUUgQVMgXCJOYW1lXCIsIFRCTkFNRSBBUyBcIlRhYmxlXCIsIFRCQ1JFQVRPUiBBUyBcIlNjaGVtYVwiLCcsXG4gICAgICAnVFJJTShDT0xUWVBFKSBBUyBcIlR5cGVcIiwgTEVOR1RIIEFTIFwiTGVuZ3RoXCIsIFNDQUxFIEFTIFwiU2NhbGVcIiwnLFxuICAgICAgJ05VTExTIEFTIFwiSXNOdWxsXCIsIERFRkFVTFQgQVMgXCJEZWZhdWx0XCIsIENPTE5PIEFTIFwiQ29sbm9cIiwnLFxuICAgICAgJ0lERU5USVRZIEFTIFwiSXNJZGVudGl0eVwiLCBLRVlTRVEgQVMgXCJLZXlTZXFcIiwgUkVNQVJLUyBBUyBcIkNvbW1lbnRcIicsXG4gICAgICBcIkZST01cIixcbiAgICAgIFwiU1lTSUJNLlNZU0NPTFVNTlNcIixcbiAgICAgIFwiV0hFUkUgVEJOQU1FID1cIixcbiAgICAgIHdyYXBTaW5nbGVRdW90ZSh0YWJsZU5hbWUpXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgICBpZiAoc2NoZW1hKSB7XG4gICAgICBzcWwgKz0gYCBBTkQgVEJDUkVBVE9SID0ke3dyYXBTaW5nbGVRdW90ZShzY2hlbWEpfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNxbCArPSBcIiBBTkQgVEJDUkVBVE9SID0gVVNFUlwiO1xuICAgIH1cbiAgICByZXR1cm4gYCR7c3FsfTtgO1xuICB9XG4gIHJlbmFtZVRhYmxlUXVlcnkoYmVmb3JlLCBhZnRlcikge1xuICAgIGNvbnN0IHF1ZXJ5ID0gXCJSRU5BTUUgVEFCTEUgPCU9IGJlZm9yZSAlPiBUTyA8JT0gYWZ0ZXIgJT47XCI7XG4gICAgcmV0dXJuIF8udGVtcGxhdGUocXVlcnksIHRoaXMuX3RlbXBsYXRlU2V0dGluZ3MpKHtcbiAgICAgIGJlZm9yZTogdGhpcy5xdW90ZVRhYmxlKGJlZm9yZSksXG4gICAgICBhZnRlcjogdGhpcy5xdW90ZVRhYmxlKGFmdGVyKVxuICAgIH0pO1xuICB9XG4gIHNob3dUYWJsZXNRdWVyeSgpIHtcbiAgICByZXR1cm4gYFNFTEVDVCBUQUJOQU1FIEFTIFwidGFibGVOYW1lXCIsIFRSSU0oVEFCU0NIRU1BKSBBUyBcInRhYmxlU2NoZW1hXCIgRlJPTSBTWVNDQVQuVEFCTEVTIFdIRVJFIFRBQlNDSEVNQSA9IFVTRVIgQU5EIFRZUEUgPSAnVCcgT1JERVIgQlkgVEFCU0NIRU1BLCBUQUJOQU1FYDtcbiAgfVxuICB0YWJsZUV4aXN0c1F1ZXJ5KHRhYmxlKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGFibGUudGFibGVOYW1lIHx8IHRhYmxlO1xuICAgIGNvbnN0IHNjaGVtYU5hbWUgPSB0YWJsZS5zY2hlbWEgfHwgdGhpcy5zZXF1ZWxpemUuY29uZmlnLnVzZXJuYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIGBTRUxFQ1QgbmFtZSBGUk9NIHN5c2libS5zeXN0YWJsZXMgV0hFUkUgTkFNRSA9ICR7d3JhcFNpbmdsZVF1b3RlKHRhYmxlTmFtZSl9IEFORCBDUkVBVE9SID0gJHt3cmFwU2luZ2xlUXVvdGUoc2NoZW1hTmFtZSl9YDtcbiAgfVxuICBkcm9wVGFibGVRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICBjb25zdCBxdWVyeSA9IFwiRFJPUCBUQUJMRSA8JT0gdGFibGUgJT5cIjtcbiAgICBjb25zdCB2YWx1ZXMgPSB7XG4gICAgICB0YWJsZTogdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSlcbiAgICB9O1xuICAgIHJldHVybiBgJHtfLnRlbXBsYXRlKHF1ZXJ5LCB0aGlzLl90ZW1wbGF0ZVNldHRpbmdzKSh2YWx1ZXMpLnRyaW0oKX07YDtcbiAgfVxuICBhZGRDb2x1bW5RdWVyeSh0YWJsZSwga2V5LCBkYXRhVHlwZSkge1xuICAgIGRhdGFUeXBlLmZpZWxkID0ga2V5O1xuICAgIGNvbnN0IHF1ZXJ5ID0gXCJBTFRFUiBUQUJMRSA8JT0gdGFibGUgJT4gQUREIDwlPSBhdHRyaWJ1dGUgJT47XCIsIGF0dHJpYnV0ZSA9IF8udGVtcGxhdGUoXCI8JT0ga2V5ICU+IDwlPSBkZWZpbml0aW9uICU+XCIsIHRoaXMuX3RlbXBsYXRlU2V0dGluZ3MpKHtcbiAgICAgIGtleTogdGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KSxcbiAgICAgIGRlZmluaXRpb246IHRoaXMuYXR0cmlidXRlVG9TUUwoZGF0YVR5cGUsIHtcbiAgICAgICAgY29udGV4dDogXCJhZGRDb2x1bW5cIlxuICAgICAgfSlcbiAgICB9KTtcbiAgICByZXR1cm4gXy50ZW1wbGF0ZShxdWVyeSwgdGhpcy5fdGVtcGxhdGVTZXR0aW5ncykoe1xuICAgICAgdGFibGU6IHRoaXMucXVvdGVUYWJsZSh0YWJsZSksXG4gICAgICBhdHRyaWJ1dGVcbiAgICB9KTtcbiAgfVxuICByZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBjb25zdCBxdWVyeSA9IFwiQUxURVIgVEFCTEUgPCU9IHRhYmxlTmFtZSAlPiBEUk9QIENPTFVNTiA8JT0gYXR0cmlidXRlTmFtZSAlPjtcIjtcbiAgICByZXR1cm4gXy50ZW1wbGF0ZShxdWVyeSwgdGhpcy5fdGVtcGxhdGVTZXR0aW5ncykoe1xuICAgICAgdGFibGVOYW1lOiB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIGF0dHJpYnV0ZU5hbWU6IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpXG4gICAgfSk7XG4gIH1cbiAgY2hhbmdlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgcXVlcnkgPSBcIkFMVEVSIFRBQkxFIDwlPSB0YWJsZU5hbWUgJT4gPCU9IHF1ZXJ5ICU+O1wiO1xuICAgIGNvbnN0IGF0dHJTdHJpbmcgPSBbXSwgY29uc3RyYWludFN0cmluZyA9IFtdO1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyVmFsdWUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgbGV0IGRlZnMgPSBbYXR0clZhbHVlXTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGF0dHJWYWx1ZSkpIHtcbiAgICAgICAgZGVmcyA9IGF0dHJWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gZGVmc1tpXTtcbiAgICAgICAgaWYgKGRlZmluaXRpb24ubWF0Y2goL1JFRkVSRU5DRVMvKSkge1xuICAgICAgICAgIGNvbnN0cmFpbnRTdHJpbmcucHVzaChfLnRlbXBsYXRlKFwiPCU9IGZrTmFtZSAlPiBGT1JFSUdOIEtFWSAoPCU9IGF0dHJOYW1lICU+KSA8JT0gZGVmaW5pdGlvbiAlPlwiLCB0aGlzLl90ZW1wbGF0ZVNldHRpbmdzKSh7XG4gICAgICAgICAgICBma05hbWU6IHRoaXMucXVvdGVJZGVudGlmaWVyKGAke2F0dHJpYnV0ZU5hbWV9X2ZvcmVpZ25faWR4YCksXG4gICAgICAgICAgICBhdHRyTmFtZTogdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSksXG4gICAgICAgICAgICBkZWZpbml0aW9uOiBkZWZpbml0aW9uLnJlcGxhY2UoLy4rPyg/PVJFRkVSRU5DRVMpLywgXCJcIilcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5zdGFydHNXaXRoKGRlZmluaXRpb24sIFwiRFJPUCBcIikpIHtcbiAgICAgICAgICBhdHRyU3RyaW5nLnB1c2goXy50ZW1wbGF0ZShcIjwlPSBhdHRyTmFtZSAlPiA8JT0gZGVmaW5pdGlvbiAlPlwiLCB0aGlzLl90ZW1wbGF0ZVNldHRpbmdzKSh7XG4gICAgICAgICAgICBhdHRyTmFtZTogdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSksXG4gICAgICAgICAgICBkZWZpbml0aW9uXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0dHJTdHJpbmcucHVzaChfLnRlbXBsYXRlKFwiPCU9IGF0dHJOYW1lICU+IFNFVCA8JT0gZGVmaW5pdGlvbiAlPlwiLCB0aGlzLl90ZW1wbGF0ZVNldHRpbmdzKSh7XG4gICAgICAgICAgICBhdHRyTmFtZTogdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSksXG4gICAgICAgICAgICBkZWZpbml0aW9uXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBmaW5hbFF1ZXJ5ID0gXCJcIjtcbiAgICBpZiAoYXR0clN0cmluZy5sZW5ndGgpIHtcbiAgICAgIGZpbmFsUXVlcnkgKz0gYEFMVEVSIENPTFVNTiAke2F0dHJTdHJpbmcuam9pbihcIiBBTFRFUiBDT0xVTU4gXCIpfWA7XG4gICAgICBmaW5hbFF1ZXJ5ICs9IGNvbnN0cmFpbnRTdHJpbmcubGVuZ3RoID8gXCIgXCIgOiBcIlwiO1xuICAgIH1cbiAgICBpZiAoY29uc3RyYWludFN0cmluZy5sZW5ndGgpIHtcbiAgICAgIGZpbmFsUXVlcnkgKz0gYEFERCBDT05TVFJBSU5UICR7Y29uc3RyYWludFN0cmluZy5qb2luKFwiIEFERCBDT05TVFJBSU5UIFwiKX1gO1xuICAgIH1cbiAgICByZXR1cm4gXy50ZW1wbGF0ZShxdWVyeSwgdGhpcy5fdGVtcGxhdGVTZXR0aW5ncykoe1xuICAgICAgdGFibGVOYW1lOiB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIHF1ZXJ5OiBmaW5hbFF1ZXJ5XG4gICAgfSk7XG4gIH1cbiAgcmVuYW1lQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyQmVmb3JlLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgcXVlcnkgPSBcIkFMVEVSIFRBQkxFIDwlPSB0YWJsZU5hbWUgJT4gUkVOQU1FIENPTFVNTiA8JT0gYmVmb3JlICU+IFRPIDwlPSBhZnRlciAlPjtcIiwgbmV3TmFtZSA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpWzBdO1xuICAgIHJldHVybiBfLnRlbXBsYXRlKHF1ZXJ5LCB0aGlzLl90ZW1wbGF0ZVNldHRpbmdzKSh7XG4gICAgICB0YWJsZU5hbWU6IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgYmVmb3JlOiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyQmVmb3JlKSxcbiAgICAgIGFmdGVyOiB0aGlzLnF1b3RlSWRlbnRpZmllcihuZXdOYW1lKVxuICAgIH0pO1xuICB9XG4gIGFkZENvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAob3B0aW9ucy5vblVwZGF0ZSAmJiBvcHRpb25zLm9uVXBkYXRlLnRvVXBwZXJDYXNlKCkgPT09IFwiQ0FTQ0FERVwiKSB7XG4gICAgICBkZWxldGUgb3B0aW9ucy5vblVwZGF0ZTtcbiAgICB9XG4gICAgY29uc3QgY29uc3RyYWludFNuaXBwZXQgPSB0aGlzLmdldENvbnN0cmFpbnRTbmlwcGV0KHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgaWYgKHR5cGVvZiB0YWJsZU5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRhYmxlTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVycyh0YWJsZU5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGBBTFRFUiBUQUJMRSAke3RhYmxlTmFtZX0gQUREICR7Y29uc3RyYWludFNuaXBwZXR9O2A7XG4gIH1cbiAgYnVsa0luc2VydFF1ZXJ5KHRhYmxlTmFtZSwgYXR0clZhbHVlSGFzaGVzLCBvcHRpb25zLCBhdHRyaWJ1dGVzKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwge307XG4gICAgbGV0IHF1ZXJ5ID0gXCJJTlNFUlQgSU5UTyA8JT0gdGFibGUgJT4gKDwlPSBhdHRyaWJ1dGVzICU+KTwlPSBvdXRwdXQgJT4gVkFMVUVTIDwlPSB0dXBsZXMgJT47XCI7XG4gICAgaWYgKG9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICBxdWVyeSA9IFwiU0VMRUNUICogRlJPTSBGSU5BTCBUQUJMRSggSU5TRVJUIElOVE8gPCU9IHRhYmxlICU+ICg8JT0gYXR0cmlidXRlcyAlPik8JT0gb3V0cHV0ICU+IFZBTFVFUyA8JT0gdHVwbGVzICU+KTtcIjtcbiAgICB9XG4gICAgY29uc3QgZW1wdHlRdWVyeSA9IFwiSU5TRVJUIElOVE8gPCU9IHRhYmxlICU+XCIsIHR1cGxlcyA9IFtdLCBhbGxBdHRyaWJ1dGVzID0gW10sIGFsbFF1ZXJpZXMgPSBbXTtcbiAgICBsZXQgb3V0cHV0RnJhZ21lbnQ7XG4gICAgY29uc3QgdmFsdWVzRm9yRW1wdHlRdWVyeSA9IFtdO1xuICAgIGlmIChvcHRpb25zLnJldHVybmluZykge1xuICAgICAgb3V0cHV0RnJhZ21lbnQgPSBcIlwiO1xuICAgIH1cbiAgICBfLmZvckVhY2goYXR0clZhbHVlSGFzaGVzLCAoYXR0clZhbHVlSGFzaCkgPT4ge1xuICAgICAgY29uc3QgZmllbGRzID0gT2JqZWN0LmtleXMoYXR0clZhbHVlSGFzaCk7XG4gICAgICBjb25zdCBmaXJzdEF0dHIgPSBhdHRyaWJ1dGVzW2ZpZWxkc1swXV07XG4gICAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMSAmJiBmaXJzdEF0dHIgJiYgZmlyc3RBdHRyLmF1dG9JbmNyZW1lbnQgJiYgYXR0clZhbHVlSGFzaFtmaWVsZHNbMF1dID09PSBudWxsKSB7XG4gICAgICAgIHZhbHVlc0ZvckVtcHR5UXVlcnkucHVzaChgKCR7dGhpcy5hdXRvR2VuVmFsdWUrK30pYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF8uZm9yT3duKGF0dHJWYWx1ZUhhc2gsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGlmIChhbGxBdHRyaWJ1dGVzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgJiYgYXR0cmlidXRlc1trZXldICYmIGF0dHJpYnV0ZXNba2V5XS5hdXRvSW5jcmVtZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGFsbEF0dHJpYnV0ZXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAodmFsdWVzRm9yRW1wdHlRdWVyeS5sZW5ndGggPiAwKSB7XG4gICAgICBhbGxRdWVyaWVzLnB1c2goYCR7ZW1wdHlRdWVyeX0gVkFMVUVTICR7dmFsdWVzRm9yRW1wdHlRdWVyeS5qb2luKFwiLFwiKX1gKTtcbiAgICB9XG4gICAgaWYgKGFsbEF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgXy5mb3JFYWNoKGF0dHJWYWx1ZUhhc2hlcywgKGF0dHJWYWx1ZUhhc2gpID0+IHtcbiAgICAgICAgdHVwbGVzLnB1c2goYCgke2FsbEF0dHJpYnV0ZXMubWFwKChrZXkpID0+IHRoaXMuZXNjYXBlKGF0dHJWYWx1ZUhhc2hba2V5XSksIHZvaWQgMCwgeyBjb250ZXh0OiBcIklOU0VSVFwiIH0pLmpvaW4oXCIsXCIpfSlgKTtcbiAgICAgIH0pO1xuICAgICAgYWxsUXVlcmllcy5wdXNoKHF1ZXJ5KTtcbiAgICB9XG4gICAgY29uc3QgcmVwbGFjZW1lbnRzID0ge1xuICAgICAgdGFibGU6IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgYXR0cmlidXRlczogYWxsQXR0cmlidXRlcy5tYXAoKGF0dHIpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpKS5qb2luKFwiLFwiKSxcbiAgICAgIHR1cGxlcyxcbiAgICAgIG91dHB1dDogb3V0cHV0RnJhZ21lbnRcbiAgICB9O1xuICAgIGNvbnN0IGdlbmVyYXRlZFF1ZXJ5ID0gXy50ZW1wbGF0ZShhbGxRdWVyaWVzLmpvaW4oXCI7XCIpLCB0aGlzLl90ZW1wbGF0ZVNldHRpbmdzKShyZXBsYWNlbWVudHMpO1xuICAgIHJldHVybiBnZW5lcmF0ZWRRdWVyeTtcbiAgfVxuICB1cGRhdGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJWYWx1ZUhhc2gsIHdoZXJlLCBvcHRpb25zLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3Qgc3FsID0gc3VwZXIudXBkYXRlUXVlcnkodGFibGVOYW1lLCBhdHRyVmFsdWVIYXNoLCB3aGVyZSwgb3B0aW9ucywgYXR0cmlidXRlcyk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgXy5kZWZhdWx0cyhvcHRpb25zLCB0aGlzLm9wdGlvbnMpO1xuICAgIGlmICghb3B0aW9ucy5saW1pdCkge1xuICAgICAgc3FsLnF1ZXJ5ID0gYFNFTEVDVCAqIEZST00gRklOQUwgVEFCTEUgKCR7c3FsLnF1ZXJ5fSk7YDtcbiAgICAgIHJldHVybiBzcWw7XG4gICAgfVxuICAgIGF0dHJWYWx1ZUhhc2ggPSBVdGlscy5yZW1vdmVOdWxsVmFsdWVzRnJvbUhhc2goYXR0clZhbHVlSGFzaCwgb3B0aW9ucy5vbWl0TnVsbCwgb3B0aW9ucyk7XG4gICAgY29uc3QgbW9kZWxBdHRyaWJ1dGVNYXAgPSB7fTtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBjb25zdCBiaW5kID0gW107XG4gICAgY29uc3QgYmluZFBhcmFtID0gb3B0aW9ucy5iaW5kUGFyYW0gfHwgdGhpcy5iaW5kUGFyYW0oYmluZCk7XG4gICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgIF8uZWFjaChhdHRyaWJ1dGVzLCAoYXR0cmlidXRlLCBrZXkpID0+IHtcbiAgICAgICAgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5maWVsZCkge1xuICAgICAgICAgIG1vZGVsQXR0cmlidXRlTWFwW2F0dHJpYnV0ZS5maWVsZF0gPSBhdHRyaWJ1dGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyVmFsdWVIYXNoKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGF0dHJWYWx1ZUhhc2hba2V5XTtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCB8fCBvcHRpb25zLmJpbmRQYXJhbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFsdWVzLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KX09JHt0aGlzLmVzY2FwZSh2YWx1ZSwgbW9kZWxBdHRyaWJ1dGVNYXAgJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSB8fCB2b2lkIDAsIHsgY29udGV4dDogXCJVUERBVEVcIiB9KX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGtleSl9PSR7dGhpcy5mb3JtYXQodmFsdWUsIG1vZGVsQXR0cmlidXRlTWFwICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gfHwgdm9pZCAwLCB7IGNvbnRleHQ6IFwiVVBEQVRFXCIgfSwgYmluZFBhcmFtKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGNvbnN0IHdoZXJlT3B0aW9ucyA9IF8uZGVmYXVsdHMoeyBiaW5kUGFyYW0gfSwgb3B0aW9ucyk7XG4gICAgcXVlcnkgPSBgVVBEQVRFIChTRUxFQ1QgKiBGUk9NICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9ICR7dGhpcy53aGVyZVF1ZXJ5KHdoZXJlLCB3aGVyZU9wdGlvbnMpfSBGRVRDSCBORVhUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9IFJPV1MgT05MWSkgU0VUICR7dmFsdWVzLmpvaW4oXCIsXCIpfWA7XG4gICAgcXVlcnkgPSBgU0VMRUNUICogRlJPTSBGSU5BTCBUQUJMRSAoJHtxdWVyeX0pO2A7XG4gICAgcmV0dXJuIHsgcXVlcnksIGJpbmQgfTtcbiAgfVxuICB1cHNlcnRRdWVyeSh0YWJsZU5hbWUsIGluc2VydFZhbHVlcywgdXBkYXRlVmFsdWVzLCB3aGVyZSwgbW9kZWwpIHtcbiAgICBjb25zdCB0YXJnZXRUYWJsZUFsaWFzID0gdGhpcy5xdW90ZVRhYmxlKGAke3RhYmxlTmFtZX1fdGFyZ2V0YCk7XG4gICAgY29uc3Qgc291cmNlVGFibGVBbGlhcyA9IHRoaXMucXVvdGVUYWJsZShgJHt0YWJsZU5hbWV9X3NvdXJjZWApO1xuICAgIGNvbnN0IHByaW1hcnlLZXlzQXR0cnMgPSBbXTtcbiAgICBjb25zdCBpZGVudGl0eUF0dHJzID0gW107XG4gICAgY29uc3QgdW5pcXVlQXR0cnMgPSBbXTtcbiAgICBjb25zdCB0YWJsZU5hbWVRdW90ZWQgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtb2RlbC5yYXdBdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAobW9kZWwucmF3QXR0cmlidXRlc1trZXldLnByaW1hcnlLZXkpIHtcbiAgICAgICAgcHJpbWFyeUtleXNBdHRycy5wdXNoKG1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS5maWVsZCB8fCBrZXkpO1xuICAgICAgfVxuICAgICAgaWYgKG1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS51bmlxdWUpIHtcbiAgICAgICAgdW5pcXVlQXR0cnMucHVzaChtb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0uZmllbGQgfHwga2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0uYXV0b0luY3JlbWVudCkge1xuICAgICAgICBpZGVudGl0eUF0dHJzLnB1c2gobW9kZWwucmF3QXR0cmlidXRlc1trZXldLmZpZWxkIHx8IGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgaW5kZXggb2YgbW9kZWwuX2luZGV4ZXMpIHtcbiAgICAgIGlmIChpbmRleC51bmlxdWUgJiYgaW5kZXguZmllbGRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgaW5kZXguZmllbGRzKSB7XG4gICAgICAgICAgY29uc3QgZmllbGROYW1lID0gdHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiID8gZmllbGQgOiBmaWVsZC5uYW1lIHx8IGZpZWxkLmF0dHJpYnV0ZTtcbiAgICAgICAgICBpZiAodW5pcXVlQXR0cnMuaW5kZXhPZihmaWVsZE5hbWUpID09PSAtMSAmJiBtb2RlbC5yYXdBdHRyaWJ1dGVzW2ZpZWxkTmFtZV0pIHtcbiAgICAgICAgICAgIHVuaXF1ZUF0dHJzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXBkYXRlS2V5cyA9IE9iamVjdC5rZXlzKHVwZGF0ZVZhbHVlcyk7XG4gICAgY29uc3QgaW5zZXJ0S2V5cyA9IE9iamVjdC5rZXlzKGluc2VydFZhbHVlcyk7XG4gICAgY29uc3QgaW5zZXJ0S2V5c1F1b3RlZCA9IGluc2VydEtleXMubWFwKChrZXkpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSkpLmpvaW4oXCIsIFwiKTtcbiAgICBjb25zdCBpbnNlcnRWYWx1ZXNFc2NhcGVkID0gaW5zZXJ0S2V5cy5tYXAoKGtleSkgPT4gdGhpcy5lc2NhcGUoaW5zZXJ0VmFsdWVzW2tleV0pKS5qb2luKFwiLCBcIik7XG4gICAgY29uc3Qgc291cmNlVGFibGVRdWVyeSA9IGBWQUxVRVMoJHtpbnNlcnRWYWx1ZXNFc2NhcGVkfSlgO1xuICAgIGxldCBqb2luQ29uZGl0aW9uO1xuICAgIGNvbnN0IGNsYXVzZXMgPSB3aGVyZVtPcC5vcl0uZmlsdGVyKChjbGF1c2UpID0+IHtcbiAgICAgIGxldCB2YWxpZCA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjbGF1c2UpIHtcbiAgICAgICAgaWYgKCFjbGF1c2Vba2V5XSkge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9KTtcbiAgICBjb25zdCBnZXRKb2luU25pcHBldCA9IChhcnJheSkgPT4ge1xuICAgICAgcmV0dXJuIGFycmF5Lm1hcCgoa2V5KSA9PiB7XG4gICAgICAgIGtleSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSk7XG4gICAgICAgIHJldHVybiBgJHt0YXJnZXRUYWJsZUFsaWFzfS4ke2tleX0gPSAke3NvdXJjZVRhYmxlQWxpYXN9LiR7a2V5fWA7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChjbGF1c2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJpbWFyeSBLZXkgb3IgVW5pcXVlIGtleSBzaG91bGQgYmUgcGFzc2VkIHRvIHVwc2VydCBxdWVyeVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY2xhdXNlcykge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY2xhdXNlc1trZXldKTtcbiAgICAgICAgaWYgKHByaW1hcnlLZXlzQXR0cnMuaW5kZXhPZihrZXlzWzBdKSAhPT0gLTEpIHtcbiAgICAgICAgICBqb2luQ29uZGl0aW9uID0gZ2V0Sm9pblNuaXBwZXQocHJpbWFyeUtleXNBdHRycykuam9pbihcIiBBTkQgXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWpvaW5Db25kaXRpb24pIHtcbiAgICAgICAgam9pbkNvbmRpdGlvbiA9IGdldEpvaW5TbmlwcGV0KHVuaXF1ZUF0dHJzKS5qb2luKFwiIEFORCBcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlcmVkVXBkYXRlQ2xhdXNlcyA9IHVwZGF0ZUtleXMuZmlsdGVyKChrZXkpID0+IHtcbiAgICAgIGlmIChpZGVudGl0eUF0dHJzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSkubWFwKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5lc2NhcGUodXBkYXRlVmFsdWVzW2tleV0pO1xuICAgICAga2V5ID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KTtcbiAgICAgIHJldHVybiBgJHt0YXJnZXRUYWJsZUFsaWFzfS4ke2tleX0gPSAke3ZhbHVlfWA7XG4gICAgfSkuam9pbihcIiwgXCIpO1xuICAgIGNvbnN0IHVwZGF0ZVNuaXBwZXQgPSBmaWx0ZXJlZFVwZGF0ZUNsYXVzZXMubGVuZ3RoID4gMCA/IGBXSEVOIE1BVENIRUQgVEhFTiBVUERBVEUgU0VUICR7ZmlsdGVyZWRVcGRhdGVDbGF1c2VzfWAgOiBcIlwiO1xuICAgIGNvbnN0IGluc2VydFNuaXBwZXQgPSBgKCR7aW5zZXJ0S2V5c1F1b3RlZH0pIFZBTFVFUygke2luc2VydFZhbHVlc0VzY2FwZWR9KWA7XG4gICAgbGV0IHF1ZXJ5ID0gYE1FUkdFIElOVE8gJHt0YWJsZU5hbWVRdW90ZWR9IEFTICR7dGFyZ2V0VGFibGVBbGlhc30gVVNJTkcgKCR7c291cmNlVGFibGVRdWVyeX0pIEFTICR7c291cmNlVGFibGVBbGlhc30oJHtpbnNlcnRLZXlzUXVvdGVkfSkgT04gJHtqb2luQ29uZGl0aW9ufWA7XG4gICAgcXVlcnkgKz0gYCAke3VwZGF0ZVNuaXBwZXR9IFdIRU4gTk9UIE1BVENIRUQgVEhFTiBJTlNFUlQgJHtpbnNlcnRTbmlwcGV0fTtgO1xuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuICB0cnVuY2F0ZVRhYmxlUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIGBUUlVOQ0FURSBUQUJMRSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSBJTU1FRElBVEVgO1xuICB9XG4gIGRlbGV0ZVF1ZXJ5KHRhYmxlTmFtZSwgd2hlcmUsIG9wdGlvbnMgPSB7fSwgbW9kZWwpIHtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIGNvbnN0IHF1ZXJ5ID0gXCJERUxFVEUgRlJPTSA8JT0gdGFibGUgJT48JT0gd2hlcmUgJT48JT0gbGltaXQgJT5cIjtcbiAgICB3aGVyZSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKHdoZXJlLCBudWxsLCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgbGV0IGxpbWl0ID0gXCJcIjtcbiAgICBpZiAob3B0aW9ucy5vZmZzZXQgPiAwKSB7XG4gICAgICBsaW1pdCA9IGAgT0ZGU0VUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5vZmZzZXQpfSBST1dTYDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGltaXQpIHtcbiAgICAgIGxpbWl0ICs9IGAgRkVUQ0ggTkVYVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpfSBST1dTIE9OTFlgO1xuICAgIH1cbiAgICBjb25zdCByZXBsYWNlbWVudHMgPSB7XG4gICAgICBsaW1pdCxcbiAgICAgIHRhYmxlLFxuICAgICAgd2hlcmVcbiAgICB9O1xuICAgIGlmIChyZXBsYWNlbWVudHMud2hlcmUpIHtcbiAgICAgIHJlcGxhY2VtZW50cy53aGVyZSA9IGAgV0hFUkUgJHtyZXBsYWNlbWVudHMud2hlcmV9YDtcbiAgICB9XG4gICAgcmV0dXJuIF8udGVtcGxhdGUocXVlcnksIHRoaXMuX3RlbXBsYXRlU2V0dGluZ3MpKHJlcGxhY2VtZW50cyk7XG4gIH1cbiAgc2hvd0luZGV4ZXNRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICBsZXQgc3FsID0gJ1NFTEVDVCBOQU1FIEFTIFwibmFtZVwiLCBUQk5BTUUgQVMgXCJ0YWJsZU5hbWVcIiwgVU5JUVVFUlVMRSBBUyBcImtleVR5cGVcIiwgQ09MTkFNRVMsIElOREVYVFlQRSBBUyBcInR5cGVcIiBGUk9NIFNZU0lCTS5TWVNJTkRFWEVTIFdIRVJFIFRCTkFNRSA9IDwlPSB0YWJsZU5hbWUgJT4nO1xuICAgIGxldCBzY2hlbWEgPSB2b2lkIDA7XG4gICAgaWYgKF8uaXNPYmplY3QodGFibGVOYW1lKSkge1xuICAgICAgc2NoZW1hID0gdGFibGVOYW1lLnNjaGVtYTtcbiAgICAgIHRhYmxlTmFtZSA9IHRhYmxlTmFtZS50YWJsZU5hbWU7XG4gICAgfVxuICAgIGlmIChzY2hlbWEpIHtcbiAgICAgIHNxbCA9IGAke3NxbH0gQU5EIFRCQ1JFQVRPUiA9IDwlPSBzY2hlbWFOYW1lICU+YDtcbiAgICB9XG4gICAgc3FsID0gYCR7c3FsfSBPUkRFUiBCWSBOQU1FO2A7XG4gICAgcmV0dXJuIF8udGVtcGxhdGUoc3FsLCB0aGlzLl90ZW1wbGF0ZVNldHRpbmdzKSh7XG4gICAgICB0YWJsZU5hbWU6IHdyYXBTaW5nbGVRdW90ZSh0YWJsZU5hbWUpLFxuICAgICAgc2NoZW1hTmFtZTogd3JhcFNpbmdsZVF1b3RlKHNjaGVtYSlcbiAgICB9KTtcbiAgfVxuICBzaG93Q29uc3RyYWludHNRdWVyeSh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lKSB7XG4gICAgbGV0IHNxbCA9IGBTRUxFQ1QgQ09OU1ROQU1FIEFTIFwiY29uc3RyYWludE5hbWVcIiwgVFJJTShUQUJTQ0hFTUEpIEFTIFwic2NoZW1hTmFtZVwiLCBUQUJOQU1FIEFTIFwidGFibGVOYW1lXCIgRlJPTSBTWVNDQVQuVEFCQ09OU1QgV0hFUkUgVEFCTkFNRSA9ICcke3RhYmxlTmFtZX0nYDtcbiAgICBpZiAoY29uc3RyYWludE5hbWUpIHtcbiAgICAgIHNxbCArPSBgIEFORCBDT05TVE5BTUUgTElLRSAnJSR7Y29uc3RyYWludE5hbWV9JSdgO1xuICAgIH1cbiAgICByZXR1cm4gYCR7c3FsfSBPUkRFUiBCWSBDT05TVE5BTUU7YDtcbiAgfVxuICByZW1vdmVJbmRleFF1ZXJ5KHRhYmxlTmFtZSwgaW5kZXhOYW1lT3JBdHRyaWJ1dGVzKSB7XG4gICAgY29uc3Qgc3FsID0gXCJEUk9QIElOREVYIDwlPSBpbmRleE5hbWUgJT5cIjtcbiAgICBsZXQgaW5kZXhOYW1lID0gaW5kZXhOYW1lT3JBdHRyaWJ1dGVzO1xuICAgIGlmICh0eXBlb2YgaW5kZXhOYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBpbmRleE5hbWUgPSBVdGlscy51bmRlcnNjb3JlKGAke3RhYmxlTmFtZX1fJHtpbmRleE5hbWVPckF0dHJpYnV0ZXMuam9pbihcIl9cIil9YCk7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlcyA9IHtcbiAgICAgIHRhYmxlTmFtZTogdGhpcy5xdW90ZUlkZW50aWZpZXJzKHRhYmxlTmFtZSksXG4gICAgICBpbmRleE5hbWU6IHRoaXMucXVvdGVJZGVudGlmaWVycyhpbmRleE5hbWUpXG4gICAgfTtcbiAgICByZXR1cm4gXy50ZW1wbGF0ZShzcWwsIHRoaXMuX3RlbXBsYXRlU2V0dGluZ3MpKHZhbHVlcyk7XG4gIH1cbiAgYXR0cmlidXRlVG9TUUwoYXR0cmlidXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFfLmlzUGxhaW5PYmplY3QoYXR0cmlidXRlKSkge1xuICAgICAgYXR0cmlidXRlID0ge1xuICAgICAgICB0eXBlOiBhdHRyaWJ1dGVcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCB0ZW1wbGF0ZTtcbiAgICBsZXQgY2hhbmdlTnVsbCA9IDE7XG4gICAgaWYgKGF0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0pIHtcbiAgICAgIGlmIChhdHRyaWJ1dGUudHlwZS52YWx1ZXMgJiYgIWF0dHJpYnV0ZS52YWx1ZXMpXG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZXMgPSBhdHRyaWJ1dGUudHlwZS52YWx1ZXM7XG4gICAgICB0ZW1wbGF0ZSA9IGF0dHJpYnV0ZS50eXBlLnRvU3FsKCk7XG4gICAgICB0ZW1wbGF0ZSArPSBgIENIRUNLICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZS5maWVsZCl9IElOKCR7YXR0cmlidXRlLnZhbHVlcy5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVzY2FwZSh2YWx1ZSk7XG4gICAgICB9KS5qb2luKFwiLCBcIil9KSlgO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZW1wbGF0ZSA9IGF0dHJpYnV0ZS50eXBlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCA9PT0gXCJjaGFuZ2VDb2x1bW5cIiAmJiBhdHRyaWJ1dGUudHlwZSkge1xuICAgICAgdGVtcGxhdGUgPSBgREFUQSBUWVBFICR7dGVtcGxhdGV9YDtcbiAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZS5hbGxvd051bGwgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZS5wcmltYXJ5S2V5ID09PSB0cnVlIHx8IGF0dHJpYnV0ZS51bmlxdWUpIHtcbiAgICAgIHRlbXBsYXRlICs9IFwiIE5PVCBOVUxMXCI7XG4gICAgICBjaGFuZ2VOdWxsID0gMDtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5hdXRvSW5jcmVtZW50KSB7XG4gICAgICBsZXQgaW5pdGlhbFZhbHVlID0gMTtcbiAgICAgIGlmIChhdHRyaWJ1dGUuaW5pdGlhbEF1dG9JbmNyZW1lbnQpIHtcbiAgICAgICAgaW5pdGlhbFZhbHVlID0gYXR0cmlidXRlLmluaXRpYWxBdXRvSW5jcmVtZW50O1xuICAgICAgfVxuICAgICAgdGVtcGxhdGUgKz0gYCBHRU5FUkFURUQgQlkgREVGQVVMVCBBUyBJREVOVElUWShTVEFSVCBXSVRIICR7aW5pdGlhbFZhbHVlfSwgSU5DUkVNRU5UIEJZIDEpYDtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS50eXBlICE9PSBcIlRFWFRcIiAmJiBhdHRyaWJ1dGUudHlwZS5fYmluYXJ5ICE9PSB0cnVlICYmIFV0aWxzLmRlZmF1bHRWYWx1ZVNjaGVtYWJsZShhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlKSkge1xuICAgICAgdGVtcGxhdGUgKz0gYCBERUZBVUxUICR7dGhpcy5lc2NhcGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSl9YDtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS51bmlxdWUgPT09IHRydWUpIHtcbiAgICAgIHRlbXBsYXRlICs9IFwiIFVOSVFVRVwiO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLnByaW1hcnlLZXkpIHtcbiAgICAgIHRlbXBsYXRlICs9IFwiIFBSSU1BUlkgS0VZXCI7XG4gICAgfVxuICAgIGlmICgoIW9wdGlvbnMgfHwgIW9wdGlvbnMud2l0aG91dEZvcmVpZ25LZXlDb25zdHJhaW50cykgJiYgYXR0cmlidXRlLnJlZmVyZW5jZXMpIHtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCA9PT0gXCJhZGRDb2x1bW5cIiAmJiBvcHRpb25zLmZvcmVpZ25LZXkpIHtcbiAgICAgICAgY29uc3QgYXR0ck5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLmZvcmVpZ25LZXkpO1xuICAgICAgICBjb25zdCBma05hbWUgPSBgJHtvcHRpb25zLnRhYmxlTmFtZX1fJHthdHRyTmFtZX1fZmlkeGA7XG4gICAgICAgIHRlbXBsYXRlICs9IGAsIENPTlNUUkFJTlQgJHtma05hbWV9IEZPUkVJR04gS0VZICgke2F0dHJOYW1lfSlgO1xuICAgICAgfVxuICAgICAgdGVtcGxhdGUgKz0gYCBSRUZFUkVOQ0VTICR7dGhpcy5xdW90ZVRhYmxlKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsKX1gO1xuICAgICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLmtleSkge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLmtleSl9KWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgICgke3RoaXMucXVvdGVJZGVudGlmaWVyKFwiaWRcIil9KWA7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlLm9uRGVsZXRlKSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgT04gREVMRVRFICR7YXR0cmlidXRlLm9uRGVsZXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGUub25VcGRhdGUgJiYgYXR0cmlidXRlLm9uVXBkYXRlLnRvVXBwZXJDYXNlKCkgIT0gXCJDQVNDQURFXCIpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCBPTiBVUERBVEUgJHthdHRyaWJ1dGUub25VcGRhdGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbnRleHQgPT09IFwiY2hhbmdlQ29sdW1uXCIgJiYgY2hhbmdlTnVsbCA9PT0gMSAmJiBhdHRyaWJ1dGUuYWxsb3dOdWxsICE9PSB2b2lkIDApIHtcbiAgICAgIHRlbXBsYXRlID0gW3RlbXBsYXRlXTtcbiAgICAgIGlmIChhdHRyaWJ1dGUuYWxsb3dOdWxsKSB7XG4gICAgICAgIHRlbXBsYXRlLnB1c2goXCJEUk9QIE5PVCBOVUxMXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcGxhdGUucHVzaChcIk5PVCBOVUxMXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLmNvbW1lbnQgJiYgdHlwZW9mIGF0dHJpYnV0ZS5jb21tZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBgIENPTU1FTlQgJHthdHRyaWJ1dGUuY29tbWVudH1gO1xuICAgIH1cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH1cbiAgYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fSwgZXhpc3RpbmdDb25zdHJhaW50cyA9IFtdO1xuICAgIGxldCBrZXksIGF0dHJpYnV0ZTtcbiAgICBmb3IgKGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMpIHtcbiAgICAgICAgaWYgKGV4aXN0aW5nQ29uc3RyYWludHMuaW5kZXhPZihhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbC50b1N0cmluZygpKSAhPT0gLTEpIHtcbiAgICAgICAgICBhdHRyaWJ1dGUub25EZWxldGUgPSBcIlwiO1xuICAgICAgICAgIGF0dHJpYnV0ZS5vblVwZGF0ZSA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoYXR0cmlidXRlLnVuaXF1ZSAmJiBhdHRyaWJ1dGUudW5pcXVlID09PSB0cnVlKSB7XG4gICAgICAgICAgYXR0cmlidXRlLm9uRGVsZXRlID0gXCJcIjtcbiAgICAgICAgICBhdHRyaWJ1dGUub25VcGRhdGUgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4aXN0aW5nQ29uc3RyYWludHMucHVzaChhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbC50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGtleSAmJiAhYXR0cmlidXRlLmZpZWxkICYmIHR5cGVvZiBhdHRyaWJ1dGUgPT09IFwib2JqZWN0XCIpXG4gICAgICAgIGF0dHJpYnV0ZS5maWVsZCA9IGtleTtcbiAgICAgIHJlc3VsdFthdHRyaWJ1dGUuZmllbGQgfHwga2V5XSA9IHRoaXMuYXR0cmlidXRlVG9TUUwoYXR0cmlidXRlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjcmVhdGVUcmlnZ2VyKCkge1xuICAgIHRocm93TWV0aG9kVW5kZWZpbmVkKFwiY3JlYXRlVHJpZ2dlclwiKTtcbiAgfVxuICBkcm9wVHJpZ2dlcigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZChcImRyb3BUcmlnZ2VyXCIpO1xuICB9XG4gIHJlbmFtZVRyaWdnZXIoKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoXCJyZW5hbWVUcmlnZ2VyXCIpO1xuICB9XG4gIGNyZWF0ZUZ1bmN0aW9uKCkge1xuICAgIHRocm93TWV0aG9kVW5kZWZpbmVkKFwiY3JlYXRlRnVuY3Rpb25cIik7XG4gIH1cbiAgZHJvcEZ1bmN0aW9uKCkge1xuICAgIHRocm93TWV0aG9kVW5kZWZpbmVkKFwiZHJvcEZ1bmN0aW9uXCIpO1xuICB9XG4gIHJlbmFtZUZ1bmN0aW9uKCkge1xuICAgIHRocm93TWV0aG9kVW5kZWZpbmVkKFwicmVuYW1lRnVuY3Rpb25cIik7XG4gIH1cbiAgX2dldEZvcmVpZ25LZXlzUXVlcnlTUUwoY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIGBTRUxFQ1QgUi5DT05TVE5BTUUgQVMgXCJjb25zdHJhaW50TmFtZVwiLCBUUklNKFIuVEFCU0NIRU1BKSBBUyBcImNvbnN0cmFpbnRTY2hlbWFcIiwgUi5UQUJOQU1FIEFTIFwidGFibGVOYW1lXCIsIFRSSU0oUi5UQUJTQ0hFTUEpIEFTIFwidGFibGVTY2hlbWFcIiwgTElTVEFHRyhDLkNPTE5BTUUsJywgJykgV0lUSElOIEdST1VQIChPUkRFUiBCWSBDLkNPTE5BTUUpIEFTIFwiY29sdW1uTmFtZVwiLCBUUklNKFIuUkVGVEFCU0NIRU1BKSBBUyBcInJlZmVyZW5jZWRUYWJsZVNjaGVtYVwiLCBSLlJFRlRBQk5BTUUgQVMgXCJyZWZlcmVuY2VkVGFibGVOYW1lXCIsIFRSSU0oUi5QS19DT0xOQU1FUykgQVMgXCJyZWZlcmVuY2VkQ29sdW1uTmFtZVwiIEZST00gU1lTQ0FULlJFRkVSRU5DRVMgUiwgU1lTQ0FULktFWUNPTFVTRSBDIFdIRVJFIFIuQ09OU1ROQU1FID0gQy5DT05TVE5BTUUgQU5EIFIuVEFCU0NIRU1BID0gQy5UQUJTQ0hFTUEgQU5EIFIuVEFCTkFNRSA9IEMuVEFCTkFNRSR7Y29uZGl0aW9ufSBHUk9VUCBCWSBSLlJFRlRBQlNDSEVNQSwgUi5SRUZUQUJOQU1FLCBSLlRBQlNDSEVNQSwgUi5UQUJOQU1FLCBSLkNPTlNUTkFNRSwgUi5QS19DT0xOQU1FU2A7XG4gIH1cbiAgZ2V0Rm9yZWlnbktleXNRdWVyeSh0YWJsZSwgc2NoZW1hTmFtZSkge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZTtcbiAgICBzY2hlbWFOYW1lID0gdGFibGUuc2NoZW1hIHx8IHNjaGVtYU5hbWU7XG4gICAgbGV0IHNxbCA9IFwiXCI7XG4gICAgaWYgKHRhYmxlTmFtZSkge1xuICAgICAgc3FsID0gYCBBTkQgUi5UQUJOQU1FID0gJHt3cmFwU2luZ2xlUXVvdGUodGFibGVOYW1lKX1gO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hTmFtZSkge1xuICAgICAgc3FsICs9IGAgQU5EIFIuVEFCU0NIRU1BID0gJHt3cmFwU2luZ2xlUXVvdGUoc2NoZW1hTmFtZSl9YDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2dldEZvcmVpZ25LZXlzUXVlcnlTUUwoc3FsKTtcbiAgfVxuICBnZXRGb3JlaWduS2V5UXVlcnkodGFibGUsIGNvbHVtbk5hbWUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZS50YWJsZU5hbWUgfHwgdGFibGU7XG4gICAgY29uc3Qgc2NoZW1hTmFtZSA9IHRhYmxlLnNjaGVtYTtcbiAgICBsZXQgc3FsID0gXCJcIjtcbiAgICBpZiAodGFibGVOYW1lKSB7XG4gICAgICBzcWwgPSBgIEFORCBSLlRBQk5BTUUgPSAke3dyYXBTaW5nbGVRdW90ZSh0YWJsZU5hbWUpfWA7XG4gICAgfVxuICAgIGlmIChzY2hlbWFOYW1lKSB7XG4gICAgICBzcWwgKz0gYCBBTkQgUi5UQUJTQ0hFTUEgPSAke3dyYXBTaW5nbGVRdW90ZShzY2hlbWFOYW1lKX1gO1xuICAgIH1cbiAgICBpZiAoY29sdW1uTmFtZSkge1xuICAgICAgc3FsICs9IGAgQU5EIEMuQ09MTkFNRSA9ICR7d3JhcFNpbmdsZVF1b3RlKGNvbHVtbk5hbWUpfWA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9nZXRGb3JlaWduS2V5c1F1ZXJ5U1FMKHNxbCk7XG4gIH1cbiAgZ2V0UHJpbWFyeUtleUNvbnN0cmFpbnRRdWVyeSh0YWJsZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHdyYXBTaW5nbGVRdW90ZSh0YWJsZS50YWJsZU5hbWUgfHwgdGFibGUpO1xuICAgIHJldHVybiBbXG4gICAgICAnU0VMRUNUIFRBQk5BTUUgQVMgXCJ0YWJsZU5hbWVcIiwnLFxuICAgICAgJ0NPTE5BTUUgQVMgXCJjb2x1bW5OYW1lXCIsJyxcbiAgICAgICdDT05TVE5BTUUgQVMgXCJjb25zdHJhaW50TmFtZVwiJyxcbiAgICAgIFwiRlJPTSBTWVNDQVQuS0VZQ09MVVNFIFdIRVJFIENPTlNUTkFNRSBMSUtFICdQS18lJ1wiLFxuICAgICAgYEFORCBDT0xOQU1FID0gJHt3cmFwU2luZ2xlUXVvdGUoYXR0cmlidXRlTmFtZSl9YCxcbiAgICAgIGBBTkQgVEFCTkFNRSA9ICR7dGFibGVOYW1lfTtgXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgfVxuICBkcm9wRm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZSwgZm9yZWlnbktleSkge1xuICAgIHJldHVybiBfLnRlbXBsYXRlKFwiQUxURVIgVEFCTEUgPCU9IHRhYmxlICU+IERST1AgPCU9IGtleSAlPlwiLCB0aGlzLl90ZW1wbGF0ZVNldHRpbmdzKSh7XG4gICAgICB0YWJsZTogdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBrZXk6IHRoaXMucXVvdGVJZGVudGlmaWVyKGZvcmVpZ25LZXkpXG4gICAgfSk7XG4gIH1cbiAgZHJvcENvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lKSB7XG4gICAgY29uc3Qgc3FsID0gXCJBTFRFUiBUQUJMRSA8JT0gdGFibGUgJT4gRFJPUCBDT05TVFJBSU5UIDwlPSBjb25zdHJhaW50ICU+O1wiO1xuICAgIHJldHVybiBfLnRlbXBsYXRlKHNxbCwgdGhpcy5fdGVtcGxhdGVTZXR0aW5ncykoe1xuICAgICAgdGFibGU6IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgY29uc3RyYWludDogdGhpcy5xdW90ZUlkZW50aWZpZXIoY29uc3RyYWludE5hbWUpXG4gICAgfSk7XG4gIH1cbiAgc2V0QXV0b2NvbW1pdFF1ZXJ5KCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIHNldElzb2xhdGlvbkxldmVsUXVlcnkoKSB7XG4gIH1cbiAgZ2VuZXJhdGVUcmFuc2FjdGlvbklkKCkge1xuICAgIHJldHVybiByYW5kb21CeXRlcygxMCkudG9TdHJpbmcoXCJoZXhcIik7XG4gIH1cbiAgc3RhcnRUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgcmV0dXJuIGBTQVZFIFRSQU5TQUNUSU9OICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodHJhbnNhY3Rpb24ubmFtZSl9O2A7XG4gICAgfVxuICAgIHJldHVybiBcIkJFR0lOIFRSQU5TQUNUSU9OO1wiO1xuICB9XG4gIGNvbW1pdFRyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBcIkNPTU1JVCBUUkFOU0FDVElPTjtcIjtcbiAgfVxuICByb2xsYmFja1RyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICByZXR1cm4gYFJPTExCQUNLIFRSQU5TQUNUSU9OICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodHJhbnNhY3Rpb24ubmFtZSl9O2A7XG4gICAgfVxuICAgIHJldHVybiBcIlJPTExCQUNLIFRSQU5TQUNUSU9OO1wiO1xuICB9XG4gIGFkZExpbWl0QW5kT2Zmc2V0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBvZmZzZXQgPSBvcHRpb25zLm9mZnNldCB8fCAwO1xuICAgIGxldCBmcmFnbWVudCA9IFwiXCI7XG4gICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgIGZyYWdtZW50ICs9IGAgT0ZGU0VUICR7dGhpcy5lc2NhcGUob2Zmc2V0KX0gUk9XU2A7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxpbWl0KSB7XG4gICAgICBmcmFnbWVudCArPSBgIEZFVENIIE5FWFQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX0gUk9XUyBPTkxZYDtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9XG4gIGJvb2xlYW5WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA/IDEgOiAwO1xuICB9XG4gIGFkZFVuaXF1ZUZpZWxkcyhkYXRhVmFsdWVzLCByYXdBdHRyaWJ1dGVzLCB1bmlxbm8pIHtcbiAgICB1bmlxbm8gPSB1bmlxbm8gPT09IHZvaWQgMCA/IDEgOiB1bmlxbm87XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3QXR0cmlidXRlcykge1xuICAgICAgaWYgKHJhd0F0dHJpYnV0ZXNba2V5XS51bmlxdWUgJiYgZGF0YVZhbHVlc1trZXldID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHJhd0F0dHJpYnV0ZXNba2V5XS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkRBVEUpIHtcbiAgICAgICAgICBkYXRhVmFsdWVzW2tleV0gPSBVdGlscy5ub3coXCJkYjJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAocmF3QXR0cmlidXRlc1trZXldLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuU1RSSU5HKSB7XG4gICAgICAgICAgZGF0YVZhbHVlc1trZXldID0gYHVuaXF1ZSR7dW5pcW5vKyt9YDtcbiAgICAgICAgfSBlbHNlIGlmIChyYXdBdHRyaWJ1dGVzW2tleV0udHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5JTlRFR0VSKSB7XG4gICAgICAgICAgZGF0YVZhbHVlc1trZXldID0gdW5pcW5vKys7XG4gICAgICAgIH0gZWxzZSBpZiAocmF3QXR0cmlidXRlc1trZXldLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQk9PTEVBTikge1xuICAgICAgICAgIGRhdGFWYWx1ZXNba2V5XSA9IG5ldyBEYXRhVHlwZXMuQk9PTEVBTihmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuaXFubztcbiAgfVxuICBxdW90ZUlkZW50aWZpZXIoaWRlbnRpZmllciwgZm9yY2UpIHtcbiAgICByZXR1cm4gVXRpbHMuYWRkVGlja3MoVXRpbHMucmVtb3ZlVGlja3MoaWRlbnRpZmllciwgJ1wiJyksICdcIicpO1xuICB9XG59XG5mdW5jdGlvbiB3cmFwU2luZ2xlUXVvdGUoaWRlbnRpZmllcikge1xuICBpZiAoaWRlbnRpZmllcikge1xuICAgIHJldHVybiBgJyR7aWRlbnRpZmllcn0nYDtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cbm1vZHVsZS5leHBvcnRzID0gRGIyUXVlcnlHZW5lcmF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS1nZW5lcmF0b3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/db2/query-generator.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/db2/query-interface.js":
/*!*********************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/db2/query-interface.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst Op = __webpack_require__(/*! ../../operators */ \"(action-browser)/../node_modules/sequelize/lib/operators.js\");\nconst { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(action-browser)/../node_modules/sequelize/lib/query-types.js\");\nclass Db2QueryInterface extends QueryInterface {\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.username.toUpperCase());\n    return this.sequelize.query(query, queryOptions);\n  }\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    const model = options.model;\n    const wheres = [];\n    const attributes = Object.keys(insertValues);\n    let indexes = [];\n    let indexFields;\n    options = _.clone(options);\n    if (!Utils.isWhereEmpty(where)) {\n      wheres.push(where);\n    }\n    indexes = _.map(model.uniqueKeys, (value) => {\n      return value.fields;\n    });\n    model._indexes.forEach((value) => {\n      if (value.unique) {\n        indexFields = value.fields.map((field) => {\n          if (_.isPlainObject(field)) {\n            return field.attribute;\n          }\n          return field;\n        });\n        indexes.push(indexFields);\n      }\n    });\n    for (const index of indexes) {\n      if (_.intersection(attributes, index).length === index.length) {\n        where = {};\n        for (const field of index) {\n          where[field] = insertValues[field];\n        }\n        wheres.push(where);\n      }\n    }\n    where = { [Op.or]: wheres };\n    options.type = QueryTypes.UPSERT;\n    options.raw = true;\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    const result = await this.sequelize.query(sql, options);\n    return [result, void 0];\n  }\n  async createTable(tableName, attributes, options, model) {\n    let sql = \"\";\n    options = __spreadValues({}, options);\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, (uniqueKey) => {\n        if (uniqueKey.customIndex === void 0) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n    attributes = _.mapValues(attributes, (attribute) => this.sequelize.normalizeAttribute(attribute));\n    if (options.indexes) {\n      options.indexes.forEach((fields) => {\n        const fieldArr = fields.fields;\n        if (fieldArr.length === 1) {\n          fieldArr.forEach((field) => {\n            for (const property in attributes) {\n              if (field === attributes[property].field) {\n                attributes[property].unique = true;\n              }\n            }\n          });\n        }\n      });\n    }\n    if (options.alter) {\n      if (options.indexes) {\n        options.indexes.forEach((fields) => {\n          const fieldArr = fields.fields;\n          if (fieldArr.length === 1) {\n            fieldArr.forEach((field) => {\n              for (const property in attributes) {\n                if (field === attributes[property].field && attributes[property].unique) {\n                  attributes[property].unique = false;\n                }\n              }\n            });\n          }\n        });\n      }\n    }\n    if (!tableName.schema && (options.schema || !!model && model._schema)) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n    attributes = this.queryGenerator.attributesToSQL(attributes, { table: tableName, context: \"createTable\", withoutForeignKeyConstraints: options.withoutForeignKeyConstraints });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n}\nexports.Db2QueryInterface = Db2QueryInterface;\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvcXVlcnktaW50ZXJmYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMxQixjQUFjLG1CQUFPLENBQUMsNEVBQWE7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLG9GQUFpQjtBQUNwQyxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsd0hBQTZCO0FBQ2hFLG1CQUFtQixtQkFBTyxDQUFDLHdGQUFtQjtBQUM5QztBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsbUVBQW1FLDhHQUE4RztBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvcXVlcnktaW50ZXJmYWNlLmpzPzAzNDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5jb25zdCBPcCA9IHJlcXVpcmUoXCIuLi8uLi9vcGVyYXRvcnNcIik7XG5jb25zdCB7IFF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnktaW50ZXJmYWNlXCIpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9xdWVyeS10eXBlc1wiKTtcbmNsYXNzIERiMlF1ZXJ5SW50ZXJmYWNlIGV4dGVuZHMgUXVlcnlJbnRlcmZhY2Uge1xuICBhc3luYyBnZXRGb3JlaWduS2V5UmVmZXJlbmNlc0ZvclRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHF1ZXJ5T3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICB0eXBlOiBRdWVyeVR5cGVzLkZPUkVJR05LRVlTXG4gICAgfSk7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmdldEZvcmVpZ25LZXlzUXVlcnkodGFibGVOYW1lLCB0aGlzLnNlcXVlbGl6ZS5jb25maWcudXNlcm5hbWUudG9VcHBlckNhc2UoKSk7XG4gICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHF1ZXJ5LCBxdWVyeU9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIHVwc2VydCh0YWJsZU5hbWUsIGluc2VydFZhbHVlcywgdXBkYXRlVmFsdWVzLCB3aGVyZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyk7XG4gICAgY29uc3QgbW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgIGNvbnN0IHdoZXJlcyA9IFtdO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhpbnNlcnRWYWx1ZXMpO1xuICAgIGxldCBpbmRleGVzID0gW107XG4gICAgbGV0IGluZGV4RmllbGRzO1xuICAgIG9wdGlvbnMgPSBfLmNsb25lKG9wdGlvbnMpO1xuICAgIGlmICghVXRpbHMuaXNXaGVyZUVtcHR5KHdoZXJlKSkge1xuICAgICAgd2hlcmVzLnB1c2god2hlcmUpO1xuICAgIH1cbiAgICBpbmRleGVzID0gXy5tYXAobW9kZWwudW5pcXVlS2V5cywgKHZhbHVlKSA9PiB7XG4gICAgICByZXR1cm4gdmFsdWUuZmllbGRzO1xuICAgIH0pO1xuICAgIG1vZGVsLl9pbmRleGVzLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICBpZiAodmFsdWUudW5pcXVlKSB7XG4gICAgICAgIGluZGV4RmllbGRzID0gdmFsdWUuZmllbGRzLm1hcCgoZmllbGQpID0+IHtcbiAgICAgICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KGZpZWxkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkLmF0dHJpYnV0ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZpZWxkO1xuICAgICAgICB9KTtcbiAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4RmllbGRzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4ZXMpIHtcbiAgICAgIGlmIChfLmludGVyc2VjdGlvbihhdHRyaWJ1dGVzLCBpbmRleCkubGVuZ3RoID09PSBpbmRleC5sZW5ndGgpIHtcbiAgICAgICAgd2hlcmUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBpbmRleCkge1xuICAgICAgICAgIHdoZXJlW2ZpZWxkXSA9IGluc2VydFZhbHVlc1tmaWVsZF07XG4gICAgICAgIH1cbiAgICAgICAgd2hlcmVzLnB1c2god2hlcmUpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGVyZSA9IHsgW09wLm9yXTogd2hlcmVzIH07XG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5VUFNFUlQ7XG4gICAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IudXBzZXJ0UXVlcnkodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIHVwZGF0ZVZhbHVlcywgd2hlcmUsIG1vZGVsLCBvcHRpb25zKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgIHJldHVybiBbcmVzdWx0LCB2b2lkIDBdO1xuICB9XG4gIGFzeW5jIGNyZWF0ZVRhYmxlKHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucywgbW9kZWwpIHtcbiAgICBsZXQgc3FsID0gXCJcIjtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudW5pcXVlS2V5cykge1xuICAgICAgXy5mb3JPd24ob3B0aW9ucy51bmlxdWVLZXlzLCAodW5pcXVlS2V5KSA9PiB7XG4gICAgICAgIGlmICh1bmlxdWVLZXkuY3VzdG9tSW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgICAgIHVuaXF1ZUtleS5jdXN0b21JbmRleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIG9wdGlvbnMudW5pcXVlS2V5cyA9IG9wdGlvbnMudW5pcXVlS2V5cyB8fCBtb2RlbC51bmlxdWVLZXlzO1xuICAgIH1cbiAgICBhdHRyaWJ1dGVzID0gXy5tYXBWYWx1ZXMoYXR0cmlidXRlcywgKGF0dHJpYnV0ZSkgPT4gdGhpcy5zZXF1ZWxpemUubm9ybWFsaXplQXR0cmlidXRlKGF0dHJpYnV0ZSkpO1xuICAgIGlmIChvcHRpb25zLmluZGV4ZXMpIHtcbiAgICAgIG9wdGlvbnMuaW5kZXhlcy5mb3JFYWNoKChmaWVsZHMpID0+IHtcbiAgICAgICAgY29uc3QgZmllbGRBcnIgPSBmaWVsZHMuZmllbGRzO1xuICAgICAgICBpZiAoZmllbGRBcnIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgZmllbGRBcnIuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICBpZiAoZmllbGQgPT09IGF0dHJpYnV0ZXNbcHJvcGVydHldLmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlc1twcm9wZXJ0eV0udW5pcXVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYWx0ZXIpIHtcbiAgICAgIGlmIChvcHRpb25zLmluZGV4ZXMpIHtcbiAgICAgICAgb3B0aW9ucy5pbmRleGVzLmZvckVhY2goKGZpZWxkcykgPT4ge1xuICAgICAgICAgIGNvbnN0IGZpZWxkQXJyID0gZmllbGRzLmZpZWxkcztcbiAgICAgICAgICBpZiAoZmllbGRBcnIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBmaWVsZEFyci5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQgPT09IGF0dHJpYnV0ZXNbcHJvcGVydHldLmZpZWxkICYmIGF0dHJpYnV0ZXNbcHJvcGVydHldLnVuaXF1ZSkge1xuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1twcm9wZXJ0eV0udW5pcXVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRhYmxlTmFtZS5zY2hlbWEgJiYgKG9wdGlvbnMuc2NoZW1hIHx8ICEhbW9kZWwgJiYgbW9kZWwuX3NjaGVtYSkpIHtcbiAgICAgIHRhYmxlTmFtZSA9IHRoaXMucXVlcnlHZW5lcmF0b3IuYWRkU2NoZW1hKHtcbiAgICAgICAgdGFibGVOYW1lLFxuICAgICAgICBfc2NoZW1hOiAhIW1vZGVsICYmIG1vZGVsLl9zY2hlbWEgfHwgb3B0aW9ucy5zY2hlbWFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhdHRyaWJ1dGVzID0gdGhpcy5xdWVyeUdlbmVyYXRvci5hdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcywgeyB0YWJsZTogdGFibGVOYW1lLCBjb250ZXh0OiBcImNyZWF0ZVRhYmxlXCIsIHdpdGhvdXRGb3JlaWduS2V5Q29uc3RyYWludHM6IG9wdGlvbnMud2l0aG91dEZvcmVpZ25LZXlDb25zdHJhaW50cyB9KTtcbiAgICBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxufVxuZXhwb3J0cy5EYjJRdWVyeUludGVyZmFjZSA9IERiMlF1ZXJ5SW50ZXJmYWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnktaW50ZXJmYWNlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/db2/query-interface.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/db2/query.js":
/*!***********************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/db2/query.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst util = __webpack_require__(/*! util */ \"util\");\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(action-browser)/../node_modules/sequelize/lib/dialects/parserStore.js\")(\"db2\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(action-browser)/../node_modules/sequelize/lib/utils/logger.js\");\nconst moment = __webpack_require__(/*! moment */ \"(action-browser)/../node_modules/moment/moment.js\");\nconst debug = logger.debugContext(\"sql:db2\");\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return \"id\";\n  }\n  getSQLTypeFromJsType(value) {\n    if (Buffer.isBuffer(value)) {\n      return { ParamType: \"INPUT\", DataType: \"BLOB\", Data: value };\n    }\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    return value;\n  }\n  async _run(connection, sql, parameters) {\n    this.sql = sql;\n    const benchmark = this.sequelize.options.benchmark || this.options.benchmark;\n    let queryBegin;\n    if (benchmark) {\n      queryBegin = Date.now();\n    } else {\n      this.sequelize.log(`Executing (${this.connection.uuid || \"default\"}): ${this.sql}`, this.options);\n    }\n    const errStack = new Error().stack;\n    return new Promise((resolve, reject) => {\n      if (_.startsWith(this.sql, \"BEGIN TRANSACTION\")) {\n        connection.beginTransaction((err) => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          } else {\n            resolve(this.formatResults());\n          }\n        });\n      } else if (_.startsWith(this.sql, \"COMMIT TRANSACTION\")) {\n        connection.commitTransaction((err) => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          } else {\n            resolve(this.formatResults());\n          }\n        });\n      } else if (_.startsWith(this.sql, \"ROLLBACK TRANSACTION\")) {\n        connection.rollbackTransaction((err) => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          } else {\n            resolve(this.formatResults());\n          }\n        });\n      } else if (_.startsWith(this.sql, \"SAVE TRANSACTION\")) {\n        connection.commitTransaction((err) => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          } else {\n            connection.beginTransaction((err2) => {\n              if (err2) {\n                reject(this.formatError(err2, errStack));\n              } else {\n                resolve(this.formatResults());\n              }\n            });\n          }\n        }, this.options.transaction.name);\n      } else {\n        const params = [];\n        if (parameters) {\n          _.forOwn(parameters, (value, key) => {\n            const param = this.getSQLTypeFromJsType(value, key);\n            params.push(param);\n          });\n        }\n        const SQL = this.sql.toUpperCase();\n        let newSql = this.sql;\n        if ((this.isSelectQuery() || _.startsWith(SQL, \"SELECT \")) && SQL.indexOf(\" FROM \", 8) === -1) {\n          if (this.sql.charAt(this.sql.length - 1) === \";\") {\n            newSql = this.sql.slice(0, this.sql.length - 1);\n          }\n          newSql += \" FROM SYSIBM.SYSDUMMY1;\";\n        }\n        connection.prepare(newSql, (err, stmt) => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          }\n          stmt.execute(params, (err2, result, outparams) => {\n            debug(`executed(${this.connection.uuid || \"default\"}):${newSql} ${parameters ? util.inspect(parameters, { compact: true, breakLength: Infinity }) : \"\"}`);\n            if (benchmark) {\n              this.sequelize.log(`Executed (${this.connection.uuid || \"default\"}): ${newSql} ${parameters ? util.inspect(parameters, { compact: true, breakLength: Infinity }) : \"\"}`, Date.now() - queryBegin, this.options);\n            }\n            if (err2 && err2.message) {\n              err2 = this.filterSQLError(err2, this.sql, connection);\n              if (err2 === null) {\n                stmt.closeSync();\n                resolve(this.formatResults([], 0));\n              }\n            }\n            if (err2) {\n              err2.sql = sql;\n              stmt.closeSync();\n              reject(this.formatError(err2, errStack, connection, parameters));\n            } else {\n              let data = [];\n              let metadata = [];\n              let affectedRows = 0;\n              if (typeof result === \"object\") {\n                if (_.startsWith(this.sql, \"DELETE FROM \")) {\n                  affectedRows = result.getAffectedRowsSync();\n                } else {\n                  data = result.fetchAllSync();\n                  metadata = result.getColumnMetadataSync();\n                }\n                result.closeSync();\n              }\n              stmt.closeSync();\n              const datalen = data.length;\n              if (datalen > 0) {\n                const coltypes = {};\n                for (let i = 0; i < metadata.length; i++) {\n                  coltypes[metadata[i].SQL_DESC_NAME] = metadata[i].SQL_DESC_TYPE_NAME;\n                }\n                for (let i = 0; i < datalen; i++) {\n                  for (const column in data[i]) {\n                    const parse = parserStore.get(coltypes[column]);\n                    const value = data[i][column];\n                    if (value !== null) {\n                      if (parse) {\n                        data[i][column] = parse(value);\n                      } else if (coltypes[column] === \"TIMESTAMP\") {\n                        data[i][column] = new Date(moment.utc(value));\n                      } else if (coltypes[column] === \"BLOB\") {\n                        data[i][column] = new Buffer.from(value);\n                      } else if (coltypes[column].indexOf(\"FOR BIT DATA\") > 0) {\n                        data[i][column] = new Buffer.from(value, \"hex\");\n                      }\n                    }\n                  }\n                }\n                if (outparams && outparams.length) {\n                  data.unshift(outparams);\n                }\n                resolve(this.formatResults(data, datalen, metadata, connection));\n              } else {\n                resolve(this.formatResults(data, affectedRows));\n              }\n            }\n          });\n        });\n      }\n    });\n  }\n  async run(sql, parameters) {\n    return await this._run(this.connection, sql, parameters);\n  }\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam = {};\n    const replacementFunc = (match, key, values2) => {\n      if (values2[key] !== void 0) {\n        bindParam[key] = values2[key];\n        return \"?\";\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    if (Array.isArray(values) && typeof values[0] === \"object\") {\n      bindParam = values;\n    }\n    return [sql, bindParam];\n  }\n  filterSQLError(err, sql, connection) {\n    if (err.message.search(\"SQL0204N\") != -1 && _.startsWith(sql, \"DROP \")) {\n      err = null;\n    } else if (err.message.search(\"SQL0443N\") != -1) {\n      if (this.isDropSchemaQuery()) {\n        connection.querySync(\"DROP TABLE ERRORSCHEMA.ERRORTABLE;\");\n        connection.querySync(this.sql);\n      }\n      err = null;\n    } else if (err.message.search(\"SQL0601N\") != -1) {\n      const match = err.message.match(/SQL0601N {2}The name of the object to be created is identical to the existing name \"(.*)\" of type \"(.*)\"./);\n      if (match && match.length > 1 && match[2] === \"TABLE\") {\n        let table;\n        const mtarray = match[1].split(\".\");\n        if (mtarray[1]) {\n          table = `\"${mtarray[0]}\".\"${mtarray[1]}\"`;\n        } else {\n          table = `\"${mtarray[0]}\"`;\n        }\n        if (connection.dropTable !== false) {\n          connection.querySync(`DROP TABLE ${table}`);\n          err = connection.querySync(sql);\n        } else {\n          err = null;\n        }\n      } else {\n        err = null;\n      }\n    } else if (err.message.search(\"SQL0911N\") != -1) {\n      if (err.message.search('Reason code \"2\"') != -1) {\n        err = null;\n      }\n    } else if (err.message.search(\"SQL0605W\") != -1) {\n      err = null;\n    } else if (err.message.search(\"SQL0668N\") != -1 && _.startsWith(sql, \"ALTER TABLE \")) {\n      connection.querySync(`CALL SYSPROC.ADMIN_CMD('REORG TABLE ${sql.substring(12).split(\" \")[0]}')`);\n      err = connection.querySync(sql);\n    }\n    if (err && err.length === 0) {\n      err = null;\n    }\n    return err;\n  }\n  formatResults(data, rowCount, metadata, conn) {\n    let result = this.instance;\n    if (this.isInsertQuery(data, metadata)) {\n      this.handleInsertQuery(data, metadata);\n      if (!this.instance) {\n        if (this.options.plain) {\n          const record = data[0];\n          result = record[Object.keys(record)[0]];\n        } else {\n          result = data;\n        }\n      }\n    }\n    if (this.isShowTablesQuery()) {\n      result = data;\n    } else if (this.isDescribeQuery()) {\n      result = {};\n      for (const _result of data) {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", \"\").replace(\"')\", \"\").replace(/'/g, \"\");\n        }\n        result[_result.Name] = {\n          type: _result.Type.toUpperCase(),\n          allowNull: _result.IsNull === \"Y\" ? true : false,\n          defaultValue: _result.Default,\n          primaryKey: _result.KeySeq > 0,\n          autoIncrement: _result.IsIdentity === \"Y\" ? true : false,\n          comment: _result.Comment\n        };\n      }\n    } else if (this.isShowIndexesQuery()) {\n      result = this.handleShowIndexesQuery(data);\n    } else if (this.isSelectQuery()) {\n      result = this.handleSelectQuery(data);\n    } else if (this.isUpsertQuery()) {\n      result = data;\n    } else if (this.isDropSchemaQuery()) {\n      result = data[0];\n      if (conn) {\n        const query = \"DROP TABLE ERRORSCHEMA.ERRORTABLE\";\n        conn.querySync(query);\n      }\n    } else if (this.isCallQuery()) {\n      result = data;\n    } else if (this.isBulkUpdateQuery()) {\n      result = data.length;\n    } else if (this.isBulkDeleteQuery()) {\n      result = rowCount;\n    } else if (this.isVersionQuery()) {\n      result = data[0].VERSION;\n    } else if (this.isForeignKeysQuery()) {\n      result = data;\n    } else if (this.isInsertQuery() || this.isUpdateQuery()) {\n      result = [result, rowCount];\n    } else if (this.isShowConstraintsQuery()) {\n      result = this.handleShowConstraintsQuery(data);\n    } else if (this.isRawQuery()) {\n      result = [data, metadata];\n    } else {\n      result = data;\n    }\n    return result;\n  }\n  handleShowTablesQuery(results) {\n    return results.map((resultSet) => {\n      return {\n        tableName: resultSet.TABLE_NAME,\n        schema: resultSet.TABLE_SCHEMA\n      };\n    });\n  }\n  handleShowConstraintsQuery(data) {\n    return _.remove(data, (constraint) => {\n      return !_.startsWith(constraint.constraintName, \"SQL\");\n    });\n  }\n  formatError(err, errStack, conn, parameters) {\n    let match;\n    if (!(err && err.message)) {\n      err[\"message\"] = \"No error message found.\";\n    }\n    match = err.message.match(/SQL0803N {2}One or more values in the INSERT statement, UPDATE statement, or foreign key update caused by a DELETE statement are not valid because the primary key, unique constraint or unique index identified by \"(\\d)+\" constrains table \"(.*)\\.(.*)\" from having duplicate values for the index key./);\n    if (match && match.length > 0) {\n      let uniqueIndexName = \"\";\n      let uniqueKey = \"\";\n      const fields = {};\n      let message = err.message;\n      const query = `SELECT INDNAME FROM SYSCAT.INDEXES  WHERE IID = ${match[1]} AND TABSCHEMA = '${match[2]}' AND TABNAME = '${match[3]}'`;\n      if (!!conn && match.length > 3) {\n        uniqueIndexName = conn.querySync(query);\n        uniqueIndexName = uniqueIndexName[0][\"INDNAME\"];\n      }\n      if (this.model && !!uniqueIndexName) {\n        uniqueKey = this.model.uniqueKeys[uniqueIndexName];\n      }\n      if (!uniqueKey && this.options.fields) {\n        uniqueKey = this.options.fields[match[1] - 1];\n      }\n      if (uniqueKey) {\n        if (this.options.where && this.options.where[uniqueKey.column] !== void 0) {\n          fields[uniqueKey.column] = this.options.where[uniqueKey.column];\n        } else if (this.options.instance && this.options.instance.dataValues && this.options.instance.dataValues[uniqueKey.column]) {\n          fields[uniqueKey.column] = this.options.instance.dataValues[uniqueKey.column];\n        } else if (parameters) {\n          fields[uniqueKey.column] = parameters[\"0\"];\n        }\n      }\n      if (uniqueKey && !!uniqueKey.msg) {\n        message = uniqueKey.msg;\n      }\n      const errors = [];\n      _.forOwn(fields, (value, field) => {\n        errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, value, this.instance, \"not_unique\"));\n      });\n      return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n    }\n    match = err.message.match(/SQL0532N {2}A parent row cannot be deleted because the relationship \"(.*)\" restricts the deletion/) || err.message.match(/SQL0530N/) || err.message.match(/SQL0531N/);\n    if (match && match.length > 0) {\n      return new sequelizeErrors.ForeignKeyConstraintError({\n        fields: null,\n        index: match[1],\n        parent: err,\n        stack: errStack\n      });\n    }\n    match = err.message.match(/SQL0204N {2}\"(.*)\" is an undefined name./);\n    if (match && match.length > 1) {\n      const constraint = match[1];\n      let table = err.sql.match(/table \"(.+?)\"/i);\n      table = table ? table[1] : void 0;\n      return new sequelizeErrors.UnknownConstraintError({\n        message: match[0],\n        constraint,\n        table,\n        parent: err,\n        stack: errStack\n      });\n    }\n    return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n  }\n  isDropSchemaQuery() {\n    let result = false;\n    if (_.startsWith(this.sql, \"CALL SYSPROC.ADMIN_DROP_SCHEMA\")) {\n      result = true;\n    }\n    return result;\n  }\n  isShowOrDescribeQuery() {\n    let result = false;\n    result = result || this.sql.toLowerCase().startsWith(\"select c.column_name as 'name', c.data_type as 'type', c.is_nullable as 'isnull'\");\n    result = result || this.sql.toLowerCase().startsWith(\"select tablename = t.name, name = ind.name,\");\n    result = result || this.sql.toLowerCase().startsWith(\"exec sys.sp_helpindex @objname\");\n    return result;\n  }\n  isShowIndexesQuery() {\n    let result = false;\n    result = result || this.sql.toLowerCase().startsWith(\"exec sys.sp_helpindex @objname\");\n    result = result || this.sql.startsWith('SELECT NAME AS \"name\", TBNAME AS \"tableName\", UNIQUERULE AS \"keyType\", COLNAMES, INDEXTYPE AS \"type\" FROM SYSIBM.SYSINDEXES');\n    return result;\n  }\n  handleShowIndexesQuery(data) {\n    let currItem;\n    const result = [];\n    data.forEach((item) => {\n      if (!currItem || currItem.name !== item.Key_name) {\n        currItem = {\n          primary: item.keyType === \"P\",\n          fields: [],\n          name: item.name,\n          tableName: item.tableName,\n          unique: item.keyType === \"U\",\n          type: item.type\n        };\n        _.forEach(item.COLNAMES.replace(/\\+|-/g, (x) => {\n          return ` ${x}`;\n        }).split(\" \"), (column) => {\n          let columnName = column.trim();\n          if (columnName) {\n            columnName = columnName.replace(/\\+|-/, \"\");\n            currItem.fields.push({\n              attribute: columnName,\n              length: void 0,\n              order: column.indexOf(\"-\") === -1 ? \"ASC\" : \"DESC\",\n              collate: void 0\n            });\n          }\n        });\n        result.push(currItem);\n      }\n    });\n    return result;\n  }\n  handleInsertQuery(results, metaData) {\n    if (this.instance) {\n      const autoIncrementAttribute = this.model.autoIncrementAttribute;\n      let id = null;\n      let autoIncrementAttributeAlias = null;\n      if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementAttribute) && this.model.rawAttributes[autoIncrementAttribute].field !== void 0)\n        autoIncrementAttributeAlias = this.model.rawAttributes[autoIncrementAttribute].field;\n      id = id || results && results[0][this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      id = id || results && results[0][autoIncrementAttribute];\n      id = id || autoIncrementAttributeAlias && results && results[0][autoIncrementAttributeAlias];\n      this.instance[autoIncrementAttribute] = id;\n    }\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports[\"default\"] = Query;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0Isc0JBQXNCLG1CQUFPLENBQUMsb0dBQW1CO0FBQ2pELHdCQUF3QixtQkFBTyxDQUFDLG9GQUFjO0FBQzlDLG9CQUFvQixtQkFBTyxDQUFDLDhGQUFnQjtBQUM1QyxVQUFVLG1CQUFPLENBQUMsaUVBQVE7QUFDMUIsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQywwRkFBb0I7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLGlFQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix1Q0FBdUMsa0NBQWtDLEtBQUssU0FBUztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0MsSUFBSSxRQUFRLEVBQUUsd0NBQXdDLHNDQUFzQyxPQUFPO0FBQ25LO0FBQ0EsOENBQThDLGtDQUFrQyxLQUFLLFFBQVEsRUFBRSx3Q0FBd0Msc0NBQXNDLE9BQU87QUFDcEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVcsS0FBSyxXQUFXO0FBQ2pELFVBQVU7QUFDVixzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTixrRUFBa0UsZ0NBQWdDO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxFQUFFO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsVUFBVSxtQkFBbUIsU0FBUyxtQkFBbUIsU0FBUztBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AseURBQXlELHVEQUF1RDtBQUNoSDtBQUNBLHlDQUF5QyxFQUFFO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHlDQUF5QyxFQUFFO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEVBQUU7QUFDdkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIseUJBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL2RiMi9xdWVyeS5qcz9hMTA0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgQWJzdHJhY3RRdWVyeSA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9xdWVyeVwiKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCBwYXJzZXJTdG9yZSA9IHJlcXVpcmUoXCIuLi9wYXJzZXJTdG9yZVwiKShcImRiMlwiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9sb2dnZXJcIik7XG5jb25zdCBtb21lbnQgPSByZXF1aXJlKFwibW9tZW50XCIpO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KFwic3FsOmRiMlwiKTtcbmNsYXNzIFF1ZXJ5IGV4dGVuZHMgQWJzdHJhY3RRdWVyeSB7XG4gIGdldEluc2VydElkRmllbGQoKSB7XG4gICAgcmV0dXJuIFwiaWRcIjtcbiAgfVxuICBnZXRTUUxUeXBlRnJvbUpzVHlwZSh2YWx1ZSkge1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4geyBQYXJhbVR5cGU6IFwiSU5QVVRcIiwgRGF0YVR5cGU6IFwiQkxPQlwiLCBEYXRhOiB2YWx1ZSB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGFzeW5jIF9ydW4oY29ubmVjdGlvbiwgc3FsLCBwYXJhbWV0ZXJzKSB7XG4gICAgdGhpcy5zcWwgPSBzcWw7XG4gICAgY29uc3QgYmVuY2htYXJrID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5iZW5jaG1hcmsgfHwgdGhpcy5vcHRpb25zLmJlbmNobWFyaztcbiAgICBsZXQgcXVlcnlCZWdpbjtcbiAgICBpZiAoYmVuY2htYXJrKSB7XG4gICAgICBxdWVyeUJlZ2luID0gRGF0ZS5ub3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXF1ZWxpemUubG9nKGBFeGVjdXRpbmcgKCR7dGhpcy5jb25uZWN0aW9uLnV1aWQgfHwgXCJkZWZhdWx0XCJ9KTogJHt0aGlzLnNxbH1gLCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBlcnJTdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoXy5zdGFydHNXaXRoKHRoaXMuc3FsLCBcIkJFR0lOIFRSQU5TQUNUSU9OXCIpKSB7XG4gICAgICAgIGNvbm5lY3Rpb24uYmVnaW5UcmFuc2FjdGlvbigoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KHRoaXMuZm9ybWF0RXJyb3IoZXJyLCBlcnJTdGFjaykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMuZm9ybWF0UmVzdWx0cygpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChfLnN0YXJ0c1dpdGgodGhpcy5zcWwsIFwiQ09NTUlUIFRSQU5TQUNUSU9OXCIpKSB7XG4gICAgICAgIGNvbm5lY3Rpb24uY29tbWl0VHJhbnNhY3Rpb24oKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdCh0aGlzLmZvcm1hdEVycm9yKGVyciwgZXJyU3RhY2spKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLmZvcm1hdFJlc3VsdHMoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoXy5zdGFydHNXaXRoKHRoaXMuc3FsLCBcIlJPTExCQUNLIFRSQU5TQUNUSU9OXCIpKSB7XG4gICAgICAgIGNvbm5lY3Rpb24ucm9sbGJhY2tUcmFuc2FjdGlvbigoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KHRoaXMuZm9ybWF0RXJyb3IoZXJyLCBlcnJTdGFjaykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMuZm9ybWF0UmVzdWx0cygpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChfLnN0YXJ0c1dpdGgodGhpcy5zcWwsIFwiU0FWRSBUUkFOU0FDVElPTlwiKSkge1xuICAgICAgICBjb25uZWN0aW9uLmNvbW1pdFRyYW5zYWN0aW9uKChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QodGhpcy5mb3JtYXRFcnJvcihlcnIsIGVyclN0YWNrKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uYmVnaW5UcmFuc2FjdGlvbigoZXJyMikgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyMikge1xuICAgICAgICAgICAgICAgIHJlamVjdCh0aGlzLmZvcm1hdEVycm9yKGVycjIsIGVyclN0YWNrKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLmZvcm1hdFJlc3VsdHMoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLnRyYW5zYWN0aW9uLm5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgICAgIGlmIChwYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgXy5mb3JPd24ocGFyYW1ldGVycywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtID0gdGhpcy5nZXRTUUxUeXBlRnJvbUpzVHlwZSh2YWx1ZSwga2V5KTtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBTUUwgPSB0aGlzLnNxbC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBsZXQgbmV3U3FsID0gdGhpcy5zcWw7XG4gICAgICAgIGlmICgodGhpcy5pc1NlbGVjdFF1ZXJ5KCkgfHwgXy5zdGFydHNXaXRoKFNRTCwgXCJTRUxFQ1QgXCIpKSAmJiBTUUwuaW5kZXhPZihcIiBGUk9NIFwiLCA4KSA9PT0gLTEpIHtcbiAgICAgICAgICBpZiAodGhpcy5zcWwuY2hhckF0KHRoaXMuc3FsLmxlbmd0aCAtIDEpID09PSBcIjtcIikge1xuICAgICAgICAgICAgbmV3U3FsID0gdGhpcy5zcWwuc2xpY2UoMCwgdGhpcy5zcWwubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5ld1NxbCArPSBcIiBGUk9NIFNZU0lCTS5TWVNEVU1NWTE7XCI7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGlvbi5wcmVwYXJlKG5ld1NxbCwgKGVyciwgc3RtdCkgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdCh0aGlzLmZvcm1hdEVycm9yKGVyciwgZXJyU3RhY2spKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RtdC5leGVjdXRlKHBhcmFtcywgKGVycjIsIHJlc3VsdCwgb3V0cGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhgZXhlY3V0ZWQoJHt0aGlzLmNvbm5lY3Rpb24udXVpZCB8fCBcImRlZmF1bHRcIn0pOiR7bmV3U3FsfSAke3BhcmFtZXRlcnMgPyB1dGlsLmluc3BlY3QocGFyYW1ldGVycywgeyBjb21wYWN0OiB0cnVlLCBicmVha0xlbmd0aDogSW5maW5pdHkgfSkgOiBcIlwifWApO1xuICAgICAgICAgICAgaWYgKGJlbmNobWFyaykge1xuICAgICAgICAgICAgICB0aGlzLnNlcXVlbGl6ZS5sb2coYEV4ZWN1dGVkICgke3RoaXMuY29ubmVjdGlvbi51dWlkIHx8IFwiZGVmYXVsdFwifSk6ICR7bmV3U3FsfSAke3BhcmFtZXRlcnMgPyB1dGlsLmluc3BlY3QocGFyYW1ldGVycywgeyBjb21wYWN0OiB0cnVlLCBicmVha0xlbmd0aDogSW5maW5pdHkgfSkgOiBcIlwifWAsIERhdGUubm93KCkgLSBxdWVyeUJlZ2luLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycjIgJiYgZXJyMi5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgIGVycjIgPSB0aGlzLmZpbHRlclNRTEVycm9yKGVycjIsIHRoaXMuc3FsLCBjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgaWYgKGVycjIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdG10LmNsb3NlU3luYygpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5mb3JtYXRSZXN1bHRzKFtdLCAwKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnIyKSB7XG4gICAgICAgICAgICAgIGVycjIuc3FsID0gc3FsO1xuICAgICAgICAgICAgICBzdG10LmNsb3NlU3luYygpO1xuICAgICAgICAgICAgICByZWplY3QodGhpcy5mb3JtYXRFcnJvcihlcnIyLCBlcnJTdGFjaywgY29ubmVjdGlvbiwgcGFyYW1ldGVycykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGV0IGRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhID0gW107XG4gICAgICAgICAgICAgIGxldCBhZmZlY3RlZFJvd3MgPSAwO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChfLnN0YXJ0c1dpdGgodGhpcy5zcWwsIFwiREVMRVRFIEZST00gXCIpKSB7XG4gICAgICAgICAgICAgICAgICBhZmZlY3RlZFJvd3MgPSByZXN1bHQuZ2V0QWZmZWN0ZWRSb3dzU3luYygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBkYXRhID0gcmVzdWx0LmZldGNoQWxsU3luYygpO1xuICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgPSByZXN1bHQuZ2V0Q29sdW1uTWV0YWRhdGFTeW5jKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5jbG9zZVN5bmMoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdG10LmNsb3NlU3luYygpO1xuICAgICAgICAgICAgICBjb25zdCBkYXRhbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmIChkYXRhbGVuID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbHR5cGVzID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRhZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgY29sdHlwZXNbbWV0YWRhdGFbaV0uU1FMX0RFU0NfTkFNRV0gPSBtZXRhZGF0YVtpXS5TUUxfREVTQ19UWVBFX05BTUU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YWxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbHVtbiBpbiBkYXRhW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlID0gcGFyc2VyU3RvcmUuZ2V0KGNvbHR5cGVzW2NvbHVtbl0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGFbaV1bY29sdW1uXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2ldW2NvbHVtbl0gPSBwYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2x0eXBlc1tjb2x1bW5dID09PSBcIlRJTUVTVEFNUFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2ldW2NvbHVtbl0gPSBuZXcgRGF0ZShtb21lbnQudXRjKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2x0eXBlc1tjb2x1bW5dID09PSBcIkJMT0JcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpXVtjb2x1bW5dID0gbmV3IEJ1ZmZlci5mcm9tKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbHR5cGVzW2NvbHVtbl0uaW5kZXhPZihcIkZPUiBCSVQgREFUQVwiKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaV1bY29sdW1uXSA9IG5ldyBCdWZmZXIuZnJvbSh2YWx1ZSwgXCJoZXhcIik7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvdXRwYXJhbXMgJiYgb3V0cGFyYW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgZGF0YS51bnNoaWZ0KG91dHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5mb3JtYXRSZXN1bHRzKGRhdGEsIGRhdGFsZW4sIG1ldGFkYXRhLCBjb25uZWN0aW9uKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLmZvcm1hdFJlc3VsdHMoZGF0YSwgYWZmZWN0ZWRSb3dzKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcnVuKHNxbCwgcGFyYW1ldGVycykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9ydW4odGhpcy5jb25uZWN0aW9uLCBzcWwsIHBhcmFtZXRlcnMpO1xuICB9XG4gIHN0YXRpYyBmb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCkge1xuICAgIGxldCBiaW5kUGFyYW0gPSB7fTtcbiAgICBjb25zdCByZXBsYWNlbWVudEZ1bmMgPSAobWF0Y2gsIGtleSwgdmFsdWVzMikgPT4ge1xuICAgICAgaWYgKHZhbHVlczJba2V5XSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGJpbmRQYXJhbVtrZXldID0gdmFsdWVzMltrZXldO1xuICAgICAgICByZXR1cm4gXCI/XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG4gICAgc3FsID0gQWJzdHJhY3RRdWVyeS5mb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCwgcmVwbGFjZW1lbnRGdW5jKVswXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpICYmIHR5cGVvZiB2YWx1ZXNbMF0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGJpbmRQYXJhbSA9IHZhbHVlcztcbiAgICB9XG4gICAgcmV0dXJuIFtzcWwsIGJpbmRQYXJhbV07XG4gIH1cbiAgZmlsdGVyU1FMRXJyb3IoZXJyLCBzcWwsIGNvbm5lY3Rpb24pIHtcbiAgICBpZiAoZXJyLm1lc3NhZ2Uuc2VhcmNoKFwiU1FMMDIwNE5cIikgIT0gLTEgJiYgXy5zdGFydHNXaXRoKHNxbCwgXCJEUk9QIFwiKSkge1xuICAgICAgZXJyID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGVyci5tZXNzYWdlLnNlYXJjaChcIlNRTDA0NDNOXCIpICE9IC0xKSB7XG4gICAgICBpZiAodGhpcy5pc0Ryb3BTY2hlbWFRdWVyeSgpKSB7XG4gICAgICAgIGNvbm5lY3Rpb24ucXVlcnlTeW5jKFwiRFJPUCBUQUJMRSBFUlJPUlNDSEVNQS5FUlJPUlRBQkxFO1wiKTtcbiAgICAgICAgY29ubmVjdGlvbi5xdWVyeVN5bmModGhpcy5zcWwpO1xuICAgICAgfVxuICAgICAgZXJyID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGVyci5tZXNzYWdlLnNlYXJjaChcIlNRTDA2MDFOXCIpICE9IC0xKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9TUUwwNjAxTiB7Mn1UaGUgbmFtZSBvZiB0aGUgb2JqZWN0IHRvIGJlIGNyZWF0ZWQgaXMgaWRlbnRpY2FsIHRvIHRoZSBleGlzdGluZyBuYW1lIFwiKC4qKVwiIG9mIHR5cGUgXCIoLiopXCIuLyk7XG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaFsyXSA9PT0gXCJUQUJMRVwiKSB7XG4gICAgICAgIGxldCB0YWJsZTtcbiAgICAgICAgY29uc3QgbXRhcnJheSA9IG1hdGNoWzFdLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgaWYgKG10YXJyYXlbMV0pIHtcbiAgICAgICAgICB0YWJsZSA9IGBcIiR7bXRhcnJheVswXX1cIi5cIiR7bXRhcnJheVsxXX1cImA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFibGUgPSBgXCIke210YXJyYXlbMF19XCJgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0aW9uLmRyb3BUYWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBjb25uZWN0aW9uLnF1ZXJ5U3luYyhgRFJPUCBUQUJMRSAke3RhYmxlfWApO1xuICAgICAgICAgIGVyciA9IGNvbm5lY3Rpb24ucXVlcnlTeW5jKHNxbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVyci5tZXNzYWdlLnNlYXJjaChcIlNRTDA5MTFOXCIpICE9IC0xKSB7XG4gICAgICBpZiAoZXJyLm1lc3NhZ2Uuc2VhcmNoKCdSZWFzb24gY29kZSBcIjJcIicpICE9IC0xKSB7XG4gICAgICAgIGVyciA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlcnIubWVzc2FnZS5zZWFyY2goXCJTUUwwNjA1V1wiKSAhPSAtMSkge1xuICAgICAgZXJyID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGVyci5tZXNzYWdlLnNlYXJjaChcIlNRTDA2NjhOXCIpICE9IC0xICYmIF8uc3RhcnRzV2l0aChzcWwsIFwiQUxURVIgVEFCTEUgXCIpKSB7XG4gICAgICBjb25uZWN0aW9uLnF1ZXJ5U3luYyhgQ0FMTCBTWVNQUk9DLkFETUlOX0NNRCgnUkVPUkcgVEFCTEUgJHtzcWwuc3Vic3RyaW5nKDEyKS5zcGxpdChcIiBcIilbMF19JylgKTtcbiAgICAgIGVyciA9IGNvbm5lY3Rpb24ucXVlcnlTeW5jKHNxbCk7XG4gICAgfVxuICAgIGlmIChlcnIgJiYgZXJyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZXJyID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGVycjtcbiAgfVxuICBmb3JtYXRSZXN1bHRzKGRhdGEsIHJvd0NvdW50LCBtZXRhZGF0YSwgY29ubikge1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmluc3RhbmNlO1xuICAgIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkoZGF0YSwgbWV0YWRhdGEpKSB7XG4gICAgICB0aGlzLmhhbmRsZUluc2VydFF1ZXJ5KGRhdGEsIG1ldGFkYXRhKTtcbiAgICAgIGlmICghdGhpcy5pbnN0YW5jZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBsYWluKSB7XG4gICAgICAgICAgY29uc3QgcmVjb3JkID0gZGF0YVswXTtcbiAgICAgICAgICByZXN1bHQgPSByZWNvcmRbT2JqZWN0LmtleXMocmVjb3JkKVswXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dUYWJsZXNRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSBkYXRhO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0Rlc2NyaWJlUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IF9yZXN1bHQgb2YgZGF0YSkge1xuICAgICAgICBpZiAoX3Jlc3VsdC5EZWZhdWx0KSB7XG4gICAgICAgICAgX3Jlc3VsdC5EZWZhdWx0ID0gX3Jlc3VsdC5EZWZhdWx0LnJlcGxhY2UoXCIoJ1wiLCBcIlwiKS5yZXBsYWNlKFwiJylcIiwgXCJcIikucmVwbGFjZSgvJy9nLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbX3Jlc3VsdC5OYW1lXSA9IHtcbiAgICAgICAgICB0eXBlOiBfcmVzdWx0LlR5cGUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICBhbGxvd051bGw6IF9yZXN1bHQuSXNOdWxsID09PSBcIllcIiA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IF9yZXN1bHQuRGVmYXVsdCxcbiAgICAgICAgICBwcmltYXJ5S2V5OiBfcmVzdWx0LktleVNlcSA+IDAsXG4gICAgICAgICAgYXV0b0luY3JlbWVudDogX3Jlc3VsdC5Jc0lkZW50aXR5ID09PSBcIllcIiA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICBjb21tZW50OiBfcmVzdWx0LkNvbW1lbnRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNTaG93SW5kZXhlc1F1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShkYXRhKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNTZWxlY3RRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLmhhbmRsZVNlbGVjdFF1ZXJ5KGRhdGEpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1Vwc2VydFF1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IGRhdGE7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzRHJvcFNjaGVtYVF1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IGRhdGFbMF07XG4gICAgICBpZiAoY29ubikge1xuICAgICAgICBjb25zdCBxdWVyeSA9IFwiRFJPUCBUQUJMRSBFUlJPUlNDSEVNQS5FUlJPUlRBQkxFXCI7XG4gICAgICAgIGNvbm4ucXVlcnlTeW5jKHF1ZXJ5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDYWxsUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gZGF0YTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNCdWxrVXBkYXRlUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gZGF0YS5sZW5ndGg7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQnVsa0RlbGV0ZVF1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IHJvd0NvdW50O1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1ZlcnNpb25RdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSBkYXRhWzBdLlZFUlNJT047XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzRm9yZWlnbktleXNRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSBkYXRhO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KCkgfHwgdGhpcy5pc1VwZGF0ZVF1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IFtyZXN1bHQsIHJvd0NvdW50XTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNTaG93Q29uc3RyYWludHNRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLmhhbmRsZVNob3dDb25zdHJhaW50c1F1ZXJ5KGRhdGEpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1Jhd1F1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IFtkYXRhLCBtZXRhZGF0YV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGRhdGE7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaGFuZGxlU2hvd1RhYmxlc1F1ZXJ5KHJlc3VsdHMpIHtcbiAgICByZXR1cm4gcmVzdWx0cy5tYXAoKHJlc3VsdFNldCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFibGVOYW1lOiByZXN1bHRTZXQuVEFCTEVfTkFNRSxcbiAgICAgICAgc2NoZW1hOiByZXN1bHRTZXQuVEFCTEVfU0NIRU1BXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGhhbmRsZVNob3dDb25zdHJhaW50c1F1ZXJ5KGRhdGEpIHtcbiAgICByZXR1cm4gXy5yZW1vdmUoZGF0YSwgKGNvbnN0cmFpbnQpID0+IHtcbiAgICAgIHJldHVybiAhXy5zdGFydHNXaXRoKGNvbnN0cmFpbnQuY29uc3RyYWludE5hbWUsIFwiU1FMXCIpO1xuICAgIH0pO1xuICB9XG4gIGZvcm1hdEVycm9yKGVyciwgZXJyU3RhY2ssIGNvbm4sIHBhcmFtZXRlcnMpIHtcbiAgICBsZXQgbWF0Y2g7XG4gICAgaWYgKCEoZXJyICYmIGVyci5tZXNzYWdlKSkge1xuICAgICAgZXJyW1wibWVzc2FnZVwiXSA9IFwiTm8gZXJyb3IgbWVzc2FnZSBmb3VuZC5cIjtcbiAgICB9XG4gICAgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvU1FMMDgwM04gezJ9T25lIG9yIG1vcmUgdmFsdWVzIGluIHRoZSBJTlNFUlQgc3RhdGVtZW50LCBVUERBVEUgc3RhdGVtZW50LCBvciBmb3JlaWduIGtleSB1cGRhdGUgY2F1c2VkIGJ5IGEgREVMRVRFIHN0YXRlbWVudCBhcmUgbm90IHZhbGlkIGJlY2F1c2UgdGhlIHByaW1hcnkga2V5LCB1bmlxdWUgY29uc3RyYWludCBvciB1bmlxdWUgaW5kZXggaWRlbnRpZmllZCBieSBcIihcXGQpK1wiIGNvbnN0cmFpbnMgdGFibGUgXCIoLiopXFwuKC4qKVwiIGZyb20gaGF2aW5nIGR1cGxpY2F0ZSB2YWx1ZXMgZm9yIHRoZSBpbmRleCBrZXkuLyk7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCB1bmlxdWVJbmRleE5hbWUgPSBcIlwiO1xuICAgICAgbGV0IHVuaXF1ZUtleSA9IFwiXCI7XG4gICAgICBjb25zdCBmaWVsZHMgPSB7fTtcbiAgICAgIGxldCBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICBjb25zdCBxdWVyeSA9IGBTRUxFQ1QgSU5ETkFNRSBGUk9NIFNZU0NBVC5JTkRFWEVTICBXSEVSRSBJSUQgPSAke21hdGNoWzFdfSBBTkQgVEFCU0NIRU1BID0gJyR7bWF0Y2hbMl19JyBBTkQgVEFCTkFNRSA9ICcke21hdGNoWzNdfSdgO1xuICAgICAgaWYgKCEhY29ubiAmJiBtYXRjaC5sZW5ndGggPiAzKSB7XG4gICAgICAgIHVuaXF1ZUluZGV4TmFtZSA9IGNvbm4ucXVlcnlTeW5jKHF1ZXJ5KTtcbiAgICAgICAgdW5pcXVlSW5kZXhOYW1lID0gdW5pcXVlSW5kZXhOYW1lWzBdW1wiSU5ETkFNRVwiXTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1vZGVsICYmICEhdW5pcXVlSW5kZXhOYW1lKSB7XG4gICAgICAgIHVuaXF1ZUtleSA9IHRoaXMubW9kZWwudW5pcXVlS2V5c1t1bmlxdWVJbmRleE5hbWVdO1xuICAgICAgfVxuICAgICAgaWYgKCF1bmlxdWVLZXkgJiYgdGhpcy5vcHRpb25zLmZpZWxkcykge1xuICAgICAgICB1bmlxdWVLZXkgPSB0aGlzLm9wdGlvbnMuZmllbGRzW21hdGNoWzFdIC0gMV07XG4gICAgICB9XG4gICAgICBpZiAodW5pcXVlS2V5KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMud2hlcmUgJiYgdGhpcy5vcHRpb25zLndoZXJlW3VuaXF1ZUtleS5jb2x1bW5dICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBmaWVsZHNbdW5pcXVlS2V5LmNvbHVtbl0gPSB0aGlzLm9wdGlvbnMud2hlcmVbdW5pcXVlS2V5LmNvbHVtbl07XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmluc3RhbmNlICYmIHRoaXMub3B0aW9ucy5pbnN0YW5jZS5kYXRhVmFsdWVzICYmIHRoaXMub3B0aW9ucy5pbnN0YW5jZS5kYXRhVmFsdWVzW3VuaXF1ZUtleS5jb2x1bW5dKSB7XG4gICAgICAgICAgZmllbGRzW3VuaXF1ZUtleS5jb2x1bW5dID0gdGhpcy5vcHRpb25zLmluc3RhbmNlLmRhdGFWYWx1ZXNbdW5pcXVlS2V5LmNvbHVtbl07XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1ldGVycykge1xuICAgICAgICAgIGZpZWxkc1t1bmlxdWVLZXkuY29sdW1uXSA9IHBhcmFtZXRlcnNbXCIwXCJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodW5pcXVlS2V5ICYmICEhdW5pcXVlS2V5Lm1zZykge1xuICAgICAgICBtZXNzYWdlID0gdW5pcXVlS2V5Lm1zZztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgXy5mb3JPd24oZmllbGRzLCAodmFsdWUsIGZpZWxkKSA9PiB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9ySXRlbSh0aGlzLmdldFVuaXF1ZUNvbnN0cmFpbnRFcnJvck1lc3NhZ2UoZmllbGQpLCBcInVuaXF1ZSB2aW9sYXRpb25cIiwgZmllbGQsIHZhbHVlLCB0aGlzLmluc3RhbmNlLCBcIm5vdF91bmlxdWVcIikpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5VbmlxdWVDb25zdHJhaW50RXJyb3IoeyBtZXNzYWdlLCBlcnJvcnMsIHBhcmVudDogZXJyLCBmaWVsZHMsIHN0YWNrOiBlcnJTdGFjayB9KTtcbiAgICB9XG4gICAgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvU1FMMDUzMk4gezJ9QSBwYXJlbnQgcm93IGNhbm5vdCBiZSBkZWxldGVkIGJlY2F1c2UgdGhlIHJlbGF0aW9uc2hpcCBcIiguKilcIiByZXN0cmljdHMgdGhlIGRlbGV0aW9uLykgfHwgZXJyLm1lc3NhZ2UubWF0Y2goL1NRTDA1MzBOLykgfHwgZXJyLm1lc3NhZ2UubWF0Y2goL1NRTDA1MzFOLyk7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3Ioe1xuICAgICAgICBmaWVsZHM6IG51bGwsXG4gICAgICAgIGluZGV4OiBtYXRjaFsxXSxcbiAgICAgICAgcGFyZW50OiBlcnIsXG4gICAgICAgIHN0YWNrOiBlcnJTdGFja1xuICAgICAgfSk7XG4gICAgfVxuICAgIG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL1NRTDAyMDROIHsyfVwiKC4qKVwiIGlzIGFuIHVuZGVmaW5lZCBuYW1lLi8pO1xuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBjb25zdHJhaW50ID0gbWF0Y2hbMV07XG4gICAgICBsZXQgdGFibGUgPSBlcnIuc3FsLm1hdGNoKC90YWJsZSBcIiguKz8pXCIvaSk7XG4gICAgICB0YWJsZSA9IHRhYmxlID8gdGFibGVbMV0gOiB2b2lkIDA7XG4gICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5Vbmtub3duQ29uc3RyYWludEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogbWF0Y2hbMF0sXG4gICAgICAgIGNvbnN0cmFpbnQsXG4gICAgICAgIHRhYmxlLFxuICAgICAgICBwYXJlbnQ6IGVycixcbiAgICAgICAgc3RhY2s6IGVyclN0YWNrXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRGF0YWJhc2VFcnJvcihlcnIsIHsgc3RhY2s6IGVyclN0YWNrIH0pO1xuICB9XG4gIGlzRHJvcFNjaGVtYVF1ZXJ5KCkge1xuICAgIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAoXy5zdGFydHNXaXRoKHRoaXMuc3FsLCBcIkNBTEwgU1lTUFJPQy5BRE1JTl9EUk9QX1NDSEVNQVwiKSkge1xuICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpc1Nob3dPckRlc2NyaWJlUXVlcnkoKSB7XG4gICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJzZWxlY3QgYy5jb2x1bW5fbmFtZSBhcyAnbmFtZScsIGMuZGF0YV90eXBlIGFzICd0eXBlJywgYy5pc19udWxsYWJsZSBhcyAnaXNudWxsJ1wiKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwic2VsZWN0IHRhYmxlbmFtZSA9IHQubmFtZSwgbmFtZSA9IGluZC5uYW1lLFwiKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwiZXhlYyBzeXMuc3BfaGVscGluZGV4IEBvYmpuYW1lXCIpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaXNTaG93SW5kZXhlc1F1ZXJ5KCkge1xuICAgIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwiZXhlYyBzeXMuc3BfaGVscGluZGV4IEBvYmpuYW1lXCIpO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLnNxbC5zdGFydHNXaXRoKCdTRUxFQ1QgTkFNRSBBUyBcIm5hbWVcIiwgVEJOQU1FIEFTIFwidGFibGVOYW1lXCIsIFVOSVFVRVJVTEUgQVMgXCJrZXlUeXBlXCIsIENPTE5BTUVTLCBJTkRFWFRZUEUgQVMgXCJ0eXBlXCIgRlJPTSBTWVNJQk0uU1lTSU5ERVhFUycpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShkYXRhKSB7XG4gICAgbGV0IGN1cnJJdGVtO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGRhdGEuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKCFjdXJySXRlbSB8fCBjdXJySXRlbS5uYW1lICE9PSBpdGVtLktleV9uYW1lKSB7XG4gICAgICAgIGN1cnJJdGVtID0ge1xuICAgICAgICAgIHByaW1hcnk6IGl0ZW0ua2V5VHlwZSA9PT0gXCJQXCIsXG4gICAgICAgICAgZmllbGRzOiBbXSxcbiAgICAgICAgICBuYW1lOiBpdGVtLm5hbWUsXG4gICAgICAgICAgdGFibGVOYW1lOiBpdGVtLnRhYmxlTmFtZSxcbiAgICAgICAgICB1bmlxdWU6IGl0ZW0ua2V5VHlwZSA9PT0gXCJVXCIsXG4gICAgICAgICAgdHlwZTogaXRlbS50eXBlXG4gICAgICAgIH07XG4gICAgICAgIF8uZm9yRWFjaChpdGVtLkNPTE5BTUVTLnJlcGxhY2UoL1xcK3wtL2csICh4KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGAgJHt4fWA7XG4gICAgICAgIH0pLnNwbGl0KFwiIFwiKSwgKGNvbHVtbikgPT4ge1xuICAgICAgICAgIGxldCBjb2x1bW5OYW1lID0gY29sdW1uLnRyaW0oKTtcbiAgICAgICAgICBpZiAoY29sdW1uTmFtZSkge1xuICAgICAgICAgICAgY29sdW1uTmFtZSA9IGNvbHVtbk5hbWUucmVwbGFjZSgvXFwrfC0vLCBcIlwiKTtcbiAgICAgICAgICAgIGN1cnJJdGVtLmZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgICAgYXR0cmlidXRlOiBjb2x1bW5OYW1lLFxuICAgICAgICAgICAgICBsZW5ndGg6IHZvaWQgMCxcbiAgICAgICAgICAgICAgb3JkZXI6IGNvbHVtbi5pbmRleE9mKFwiLVwiKSA9PT0gLTEgPyBcIkFTQ1wiIDogXCJERVNDXCIsXG4gICAgICAgICAgICAgIGNvbGxhdGU6IHZvaWQgMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0LnB1c2goY3Vyckl0ZW0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaGFuZGxlSW5zZXJ0UXVlcnkocmVzdWx0cywgbWV0YURhdGEpIHtcbiAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgY29uc3QgYXV0b0luY3JlbWVudEF0dHJpYnV0ZSA9IHRoaXMubW9kZWwuYXV0b0luY3JlbWVudEF0dHJpYnV0ZTtcbiAgICAgIGxldCBpZCA9IG51bGw7XG4gICAgICBsZXQgYXV0b0luY3JlbWVudEF0dHJpYnV0ZUFsaWFzID0gbnVsbDtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzLCBhdXRvSW5jcmVtZW50QXR0cmlidXRlKSAmJiB0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbYXV0b0luY3JlbWVudEF0dHJpYnV0ZV0uZmllbGQgIT09IHZvaWQgMClcbiAgICAgICAgYXV0b0luY3JlbWVudEF0dHJpYnV0ZUFsaWFzID0gdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2F1dG9JbmNyZW1lbnRBdHRyaWJ1dGVdLmZpZWxkO1xuICAgICAgaWQgPSBpZCB8fCByZXN1bHRzICYmIHJlc3VsdHNbMF1bdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuICAgICAgaWQgPSBpZCB8fCBtZXRhRGF0YSAmJiBtZXRhRGF0YVt0aGlzLmdldEluc2VydElkRmllbGQoKV07XG4gICAgICBpZCA9IGlkIHx8IHJlc3VsdHMgJiYgcmVzdWx0c1swXVthdXRvSW5jcmVtZW50QXR0cmlidXRlXTtcbiAgICAgIGlkID0gaWQgfHwgYXV0b0luY3JlbWVudEF0dHJpYnV0ZUFsaWFzICYmIHJlc3VsdHMgJiYgcmVzdWx0c1swXVthdXRvSW5jcmVtZW50QXR0cmlidXRlQWxpYXNdO1xuICAgICAgdGhpcy5pbnN0YW5jZVthdXRvSW5jcmVtZW50QXR0cmlidXRlXSA9IGlkO1xuICAgIH1cbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeTtcbm1vZHVsZS5leHBvcnRzLlF1ZXJ5ID0gUXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gUXVlcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/db2/query.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/mariadb/connection-manager.js":
/*!****************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/mariadb/connection-manager.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst semver = __webpack_require__(/*! semver */ \"(action-browser)/../node_modules/semver/index.js\");\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst SequelizeErrors = __webpack_require__(/*! ../../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(action-browser)/../node_modules/sequelize/lib/utils/logger.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\").mariadb);\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(action-browser)/../node_modules/moment-timezone/index.js\");\nconst debug = logger.debugContext(\"connection:mariadb\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(action-browser)/../node_modules/sequelize/lib/dialects/parserStore.js\")(\"mariadb\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"mariadb\");\n    this.refreshTypeParser(DataTypes);\n  }\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  async connect(config) {\n    let tzOffset = this.sequelize.options.timezone;\n    tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format(\"Z\") : tzOffset;\n    const connectionConfig = __spreadValues({\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      password: config.password,\n      database: config.database,\n      timezone: tzOffset,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true,\n      foundRows: false\n    }, config.dialectOptions);\n    if (!this.sequelize.config.keepDefaultTimezone) {\n      if (connectionConfig.initSql) {\n        if (!Array.isArray(connectionConfig.initSql)) {\n          connectionConfig.initSql = [connectionConfig.initSql];\n        }\n        connectionConfig.initSql.push(`SET time_zone = '${tzOffset}'`);\n      } else {\n        connectionConfig.initSql = `SET time_zone = '${tzOffset}'`;\n      }\n    }\n    try {\n      const connection = await this.lib.createConnection(connectionConfig);\n      this.sequelize.options.databaseVersion = semver.coerce(connection.serverVersion()).version;\n      debug(\"connection acquired\");\n      connection.on(\"error\", (error) => {\n        switch (error.code) {\n          case \"ESOCKET\":\n          case \"ECONNRESET\":\n          case \"EPIPE\":\n          case \"PROTOCOL_CONNECTION_LOST\":\n            this.pool.destroy(connection);\n        }\n      });\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case \"ECONNREFUSED\":\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case \"ER_ACCESS_DENIED_ERROR\":\n        case \"ER_ACCESS_DENIED_NO_PASSWORD_ERROR\":\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case \"ENOTFOUND\":\n          throw new SequelizeErrors.HostNotFoundError(err);\n        case \"EHOSTUNREACH\":\n        case \"ENETUNREACH\":\n        case \"EADDRNOTAVAIL\":\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case \"EINVAL\":\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n  async disconnect(connection) {\n    if (!connection.isValid()) {\n      debug(\"connection tried to disconnect but was already at CLOSED state\");\n      return;\n    }\n    return await connection.end();\n  }\n  validate(connection) {\n    return connection && connection.isValid();\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL2Nvbm5lY3Rpb24tbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsZ0VBQVE7QUFDL0Isa0NBQWtDLG1CQUFPLENBQUMsOEhBQWdDO0FBQzFFLHdCQUF3QixtQkFBTyxDQUFDLG9GQUFjO0FBQzlDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsMEZBQW9CO0FBQy9DLGtCQUFrQixxSEFBbUM7QUFDckQsaUJBQWlCLG1CQUFPLENBQUMsa0ZBQWlCO0FBQzFDO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsOEZBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFNBQVM7QUFDbkUsUUFBUTtBQUNSLHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMseUJBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21hcmlhZGIvY29ubmVjdGlvbi1tYW5hZ2VyLmpzPzgyZmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xuY29uc3QgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9jb25uZWN0aW9uLW1hbmFnZXJcIik7XG5jb25zdCBTZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzXCIpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9sb2dnZXJcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKS5tYXJpYWRiO1xuY29uc3QgbW9tZW50VHogPSByZXF1aXJlKFwibW9tZW50LXRpbWV6b25lXCIpO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KFwiY29ubmVjdGlvbjptYXJpYWRiXCIpO1xuY29uc3QgcGFyc2VyU3RvcmUgPSByZXF1aXJlKFwiLi4vcGFyc2VyU3RvcmVcIikoXCJtYXJpYWRiXCIpO1xuY2xhc3MgQ29ubmVjdGlvbk1hbmFnZXIgZXh0ZW5kcyBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZGlhbGVjdCwgc2VxdWVsaXplKSB7XG4gICAgc2VxdWVsaXplLmNvbmZpZy5wb3J0ID0gc2VxdWVsaXplLmNvbmZpZy5wb3J0IHx8IDMzMDY7XG4gICAgc3VwZXIoZGlhbGVjdCwgc2VxdWVsaXplKTtcbiAgICB0aGlzLmxpYiA9IHRoaXMuX2xvYWREaWFsZWN0TW9kdWxlKFwibWFyaWFkYlwiKTtcbiAgICB0aGlzLnJlZnJlc2hUeXBlUGFyc2VyKERhdGFUeXBlcyk7XG4gIH1cbiAgc3RhdGljIF90eXBlY2FzdChmaWVsZCwgbmV4dCkge1xuICAgIGlmIChwYXJzZXJTdG9yZS5nZXQoZmllbGQudHlwZSkpIHtcbiAgICAgIHJldHVybiBwYXJzZXJTdG9yZS5nZXQoZmllbGQudHlwZSkoZmllbGQsIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMsIG5leHQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dCgpO1xuICB9XG4gIF9yZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZSkge1xuICAgIHBhcnNlclN0b3JlLnJlZnJlc2goZGF0YVR5cGUpO1xuICB9XG4gIF9jbGVhclR5cGVQYXJzZXIoKSB7XG4gICAgcGFyc2VyU3RvcmUuY2xlYXIoKTtcbiAgfVxuICBhc3luYyBjb25uZWN0KGNvbmZpZykge1xuICAgIGxldCB0ek9mZnNldCA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMudGltZXpvbmU7XG4gICAgdHpPZmZzZXQgPSAvXFwvLy50ZXN0KHR6T2Zmc2V0KSA/IG1vbWVudFR6LnR6KHR6T2Zmc2V0KS5mb3JtYXQoXCJaXCIpIDogdHpPZmZzZXQ7XG4gICAgY29uc3QgY29ubmVjdGlvbkNvbmZpZyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGhvc3Q6IGNvbmZpZy5ob3N0LFxuICAgICAgcG9ydDogY29uZmlnLnBvcnQsXG4gICAgICB1c2VyOiBjb25maWcudXNlcm5hbWUsXG4gICAgICBwYXNzd29yZDogY29uZmlnLnBhc3N3b3JkLFxuICAgICAgZGF0YWJhc2U6IGNvbmZpZy5kYXRhYmFzZSxcbiAgICAgIHRpbWV6b25lOiB0ek9mZnNldCxcbiAgICAgIHR5cGVDYXN0OiBDb25uZWN0aW9uTWFuYWdlci5fdHlwZWNhc3QuYmluZCh0aGlzKSxcbiAgICAgIGJpZ051bWJlclN0cmluZ3M6IGZhbHNlLFxuICAgICAgc3VwcG9ydEJpZ051bWJlcnM6IHRydWUsXG4gICAgICBmb3VuZFJvd3M6IGZhbHNlXG4gICAgfSwgY29uZmlnLmRpYWxlY3RPcHRpb25zKTtcbiAgICBpZiAoIXRoaXMuc2VxdWVsaXplLmNvbmZpZy5rZWVwRGVmYXVsdFRpbWV6b25lKSB7XG4gICAgICBpZiAoY29ubmVjdGlvbkNvbmZpZy5pbml0U3FsKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb25uZWN0aW9uQ29uZmlnLmluaXRTcWwpKSB7XG4gICAgICAgICAgY29ubmVjdGlvbkNvbmZpZy5pbml0U3FsID0gW2Nvbm5lY3Rpb25Db25maWcuaW5pdFNxbF07XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGlvbkNvbmZpZy5pbml0U3FsLnB1c2goYFNFVCB0aW1lX3pvbmUgPSAnJHt0ek9mZnNldH0nYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25uZWN0aW9uQ29uZmlnLmluaXRTcWwgPSBgU0VUIHRpbWVfem9uZSA9ICcke3R6T2Zmc2V0fSdgO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHRoaXMubGliLmNyZWF0ZUNvbm5lY3Rpb24oY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbiA9IHNlbXZlci5jb2VyY2UoY29ubmVjdGlvbi5zZXJ2ZXJWZXJzaW9uKCkpLnZlcnNpb247XG4gICAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gYWNxdWlyZWRcIik7XG4gICAgICBjb25uZWN0aW9uLm9uKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoZXJyb3IuY29kZSkge1xuICAgICAgICAgIGNhc2UgXCJFU09DS0VUXCI6XG4gICAgICAgICAgY2FzZSBcIkVDT05OUkVTRVRcIjpcbiAgICAgICAgICBjYXNlIFwiRVBJUEVcIjpcbiAgICAgICAgICBjYXNlIFwiUFJPVE9DT0xfQ09OTkVDVElPTl9MT1NUXCI6XG4gICAgICAgICAgICB0aGlzLnBvb2wuZGVzdHJveShjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcbiAgICAgICAgY2FzZSBcIkVDT05OUkVGVVNFRFwiOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvblJlZnVzZWRFcnJvcihlcnIpO1xuICAgICAgICBjYXNlIFwiRVJfQUNDRVNTX0RFTklFRF9FUlJPUlwiOlxuICAgICAgICBjYXNlIFwiRVJfQUNDRVNTX0RFTklFRF9OT19QQVNTV09SRF9FUlJPUlwiOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuQWNjZXNzRGVuaWVkRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSBcIkVOT1RGT1VORFwiOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuSG9zdE5vdEZvdW5kRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSBcIkVIT1NUVU5SRUFDSFwiOlxuICAgICAgICBjYXNlIFwiRU5FVFVOUkVBQ0hcIjpcbiAgICAgICAgY2FzZSBcIkVBRERSTk9UQVZBSUxcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkhvc3ROb3RSZWFjaGFibGVFcnJvcihlcnIpO1xuICAgICAgICBjYXNlIFwiRUlOVkFMXCI6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5JbnZhbGlkQ29ubmVjdGlvbkVycm9yKGVycik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgZGlzY29ubmVjdChjb25uZWN0aW9uKSB7XG4gICAgaWYgKCFjb25uZWN0aW9uLmlzVmFsaWQoKSkge1xuICAgICAgZGVidWcoXCJjb25uZWN0aW9uIHRyaWVkIHRvIGRpc2Nvbm5lY3QgYnV0IHdhcyBhbHJlYWR5IGF0IENMT1NFRCBzdGF0ZVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGNvbm5lY3Rpb24uZW5kKCk7XG4gIH1cbiAgdmFsaWRhdGUoY29ubmVjdGlvbikge1xuICAgIHJldHVybiBjb25uZWN0aW9uICYmIGNvbm5lY3Rpb24uaXNWYWxpZCgpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbk1hbmFnZXIgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpb24tbWFuYWdlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/mariadb/connection-manager.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/mariadb/data-types.js":
/*!********************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/mariadb/data-types.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst wkx = __webpack_require__(/*! wkx */ \"(action-browser)/../node_modules/wkx/lib/wkx.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(action-browser)/../node_modules/moment-timezone/index.js\");\nconst moment = __webpack_require__(/*! moment */ \"(action-browser)/../node_modules/moment/moment.js\");\nmodule.exports = (BaseTypes) => {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = \"https://mariadb.com/kb/en/library/resultset/#field-types\";\n  BaseTypes.DATE.types.mariadb = [\"DATETIME\"];\n  BaseTypes.STRING.types.mariadb = [\"VAR_STRING\"];\n  BaseTypes.CHAR.types.mariadb = [\"STRING\"];\n  BaseTypes.TEXT.types.mariadb = [\"BLOB\"];\n  BaseTypes.TINYINT.types.mariadb = [\"TINY\"];\n  BaseTypes.SMALLINT.types.mariadb = [\"SHORT\"];\n  BaseTypes.MEDIUMINT.types.mariadb = [\"INT24\"];\n  BaseTypes.INTEGER.types.mariadb = [\"LONG\"];\n  BaseTypes.BIGINT.types.mariadb = [\"LONGLONG\"];\n  BaseTypes.FLOAT.types.mariadb = [\"FLOAT\"];\n  BaseTypes.TIME.types.mariadb = [\"TIME\"];\n  BaseTypes.DATEONLY.types.mariadb = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.mariadb = [\"TINY\"];\n  BaseTypes.BLOB.types.mariadb = [\"TINYBLOB\", \"BLOB\", \"LONGBLOB\"];\n  BaseTypes.DECIMAL.types.mariadb = [\"NEWDECIMAL\"];\n  BaseTypes.UUID.types.mariadb = false;\n  BaseTypes.ENUM.types.mariadb = false;\n  BaseTypes.REAL.types.mariadb = [\"DOUBLE\"];\n  BaseTypes.DOUBLE.types.mariadb = [\"DOUBLE\"];\n  BaseTypes.GEOMETRY.types.mariadb = [\"GEOMETRY\"];\n  BaseTypes.JSON.types.mariadb = [\"JSON\"];\n  class DECIMAL extends BaseTypes.DECIMAL {\n    toSql() {\n      let definition = super.toSql();\n      if (this._unsigned) {\n        definition += \" UNSIGNED\";\n      }\n      if (this._zerofill) {\n        definition += \" ZEROFILL\";\n      }\n      return definition;\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return this._length ? `DATETIME(${this._length})` : \"DATETIME\";\n    }\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n      return date.format(\"YYYY-MM-DD HH:mm:ss.SSS\");\n    }\n    static parse(value, options) {\n      value = value.string();\n      if (value === null) {\n        return value;\n      }\n      if (momentTz.tz.zone(options.timezone)) {\n        value = momentTz.tz(value, options.timezone).toDate();\n      } else {\n        value = new Date(`${value} ${options.timezone}`);\n      }\n      return value;\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return value.string();\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"CHAR(36) BINARY\";\n    }\n  }\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    constructor(type, srid) {\n      super(type, srid);\n      if (_.isEmpty(this.type)) {\n        this.sqlType = this.key;\n      } else {\n        this.sqlType = this.type;\n      }\n    }\n    static parse(value) {\n      value = value.buffer();\n      if (!value || value.length === 0) {\n        return null;\n      }\n      value = value.slice(4);\n      return wkx.Geometry.parse(value).toGeoJSON({ shortCrs: true });\n    }\n    toSql() {\n      return this.sqlType;\n    }\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql(options) {\n      return `ENUM(${this.values.map((value) => options.escape(value)).join(\", \")})`;\n    }\n  }\n  class JSONTYPE extends BaseTypes.JSON {\n    _stringify(value, options) {\n      return options.operation === \"where\" && typeof value === \"string\" ? value : JSON.stringify(value);\n    }\n  }\n  return {\n    ENUM,\n    DATE,\n    DATEONLY,\n    UUID,\n    GEOMETRY,\n    DECIMAL,\n    JSON: JSONTYPE\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL2RhdGEtdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixZQUFZLG1CQUFPLENBQUMsNERBQUs7QUFDekIsVUFBVSxtQkFBTyxDQUFDLGlFQUFRO0FBQzFCLGlCQUFpQixtQkFBTyxDQUFDLGtGQUFpQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMsaUVBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDRCQUE0QixPQUFPLEVBQUUsaUJBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkRBQTZEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL2RhdGEtdHlwZXMuanM/YzlhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHdreCA9IHJlcXVpcmUoXCJ3a3hcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IG1vbWVudFR6ID0gcmVxdWlyZShcIm1vbWVudC10aW1lem9uZVwiKTtcbmNvbnN0IG1vbWVudCA9IHJlcXVpcmUoXCJtb21lbnRcIik7XG5tb2R1bGUuZXhwb3J0cyA9IChCYXNlVHlwZXMpID0+IHtcbiAgQmFzZVR5cGVzLkFCU1RSQUNULnByb3RvdHlwZS5kaWFsZWN0VHlwZXMgPSBcImh0dHBzOi8vbWFyaWFkYi5jb20va2IvZW4vbGlicmFyeS9yZXN1bHRzZXQvI2ZpZWxkLXR5cGVzXCI7XG4gIEJhc2VUeXBlcy5EQVRFLnR5cGVzLm1hcmlhZGIgPSBbXCJEQVRFVElNRVwiXTtcbiAgQmFzZVR5cGVzLlNUUklORy50eXBlcy5tYXJpYWRiID0gW1wiVkFSX1NUUklOR1wiXTtcbiAgQmFzZVR5cGVzLkNIQVIudHlwZXMubWFyaWFkYiA9IFtcIlNUUklOR1wiXTtcbiAgQmFzZVR5cGVzLlRFWFQudHlwZXMubWFyaWFkYiA9IFtcIkJMT0JcIl07XG4gIEJhc2VUeXBlcy5USU5ZSU5ULnR5cGVzLm1hcmlhZGIgPSBbXCJUSU5ZXCJdO1xuICBCYXNlVHlwZXMuU01BTExJTlQudHlwZXMubWFyaWFkYiA9IFtcIlNIT1JUXCJdO1xuICBCYXNlVHlwZXMuTUVESVVNSU5ULnR5cGVzLm1hcmlhZGIgPSBbXCJJTlQyNFwiXTtcbiAgQmFzZVR5cGVzLklOVEVHRVIudHlwZXMubWFyaWFkYiA9IFtcIkxPTkdcIl07XG4gIEJhc2VUeXBlcy5CSUdJTlQudHlwZXMubWFyaWFkYiA9IFtcIkxPTkdMT05HXCJdO1xuICBCYXNlVHlwZXMuRkxPQVQudHlwZXMubWFyaWFkYiA9IFtcIkZMT0FUXCJdO1xuICBCYXNlVHlwZXMuVElNRS50eXBlcy5tYXJpYWRiID0gW1wiVElNRVwiXTtcbiAgQmFzZVR5cGVzLkRBVEVPTkxZLnR5cGVzLm1hcmlhZGIgPSBbXCJEQVRFXCJdO1xuICBCYXNlVHlwZXMuQk9PTEVBTi50eXBlcy5tYXJpYWRiID0gW1wiVElOWVwiXTtcbiAgQmFzZVR5cGVzLkJMT0IudHlwZXMubWFyaWFkYiA9IFtcIlRJTllCTE9CXCIsIFwiQkxPQlwiLCBcIkxPTkdCTE9CXCJdO1xuICBCYXNlVHlwZXMuREVDSU1BTC50eXBlcy5tYXJpYWRiID0gW1wiTkVXREVDSU1BTFwiXTtcbiAgQmFzZVR5cGVzLlVVSUQudHlwZXMubWFyaWFkYiA9IGZhbHNlO1xuICBCYXNlVHlwZXMuRU5VTS50eXBlcy5tYXJpYWRiID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5SRUFMLnR5cGVzLm1hcmlhZGIgPSBbXCJET1VCTEVcIl07XG4gIEJhc2VUeXBlcy5ET1VCTEUudHlwZXMubWFyaWFkYiA9IFtcIkRPVUJMRVwiXTtcbiAgQmFzZVR5cGVzLkdFT01FVFJZLnR5cGVzLm1hcmlhZGIgPSBbXCJHRU9NRVRSWVwiXTtcbiAgQmFzZVR5cGVzLkpTT04udHlwZXMubWFyaWFkYiA9IFtcIkpTT05cIl07XG4gIGNsYXNzIERFQ0lNQUwgZXh0ZW5kcyBCYXNlVHlwZXMuREVDSU1BTCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBsZXQgZGVmaW5pdGlvbiA9IHN1cGVyLnRvU3FsKCk7XG4gICAgICBpZiAodGhpcy5fdW5zaWduZWQpIHtcbiAgICAgICAgZGVmaW5pdGlvbiArPSBcIiBVTlNJR05FRFwiO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3plcm9maWxsKSB7XG4gICAgICAgIGRlZmluaXRpb24gKz0gXCIgWkVST0ZJTExcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgIH1cbiAgfVxuICBjbGFzcyBEQVRFIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEUge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aCA/IGBEQVRFVElNRSgke3RoaXMuX2xlbmd0aH0pYCA6IFwiREFURVRJTUVcIjtcbiAgICB9XG4gICAgX3N0cmluZ2lmeShkYXRlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW1vbWVudC5pc01vbWVudChkYXRlKSkge1xuICAgICAgICBkYXRlID0gdGhpcy5fYXBwbHlUaW1lem9uZShkYXRlLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRlLmZvcm1hdChcIllZWVktTU0tREQgSEg6bW06c3MuU1NTXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuc3RyaW5nKCk7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKG1vbWVudFR6LnR6LnpvbmUob3B0aW9ucy50aW1lem9uZSkpIHtcbiAgICAgICAgdmFsdWUgPSBtb21lbnRUei50eih2YWx1ZSwgb3B0aW9ucy50aW1lem9uZSkudG9EYXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKGAke3ZhbHVlfSAke29wdGlvbnMudGltZXpvbmV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIGNsYXNzIERBVEVPTkxZIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEVPTkxZIHtcbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5zdHJpbmcoKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgVVVJRCBleHRlbmRzIEJhc2VUeXBlcy5VVUlEIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIkNIQVIoMzYpIEJJTkFSWVwiO1xuICAgIH1cbiAgfVxuICBjbGFzcyBHRU9NRVRSWSBleHRlbmRzIEJhc2VUeXBlcy5HRU9NRVRSWSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgc3JpZCkge1xuICAgICAgc3VwZXIodHlwZSwgc3JpZCk7XG4gICAgICBpZiAoXy5pc0VtcHR5KHRoaXMudHlwZSkpIHtcbiAgICAgICAgdGhpcy5zcWxUeXBlID0gdGhpcy5rZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNxbFR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5idWZmZXIoKTtcbiAgICAgIGlmICghdmFsdWUgfHwgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSg0KTtcbiAgICAgIHJldHVybiB3a3guR2VvbWV0cnkucGFyc2UodmFsdWUpLnRvR2VvSlNPTih7IHNob3J0Q3JzOiB0cnVlIH0pO1xuICAgIH1cbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNxbFR5cGU7XG4gICAgfVxuICB9XG4gIGNsYXNzIEVOVU0gZXh0ZW5kcyBCYXNlVHlwZXMuRU5VTSB7XG4gICAgdG9TcWwob3B0aW9ucykge1xuICAgICAgcmV0dXJuIGBFTlVNKCR7dGhpcy52YWx1ZXMubWFwKCh2YWx1ZSkgPT4gb3B0aW9ucy5lc2NhcGUodmFsdWUpKS5qb2luKFwiLCBcIil9KWA7XG4gICAgfVxuICB9XG4gIGNsYXNzIEpTT05UWVBFIGV4dGVuZHMgQmFzZVR5cGVzLkpTT04ge1xuICAgIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLm9wZXJhdGlvbiA9PT0gXCJ3aGVyZVwiICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIEVOVU0sXG4gICAgREFURSxcbiAgICBEQVRFT05MWSxcbiAgICBVVUlELFxuICAgIEdFT01FVFJZLFxuICAgIERFQ0lNQUwsXG4gICAgSlNPTjogSlNPTlRZUEVcbiAgfTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLXR5cGVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/mariadb/data-types.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/mariadb/index.js":
/*!***************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/mariadb/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst AbstractDialect = __webpack_require__(/*! ../abstract */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst ConnectionManager = __webpack_require__(/*! ./connection-manager */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mariadb/connection-manager.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mariadb/query.js\");\nconst QueryGenerator = __webpack_require__(/*! ./query-generator */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mariadb/query-generator.js\");\nconst { MySQLQueryInterface } = __webpack_require__(/*! ../mysql/query-interface */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mysql/query-interface.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\").mariadb);\nclass MariadbDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new MySQLQueryInterface(sequelize, this.queryGenerator);\n  }\n  canBackslashEscape() {\n    return true;\n  }\n}\nMariadbDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  \"VALUES ()\": true,\n  \"LIMIT ON UPDATE\": true,\n  lock: true,\n  forShare: \"LOCK IN SHARE MODE\",\n  settingIsolationLevelDuringTransaction: false,\n  schemas: true,\n  inserts: {\n    ignoreDuplicates: \" IGNORE\",\n    updateOnDuplicate: \" ON DUPLICATE KEY UPDATE\"\n  },\n  index: {\n    collate: false,\n    length: true,\n    parser: true,\n    type: true,\n    using: 1\n  },\n  constraints: {\n    dropConstraint: false,\n    check: false\n  },\n  indexViaAlter: true,\n  indexHints: true,\n  NUMERIC: true,\n  GEOMETRY: true,\n  JSON: true,\n  REGEXP: true\n});\nMariadbDialect.prototype.defaultVersion = \"10.1.44\";\nMariadbDialect.prototype.Query = Query;\nMariadbDialect.prototype.QueryGenerator = QueryGenerator;\nMariadbDialect.prototype.DataTypes = DataTypes;\nMariadbDialect.prototype.name = \"mariadb\";\nMariadbDialect.prototype.TICK_CHAR = \"`\";\nMariadbDialect.prototype.TICK_CHAR_LEFT = MariadbDialect.prototype.TICK_CHAR;\nMariadbDialect.prototype.TICK_CHAR_RIGHT = MariadbDialect.prototype.TICK_CHAR;\nmodule.exports = MariadbDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsVUFBVSxtQkFBTyxDQUFDLGlFQUFRO0FBQzFCLHdCQUF3QixtQkFBTyxDQUFDLDhGQUFhO0FBQzdDLDBCQUEwQixtQkFBTyxDQUFDLG1IQUFzQjtBQUN4RCxjQUFjLG1CQUFPLENBQUMseUZBQVM7QUFDL0IsdUJBQXVCLG1CQUFPLENBQUMsNkdBQW1CO0FBQ2xELFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyxrSEFBMEI7QUFDbEUsa0JBQWtCLHFIQUFtQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21hcmlhZGIvaW5kZXguanM/YzZkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgQWJzdHJhY3REaWFsZWN0ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0XCIpO1xuY29uc3QgQ29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi9jb25uZWN0aW9uLW1hbmFnZXJcIik7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoXCIuL3F1ZXJ5XCIpO1xuY29uc3QgUXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKFwiLi9xdWVyeS1nZW5lcmF0b3JcIik7XG5jb25zdCB7IE15U1FMUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoXCIuLi9teXNxbC9xdWVyeS1pbnRlcmZhY2VcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKS5tYXJpYWRiO1xuY2xhc3MgTWFyaWFkYkRpYWxlY3QgZXh0ZW5kcyBBYnN0cmFjdERpYWxlY3Qge1xuICBjb25zdHJ1Y3RvcihzZXF1ZWxpemUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgQ29ubmVjdGlvbk1hbmFnZXIodGhpcywgc2VxdWVsaXplKTtcbiAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yID0gbmV3IFF1ZXJ5R2VuZXJhdG9yKHtcbiAgICAgIF9kaWFsZWN0OiB0aGlzLFxuICAgICAgc2VxdWVsaXplXG4gICAgfSk7XG4gICAgdGhpcy5xdWVyeUludGVyZmFjZSA9IG5ldyBNeVNRTFF1ZXJ5SW50ZXJmYWNlKHNlcXVlbGl6ZSwgdGhpcy5xdWVyeUdlbmVyYXRvcik7XG4gIH1cbiAgY2FuQmFja3NsYXNoRXNjYXBlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5NYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMgPSBfLm1lcmdlKF8uY2xvbmVEZWVwKEFic3RyYWN0RGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMpLCB7XG4gIFwiVkFMVUVTICgpXCI6IHRydWUsXG4gIFwiTElNSVQgT04gVVBEQVRFXCI6IHRydWUsXG4gIGxvY2s6IHRydWUsXG4gIGZvclNoYXJlOiBcIkxPQ0sgSU4gU0hBUkUgTU9ERVwiLFxuICBzZXR0aW5nSXNvbGF0aW9uTGV2ZWxEdXJpbmdUcmFuc2FjdGlvbjogZmFsc2UsXG4gIHNjaGVtYXM6IHRydWUsXG4gIGluc2VydHM6IHtcbiAgICBpZ25vcmVEdXBsaWNhdGVzOiBcIiBJR05PUkVcIixcbiAgICB1cGRhdGVPbkR1cGxpY2F0ZTogXCIgT04gRFVQTElDQVRFIEtFWSBVUERBVEVcIlxuICB9LFxuICBpbmRleDoge1xuICAgIGNvbGxhdGU6IGZhbHNlLFxuICAgIGxlbmd0aDogdHJ1ZSxcbiAgICBwYXJzZXI6IHRydWUsXG4gICAgdHlwZTogdHJ1ZSxcbiAgICB1c2luZzogMVxuICB9LFxuICBjb25zdHJhaW50czoge1xuICAgIGRyb3BDb25zdHJhaW50OiBmYWxzZSxcbiAgICBjaGVjazogZmFsc2VcbiAgfSxcbiAgaW5kZXhWaWFBbHRlcjogdHJ1ZSxcbiAgaW5kZXhIaW50czogdHJ1ZSxcbiAgTlVNRVJJQzogdHJ1ZSxcbiAgR0VPTUVUUlk6IHRydWUsXG4gIEpTT046IHRydWUsXG4gIFJFR0VYUDogdHJ1ZVxufSk7XG5NYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUuZGVmYXVsdFZlcnNpb24gPSBcIjEwLjEuNDRcIjtcbk1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5RdWVyeSA9IFF1ZXJ5O1xuTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLlF1ZXJ5R2VuZXJhdG9yID0gUXVlcnlHZW5lcmF0b3I7XG5NYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUuRGF0YVR5cGVzID0gRGF0YVR5cGVzO1xuTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLm5hbWUgPSBcIm1hcmlhZGJcIjtcbk1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVIgPSBcImBcIjtcbk1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfTEVGVCA9IE1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVI7XG5NYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX1JJR0hUID0gTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUjtcbm1vZHVsZS5leHBvcnRzID0gTWFyaWFkYkRpYWxlY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/mariadb/index.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/mariadb/query-generator.js":
/*!*************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/mariadb/query-generator.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst MySQLQueryGenerator = __webpack_require__(/*! ../mysql/query-generator */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mysql/query-generator.js\");\nconst Utils = __webpack_require__(/*! ./../../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nclass MariaDBQueryGenerator extends MySQLQueryGenerator {\n  createSchema(schema, options) {\n    options = __spreadValues({\n      charset: null,\n      collate: null\n    }, options);\n    return Utils.joinSQLFragments([\n      \"CREATE SCHEMA IF NOT EXISTS\",\n      this.quoteIdentifier(schema),\n      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,\n      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,\n      \";\"\n    ]);\n  }\n  dropSchema(schema) {\n    return `DROP SCHEMA IF EXISTS ${this.quoteIdentifier(schema)};`;\n  }\n  showSchemasQuery(options) {\n    const schemasToSkip = [\n      \"'MYSQL'\",\n      \"'INFORMATION_SCHEMA'\",\n      \"'PERFORMANCE_SCHEMA'\"\n    ];\n    if (options.skip && Array.isArray(options.skip) && options.skip.length > 0) {\n      for (const schemaName of options.skip) {\n        schemasToSkip.push(this.escape(schemaName));\n      }\n    }\n    return Utils.joinSQLFragments([\n      \"SELECT SCHEMA_NAME as schema_name\",\n      \"FROM INFORMATION_SCHEMA.SCHEMATA\",\n      `WHERE SCHEMA_NAME NOT IN (${schemasToSkip.join(\", \")})`,\n      \";\"\n    ]);\n  }\n  showTablesQuery(database) {\n    let query = \"SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'\";\n    if (database) {\n      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;\n    } else {\n      query += \" AND TABLE_SCHEMA NOT IN ('MYSQL', 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA')\";\n    }\n    return `${query};`;\n  }\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, \"`\"), \"`\");\n  }\n}\nmodule.exports = MariaDBQueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL3F1ZXJ5LWdlbmVyYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQU8sQ0FBQyxrSEFBMEI7QUFDOUQsY0FBYyxtQkFBTyxDQUFDLDhFQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDZCQUE2QjtBQUMvRSw0Q0FBNEMsNkJBQTZCO0FBQ3pFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsOEJBQThCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5QkFBeUI7QUFDNUQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVELE1BQU07QUFDTjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21hcmlhZGIvcXVlcnktZ2VuZXJhdG9yLmpzP2VmNjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG5jb25zdCBNeVNRTFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZShcIi4uL215c3FsL3F1ZXJ5LWdlbmVyYXRvclwiKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4vLi4vLi4vdXRpbHNcIik7XG5jbGFzcyBNYXJpYURCUXVlcnlHZW5lcmF0b3IgZXh0ZW5kcyBNeVNRTFF1ZXJ5R2VuZXJhdG9yIHtcbiAgY3JlYXRlU2NoZW1hKHNjaGVtYSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBjaGFyc2V0OiBudWxsLFxuICAgICAgY29sbGF0ZTogbnVsbFxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQ1JFQVRFIFNDSEVNQSBJRiBOT1QgRVhJU1RTXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihzY2hlbWEpLFxuICAgICAgb3B0aW9ucy5jaGFyc2V0ICYmIGBERUZBVUxUIENIQVJBQ1RFUiBTRVQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmNoYXJzZXQpfWAsXG4gICAgICBvcHRpb25zLmNvbGxhdGUgJiYgYERFRkFVTFQgQ09MTEFURSAke3RoaXMuZXNjYXBlKG9wdGlvbnMuY29sbGF0ZSl9YCxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgZHJvcFNjaGVtYShzY2hlbWEpIHtcbiAgICByZXR1cm4gYERST1AgU0NIRU1BIElGIEVYSVNUUyAke3RoaXMucXVvdGVJZGVudGlmaWVyKHNjaGVtYSl9O2A7XG4gIH1cbiAgc2hvd1NjaGVtYXNRdWVyeShvcHRpb25zKSB7XG4gICAgY29uc3Qgc2NoZW1hc1RvU2tpcCA9IFtcbiAgICAgIFwiJ01ZU1FMJ1wiLFxuICAgICAgXCInSU5GT1JNQVRJT05fU0NIRU1BJ1wiLFxuICAgICAgXCInUEVSRk9STUFOQ0VfU0NIRU1BJ1wiXG4gICAgXTtcbiAgICBpZiAob3B0aW9ucy5za2lwICYmIEFycmF5LmlzQXJyYXkob3B0aW9ucy5za2lwKSAmJiBvcHRpb25zLnNraXAubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBzY2hlbWFOYW1lIG9mIG9wdGlvbnMuc2tpcCkge1xuICAgICAgICBzY2hlbWFzVG9Ta2lwLnB1c2godGhpcy5lc2NhcGUoc2NoZW1hTmFtZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIlNFTEVDVCBTQ0hFTUFfTkFNRSBhcyBzY2hlbWFfbmFtZVwiLFxuICAgICAgXCJGUk9NIElORk9STUFUSU9OX1NDSEVNQS5TQ0hFTUFUQVwiLFxuICAgICAgYFdIRVJFIFNDSEVNQV9OQU1FIE5PVCBJTiAoJHtzY2hlbWFzVG9Ta2lwLmpvaW4oXCIsIFwiKX0pYCxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgc2hvd1RhYmxlc1F1ZXJ5KGRhdGFiYXNlKSB7XG4gICAgbGV0IHF1ZXJ5ID0gXCJTRUxFQ1QgVEFCTEVfTkFNRSwgVEFCTEVfU0NIRU1BIEZST00gSU5GT1JNQVRJT05fU0NIRU1BLlRBQkxFUyBXSEVSRSBUQUJMRV9UWVBFID0gJ0JBU0UgVEFCTEUnXCI7XG4gICAgaWYgKGRhdGFiYXNlKSB7XG4gICAgICBxdWVyeSArPSBgIEFORCBUQUJMRV9TQ0hFTUEgPSAke3RoaXMuZXNjYXBlKGRhdGFiYXNlKX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeSArPSBcIiBBTkQgVEFCTEVfU0NIRU1BIE5PVCBJTiAoJ01ZU1FMJywgJ0lORk9STUFUSU9OX1NDSEVNQScsICdQRVJGT1JNQU5DRV9TQ0hFTUEnKVwiO1xuICAgIH1cbiAgICByZXR1cm4gYCR7cXVlcnl9O2A7XG4gIH1cbiAgcXVvdGVJZGVudGlmaWVyKGlkZW50aWZpZXIsIGZvcmNlKSB7XG4gICAgcmV0dXJuIFV0aWxzLmFkZFRpY2tzKFV0aWxzLnJlbW92ZVRpY2tzKGlkZW50aWZpZXIsIFwiYFwiKSwgXCJgXCIpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IE1hcmlhREJRdWVyeUdlbmVyYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWdlbmVyYXRvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/mariadb/query-generator.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/mariadb/query.js":
/*!***************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/mariadb/query.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(action-browser)/../node_modules/sequelize/lib/utils/logger.js\");\nconst ER_DUP_ENTRY = 1062;\nconst ER_DEADLOCK = 1213;\nconst ER_ROW_IS_REFERENCED = 1451;\nconst ER_NO_REFERENCED_ROW = 1452;\nconst debug = logger.debugContext(\"sql:mariadb\");\nclass Query extends AbstractQuery {\n  constructor(connection, sequelize, options) {\n    super(connection, sequelize, __spreadValues({ showWarnings: false }, options));\n  }\n  static formatBindParameters(sql, values, dialect) {\n    const bindParam = [];\n    const replacementFunc = (match, key, values_) => {\n      if (values_[key] !== void 0) {\n        bindParam.push(values_[key]);\n        return \"?\";\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, bindParam.length > 0 ? bindParam : void 0];\n  }\n  async run(sql, parameters) {\n    this.sql = sql;\n    const { connection, options } = this;\n    const showWarnings = this.sequelize.options.showWarnings || options.showWarnings;\n    const complete = this._logQuery(sql, debug, parameters);\n    if (parameters) {\n      debug(\"parameters(%j)\", parameters);\n    }\n    let results;\n    const errForStack = new Error();\n    try {\n      results = await connection.query(this.sql, parameters);\n    } catch (error) {\n      if (options.transaction && error.errno === ER_DEADLOCK) {\n        try {\n          await options.transaction.rollback();\n        } catch (error_) {\n        }\n        options.transaction.finished = \"rollback\";\n      }\n      error.sql = sql;\n      error.parameters = parameters;\n      throw this.formatError(error, errForStack.stack);\n    } finally {\n      complete();\n    }\n    if (showWarnings && results && results.warningStatus > 0) {\n      await this.logWarnings(results);\n    }\n    return this.formatResults(results);\n  }\n  formatResults(data) {\n    let result = this.instance;\n    if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery()) {\n      return data.affectedRows;\n    }\n    if (this.isUpsertQuery()) {\n      return [result, data.affectedRows === 1];\n    }\n    if (this.isInsertQuery(data)) {\n      this.handleInsertQuery(data);\n      if (!this.instance) {\n        if (this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n          const startId = data[this.getInsertIdField()];\n          result = new Array(data.affectedRows);\n          const pkField = this.model.rawAttributes[this.model.primaryKeyAttribute].field;\n          for (let i = 0; i < data.affectedRows; i++) {\n            result[i] = { [pkField]: startId + i };\n          }\n          return [result, data.affectedRows];\n        }\n        return [data[this.getInsertIdField()], data.affectedRows];\n      }\n    }\n    if (this.isSelectQuery()) {\n      this.handleJsonSelectQuery(data);\n      return this.handleSelectQuery(data);\n    }\n    if (this.isInsertQuery() || this.isUpdateQuery()) {\n      return [result, data.affectedRows];\n    }\n    if (this.isCallQuery()) {\n      return data[0];\n    }\n    if (this.isRawQuery()) {\n      const meta = data.meta;\n      delete data.meta;\n      return [data, meta];\n    }\n    if (this.isShowIndexesQuery()) {\n      return this.handleShowIndexesQuery(data);\n    }\n    if (this.isForeignKeysQuery() || this.isShowConstraintsQuery()) {\n      return data;\n    }\n    if (this.isShowTablesQuery()) {\n      return this.handleShowTablesQuery(data);\n    }\n    if (this.isDescribeQuery()) {\n      result = {};\n      for (const _result of data) {\n        result[_result.Field] = {\n          type: _result.Type.toLowerCase().startsWith(\"enum\") ? _result.Type.replace(/^enum/i, \"ENUM\") : _result.Type.toUpperCase(),\n          allowNull: _result.Null === \"YES\",\n          defaultValue: _result.Default,\n          primaryKey: _result.Key === \"PRI\",\n          autoIncrement: Object.prototype.hasOwnProperty.call(_result, \"Extra\") && _result.Extra.toLowerCase() === \"auto_increment\",\n          comment: _result.Comment ? _result.Comment : null\n        };\n      }\n      return result;\n    }\n    if (this.isVersionQuery()) {\n      return data[0].version;\n    }\n    return result;\n  }\n  handleJsonSelectQuery(rows) {\n    if (!this.model || !this.model.fieldRawAttributesMap) {\n      return;\n    }\n    for (const _field of Object.keys(this.model.fieldRawAttributesMap)) {\n      const modelField = this.model.fieldRawAttributesMap[_field];\n      if (modelField.type instanceof DataTypes.JSON) {\n        rows = rows.map((row) => {\n          if (row[modelField.fieldName] && typeof row[modelField.fieldName] === \"string\" && !this.connection.info.hasMinVersion(10, 5, 2)) {\n            row[modelField.fieldName] = JSON.parse(row[modelField.fieldName]);\n          }\n          if (DataTypes.JSON.parse) {\n            return DataTypes.JSON.parse(modelField, this.sequelize.options, row[modelField.fieldName]);\n          }\n          return row;\n        });\n      }\n    }\n  }\n  async logWarnings(results) {\n    const warningResults = await this.run(\"SHOW WARNINGS\");\n    const warningMessage = `MariaDB Warnings (${this.connection.uuid || \"default\"}): `;\n    const messages = [];\n    for (const _warningRow of warningResults) {\n      if (_warningRow === void 0 || typeof _warningRow[Symbol.iterator] !== \"function\") {\n        continue;\n      }\n      for (const _warningResult of _warningRow) {\n        if (Object.prototype.hasOwnProperty.call(_warningResult, \"Message\")) {\n          messages.push(_warningResult.Message);\n        } else {\n          for (const _objectKey of _warningResult.keys()) {\n            messages.push([_objectKey, _warningResult[_objectKey]].join(\": \"));\n          }\n        }\n      }\n    }\n    this.sequelize.log(warningMessage + messages.join(\"; \"), this.options);\n    return results;\n  }\n  formatError(err, errStack) {\n    switch (err.errno) {\n      case ER_DUP_ENTRY: {\n        const match = err.message.match(/Duplicate entry '([\\s\\S]*)' for key '?((.|\\s)*?)'?\\s.*$/);\n        let fields = {};\n        let message = \"Validation error\";\n        const values = match ? match[1].split(\"-\") : void 0;\n        const fieldKey = match ? match[2] : void 0;\n        const fieldVal = match ? match[1] : void 0;\n        const uniqueKey = this.model && this.model.uniqueKeys[fieldKey];\n        if (uniqueKey) {\n          if (uniqueKey.msg)\n            message = uniqueKey.msg;\n          fields = _.zipObject(uniqueKey.fields, values);\n        } else {\n          fields[fieldKey] = fieldVal;\n        }\n        const errors = [];\n        _.forOwn(fields, (value, field) => {\n          errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, value, this.instance, \"not_unique\"));\n        });\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n      }\n      case ER_ROW_IS_REFERENCED:\n      case ER_NO_REFERENCED_ROW: {\n        const match = err.message.match(/CONSTRAINT ([`\"])(.*)\\1 FOREIGN KEY \\(\\1(.*)\\1\\) REFERENCES \\1(.*)\\1 \\(\\1(.*)\\1\\)/);\n        const quoteChar = match ? match[1] : \"`\";\n        const fields = match ? match[3].split(new RegExp(`${quoteChar}, *${quoteChar}`)) : void 0;\n        return new sequelizeErrors.ForeignKeyConstraintError({\n          reltype: err.errno === ER_ROW_IS_REFERENCED ? \"parent\" : \"child\",\n          table: match ? match[4] : void 0,\n          fields,\n          value: fields && fields.length && this.instance && this.instance[fields[0]] || void 0,\n          index: match ? match[2] : void 0,\n          parent: err,\n          stack: errStack\n        });\n      }\n      default:\n        return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n    }\n  }\n  handleShowTablesQuery(results) {\n    return results.map((resultSet) => ({\n      tableName: resultSet.TABLE_NAME,\n      schema: resultSet.TABLE_SCHEMA\n    }));\n  }\n  handleShowIndexesQuery(data) {\n    let currItem;\n    const result = [];\n    data.forEach((item) => {\n      if (!currItem || currItem.name !== item.Key_name) {\n        currItem = {\n          primary: item.Key_name === \"PRIMARY\",\n          fields: [],\n          name: item.Key_name,\n          tableName: item.Table,\n          unique: item.Non_unique !== 1,\n          type: item.Index_type\n        };\n        result.push(currItem);\n      }\n      currItem.fields[item.Seq_in_index - 1] = {\n        attribute: item.Column_name,\n        length: item.Sub_part || void 0,\n        order: item.Collation === \"A\" ? \"ASC\" : void 0\n      };\n    });\n    return result;\n  }\n}\nmodule.exports = Query;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL3F1ZXJ5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLG9HQUFtQjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQyxvRkFBYztBQUM5QyxVQUFVLG1CQUFPLENBQUMsaUVBQVE7QUFDMUIsa0JBQWtCLG1CQUFPLENBQUMsc0ZBQWtCO0FBQzVDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsMEZBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsa0NBQWtDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkRBQTJELHVEQUF1RDtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFVBQVUsS0FBSyxVQUFVO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdEQUF3RCxpQkFBaUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21hcmlhZGIvcXVlcnkuanM/YmUwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbmNvbnN0IEFic3RyYWN0UXVlcnkgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnlcIik7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzXCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvbG9nZ2VyXCIpO1xuY29uc3QgRVJfRFVQX0VOVFJZID0gMTA2MjtcbmNvbnN0IEVSX0RFQURMT0NLID0gMTIxMztcbmNvbnN0IEVSX1JPV19JU19SRUZFUkVOQ0VEID0gMTQ1MTtcbmNvbnN0IEVSX05PX1JFRkVSRU5DRURfUk9XID0gMTQ1MjtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dChcInNxbDptYXJpYWRiXCIpO1xuY2xhc3MgUXVlcnkgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5IHtcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbiwgc2VxdWVsaXplLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoY29ubmVjdGlvbiwgc2VxdWVsaXplLCBfX3NwcmVhZFZhbHVlcyh7IHNob3dXYXJuaW5nczogZmFsc2UgfSwgb3B0aW9ucykpO1xuICB9XG4gIHN0YXRpYyBmb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCkge1xuICAgIGNvbnN0IGJpbmRQYXJhbSA9IFtdO1xuICAgIGNvbnN0IHJlcGxhY2VtZW50RnVuYyA9IChtYXRjaCwga2V5LCB2YWx1ZXNfKSA9PiB7XG4gICAgICBpZiAodmFsdWVzX1trZXldICE9PSB2b2lkIDApIHtcbiAgICAgICAgYmluZFBhcmFtLnB1c2godmFsdWVzX1trZXldKTtcbiAgICAgICAgcmV0dXJuIFwiP1wiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuICAgIHNxbCA9IEFic3RyYWN0UXVlcnkuZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QsIHJlcGxhY2VtZW50RnVuYylbMF07XG4gICAgcmV0dXJuIFtzcWwsIGJpbmRQYXJhbS5sZW5ndGggPiAwID8gYmluZFBhcmFtIDogdm9pZCAwXTtcbiAgfVxuICBhc3luYyBydW4oc3FsLCBwYXJhbWV0ZXJzKSB7XG4gICAgdGhpcy5zcWwgPSBzcWw7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uLCBvcHRpb25zIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNob3dXYXJuaW5ncyA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuc2hvd1dhcm5pbmdzIHx8IG9wdGlvbnMuc2hvd1dhcm5pbmdzO1xuICAgIGNvbnN0IGNvbXBsZXRlID0gdGhpcy5fbG9nUXVlcnkoc3FsLCBkZWJ1ZywgcGFyYW1ldGVycyk7XG4gICAgaWYgKHBhcmFtZXRlcnMpIHtcbiAgICAgIGRlYnVnKFwicGFyYW1ldGVycyglailcIiwgcGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGxldCByZXN1bHRzO1xuICAgIGNvbnN0IGVyckZvclN0YWNrID0gbmV3IEVycm9yKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdHMgPSBhd2FpdCBjb25uZWN0aW9uLnF1ZXJ5KHRoaXMuc3FsLCBwYXJhbWV0ZXJzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gJiYgZXJyb3IuZXJybm8gPT09IEVSX0RFQURMT0NLKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgb3B0aW9ucy50cmFuc2FjdGlvbi5yb2xsYmFjaygpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcl8pIHtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnRyYW5zYWN0aW9uLmZpbmlzaGVkID0gXCJyb2xsYmFja1wiO1xuICAgICAgfVxuICAgICAgZXJyb3Iuc3FsID0gc3FsO1xuICAgICAgZXJyb3IucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICB0aHJvdyB0aGlzLmZvcm1hdEVycm9yKGVycm9yLCBlcnJGb3JTdGFjay5zdGFjayk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNvbXBsZXRlKCk7XG4gICAgfVxuICAgIGlmIChzaG93V2FybmluZ3MgJiYgcmVzdWx0cyAmJiByZXN1bHRzLndhcm5pbmdTdGF0dXMgPiAwKSB7XG4gICAgICBhd2FpdCB0aGlzLmxvZ1dhcm5pbmdzKHJlc3VsdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mb3JtYXRSZXN1bHRzKHJlc3VsdHMpO1xuICB9XG4gIGZvcm1hdFJlc3VsdHMoZGF0YSkge1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmluc3RhbmNlO1xuICAgIGlmICh0aGlzLmlzQnVsa1VwZGF0ZVF1ZXJ5KCkgfHwgdGhpcy5pc0J1bGtEZWxldGVRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YS5hZmZlY3RlZFJvd3M7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVXBzZXJ0UXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFtyZXN1bHQsIGRhdGEuYWZmZWN0ZWRSb3dzID09PSAxXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeShkYXRhKSkge1xuICAgICAgdGhpcy5oYW5kbGVJbnNlcnRRdWVyeShkYXRhKTtcbiAgICAgIGlmICghdGhpcy5pbnN0YW5jZSkge1xuICAgICAgICBpZiAodGhpcy5tb2RlbCAmJiB0aGlzLm1vZGVsLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUgJiYgdGhpcy5tb2RlbC5hdXRvSW5jcmVtZW50QXR0cmlidXRlID09PSB0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGUgJiYgdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZV0pIHtcbiAgICAgICAgICBjb25zdCBzdGFydElkID0gZGF0YVt0aGlzLmdldEluc2VydElkRmllbGQoKV07XG4gICAgICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KGRhdGEuYWZmZWN0ZWRSb3dzKTtcbiAgICAgICAgICBjb25zdCBwa0ZpZWxkID0gdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZV0uZmllbGQ7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmFmZmVjdGVkUm93czsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSB7IFtwa0ZpZWxkXTogc3RhcnRJZCArIGkgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtyZXN1bHQsIGRhdGEuYWZmZWN0ZWRSb3dzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2RhdGFbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldLCBkYXRhLmFmZmVjdGVkUm93c107XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2VsZWN0UXVlcnkoKSkge1xuICAgICAgdGhpcy5oYW5kbGVKc29uU2VsZWN0UXVlcnkoZGF0YSk7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZWxlY3RRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeSgpIHx8IHRoaXMuaXNVcGRhdGVRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW3Jlc3VsdCwgZGF0YS5hZmZlY3RlZFJvd3NdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0NhbGxRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YVswXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNSYXdRdWVyeSgpKSB7XG4gICAgICBjb25zdCBtZXRhID0gZGF0YS5tZXRhO1xuICAgICAgZGVsZXRlIGRhdGEubWV0YTtcbiAgICAgIHJldHVybiBbZGF0YSwgbWV0YV07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd0luZGV4ZXNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0ZvcmVpZ25LZXlzUXVlcnkoKSB8fCB0aGlzLmlzU2hvd0NvbnN0cmFpbnRzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd1RhYmxlc1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNob3dUYWJsZXNRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNEZXNjcmliZVF1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBfcmVzdWx0IG9mIGRhdGEpIHtcbiAgICAgICAgcmVzdWx0W19yZXN1bHQuRmllbGRdID0ge1xuICAgICAgICAgIHR5cGU6IF9yZXN1bHQuVHlwZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJlbnVtXCIpID8gX3Jlc3VsdC5UeXBlLnJlcGxhY2UoL15lbnVtL2ksIFwiRU5VTVwiKSA6IF9yZXN1bHQuVHlwZS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgIGFsbG93TnVsbDogX3Jlc3VsdC5OdWxsID09PSBcIllFU1wiLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogX3Jlc3VsdC5EZWZhdWx0LFxuICAgICAgICAgIHByaW1hcnlLZXk6IF9yZXN1bHQuS2V5ID09PSBcIlBSSVwiLFxuICAgICAgICAgIGF1dG9JbmNyZW1lbnQ6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfcmVzdWx0LCBcIkV4dHJhXCIpICYmIF9yZXN1bHQuRXh0cmEudG9Mb3dlckNhc2UoKSA9PT0gXCJhdXRvX2luY3JlbWVudFwiLFxuICAgICAgICAgIGNvbW1lbnQ6IF9yZXN1bHQuQ29tbWVudCA/IF9yZXN1bHQuQ29tbWVudCA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVmVyc2lvblF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhWzBdLnZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaGFuZGxlSnNvblNlbGVjdFF1ZXJ5KHJvd3MpIHtcbiAgICBpZiAoIXRoaXMubW9kZWwgfHwgIXRoaXMubW9kZWwuZmllbGRSYXdBdHRyaWJ1dGVzTWFwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgX2ZpZWxkIG9mIE9iamVjdC5rZXlzKHRoaXMubW9kZWwuZmllbGRSYXdBdHRyaWJ1dGVzTWFwKSkge1xuICAgICAgY29uc3QgbW9kZWxGaWVsZCA9IHRoaXMubW9kZWwuZmllbGRSYXdBdHRyaWJ1dGVzTWFwW19maWVsZF07XG4gICAgICBpZiAobW9kZWxGaWVsZC50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkpTT04pIHtcbiAgICAgICAgcm93cyA9IHJvd3MubWFwKChyb3cpID0+IHtcbiAgICAgICAgICBpZiAocm93W21vZGVsRmllbGQuZmllbGROYW1lXSAmJiB0eXBlb2Ygcm93W21vZGVsRmllbGQuZmllbGROYW1lXSA9PT0gXCJzdHJpbmdcIiAmJiAhdGhpcy5jb25uZWN0aW9uLmluZm8uaGFzTWluVmVyc2lvbigxMCwgNSwgMikpIHtcbiAgICAgICAgICAgIHJvd1ttb2RlbEZpZWxkLmZpZWxkTmFtZV0gPSBKU09OLnBhcnNlKHJvd1ttb2RlbEZpZWxkLmZpZWxkTmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoRGF0YVR5cGVzLkpTT04ucGFyc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRhVHlwZXMuSlNPTi5wYXJzZShtb2RlbEZpZWxkLCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLCByb3dbbW9kZWxGaWVsZC5maWVsZE5hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGxvZ1dhcm5pbmdzKHJlc3VsdHMpIHtcbiAgICBjb25zdCB3YXJuaW5nUmVzdWx0cyA9IGF3YWl0IHRoaXMucnVuKFwiU0hPVyBXQVJOSU5HU1wiKTtcbiAgICBjb25zdCB3YXJuaW5nTWVzc2FnZSA9IGBNYXJpYURCIFdhcm5pbmdzICgke3RoaXMuY29ubmVjdGlvbi51dWlkIHx8IFwiZGVmYXVsdFwifSk6IGA7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IF93YXJuaW5nUm93IG9mIHdhcm5pbmdSZXN1bHRzKSB7XG4gICAgICBpZiAoX3dhcm5pbmdSb3cgPT09IHZvaWQgMCB8fCB0eXBlb2YgX3dhcm5pbmdSb3dbU3ltYm9sLml0ZXJhdG9yXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBfd2FybmluZ1Jlc3VsdCBvZiBfd2FybmluZ1Jvdykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF93YXJuaW5nUmVzdWx0LCBcIk1lc3NhZ2VcIikpIHtcbiAgICAgICAgICBtZXNzYWdlcy5wdXNoKF93YXJuaW5nUmVzdWx0Lk1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgX29iamVjdEtleSBvZiBfd2FybmluZ1Jlc3VsdC5rZXlzKCkpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goW19vYmplY3RLZXksIF93YXJuaW5nUmVzdWx0W19vYmplY3RLZXldXS5qb2luKFwiOiBcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNlcXVlbGl6ZS5sb2cod2FybmluZ01lc3NhZ2UgKyBtZXNzYWdlcy5qb2luKFwiOyBcIiksIHRoaXMub3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgZm9ybWF0RXJyb3IoZXJyLCBlcnJTdGFjaykge1xuICAgIHN3aXRjaCAoZXJyLmVycm5vKSB7XG4gICAgICBjYXNlIEVSX0RVUF9FTlRSWToge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9EdXBsaWNhdGUgZW50cnkgJyhbXFxzXFxTXSopJyBmb3Iga2V5ICc/KCgufFxccykqPyknP1xccy4qJC8pO1xuICAgICAgICBsZXQgZmllbGRzID0ge307XG4gICAgICAgIGxldCBtZXNzYWdlID0gXCJWYWxpZGF0aW9uIGVycm9yXCI7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQoXCItXCIpIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBmaWVsZEtleSA9IG1hdGNoID8gbWF0Y2hbMl0gOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IGZpZWxkVmFsID0gbWF0Y2ggPyBtYXRjaFsxXSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgdW5pcXVlS2V5ID0gdGhpcy5tb2RlbCAmJiB0aGlzLm1vZGVsLnVuaXF1ZUtleXNbZmllbGRLZXldO1xuICAgICAgICBpZiAodW5pcXVlS2V5KSB7XG4gICAgICAgICAgaWYgKHVuaXF1ZUtleS5tc2cpXG4gICAgICAgICAgICBtZXNzYWdlID0gdW5pcXVlS2V5Lm1zZztcbiAgICAgICAgICBmaWVsZHMgPSBfLnppcE9iamVjdCh1bmlxdWVLZXkuZmllbGRzLCB2YWx1ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpZWxkc1tmaWVsZEtleV0gPSBmaWVsZFZhbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgXy5mb3JPd24oZmllbGRzLCAodmFsdWUsIGZpZWxkKSA9PiB7XG4gICAgICAgICAgZXJyb3JzLnB1c2gobmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3JJdGVtKHRoaXMuZ2V0VW5pcXVlQ29uc3RyYWludEVycm9yTWVzc2FnZShmaWVsZCksIFwidW5pcXVlIHZpb2xhdGlvblwiLCBmaWVsZCwgdmFsdWUsIHRoaXMuaW5zdGFuY2UsIFwibm90X3VuaXF1ZVwiKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5VbmlxdWVDb25zdHJhaW50RXJyb3IoeyBtZXNzYWdlLCBlcnJvcnMsIHBhcmVudDogZXJyLCBmaWVsZHMsIHN0YWNrOiBlcnJTdGFjayB9KTtcbiAgICAgIH1cbiAgICAgIGNhc2UgRVJfUk9XX0lTX1JFRkVSRU5DRUQ6XG4gICAgICBjYXNlIEVSX05PX1JFRkVSRU5DRURfUk9XOiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL0NPTlNUUkFJTlQgKFtgXCJdKSguKilcXDEgRk9SRUlHTiBLRVkgXFwoXFwxKC4qKVxcMVxcKSBSRUZFUkVOQ0VTIFxcMSguKilcXDEgXFwoXFwxKC4qKVxcMVxcKS8pO1xuICAgICAgICBjb25zdCBxdW90ZUNoYXIgPSBtYXRjaCA/IG1hdGNoWzFdIDogXCJgXCI7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IG1hdGNoID8gbWF0Y2hbM10uc3BsaXQobmV3IFJlZ0V4cChgJHtxdW90ZUNoYXJ9LCAqJHtxdW90ZUNoYXJ9YCkpIDogdm9pZCAwO1xuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5Gb3JlaWduS2V5Q29uc3RyYWludEVycm9yKHtcbiAgICAgICAgICByZWx0eXBlOiBlcnIuZXJybm8gPT09IEVSX1JPV19JU19SRUZFUkVOQ0VEID8gXCJwYXJlbnRcIiA6IFwiY2hpbGRcIixcbiAgICAgICAgICB0YWJsZTogbWF0Y2ggPyBtYXRjaFs0XSA6IHZvaWQgMCxcbiAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgdmFsdWU6IGZpZWxkcyAmJiBmaWVsZHMubGVuZ3RoICYmIHRoaXMuaW5zdGFuY2UgJiYgdGhpcy5pbnN0YW5jZVtmaWVsZHNbMF1dIHx8IHZvaWQgMCxcbiAgICAgICAgICBpbmRleDogbWF0Y2ggPyBtYXRjaFsyXSA6IHZvaWQgMCxcbiAgICAgICAgICBwYXJlbnQ6IGVycixcbiAgICAgICAgICBzdGFjazogZXJyU3RhY2tcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5EYXRhYmFzZUVycm9yKGVyciwgeyBzdGFjazogZXJyU3RhY2sgfSk7XG4gICAgfVxuICB9XG4gIGhhbmRsZVNob3dUYWJsZXNRdWVyeShyZXN1bHRzKSB7XG4gICAgcmV0dXJuIHJlc3VsdHMubWFwKChyZXN1bHRTZXQpID0+ICh7XG4gICAgICB0YWJsZU5hbWU6IHJlc3VsdFNldC5UQUJMRV9OQU1FLFxuICAgICAgc2NoZW1hOiByZXN1bHRTZXQuVEFCTEVfU0NIRU1BXG4gICAgfSkpO1xuICB9XG4gIGhhbmRsZVNob3dJbmRleGVzUXVlcnkoZGF0YSkge1xuICAgIGxldCBjdXJySXRlbTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBkYXRhLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGlmICghY3Vyckl0ZW0gfHwgY3Vyckl0ZW0ubmFtZSAhPT0gaXRlbS5LZXlfbmFtZSkge1xuICAgICAgICBjdXJySXRlbSA9IHtcbiAgICAgICAgICBwcmltYXJ5OiBpdGVtLktleV9uYW1lID09PSBcIlBSSU1BUllcIixcbiAgICAgICAgICBmaWVsZHM6IFtdLFxuICAgICAgICAgIG5hbWU6IGl0ZW0uS2V5X25hbWUsXG4gICAgICAgICAgdGFibGVOYW1lOiBpdGVtLlRhYmxlLFxuICAgICAgICAgIHVuaXF1ZTogaXRlbS5Ob25fdW5pcXVlICE9PSAxLFxuICAgICAgICAgIHR5cGU6IGl0ZW0uSW5kZXhfdHlwZVxuICAgICAgICB9O1xuICAgICAgICByZXN1bHQucHVzaChjdXJySXRlbSk7XG4gICAgICB9XG4gICAgICBjdXJySXRlbS5maWVsZHNbaXRlbS5TZXFfaW5faW5kZXggLSAxXSA9IHtcbiAgICAgICAgYXR0cmlidXRlOiBpdGVtLkNvbHVtbl9uYW1lLFxuICAgICAgICBsZW5ndGg6IGl0ZW0uU3ViX3BhcnQgfHwgdm9pZCAwLFxuICAgICAgICBvcmRlcjogaXRlbS5Db2xsYXRpb24gPT09IFwiQVwiID8gXCJBU0NcIiA6IHZvaWQgMFxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnkuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/mariadb/query.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/mssql/async-queue.js":
/*!*******************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/mssql/async-queue.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  AsyncQueueError: () => AsyncQueueError,\n  default: () => async_queue_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ../../errors/base-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/base-error.js\"));\nvar import_connection_error = __toModule(__webpack_require__(/*! ../../errors/connection-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/connection-error.js\"));\nclass AsyncQueueError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeAsyncQueueError\";\n  }\n}\nclass AsyncQueue {\n  constructor() {\n    __publicField(this, \"previous\");\n    __publicField(this, \"closed\");\n    __publicField(this, \"rejectCurrent\");\n    this.previous = Promise.resolve();\n    this.closed = false;\n    this.rejectCurrent = () => {\n    };\n  }\n  close() {\n    this.closed = true;\n    this.rejectCurrent(new import_connection_error.default(new AsyncQueueError(\"the connection was closed before this query could finish executing\")));\n  }\n  enqueue(asyncFunction) {\n    return new Promise((resolve, reject) => {\n      this.previous = this.previous.then(() => {\n        this.rejectCurrent = reject;\n        if (this.closed) {\n          return reject(new import_connection_error.default(new AsyncQueueError(\"the connection was closed before this query could be executed\")));\n        }\n        return asyncFunction().then(resolve, reject);\n      });\n    });\n  }\n}\nvar async_queue_default = AsyncQueue;\n//# sourceMappingURL=async-queue.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9hc3luYy1xdWV1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyxtQkFBTyxDQUFDLG9HQUF5QjtBQUNwRSx5Q0FBeUMsbUJBQU8sQ0FBQyxnSEFBK0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL2FzeW5jLXF1ZXVlLmpzP2ZlOTciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgQXN5bmNRdWV1ZUVycm9yOiAoKSA9PiBBc3luY1F1ZXVlRXJyb3IsXG4gIGRlZmF1bHQ6ICgpID0+IGFzeW5jX3F1ZXVlX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9iYXNlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi4vLi4vZXJyb3JzL2Jhc2UtZXJyb3JcIikpO1xudmFyIGltcG9ydF9jb25uZWN0aW9uX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi4vLi4vZXJyb3JzL2Nvbm5lY3Rpb24tZXJyb3JcIikpO1xuY2xhc3MgQXN5bmNRdWV1ZUVycm9yIGV4dGVuZHMgaW1wb3J0X2Jhc2VfZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZUFzeW5jUXVldWVFcnJvclwiO1xuICB9XG59XG5jbGFzcyBBc3luY1F1ZXVlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByZXZpb3VzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjbG9zZWRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlamVjdEN1cnJlbnRcIik7XG4gICAgdGhpcy5wcmV2aW91cyA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5yZWplY3RDdXJyZW50ID0gKCkgPT4ge1xuICAgIH07XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgIHRoaXMucmVqZWN0Q3VycmVudChuZXcgaW1wb3J0X2Nvbm5lY3Rpb25fZXJyb3IuZGVmYXVsdChuZXcgQXN5bmNRdWV1ZUVycm9yKFwidGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZCBiZWZvcmUgdGhpcyBxdWVyeSBjb3VsZCBmaW5pc2ggZXhlY3V0aW5nXCIpKSk7XG4gIH1cbiAgZW5xdWV1ZShhc3luY0Z1bmN0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucHJldmlvdXMgPSB0aGlzLnByZXZpb3VzLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLnJlamVjdEN1cnJlbnQgPSByZWplY3Q7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IGltcG9ydF9jb25uZWN0aW9uX2Vycm9yLmRlZmF1bHQobmV3IEFzeW5jUXVldWVFcnJvcihcInRoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgYmVmb3JlIHRoaXMgcXVlcnkgY291bGQgYmUgZXhlY3V0ZWRcIikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN5bmNGdW5jdGlvbigpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG52YXIgYXN5bmNfcXVldWVfZGVmYXVsdCA9IEFzeW5jUXVldWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luYy1xdWV1ZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/mssql/async-queue.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/mssql/connection-manager.js":
/*!**************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/mssql/connection-manager.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst AsyncQueue = (__webpack_require__(/*! ./async-queue */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mssql/async-queue.js\")[\"default\"]);\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(action-browser)/../node_modules/sequelize/lib/utils/logger.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\").mssql);\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(action-browser)/../node_modules/sequelize/lib/dialects/parserStore.js\")(\"mssql\");\nconst debug = logger.debugContext(\"connection:mssql\");\nconst debugTedious = logger.debugContext(\"connection:mssql:tedious\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 1433;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"tedious\");\n    this.refreshTypeParser(DataTypes);\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  async connect(config) {\n    const connectionConfig = {\n      server: config.host,\n      authentication: {\n        type: \"default\",\n        options: {\n          userName: config.username || void 0,\n          password: config.password || void 0\n        }\n      },\n      options: {\n        port: parseInt(config.port, 10),\n        database: config.database,\n        trustServerCertificate: true\n      }\n    };\n    if (config.dialectOptions) {\n      if (config.dialectOptions.options && config.dialectOptions.options.instanceName) {\n        delete connectionConfig.options.port;\n      }\n      if (config.dialectOptions.authentication) {\n        Object.assign(connectionConfig.authentication, config.dialectOptions.authentication);\n      }\n      Object.assign(connectionConfig.options, config.dialectOptions.options);\n    }\n    try {\n      return await new Promise((resolve, reject) => {\n        const connection = new this.lib.Connection(connectionConfig);\n        if (connection.state === connection.STATE.INITIALIZED) {\n          connection.connect();\n        }\n        connection.queue = new AsyncQueue();\n        connection.lib = this.lib;\n        const connectHandler = (error) => {\n          connection.removeListener(\"end\", endHandler);\n          connection.removeListener(\"error\", errorHandler);\n          if (error)\n            return reject(error);\n          debug(\"connection acquired\");\n          resolve(connection);\n        };\n        const endHandler = () => {\n          connection.removeListener(\"connect\", connectHandler);\n          connection.removeListener(\"error\", errorHandler);\n          reject(new Error(\"Connection was closed by remote server\"));\n        };\n        const errorHandler = (error) => {\n          connection.removeListener(\"connect\", connectHandler);\n          connection.removeListener(\"end\", endHandler);\n          reject(error);\n        };\n        connection.once(\"error\", errorHandler);\n        connection.once(\"end\", endHandler);\n        connection.once(\"connect\", connectHandler);\n        connection.on(\"error\", (error) => {\n          switch (error.code) {\n            case \"ESOCKET\":\n            case \"ECONNRESET\":\n              this.pool.destroy(connection);\n          }\n        });\n        if (config.dialectOptions && config.dialectOptions.debug) {\n          connection.on(\"debug\", debugTedious.log.bind(debugTedious));\n        }\n      });\n    } catch (error) {\n      if (!error.code) {\n        throw new sequelizeErrors.ConnectionError(error);\n      }\n      switch (error.code) {\n        case \"ESOCKET\":\n          if (error.message.includes(\"connect EHOSTUNREACH\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes(\"connect ENETUNREACH\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes(\"connect EADDRNOTAVAIL\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes(\"connect EAFNOSUPPORT\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes(\"getaddrinfo ENOTFOUND\")) {\n            throw new sequelizeErrors.HostNotFoundError(error);\n          }\n          if (error.message.includes(\"connect ECONNREFUSED\")) {\n            throw new sequelizeErrors.ConnectionRefusedError(error);\n          }\n          throw new sequelizeErrors.ConnectionError(error);\n        case \"ER_ACCESS_DENIED_ERROR\":\n        case \"ELOGIN\":\n          throw new sequelizeErrors.AccessDeniedError(error);\n        case \"EINVAL\":\n          throw new sequelizeErrors.InvalidConnectionError(error);\n        default:\n          throw new sequelizeErrors.ConnectionError(error);\n      }\n    }\n  }\n  async disconnect(connection) {\n    if (connection.closed) {\n      return;\n    }\n    connection.queue.close();\n    return new Promise((resolve) => {\n      connection.on(\"end\", resolve);\n      connection.close();\n      debug(\"connection closed\");\n    });\n  }\n  validate(connection) {\n    return connection && (connection.loggedIn || connection.state.name === \"LoggedIn\");\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9jb25uZWN0aW9uLW1hbmFnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixrQ0FBa0MsbUJBQU8sQ0FBQyw4SEFBZ0M7QUFDMUUsbUJBQW1CLHFJQUFnQztBQUNuRCxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDBGQUFvQjtBQUMvQyx3QkFBd0IsbUJBQU8sQ0FBQyxvRkFBYztBQUM5QyxrQkFBa0IsbUhBQWlDO0FBQ25ELG9CQUFvQixtQkFBTyxDQUFDLDhGQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyx5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXNzcWwvY29ubmVjdGlvbi1tYW5hZ2VyLmpzPzVlZGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L2Nvbm5lY3Rpb24tbWFuYWdlclwiKTtcbmNvbnN0IEFzeW5jUXVldWUgPSByZXF1aXJlKFwiLi9hc3luYy1xdWV1ZVwiKS5kZWZhdWx0O1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9sb2dnZXJcIik7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIikubXNzcWw7XG5jb25zdCBwYXJzZXJTdG9yZSA9IHJlcXVpcmUoXCIuLi9wYXJzZXJTdG9yZVwiKShcIm1zc3FsXCIpO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KFwiY29ubmVjdGlvbjptc3NxbFwiKTtcbmNvbnN0IGRlYnVnVGVkaW91cyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoXCJjb25uZWN0aW9uOm1zc3FsOnRlZGlvdXNcIik7XG5jbGFzcyBDb25uZWN0aW9uTWFuYWdlciBleHRlbmRzIEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihkaWFsZWN0LCBzZXF1ZWxpemUpIHtcbiAgICBzZXF1ZWxpemUuY29uZmlnLnBvcnQgPSBzZXF1ZWxpemUuY29uZmlnLnBvcnQgfHwgMTQzMztcbiAgICBzdXBlcihkaWFsZWN0LCBzZXF1ZWxpemUpO1xuICAgIHRoaXMubGliID0gdGhpcy5fbG9hZERpYWxlY3RNb2R1bGUoXCJ0ZWRpb3VzXCIpO1xuICAgIHRoaXMucmVmcmVzaFR5cGVQYXJzZXIoRGF0YVR5cGVzKTtcbiAgfVxuICBfcmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGUpIHtcbiAgICBwYXJzZXJTdG9yZS5yZWZyZXNoKGRhdGFUeXBlKTtcbiAgfVxuICBfY2xlYXJUeXBlUGFyc2VyKCkge1xuICAgIHBhcnNlclN0b3JlLmNsZWFyKCk7XG4gIH1cbiAgYXN5bmMgY29ubmVjdChjb25maWcpIHtcbiAgICBjb25zdCBjb25uZWN0aW9uQ29uZmlnID0ge1xuICAgICAgc2VydmVyOiBjb25maWcuaG9zdCxcbiAgICAgIGF1dGhlbnRpY2F0aW9uOiB7XG4gICAgICAgIHR5cGU6IFwiZGVmYXVsdFwiLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgdXNlck5hbWU6IGNvbmZpZy51c2VybmFtZSB8fCB2b2lkIDAsXG4gICAgICAgICAgcGFzc3dvcmQ6IGNvbmZpZy5wYXNzd29yZCB8fCB2b2lkIDBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcG9ydDogcGFyc2VJbnQoY29uZmlnLnBvcnQsIDEwKSxcbiAgICAgICAgZGF0YWJhc2U6IGNvbmZpZy5kYXRhYmFzZSxcbiAgICAgICAgdHJ1c3RTZXJ2ZXJDZXJ0aWZpY2F0ZTogdHJ1ZVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGNvbmZpZy5kaWFsZWN0T3B0aW9ucykge1xuICAgICAgaWYgKGNvbmZpZy5kaWFsZWN0T3B0aW9ucy5vcHRpb25zICYmIGNvbmZpZy5kaWFsZWN0T3B0aW9ucy5vcHRpb25zLmluc3RhbmNlTmFtZSkge1xuICAgICAgICBkZWxldGUgY29ubmVjdGlvbkNvbmZpZy5vcHRpb25zLnBvcnQ7XG4gICAgICB9XG4gICAgICBpZiAoY29uZmlnLmRpYWxlY3RPcHRpb25zLmF1dGhlbnRpY2F0aW9uKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29ubmVjdGlvbkNvbmZpZy5hdXRoZW50aWNhdGlvbiwgY29uZmlnLmRpYWxlY3RPcHRpb25zLmF1dGhlbnRpY2F0aW9uKTtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5hc3NpZ24oY29ubmVjdGlvbkNvbmZpZy5vcHRpb25zLCBjb25maWcuZGlhbGVjdE9wdGlvbnMub3B0aW9ucyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gbmV3IHRoaXMubGliLkNvbm5lY3Rpb24oY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgIGlmIChjb25uZWN0aW9uLnN0YXRlID09PSBjb25uZWN0aW9uLlNUQVRFLklOSVRJQUxJWkVEKSB7XG4gICAgICAgICAgY29ubmVjdGlvbi5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGlvbi5xdWV1ZSA9IG5ldyBBc3luY1F1ZXVlKCk7XG4gICAgICAgIGNvbm5lY3Rpb24ubGliID0gdGhpcy5saWI7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RIYW5kbGVyID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLCBlbmRIYW5kbGVyKTtcbiAgICAgICAgICBjb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gYWNxdWlyZWRcIik7XG4gICAgICAgICAgcmVzb2x2ZShjb25uZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZW5kSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICBjb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKFwiY29ubmVjdFwiLCBjb25uZWN0SGFuZGxlcik7XG4gICAgICAgICAgY29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIGVycm9ySGFuZGxlcik7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNvbm5lY3Rpb24gd2FzIGNsb3NlZCBieSByZW1vdGUgc2VydmVyXCIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcihcImNvbm5lY3RcIiwgY29ubmVjdEhhbmRsZXIpO1xuICAgICAgICAgIGNvbm5lY3Rpb24ucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIiwgZW5kSGFuZGxlcik7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29ubmVjdGlvbi5vbmNlKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgY29ubmVjdGlvbi5vbmNlKFwiZW5kXCIsIGVuZEhhbmRsZXIpO1xuICAgICAgICBjb25uZWN0aW9uLm9uY2UoXCJjb25uZWN0XCIsIGNvbm5lY3RIYW5kbGVyKTtcbiAgICAgICAgY29ubmVjdGlvbi5vbihcImVycm9yXCIsIChlcnJvcikgPT4ge1xuICAgICAgICAgIHN3aXRjaCAoZXJyb3IuY29kZSkge1xuICAgICAgICAgICAgY2FzZSBcIkVTT0NLRVRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJFQ09OTlJFU0VUXCI6XG4gICAgICAgICAgICAgIHRoaXMucG9vbC5kZXN0cm95KGNvbm5lY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb25maWcuZGlhbGVjdE9wdGlvbnMgJiYgY29uZmlnLmRpYWxlY3RPcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgY29ubmVjdGlvbi5vbihcImRlYnVnXCIsIGRlYnVnVGVkaW91cy5sb2cuYmluZChkZWJ1Z1RlZGlvdXMpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZXJyb3IuY29kZSkge1xuICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25FcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGVycm9yLmNvZGUpIHtcbiAgICAgICAgY2FzZSBcIkVTT0NLRVRcIjpcbiAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcImNvbm5lY3QgRUhPU1RVTlJFQUNIXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkhvc3ROb3RSZWFjaGFibGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiY29ubmVjdCBFTkVUVU5SRUFDSFwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90UmVhY2hhYmxlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcImNvbm5lY3QgRUFERFJOT1RBVkFJTFwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90UmVhY2hhYmxlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcImNvbm5lY3QgRUFGTk9TVVBQT1JUXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkhvc3ROb3RSZWFjaGFibGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiZ2V0YWRkcmluZm8gRU5PVEZPVU5EXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkhvc3ROb3RGb3VuZEVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJjb25uZWN0IEVDT05OUkVGVVNFRFwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uUmVmdXNlZEVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uRXJyb3IoZXJyb3IpO1xuICAgICAgICBjYXNlIFwiRVJfQUNDRVNTX0RFTklFRF9FUlJPUlwiOlxuICAgICAgICBjYXNlIFwiRUxPR0lOXCI6XG4gICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5BY2Nlc3NEZW5pZWRFcnJvcihlcnJvcik7XG4gICAgICAgIGNhc2UgXCJFSU5WQUxcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkludmFsaWRDb25uZWN0aW9uRXJyb3IoZXJyb3IpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvbkVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgZGlzY29ubmVjdChjb25uZWN0aW9uKSB7XG4gICAgaWYgKGNvbm5lY3Rpb24uY2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbm5lY3Rpb24ucXVldWUuY2xvc2UoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbm5lY3Rpb24ub24oXCJlbmRcIiwgcmVzb2x2ZSk7XG4gICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gY2xvc2VkXCIpO1xuICAgIH0pO1xuICB9XG4gIHZhbGlkYXRlKGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gY29ubmVjdGlvbiAmJiAoY29ubmVjdGlvbi5sb2dnZWRJbiB8fCBjb25uZWN0aW9uLnN0YXRlLm5hbWUgPT09IFwiTG9nZ2VkSW5cIik7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uTWFuYWdlciA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb25NYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbi1tYW5hZ2VyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/mssql/connection-manager.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/mssql/data-types.js":
/*!******************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/mssql/data-types.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst moment = __webpack_require__(/*! moment */ \"(action-browser)/../node_modules/moment/moment.js\");\nmodule.exports = (BaseTypes) => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"https://msdn.microsoft.com/en-us/library/ms187752%28v=sql.110%29.aspx\");\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {\n      warn(`MSSQL does not support '${dataType.key}' with options. Plain '${dataType.key}' will be used instead.`);\n      dataType._length = void 0;\n      dataType.options.length = void 0;\n      dataType._unsigned = void 0;\n      dataType._zerofill = void 0;\n    }\n  }\n  BaseTypes.DATE.types.mssql = [43];\n  BaseTypes.STRING.types.mssql = [231, 173];\n  BaseTypes.CHAR.types.mssql = [175];\n  BaseTypes.TEXT.types.mssql = false;\n  BaseTypes.TINYINT.types.mssql = [30];\n  BaseTypes.SMALLINT.types.mssql = [34];\n  BaseTypes.MEDIUMINT.types.mssql = false;\n  BaseTypes.INTEGER.types.mssql = [38];\n  BaseTypes.BIGINT.types.mssql = false;\n  BaseTypes.FLOAT.types.mssql = [109];\n  BaseTypes.TIME.types.mssql = [41];\n  BaseTypes.DATEONLY.types.mssql = [40];\n  BaseTypes.BOOLEAN.types.mssql = [104];\n  BaseTypes.BLOB.types.mssql = [165];\n  BaseTypes.DECIMAL.types.mssql = [106];\n  BaseTypes.UUID.types.mssql = false;\n  BaseTypes.ENUM.types.mssql = false;\n  BaseTypes.REAL.types.mssql = [109];\n  BaseTypes.DOUBLE.types.mssql = [109];\n  BaseTypes.GEOMETRY.types.mssql = false;\n  class BLOB extends BaseTypes.BLOB {\n    toSql() {\n      if (this._length) {\n        if (this._length.toLowerCase() === \"tiny\") {\n          warn(\"MSSQL does not support BLOB with the `length` = `tiny` option. `VARBINARY(256)` will be used instead.\");\n          return \"VARBINARY(256)\";\n        }\n        warn(\"MSSQL does not support BLOB with the `length` option. `VARBINARY(MAX)` will be used instead.\");\n      }\n      return \"VARBINARY(MAX)\";\n    }\n    _hexify(hex) {\n      return `0x${hex}`;\n    }\n  }\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (!this._binary) {\n        return `NVARCHAR(${this._length})`;\n      }\n      return `BINARY(${this._length})`;\n    }\n    _stringify(value, options) {\n      if (this._binary) {\n        return BLOB.prototype._stringify(value);\n      }\n      return options.escape(value);\n    }\n    _bindParam(value, options) {\n      return options.bindParam(this._binary ? Buffer.from(value) : value);\n    }\n  }\n  STRING.prototype.escape = false;\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      if (this._length) {\n        if (this._length.toLowerCase() === \"tiny\") {\n          warn(\"MSSQL does not support TEXT with the `length` = `tiny` option. `NVARCHAR(256)` will be used instead.\");\n          return \"NVARCHAR(256)\";\n        }\n        warn(\"MSSQL does not support TEXT with the `length` option. `NVARCHAR(MAX)` will be used instead.\");\n      }\n      return \"NVARCHAR(MAX)\";\n    }\n  }\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"BIT\";\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"CHAR(36)\";\n    }\n  }\n  class NOW extends BaseTypes.NOW {\n    toSql() {\n      return \"GETDATE()\";\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return \"DATETIMEOFFSET\";\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return moment(value).format(\"YYYY-MM-DD\");\n    }\n  }\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class REAL extends BaseTypes.REAL {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (this._length || this.options.length || this._unsigned || this._zerofill) {\n        warn(\"MSSQL does not support REAL with options. Plain `REAL` will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n    }\n  }\n  class FLOAT extends BaseTypes.FLOAT {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (this._decimals) {\n        warn(\"MSSQL does not support Float with decimals. Plain `FLOAT` will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n      }\n      if (this._unsigned) {\n        warn(\"MSSQL does not support Float unsigned. `UNSIGNED` was removed.\");\n        this._unsigned = void 0;\n      }\n      if (this._zerofill) {\n        warn(\"MSSQL does not support Float zerofill. `ZEROFILL` was removed.\");\n        this._zerofill = void 0;\n      }\n    }\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return \"VARCHAR(255)\";\n    }\n  }\n  return {\n    BLOB,\n    BOOLEAN,\n    ENUM,\n    STRING,\n    UUID,\n    DATE,\n    DATEONLY,\n    NOW,\n    TINYINT,\n    SMALLINT,\n    INTEGER,\n    BIGINT,\n    REAL,\n    FLOAT,\n    TEXT\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9kYXRhLXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsZUFBZSxtQkFBTyxDQUFDLGlFQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGFBQWEseUJBQXlCLGFBQWE7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL2RhdGEtdHlwZXMuanM/MWQ1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IG1vbWVudCA9IHJlcXVpcmUoXCJtb21lbnRcIik7XG5tb2R1bGUuZXhwb3J0cyA9IChCYXNlVHlwZXMpID0+IHtcbiAgY29uc3Qgd2FybiA9IEJhc2VUeXBlcy5BQlNUUkFDVC53YXJuLmJpbmQodm9pZCAwLCBcImh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXMxODc3NTIlMjh2PXNxbC4xMTAlMjkuYXNweFwiKTtcbiAgZnVuY3Rpb24gcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyhkYXRhVHlwZSkge1xuICAgIGlmIChkYXRhVHlwZS5fbGVuZ3RoIHx8IGRhdGFUeXBlLm9wdGlvbnMubGVuZ3RoIHx8IGRhdGFUeXBlLl91bnNpZ25lZCB8fCBkYXRhVHlwZS5femVyb2ZpbGwpIHtcbiAgICAgIHdhcm4oYE1TU1FMIGRvZXMgbm90IHN1cHBvcnQgJyR7ZGF0YVR5cGUua2V5fScgd2l0aCBvcHRpb25zLiBQbGFpbiAnJHtkYXRhVHlwZS5rZXl9JyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5gKTtcbiAgICAgIGRhdGFUeXBlLl9sZW5ndGggPSB2b2lkIDA7XG4gICAgICBkYXRhVHlwZS5vcHRpb25zLmxlbmd0aCA9IHZvaWQgMDtcbiAgICAgIGRhdGFUeXBlLl91bnNpZ25lZCA9IHZvaWQgMDtcbiAgICAgIGRhdGFUeXBlLl96ZXJvZmlsbCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgQmFzZVR5cGVzLkRBVEUudHlwZXMubXNzcWwgPSBbNDNdO1xuICBCYXNlVHlwZXMuU1RSSU5HLnR5cGVzLm1zc3FsID0gWzIzMSwgMTczXTtcbiAgQmFzZVR5cGVzLkNIQVIudHlwZXMubXNzcWwgPSBbMTc1XTtcbiAgQmFzZVR5cGVzLlRFWFQudHlwZXMubXNzcWwgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLlRJTllJTlQudHlwZXMubXNzcWwgPSBbMzBdO1xuICBCYXNlVHlwZXMuU01BTExJTlQudHlwZXMubXNzcWwgPSBbMzRdO1xuICBCYXNlVHlwZXMuTUVESVVNSU5ULnR5cGVzLm1zc3FsID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5JTlRFR0VSLnR5cGVzLm1zc3FsID0gWzM4XTtcbiAgQmFzZVR5cGVzLkJJR0lOVC50eXBlcy5tc3NxbCA9IGZhbHNlO1xuICBCYXNlVHlwZXMuRkxPQVQudHlwZXMubXNzcWwgPSBbMTA5XTtcbiAgQmFzZVR5cGVzLlRJTUUudHlwZXMubXNzcWwgPSBbNDFdO1xuICBCYXNlVHlwZXMuREFURU9OTFkudHlwZXMubXNzcWwgPSBbNDBdO1xuICBCYXNlVHlwZXMuQk9PTEVBTi50eXBlcy5tc3NxbCA9IFsxMDRdO1xuICBCYXNlVHlwZXMuQkxPQi50eXBlcy5tc3NxbCA9IFsxNjVdO1xuICBCYXNlVHlwZXMuREVDSU1BTC50eXBlcy5tc3NxbCA9IFsxMDZdO1xuICBCYXNlVHlwZXMuVVVJRC50eXBlcy5tc3NxbCA9IGZhbHNlO1xuICBCYXNlVHlwZXMuRU5VTS50eXBlcy5tc3NxbCA9IGZhbHNlO1xuICBCYXNlVHlwZXMuUkVBTC50eXBlcy5tc3NxbCA9IFsxMDldO1xuICBCYXNlVHlwZXMuRE9VQkxFLnR5cGVzLm1zc3FsID0gWzEwOV07XG4gIEJhc2VUeXBlcy5HRU9NRVRSWS50eXBlcy5tc3NxbCA9IGZhbHNlO1xuICBjbGFzcyBCTE9CIGV4dGVuZHMgQmFzZVR5cGVzLkJMT0Ige1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoLnRvTG93ZXJDYXNlKCkgPT09IFwidGlueVwiKSB7XG4gICAgICAgICAgd2FybihcIk1TU1FMIGRvZXMgbm90IHN1cHBvcnQgQkxPQiB3aXRoIHRoZSBgbGVuZ3RoYCA9IGB0aW55YCBvcHRpb24uIGBWQVJCSU5BUlkoMjU2KWAgd2lsbCBiZSB1c2VkIGluc3RlYWQuXCIpO1xuICAgICAgICAgIHJldHVybiBcIlZBUkJJTkFSWSgyNTYpXCI7XG4gICAgICAgIH1cbiAgICAgICAgd2FybihcIk1TU1FMIGRvZXMgbm90IHN1cHBvcnQgQkxPQiB3aXRoIHRoZSBgbGVuZ3RoYCBvcHRpb24uIGBWQVJCSU5BUlkoTUFYKWAgd2lsbCBiZSB1c2VkIGluc3RlYWQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiVkFSQklOQVJZKE1BWClcIjtcbiAgICB9XG4gICAgX2hleGlmeShoZXgpIHtcbiAgICAgIHJldHVybiBgMHgke2hleH1gO1xuICAgIH1cbiAgfVxuICBjbGFzcyBTVFJJTkcgZXh0ZW5kcyBCYXNlVHlwZXMuU1RSSU5HIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICghdGhpcy5fYmluYXJ5KSB7XG4gICAgICAgIHJldHVybiBgTlZBUkNIQVIoJHt0aGlzLl9sZW5ndGh9KWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYEJJTkFSWSgke3RoaXMuX2xlbmd0aH0pYDtcbiAgICB9XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuX2JpbmFyeSkge1xuICAgICAgICByZXR1cm4gQkxPQi5wcm90b3R5cGUuX3N0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5lc2NhcGUodmFsdWUpO1xuICAgIH1cbiAgICBfYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5iaW5kUGFyYW0odGhpcy5fYmluYXJ5ID8gQnVmZmVyLmZyb20odmFsdWUpIDogdmFsdWUpO1xuICAgIH1cbiAgfVxuICBTVFJJTkcucHJvdG90eXBlLmVzY2FwZSA9IGZhbHNlO1xuICBjbGFzcyBURVhUIGV4dGVuZHMgQmFzZVR5cGVzLlRFWFQge1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoLnRvTG93ZXJDYXNlKCkgPT09IFwidGlueVwiKSB7XG4gICAgICAgICAgd2FybihcIk1TU1FMIGRvZXMgbm90IHN1cHBvcnQgVEVYVCB3aXRoIHRoZSBgbGVuZ3RoYCA9IGB0aW55YCBvcHRpb24uIGBOVkFSQ0hBUigyNTYpYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cIik7XG4gICAgICAgICAgcmV0dXJuIFwiTlZBUkNIQVIoMjU2KVwiO1xuICAgICAgICB9XG4gICAgICAgIHdhcm4oXCJNU1NRTCBkb2VzIG5vdCBzdXBwb3J0IFRFWFQgd2l0aCB0aGUgYGxlbmd0aGAgb3B0aW9uLiBgTlZBUkNIQVIoTUFYKWAgd2lsbCBiZSB1c2VkIGluc3RlYWQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiTlZBUkNIQVIoTUFYKVwiO1xuICAgIH1cbiAgfVxuICBjbGFzcyBCT09MRUFOIGV4dGVuZHMgQmFzZVR5cGVzLkJPT0xFQU4ge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiQklUXCI7XG4gICAgfVxuICB9XG4gIGNsYXNzIFVVSUQgZXh0ZW5kcyBCYXNlVHlwZXMuVVVJRCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJDSEFSKDM2KVwiO1xuICAgIH1cbiAgfVxuICBjbGFzcyBOT1cgZXh0ZW5kcyBCYXNlVHlwZXMuTk9XIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIkdFVERBVEUoKVwiO1xuICAgIH1cbiAgfVxuICBjbGFzcyBEQVRFIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEUge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiREFURVRJTUVPRkZTRVRcIjtcbiAgICB9XG4gIH1cbiAgY2xhc3MgREFURU9OTFkgZXh0ZW5kcyBCYXNlVHlwZXMuREFURU9OTFkge1xuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG1vbWVudCh2YWx1ZSkuZm9ybWF0KFwiWVlZWS1NTS1ERFwiKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgSU5URUdFUiBleHRlbmRzIEJhc2VUeXBlcy5JTlRFR0VSIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBUSU5ZSU5UIGV4dGVuZHMgQmFzZVR5cGVzLlRJTllJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIGNsYXNzIFNNQUxMSU5UIGV4dGVuZHMgQmFzZVR5cGVzLlNNQUxMSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBCSUdJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuQklHSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBSRUFMIGV4dGVuZHMgQmFzZVR5cGVzLlJFQUwge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgZGVjaW1hbHMpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCwgZGVjaW1hbHMpO1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCB8fCB0aGlzLm9wdGlvbnMubGVuZ3RoIHx8IHRoaXMuX3Vuc2lnbmVkIHx8IHRoaXMuX3plcm9maWxsKSB7XG4gICAgICAgIHdhcm4oXCJNU1NRTCBkb2VzIG5vdCBzdXBwb3J0IFJFQUwgd2l0aCBvcHRpb25zLiBQbGFpbiBgUkVBTGAgd2lsbCBiZSB1c2VkIGluc3RlYWQuXCIpO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSB2b2lkIDA7XG4gICAgICAgIHRoaXMub3B0aW9ucy5sZW5ndGggPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuX3Vuc2lnbmVkID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl96ZXJvZmlsbCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2xhc3MgRkxPQVQgZXh0ZW5kcyBCYXNlVHlwZXMuRkxPQVQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgZGVjaW1hbHMpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCwgZGVjaW1hbHMpO1xuICAgICAgaWYgKHRoaXMuX2RlY2ltYWxzKSB7XG4gICAgICAgIHdhcm4oXCJNU1NRTCBkb2VzIG5vdCBzdXBwb3J0IEZsb2F0IHdpdGggZGVjaW1hbHMuIFBsYWluIGBGTE9BVGAgd2lsbCBiZSB1c2VkIGluc3RlYWQuXCIpO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSB2b2lkIDA7XG4gICAgICAgIHRoaXMub3B0aW9ucy5sZW5ndGggPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fdW5zaWduZWQpIHtcbiAgICAgICAgd2FybihcIk1TU1FMIGRvZXMgbm90IHN1cHBvcnQgRmxvYXQgdW5zaWduZWQuIGBVTlNJR05FRGAgd2FzIHJlbW92ZWQuXCIpO1xuICAgICAgICB0aGlzLl91bnNpZ25lZCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl96ZXJvZmlsbCkge1xuICAgICAgICB3YXJuKFwiTVNTUUwgZG9lcyBub3Qgc3VwcG9ydCBGbG9hdCB6ZXJvZmlsbC4gYFpFUk9GSUxMYCB3YXMgcmVtb3ZlZC5cIik7XG4gICAgICAgIHRoaXMuX3plcm9maWxsID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjbGFzcyBFTlVNIGV4dGVuZHMgQmFzZVR5cGVzLkVOVU0ge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiVkFSQ0hBUigyNTUpXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgQkxPQixcbiAgICBCT09MRUFOLFxuICAgIEVOVU0sXG4gICAgU1RSSU5HLFxuICAgIFVVSUQsXG4gICAgREFURSxcbiAgICBEQVRFT05MWSxcbiAgICBOT1csXG4gICAgVElOWUlOVCxcbiAgICBTTUFMTElOVCxcbiAgICBJTlRFR0VSLFxuICAgIEJJR0lOVCxcbiAgICBSRUFMLFxuICAgIEZMT0FULFxuICAgIFRFWFRcbiAgfTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLXR5cGVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/mssql/data-types.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/mssql/index.js":
/*!*************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/mssql/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst AbstractDialect = __webpack_require__(/*! ../abstract */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst ConnectionManager = __webpack_require__(/*! ./connection-manager */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mssql/connection-manager.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mssql/query.js\");\nconst QueryGenerator = __webpack_require__(/*! ./query-generator */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mssql/query-generator.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\").mssql);\nconst { MSSqlQueryInterface } = __webpack_require__(/*! ./query-interface */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mssql/query-interface.js\");\nclass MssqlDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new MSSqlQueryInterface(sequelize, this.queryGenerator);\n  }\n}\nMssqlDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  DEFAULT: true,\n  \"DEFAULT VALUES\": true,\n  \"LIMIT ON UPDATE\": true,\n  \"ORDER NULLS\": false,\n  lock: false,\n  transactions: true,\n  migrations: false,\n  returnValues: {\n    output: true\n  },\n  schemas: true,\n  autoIncrement: {\n    identityInsert: true,\n    defaultValue: false,\n    update: false\n  },\n  constraints: {\n    restrict: false,\n    default: true\n  },\n  index: {\n    collate: false,\n    length: false,\n    parser: false,\n    type: true,\n    using: false,\n    where: true\n  },\n  NUMERIC: true,\n  tmpTableTrigger: true\n});\nMssqlDialect.prototype.defaultVersion = \"12.0.2000\";\nMssqlDialect.prototype.Query = Query;\nMssqlDialect.prototype.name = \"mssql\";\nMssqlDialect.prototype.TICK_CHAR = '\"';\nMssqlDialect.prototype.TICK_CHAR_LEFT = \"[\";\nMssqlDialect.prototype.TICK_CHAR_RIGHT = \"]\";\nMssqlDialect.prototype.DataTypes = DataTypes;\nmodule.exports = MssqlDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFVBQVUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMxQix3QkFBd0IsbUJBQU8sQ0FBQyw4RkFBYTtBQUM3QywwQkFBMEIsbUJBQU8sQ0FBQyxpSEFBc0I7QUFDeEQsY0FBYyxtQkFBTyxDQUFDLHVGQUFTO0FBQy9CLHVCQUF1QixtQkFBTyxDQUFDLDJHQUFtQjtBQUNsRCxrQkFBa0IsbUhBQWlDO0FBQ25ELFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQywyR0FBbUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9pbmRleC5qcz8xOWE0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBBYnN0cmFjdERpYWxlY3QgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3RcIik7XG5jb25zdCBDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24tbWFuYWdlclwiKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZShcIi4vcXVlcnlcIik7XG5jb25zdCBRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoXCIuL3F1ZXJ5LWdlbmVyYXRvclwiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpLm1zc3FsO1xuY29uc3QgeyBNU1NxbFF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKFwiLi9xdWVyeS1pbnRlcmZhY2VcIik7XG5jbGFzcyBNc3NxbERpYWxlY3QgZXh0ZW5kcyBBYnN0cmFjdERpYWxlY3Qge1xuICBjb25zdHJ1Y3RvcihzZXF1ZWxpemUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgQ29ubmVjdGlvbk1hbmFnZXIodGhpcywgc2VxdWVsaXplKTtcbiAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yID0gbmV3IFF1ZXJ5R2VuZXJhdG9yKHtcbiAgICAgIF9kaWFsZWN0OiB0aGlzLFxuICAgICAgc2VxdWVsaXplXG4gICAgfSk7XG4gICAgdGhpcy5xdWVyeUludGVyZmFjZSA9IG5ldyBNU1NxbFF1ZXJ5SW50ZXJmYWNlKHNlcXVlbGl6ZSwgdGhpcy5xdWVyeUdlbmVyYXRvcik7XG4gIH1cbn1cbk1zc3FsRGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMgPSBfLm1lcmdlKF8uY2xvbmVEZWVwKEFic3RyYWN0RGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMpLCB7XG4gIERFRkFVTFQ6IHRydWUsXG4gIFwiREVGQVVMVCBWQUxVRVNcIjogdHJ1ZSxcbiAgXCJMSU1JVCBPTiBVUERBVEVcIjogdHJ1ZSxcbiAgXCJPUkRFUiBOVUxMU1wiOiBmYWxzZSxcbiAgbG9jazogZmFsc2UsXG4gIHRyYW5zYWN0aW9uczogdHJ1ZSxcbiAgbWlncmF0aW9uczogZmFsc2UsXG4gIHJldHVyblZhbHVlczoge1xuICAgIG91dHB1dDogdHJ1ZVxuICB9LFxuICBzY2hlbWFzOiB0cnVlLFxuICBhdXRvSW5jcmVtZW50OiB7XG4gICAgaWRlbnRpdHlJbnNlcnQ6IHRydWUsXG4gICAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgICB1cGRhdGU6IGZhbHNlXG4gIH0sXG4gIGNvbnN0cmFpbnRzOiB7XG4gICAgcmVzdHJpY3Q6IGZhbHNlLFxuICAgIGRlZmF1bHQ6IHRydWVcbiAgfSxcbiAgaW5kZXg6IHtcbiAgICBjb2xsYXRlOiBmYWxzZSxcbiAgICBsZW5ndGg6IGZhbHNlLFxuICAgIHBhcnNlcjogZmFsc2UsXG4gICAgdHlwZTogdHJ1ZSxcbiAgICB1c2luZzogZmFsc2UsXG4gICAgd2hlcmU6IHRydWVcbiAgfSxcbiAgTlVNRVJJQzogdHJ1ZSxcbiAgdG1wVGFibGVUcmlnZ2VyOiB0cnVlXG59KTtcbk1zc3FsRGlhbGVjdC5wcm90b3R5cGUuZGVmYXVsdFZlcnNpb24gPSBcIjEyLjAuMjAwMFwiO1xuTXNzcWxEaWFsZWN0LnByb3RvdHlwZS5RdWVyeSA9IFF1ZXJ5O1xuTXNzcWxEaWFsZWN0LnByb3RvdHlwZS5uYW1lID0gXCJtc3NxbFwiO1xuTXNzcWxEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVIgPSAnXCInO1xuTXNzcWxEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfTEVGVCA9IFwiW1wiO1xuTXNzcWxEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfUklHSFQgPSBcIl1cIjtcbk1zc3FsRGlhbGVjdC5wcm90b3R5cGUuRGF0YVR5cGVzID0gRGF0YVR5cGVzO1xubW9kdWxlLmV4cG9ydHMgPSBNc3NxbERpYWxlY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/mssql/index.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/mssql/query-generator.js":
/*!***********************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/mssql/query-generator.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\");\nconst TableHints = __webpack_require__(/*! ../../table-hints */ \"(action-browser)/../node_modules/sequelize/lib/table-hints.js\");\nconst AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-generator.js\");\nconst randomBytes = (__webpack_require__(/*! crypto */ \"crypto\").randomBytes);\nconst semver = __webpack_require__(/*! semver */ \"(action-browser)/../node_modules/semver/index.js\");\nconst Op = __webpack_require__(/*! ../../operators */ \"(action-browser)/../node_modules/sequelize/lib/operators.js\");\nconst throwMethodUndefined = function(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n};\nclass MSSQLQueryGenerator extends AbstractQueryGenerator {\n  createDatabaseQuery(databaseName, options) {\n    options = __spreadValues({ collate: null }, options);\n    const collation = options.collate ? `COLLATE ${this.escape(options.collate)}` : \"\";\n    return [\n      \"IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =\",\n      wrapSingleQuote(databaseName),\n      \")\",\n      \"BEGIN\",\n      \"CREATE DATABASE\",\n      this.quoteIdentifier(databaseName),\n      `${collation};`,\n      \"END;\"\n    ].join(\" \");\n  }\n  dropDatabaseQuery(databaseName) {\n    return [\n      \"IF EXISTS (SELECT * FROM sys.databases WHERE name =\",\n      wrapSingleQuote(databaseName),\n      \")\",\n      \"BEGIN\",\n      \"DROP DATABASE\",\n      this.quoteIdentifier(databaseName),\n      \";\",\n      \"END;\"\n    ].join(\" \");\n  }\n  createSchema(schema) {\n    return [\n      \"IF NOT EXISTS (SELECT schema_name\",\n      \"FROM information_schema.schemata\",\n      \"WHERE schema_name =\",\n      wrapSingleQuote(schema),\n      \")\",\n      \"BEGIN\",\n      \"EXEC sp_executesql N'CREATE SCHEMA\",\n      this.quoteIdentifier(schema),\n      \";'\",\n      \"END;\"\n    ].join(\" \");\n  }\n  dropSchema(schema) {\n    const quotedSchema = wrapSingleQuote(schema);\n    return [\n      \"IF EXISTS (SELECT schema_name\",\n      \"FROM information_schema.schemata\",\n      \"WHERE schema_name =\",\n      quotedSchema,\n      \")\",\n      \"BEGIN\",\n      \"DECLARE @id INT, @ms_sql NVARCHAR(2000);\",\n      \"DECLARE @cascade TABLE (\",\n      \"id INT NOT NULL IDENTITY PRIMARY KEY,\",\n      \"ms_sql NVARCHAR(2000) NOT NULL );\",\n      \"INSERT INTO @cascade ( ms_sql )\",\n      \"SELECT CASE WHEN o.type IN ('F','PK')\",\n      \"THEN N'ALTER TABLE ['+ s.name + N'].[' + p.name + N'] DROP CONSTRAINT [' + o.name + N']'\",\n      \"ELSE N'DROP TABLE ['+ s.name + N'].[' + o.name + N']' END\",\n      \"FROM sys.objects o\",\n      \"JOIN sys.schemas s on o.schema_id = s.schema_id\",\n      \"LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id\",\n      \"WHERE o.type IN ('F', 'PK', 'U') AND s.name = \",\n      quotedSchema,\n      \"ORDER BY o.type ASC;\",\n      \"SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;\",\n      \"WHILE @id IS NOT NULL\",\n      \"BEGIN\",\n      \"BEGIN TRY EXEC sp_executesql @ms_sql; END TRY\",\n      \"BEGIN CATCH BREAK; THROW; END CATCH;\",\n      \"DELETE FROM @cascade WHERE id = @id;\",\n      \"SELECT @id = NULL, @ms_sql = NULL;\",\n      \"SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;\",\n      \"END\",\n      \"EXEC sp_executesql N'DROP SCHEMA\",\n      this.quoteIdentifier(schema),\n      \";'\",\n      \"END;\"\n    ].join(\" \");\n  }\n  showSchemasQuery() {\n    return [\n      'SELECT \"name\" as \"schema_name\" FROM sys.schemas as s',\n      'WHERE \"s\".\"name\" NOT IN (',\n      \"'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'\",\n      \")\",\n      \"AND\",\n      '\"s\".\"name\" NOT LIKE',\n      \"'db_%'\"\n    ].join(\" \");\n  }\n  versionQuery() {\n    return [\n      \"DECLARE @ms_ver NVARCHAR(20);\",\n      \"SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));\",\n      \"SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'\"\n    ].join(\" \");\n  }\n  createTableQuery(tableName, attributes, options) {\n    const primaryKeys = [], foreignKeys = {}, attributesClauseParts = [];\n    let commentStr = \"\";\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        let dataType = attributes[attr];\n        let match;\n        if (dataType.includes(\"COMMENT \")) {\n          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n          const commentText = commentMatch[2].replace(\"COMMENT\", \"\").trim();\n          commentStr += this.commentTemplate(commentText, tableName, attr);\n          dataType = commentMatch[1];\n        }\n        if (dataType.includes(\"PRIMARY KEY\")) {\n          primaryKeys.push(attr);\n          if (dataType.includes(\"REFERENCES\")) {\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1].replace(\"PRIMARY KEY\", \"\")}`);\n            foreignKeys[attr] = match[2];\n          } else {\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType.replace(\"PRIMARY KEY\", \"\")}`);\n          }\n        } else if (dataType.includes(\"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n        }\n      }\n    }\n    const pkString = primaryKeys.map((pk) => this.quoteIdentifier(pk)).join(\", \");\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== \"string\") {\n            indexName = `uniq_${tableName}_${columns.fields.join(\"_\")}`;\n          }\n          attributesClauseParts.push(`CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`);\n        }\n      });\n    }\n    if (pkString.length > 0) {\n      attributesClauseParts.push(`PRIMARY KEY (${pkString})`);\n    }\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClauseParts.push(`FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`);\n      }\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([\n      `IF OBJECT_ID('${quotedTableName}', 'U') IS NULL`,\n      `CREATE TABLE ${quotedTableName} (${attributesClauseParts.join(\", \")})`,\n      \";\",\n      commentStr\n    ]);\n  }\n  describeTableQuery(tableName, schema) {\n    let sql = [\n      \"SELECT\",\n      \"c.COLUMN_NAME AS 'Name',\",\n      \"c.DATA_TYPE AS 'Type',\",\n      \"c.CHARACTER_MAXIMUM_LENGTH AS 'Length',\",\n      \"c.IS_NULLABLE as 'IsNull',\",\n      \"COLUMN_DEFAULT AS 'Default',\",\n      \"pk.CONSTRAINT_TYPE AS 'Constraint',\",\n      \"COLUMNPROPERTY(OBJECT_ID('[' + c.TABLE_SCHEMA + '].[' + c.TABLE_NAME + ']'), c.COLUMN_NAME, 'IsIdentity') as 'IsIdentity',\",\n      \"CAST(prop.value AS NVARCHAR) AS 'Comment'\",\n      \"FROM\",\n      \"INFORMATION_SCHEMA.TABLES t\",\n      \"INNER JOIN\",\n      \"INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA\",\n      \"LEFT JOIN (SELECT tc.table_schema, tc.table_name, \",\n      \"cu.column_name, tc.CONSTRAINT_TYPE \",\n      \"FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc \",\n      \"JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE  cu \",\n      \"ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name \",\n      \"and tc.constraint_name=cu.constraint_name \",\n      \"and tc.CONSTRAINT_TYPE='PRIMARY KEY') pk \",\n      \"ON pk.table_schema=c.table_schema \",\n      \"AND pk.table_name=c.table_name \",\n      \"AND pk.column_name=c.column_name \",\n      \"INNER JOIN sys.columns AS sc\",\n      \"ON sc.object_id = OBJECT_ID('[' + t.TABLE_SCHEMA + '].[' + t.TABLE_NAME + ']') AND sc.name = c.column_name\",\n      \"LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id\",\n      \"AND prop.minor_id = sc.column_id\",\n      \"AND prop.name = 'MS_Description'\",\n      \"WHERE t.TABLE_NAME =\",\n      wrapSingleQuote(tableName)\n    ].join(\" \");\n    if (schema) {\n      sql += `AND t.TABLE_SCHEMA =${wrapSingleQuote(schema)}`;\n    }\n    return sql;\n  }\n  renameTableQuery(before, after) {\n    return `EXEC sp_rename ${this.quoteTable(before)}, ${this.quoteTable(after)};`;\n  }\n  showTablesQuery() {\n    return \"SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';\";\n  }\n  tableExistsQuery(table) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema || \"dbo\";\n    return `SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = ${this.escape(tableName)} AND TABLE_SCHEMA = ${this.escape(schemaName)}`;\n  }\n  dropTableQuery(tableName) {\n    const quoteTbl = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([\n      `IF OBJECT_ID('${quoteTbl}', 'U') IS NOT NULL`,\n      \"DROP TABLE\",\n      quoteTbl,\n      \";\"\n    ]);\n  }\n  addColumnQuery(table, key, dataType) {\n    dataType.field = key;\n    let commentStr = \"\";\n    if (dataType.comment && _.isString(dataType.comment)) {\n      commentStr = this.commentTemplate(dataType.comment, table, key);\n      delete dataType[\"comment\"];\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(table),\n      \"ADD\",\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, { context: \"addColumn\" }),\n      \";\",\n      commentStr\n    ]);\n  }\n  commentTemplate(comment, table, column) {\n    return ` EXEC sp_addextendedproperty @name = N'MS_Description', @value = ${this.escape(comment)}, @level0type = N'Schema', @level0name = 'dbo', @level1type = N'Table', @level1name = ${this.quoteIdentifier(table)}, @level2type = N'Column', @level2name = ${this.quoteIdentifier(column)};`;\n  }\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP COLUMN\",\n      this.quoteIdentifier(attributeName),\n      \";\"\n    ]);\n  }\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [], constraintString = [];\n    let commentString = \"\";\n    for (const attributeName in attributes) {\n      const quotedAttrName = this.quoteIdentifier(attributeName);\n      let definition = attributes[attributeName];\n      if (definition.includes(\"COMMENT \")) {\n        const commentMatch = definition.match(/^(.+) (COMMENT.*)$/);\n        const commentText = commentMatch[2].replace(\"COMMENT\", \"\").trim();\n        commentString += this.commentTemplate(commentText, tableName, attributeName);\n        definition = commentMatch[1];\n      }\n      if (definition.includes(\"REFERENCES\")) {\n        constraintString.push(`FOREIGN KEY (${quotedAttrName}) ${definition.replace(/.+?(?=REFERENCES)/, \"\")}`);\n      } else {\n        attrString.push(`${quotedAttrName} ${definition}`);\n      }\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      attrString.length && `ALTER COLUMN ${attrString.join(\", \")}`,\n      constraintString.length && `ADD ${constraintString.join(\", \")}`,\n      \";\",\n      commentString\n    ]);\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return Utils.joinSQLFragments([\n      \"EXEC sp_rename\",\n      `'${this.quoteTable(tableName)}.${attrBefore}',`,\n      `'${newName}',`,\n      \"'COLUMN'\",\n      \";\"\n    ]);\n  }\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    const quotedTable = this.quoteTable(tableName);\n    options = options || {};\n    attributes = attributes || {};\n    const tuples = [];\n    const allAttributes = [];\n    const allQueries = [];\n    let needIdentityInsertWrapper = false, outputFragment = \"\";\n    if (options.returning) {\n      const returnValues = this.generateReturnValues(attributes, options);\n      outputFragment = returnValues.outputFragment;\n    }\n    const emptyQuery = `INSERT INTO ${quotedTable}${outputFragment} DEFAULT VALUES`;\n    attrValueHashes.forEach((attrValueHash) => {\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        allQueries.push(emptyQuery);\n        return;\n      }\n      _.forOwn(attrValueHash, (value, key) => {\n        if (value !== null && attributes[key] && attributes[key].autoIncrement) {\n          needIdentityInsertWrapper = true;\n        }\n        if (!allAttributes.includes(key)) {\n          if (value === null && attributes[key] && attributes[key].autoIncrement)\n            return;\n          allAttributes.push(key);\n        }\n      });\n    });\n    if (allAttributes.length > 0) {\n      attrValueHashes.forEach((attrValueHash) => {\n        tuples.push(`(${allAttributes.map((key) => this.escape(attrValueHash[key])).join(\",\")})`);\n      });\n      const quotedAttributes = allAttributes.map((attr) => this.quoteIdentifier(attr)).join(\",\");\n      allQueries.push((tupleStr) => `INSERT INTO ${quotedTable} (${quotedAttributes})${outputFragment} VALUES ${tupleStr};`);\n    }\n    const commands = [];\n    let offset = 0;\n    const batch = Math.floor(250 / (allAttributes.length + 1)) + 1;\n    while (offset < Math.max(tuples.length, 1)) {\n      const tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));\n      let generatedQuery = allQueries.map((v) => typeof v === \"string\" ? v : v(tupleStr)).join(\";\");\n      if (needIdentityInsertWrapper) {\n        generatedQuery = `SET IDENTITY_INSERT ${quotedTable} ON; ${generatedQuery}; SET IDENTITY_INSERT ${quotedTable} OFF;`;\n      }\n      commands.push(generatedQuery);\n      offset += batch;\n    }\n    return commands.join(\";\");\n  }\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n    if (options.limit) {\n      const updateArgs = `UPDATE TOP(${this.escape(options.limit)})`;\n      sql.query = sql.query.replace(\"UPDATE\", updateArgs);\n    }\n    return sql;\n  }\n  upsertQuery(tableName, insertValues, updateValues, where, model) {\n    const targetTableAlias = this.quoteTable(`${tableName}_target`);\n    const sourceTableAlias = this.quoteTable(`${tableName}_source`);\n    const primaryKeysAttrs = [];\n    const identityAttrs = [];\n    const uniqueAttrs = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n    let needIdentityInsertWrapper = false;\n    for (const key in model.rawAttributes) {\n      if (model.rawAttributes[key].primaryKey) {\n        primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].unique) {\n        uniqueAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].autoIncrement) {\n        identityAttrs.push(model.rawAttributes[key].field || key);\n      }\n    }\n    for (const index of model._indexes) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const fieldName = typeof field === \"string\" ? field : field.name || field.attribute;\n          if (!uniqueAttrs.includes(fieldName) && model.rawAttributes[fieldName]) {\n            uniqueAttrs.push(fieldName);\n          }\n        }\n      }\n    }\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map((key) => this.quoteIdentifier(key)).join(\", \");\n    const insertValuesEscaped = insertKeys.map((key) => this.escape(insertValues[key])).join(\", \");\n    const sourceTableQuery = `VALUES(${insertValuesEscaped})`;\n    let joinCondition;\n    identityAttrs.forEach((key) => {\n      if (insertValues[key] && insertValues[key] !== null) {\n        needIdentityInsertWrapper = true;\n      }\n    });\n    const clauses = where[Op.or].filter((clause) => {\n      let valid = true;\n      for (const key in clause) {\n        if (typeof clause[key] === \"undefined\" || clause[key] == null) {\n          valid = false;\n          break;\n        }\n      }\n      return valid;\n    });\n    const getJoinSnippet = (array) => {\n      return array.map((key) => {\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;\n      });\n    };\n    if (clauses.length === 0) {\n      throw new Error(\"Primary Key or Unique key should be passed to upsert query\");\n    } else {\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n        if (primaryKeysAttrs.includes(keys[0])) {\n          joinCondition = getJoinSnippet(primaryKeysAttrs).join(\" AND \");\n          break;\n        }\n      }\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueAttrs).join(\" AND \");\n      }\n    }\n    const filteredUpdateClauses = updateKeys.filter((key) => !identityAttrs.includes(key)).map((key) => {\n      const value = this.escape(updateValues[key]);\n      key = this.quoteIdentifier(key);\n      return `${targetTableAlias}.${key} = ${value}`;\n    });\n    const updateSnippet = filteredUpdateClauses.length > 0 ? `WHEN MATCHED THEN UPDATE SET ${filteredUpdateClauses.join(\", \")}` : \"\";\n    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;\n    let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;\n    query += ` ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;\n    if (needIdentityInsertWrapper) {\n      query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;\n    }\n    return query;\n  }\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    const whereClause = this.getWhereConditions(where, null, model, options);\n    return Utils.joinSQLFragments([\n      \"DELETE\",\n      options.limit && `TOP(${this.escape(options.limit)})`,\n      \"FROM\",\n      table,\n      whereClause && `WHERE ${whereClause}`,\n      \";\",\n      \"SELECT @@ROWCOUNT AS AFFECTEDROWS\",\n      \";\"\n    ]);\n  }\n  showIndexesQuery(tableName) {\n    return `EXEC sys.sp_helpindex @objname = N'${this.quoteTable(tableName)}';`;\n  }\n  showConstraintsQuery(tableName) {\n    return `EXEC sp_helpconstraint @objname = ${this.escape(this.quoteTable(tableName))};`;\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return `DROP INDEX ${this.quoteIdentifiers(indexName)} ON ${this.quoteIdentifiers(tableName)}`;\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    if (attribute.references) {\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log(\"MSSQL does not support self referencial constraints, we will remove it but we recommend restructuring your query\");\n        attribute.onDelete = \"\";\n        attribute.onUpdate = \"\";\n      }\n    }\n    let template;\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values)\n        attribute.values = attribute.type.values;\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map((value) => {\n        return this.escape(value);\n      }).join(\", \")}))`;\n      return template;\n    }\n    template = attribute.type.toString();\n    if (attribute.allowNull === false) {\n      template += \" NOT NULL\";\n    } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += \" NULL\";\n    }\n    if (attribute.autoIncrement) {\n      template += \" IDENTITY(1,1)\";\n    }\n    if (attribute.type !== \"TEXT\" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.unique === true) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n    if (attribute.comment && typeof attribute.comment === \"string\") {\n      template += ` COMMENT ${attribute.comment}`;\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {}, existingConstraints = [];\n    let key, attribute;\n    for (key in attributes) {\n      attribute = attributes[key];\n      if (attribute.references) {\n        if (existingConstraints.includes(attribute.references.model.toString())) {\n          attribute.onDelete = \"\";\n          attribute.onUpdate = \"\";\n        } else {\n          existingConstraints.push(attribute.references.model.toString());\n          attribute.onUpdate = \"\";\n        }\n      }\n      if (key && !attribute.field)\n        attribute.field = key;\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n    return result;\n  }\n  createTrigger() {\n    throwMethodUndefined(\"createTrigger\");\n  }\n  dropTrigger() {\n    throwMethodUndefined(\"dropTrigger\");\n  }\n  renameTrigger() {\n    throwMethodUndefined(\"renameTrigger\");\n  }\n  createFunction() {\n    throwMethodUndefined(\"createFunction\");\n  }\n  dropFunction() {\n    throwMethodUndefined(\"dropFunction\");\n  }\n  renameFunction() {\n    throwMethodUndefined(\"renameFunction\");\n  }\n  _getForeignKeysQueryPrefix(catalogName) {\n    return `${\"SELECT constraint_name = OBJ.NAME, constraintName = OBJ.NAME, \"}${catalogName ? `constraintCatalog = '${catalogName}', ` : \"\"}constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), tableName = TB.NAME, tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), ${catalogName ? `tableCatalog = '${catalogName}', ` : \"\"}columnName = COL.NAME, referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), ${catalogName ? `referencedCatalog = '${catalogName}', ` : \"\"}referencedTableName = RTB.NAME, referencedColumnName = RCOL.NAME FROM sys.foreign_key_columns FKC INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID`;\n  }\n  getForeignKeysQuery(table, catalogName) {\n    const tableName = table.tableName || table;\n    let sql = `${this._getForeignKeysQueryPrefix(catalogName)} WHERE TB.NAME =${wrapSingleQuote(tableName)}`;\n    if (table.schema) {\n      sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;\n    }\n    return sql;\n  }\n  getForeignKeyQuery(table, attributeName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\n      this._getForeignKeysQueryPrefix(),\n      \"WHERE\",\n      `TB.NAME =${wrapSingleQuote(tableName)}`,\n      \"AND\",\n      `COL.NAME =${wrapSingleQuote(attributeName)}`,\n      table.schema && `AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`\n    ]);\n  }\n  getPrimaryKeyConstraintQuery(table, attributeName) {\n    const tableName = wrapSingleQuote(table.tableName || table);\n    return Utils.joinSQLFragments([\n      \"SELECT K.TABLE_NAME AS tableName,\",\n      \"K.COLUMN_NAME AS columnName,\",\n      \"K.CONSTRAINT_NAME AS constraintName\",\n      \"FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C\",\n      \"JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K\",\n      \"ON C.TABLE_NAME = K.TABLE_NAME\",\n      \"AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG\",\n      \"AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA\",\n      \"AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME\",\n      \"WHERE C.CONSTRAINT_TYPE = 'PRIMARY KEY'\",\n      `AND K.COLUMN_NAME = ${wrapSingleQuote(attributeName)}`,\n      `AND K.TABLE_NAME = ${tableName}`,\n      \";\"\n    ]);\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP\",\n      this.quoteIdentifier(foreignKey)\n    ]);\n  }\n  getDefaultConstraintQuery(tableName, attributeName) {\n    const quotedTable = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([\n      \"SELECT name FROM sys.default_constraints\",\n      `WHERE PARENT_OBJECT_ID = OBJECT_ID('${quotedTable}', 'U')`,\n      `AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('${attributeName}')`,\n      `AND object_id = OBJECT_ID('${quotedTable}', 'U'))`,\n      \";\"\n    ]);\n  }\n  dropConstraintQuery(tableName, constraintName) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP CONSTRAINT\",\n      this.quoteIdentifier(constraintName),\n      \";\"\n    ]);\n  }\n  setIsolationLevelQuery() {\n  }\n  generateTransactionId() {\n    return randomBytes(10).toString(\"hex\");\n  }\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return \"BEGIN TRANSACTION;\";\n  }\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n    return \"COMMIT TRANSACTION;\";\n  }\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return \"ROLLBACK TRANSACTION;\";\n  }\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {\n    this._throwOnEmptyAttributes(attributes, { modelName: model && model.name, as: mainTableAs });\n    const dbVersion = this.sequelize.options.databaseVersion;\n    const isSQLServer2008 = semver.valid(dbVersion) && semver.lt(dbVersion, \"11.0.0\");\n    if (isSQLServer2008 && options.offset) {\n      const offset = options.offset || 0;\n      const isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n      let orders = { mainQueryOrder: [] };\n      if (options.order) {\n        orders = this.getQueryOrders(options, model, isSubQuery);\n      }\n      if (orders.mainQueryOrder.length === 0) {\n        orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));\n      }\n      const tmpTable = mainTableAs || \"OffsetTable\";\n      if (options.include) {\n        const subQuery = options.subQuery === void 0 ? options.limit && options.hasMultiAssociation : options.subQuery;\n        const mainTable = {\n          name: mainTableAs,\n          quotedName: null,\n          as: null,\n          model\n        };\n        const topLevelInfo = {\n          names: mainTable,\n          options,\n          subQuery\n        };\n        let mainJoinQueries = [];\n        for (const include of options.include) {\n          if (include.separate) {\n            continue;\n          }\n          const joinQueries = this.generateInclude(include, { externalAs: mainTableAs, internalAs: mainTableAs }, topLevelInfo);\n          mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n        }\n        return Utils.joinSQLFragments([\n          \"SELECT TOP 100 PERCENT\",\n          attributes.join(\", \"),\n          \"FROM (\",\n          [\n            \"SELECT\",\n            options.limit && `TOP ${options.limit}`,\n            \"* FROM (\",\n            [\n              \"SELECT ROW_NUMBER() OVER (\",\n              [\n                \"ORDER BY\",\n                orders.mainQueryOrder.join(\", \")\n              ],\n              `) as row_num, ${tmpTable}.* FROM (`,\n              [\n                \"SELECT DISTINCT\",\n                `${tmpTable}.* FROM ${tables} AS ${tmpTable}`,\n                mainJoinQueries,\n                where && `WHERE ${where}`\n              ],\n              `) AS ${tmpTable}`\n            ],\n            `) AS ${tmpTable} WHERE row_num > ${offset}`\n          ],\n          `) AS ${tmpTable}`\n        ]);\n      }\n      return Utils.joinSQLFragments([\n        \"SELECT TOP 100 PERCENT\",\n        attributes.join(\", \"),\n        \"FROM (\",\n        [\n          \"SELECT\",\n          options.limit && `TOP ${options.limit}`,\n          \"* FROM (\",\n          [\n            \"SELECT ROW_NUMBER() OVER (\",\n            [\n              \"ORDER BY\",\n              orders.mainQueryOrder.join(\", \")\n            ],\n            `) as row_num, * FROM ${tables} AS ${tmpTable}`,\n            where && `WHERE ${where}`\n          ],\n          `) AS ${tmpTable} WHERE row_num > ${offset}`\n        ],\n        `) AS ${tmpTable}`\n      ]);\n    }\n    return Utils.joinSQLFragments([\n      \"SELECT\",\n      isSQLServer2008 && options.limit && `TOP ${options.limit}`,\n      attributes.join(\", \"),\n      `FROM ${tables}`,\n      mainTableAs && `AS ${mainTableAs}`,\n      options.tableHint && TableHints[options.tableHint] && `WITH (${TableHints[options.tableHint]})`\n    ]);\n  }\n  addLimitAndOffset(options, model) {\n    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, \"11.0.0\")) {\n      return \"\";\n    }\n    const offset = options.offset || 0;\n    const isSubQuery = options.subQuery === void 0 ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation : options.subQuery;\n    let fragment = \"\";\n    let orders = {};\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n    if (options.limit || options.offset) {\n      if (!options.order || options.order.length === 0 || options.include && orders.subQueryOrder.length === 0) {\n        let primaryKey = model.primaryKeyField;\n        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(primaryKey)}`;\n        const aliasedAttribute = (options.attributes || []).find((attr) => Array.isArray(attr) && attr[1] && (attr[0] === primaryKey || attr[1] === primaryKey));\n        if (aliasedAttribute) {\n          const modelName = this.quoteIdentifier(options.tableAs || model.name);\n          const alias = this._getAliasForField(modelName, aliasedAttribute[1], options);\n          primaryKey = new Utils.Col(alias || aliasedAttribute[1]);\n        }\n        if (!options.order || !options.order.length) {\n          fragment += ` ORDER BY ${tablePkFragment}`;\n        } else {\n          const orderFieldNames = (options.order || []).map((order) => {\n            const value = Array.isArray(order) ? order[0] : order;\n            if (value instanceof Utils.Col) {\n              return value.col;\n            }\n            if (value instanceof Utils.Literal) {\n              return value.val;\n            }\n            return value;\n          });\n          const primaryKeyFieldAlreadyPresent = orderFieldNames.some((fieldName) => fieldName === (primaryKey.col || primaryKey));\n          if (!primaryKeyFieldAlreadyPresent) {\n            fragment += options.order && !isSubQuery ? \", \" : \" ORDER BY \";\n            fragment += tablePkFragment;\n          }\n        }\n      }\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n    return fragment;\n  }\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n  quoteIdentifier(identifier, force) {\n    return `[${identifier.replace(/[[\\]']+/g, \"\")}]`;\n  }\n}\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(Utils.removeTicks(identifier, \"'\"), \"'\");\n}\nmodule.exports = MSSQLQueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9xdWVyeS1nZW5lcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLGlFQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyw0RUFBYTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBa0I7QUFDNUMsbUJBQW1CLG1CQUFPLENBQUMsd0ZBQW1CO0FBQzlDLCtCQUErQixtQkFBTyxDQUFDLHdIQUE2QjtBQUNwRSxvQkFBb0IseURBQTZCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyxnRUFBUTtBQUMvQixXQUFXLG1CQUFPLENBQUMsb0ZBQWlCO0FBQ3BDO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUMsbURBQW1ELDZCQUE2QjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVztBQUNwQixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQix5RUFBeUU7QUFDekU7QUFDQTtBQUNBLDZDQUE2QztBQUM3QywwQkFBMEIsT0FBTyxVQUFVO0FBQzNDLDJDQUEyQztBQUMzQyx5Q0FBeUM7QUFDekMseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNEJBQTRCLEVBQUUsb0NBQW9DO0FBQzVHO0FBQ0EsWUFBWTtBQUNaLDBDQUEwQyw0QkFBNEIsRUFBRSxvQ0FBb0M7QUFDNUc7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx3Q0FBd0MsNEJBQTRCLEVBQUUsU0FBUztBQUMvRTtBQUNBLFVBQVU7QUFDVix3Q0FBd0MsNEJBQTRCLEVBQUUsU0FBUztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsR0FBRyx5QkFBeUI7QUFDdEU7QUFDQSxtREFBbUQsaUNBQWlDLFVBQVUsc0VBQXNFO0FBQ3BLO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsMkJBQTJCLElBQUksa0JBQWtCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QyxzQkFBc0IsaUJBQWlCLEdBQUcsaUNBQWlDO0FBQzNFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3QkFBd0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0JBQXdCLElBQUksd0JBQXdCO0FBQ2pGO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SEFBOEgsd0JBQXdCLHFCQUFxQix3QkFBd0I7QUFDbk07QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxxQkFBcUIsd0ZBQXdGLDRCQUE0QiwyQ0FBMkMsOEJBQThCO0FBQ2pTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxlQUFlLElBQUksNENBQTRDO0FBQzdHLFFBQVE7QUFDUiwyQkFBMkIsZ0JBQWdCLEVBQUUsV0FBVztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNCQUFzQjtBQUNqRSx3Q0FBd0MsNEJBQTRCO0FBQ3BFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCLEdBQUcsV0FBVztBQUNuRCxVQUFVLFFBQVE7QUFDbEI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZLEVBQUUsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCLHNFQUFzRTtBQUM5RixPQUFPO0FBQ1A7QUFDQSxtREFBbUQsYUFBYSxHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixTQUFTLFVBQVU7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0EsZ0RBQWdELGFBQWEsSUFBSSxFQUFFLGlCQUFpQixzQkFBc0IsYUFBYSxJQUFJO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJCQUEyQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFVBQVU7QUFDMUQsZ0RBQWdELFVBQVU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9CQUFvQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCLEdBQUcsS0FBSyxJQUFJLGlCQUFpQixHQUFHLElBQUk7QUFDdkUsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQixHQUFHLEtBQUssSUFBSSxNQUFNO0FBQ25ELEtBQUs7QUFDTCw2RkFBNkYsaUNBQWlDO0FBQzlILDhCQUE4QixpQkFBaUIsV0FBVyxvQkFBb0I7QUFDOUUsOEJBQThCLGlCQUFpQixvQkFBb0Isa0JBQWtCLFNBQVMsaUJBQWlCLE9BQU8saUJBQWlCLEdBQUcsaUJBQWlCLE9BQU8sY0FBYztBQUNoTCxpQkFBaUIsZUFBZSwrQkFBK0IsZUFBZSwyQkFBMkI7QUFDekc7QUFDQSxxQ0FBcUMsaUJBQWlCLElBQUksRUFBRSxPQUFPLHNCQUFzQixpQkFBaUIsSUFBSTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyQkFBMkI7QUFDeEQ7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkJBQTJCO0FBQ3pEO0FBQ0E7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQyxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDJCQUEyQixFQUFFO0FBQzlFO0FBQ0E7QUFDQSxnREFBZ0QseUNBQXlDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsR0FBRyxnQ0FBZ0M7QUFDbkY7QUFDQSx5QkFBeUIsa0NBQWtDLEtBQUssaUNBQWlDO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVDQUF1QyxLQUFLO0FBQ3pFO0FBQ0EsT0FBTyxhQUFhO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9DQUFvQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDRDQUE0QztBQUM3RTtBQUNBLHlCQUF5QiwrQ0FBK0M7QUFDeEUsUUFBUTtBQUNSLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBLGtDQUFrQyxpQ0FBaUM7QUFDbkU7QUFDQTtBQUNBLGtDQUFrQyxpQ0FBaUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtCQUFrQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpRUFBaUUsRUFBRSxzQ0FBc0MsWUFBWSxVQUFVLCtHQUErRyxpQ0FBaUMsWUFBWSxVQUFVLDZFQUE2RSxzQ0FBc0MsWUFBWSxVQUFVO0FBQzViO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4Q0FBOEMsaUJBQWlCLDJCQUEyQjtBQUMzRztBQUNBLGdEQUFnRCw4QkFBOEI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQSxtQkFBbUIsK0JBQStCO0FBQ2xELHdEQUF3RCw4QkFBOEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtCQUErQjtBQUM1RCw0QkFBNEIsVUFBVTtBQUN0QyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pELGtGQUFrRixjQUFjO0FBQ2hHLG9DQUFvQyxZQUFZO0FBQ2hELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3Q0FBd0M7QUFDekU7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0NBQXdDO0FBQzdFO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSwrQ0FBK0MsaURBQWlEO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsa0RBQWtEO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUyxVQUFVLFFBQVEsS0FBSyxTQUFTO0FBQzVEO0FBQ0Esa0NBQWtDLE1BQU07QUFDeEM7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBLG9CQUFvQixVQUFVLGtCQUFrQixPQUFPO0FBQ3ZEO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVEsS0FBSyxTQUFTO0FBQzFELDhCQUE4QixNQUFNO0FBQ3BDO0FBQ0Esa0JBQWtCLFVBQVUsa0JBQWtCLE9BQU87QUFDckQ7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxjQUFjO0FBQy9EO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLDJCQUEyQixZQUFZO0FBQ3ZDLHFFQUFxRSw4QkFBOEI7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsK0NBQStDLEdBQUcsaUNBQWlDO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQSxtQ0FBbUMsNEJBQTRCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9xdWVyeS1nZW5lcmF0b3IuanM/NWYwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKTtcbmNvbnN0IFRhYmxlSGludHMgPSByZXF1aXJlKFwiLi4vLi4vdGFibGUtaGludHNcIik7XG5jb25zdCBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5LWdlbmVyYXRvclwiKTtcbmNvbnN0IHJhbmRvbUJ5dGVzID0gcmVxdWlyZShcImNyeXB0b1wiKS5yYW5kb21CeXRlcztcbmNvbnN0IHNlbXZlciA9IHJlcXVpcmUoXCJzZW12ZXJcIik7XG5jb25zdCBPcCA9IHJlcXVpcmUoXCIuLi8uLi9vcGVyYXRvcnNcIik7XG5jb25zdCB0aHJvd01ldGhvZFVuZGVmaW5lZCA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbWV0aG9kIFwiJHttZXRob2ROYW1lfVwiIGlzIG5vdCBkZWZpbmVkISBQbGVhc2UgYWRkIGl0IHRvIHlvdXIgc3FsIGRpYWxlY3QuYCk7XG59O1xuY2xhc3MgTVNTUUxRdWVyeUdlbmVyYXRvciBleHRlbmRzIEFic3RyYWN0UXVlcnlHZW5lcmF0b3Ige1xuICBjcmVhdGVEYXRhYmFzZVF1ZXJ5KGRhdGFiYXNlTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7IGNvbGxhdGU6IG51bGwgfSwgb3B0aW9ucyk7XG4gICAgY29uc3QgY29sbGF0aW9uID0gb3B0aW9ucy5jb2xsYXRlID8gYENPTExBVEUgJHt0aGlzLmVzY2FwZShvcHRpb25zLmNvbGxhdGUpfWAgOiBcIlwiO1xuICAgIHJldHVybiBbXG4gICAgICBcIklGIE5PVCBFWElTVFMgKFNFTEVDVCAqIEZST00gc3lzLmRhdGFiYXNlcyBXSEVSRSBuYW1lID1cIixcbiAgICAgIHdyYXBTaW5nbGVRdW90ZShkYXRhYmFzZU5hbWUpLFxuICAgICAgXCIpXCIsXG4gICAgICBcIkJFR0lOXCIsXG4gICAgICBcIkNSRUFURSBEQVRBQkFTRVwiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoZGF0YWJhc2VOYW1lKSxcbiAgICAgIGAke2NvbGxhdGlvbn07YCxcbiAgICAgIFwiRU5EO1wiXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgfVxuICBkcm9wRGF0YWJhc2VRdWVyeShkYXRhYmFzZU5hbWUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJJRiBFWElTVFMgKFNFTEVDVCAqIEZST00gc3lzLmRhdGFiYXNlcyBXSEVSRSBuYW1lID1cIixcbiAgICAgIHdyYXBTaW5nbGVRdW90ZShkYXRhYmFzZU5hbWUpLFxuICAgICAgXCIpXCIsXG4gICAgICBcIkJFR0lOXCIsXG4gICAgICBcIkRST1AgREFUQUJBU0VcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGRhdGFiYXNlTmFtZSksXG4gICAgICBcIjtcIixcbiAgICAgIFwiRU5EO1wiXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgfVxuICBjcmVhdGVTY2hlbWEoc2NoZW1hKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiSUYgTk9UIEVYSVNUUyAoU0VMRUNUIHNjaGVtYV9uYW1lXCIsXG4gICAgICBcIkZST00gaW5mb3JtYXRpb25fc2NoZW1hLnNjaGVtYXRhXCIsXG4gICAgICBcIldIRVJFIHNjaGVtYV9uYW1lID1cIixcbiAgICAgIHdyYXBTaW5nbGVRdW90ZShzY2hlbWEpLFxuICAgICAgXCIpXCIsXG4gICAgICBcIkJFR0lOXCIsXG4gICAgICBcIkVYRUMgc3BfZXhlY3V0ZXNxbCBOJ0NSRUFURSBTQ0hFTUFcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKHNjaGVtYSksXG4gICAgICBcIjsnXCIsXG4gICAgICBcIkVORDtcIlxuICAgIF0uam9pbihcIiBcIik7XG4gIH1cbiAgZHJvcFNjaGVtYShzY2hlbWEpIHtcbiAgICBjb25zdCBxdW90ZWRTY2hlbWEgPSB3cmFwU2luZ2xlUXVvdGUoc2NoZW1hKTtcbiAgICByZXR1cm4gW1xuICAgICAgXCJJRiBFWElTVFMgKFNFTEVDVCBzY2hlbWFfbmFtZVwiLFxuICAgICAgXCJGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5zY2hlbWF0YVwiLFxuICAgICAgXCJXSEVSRSBzY2hlbWFfbmFtZSA9XCIsXG4gICAgICBxdW90ZWRTY2hlbWEsXG4gICAgICBcIilcIixcbiAgICAgIFwiQkVHSU5cIixcbiAgICAgIFwiREVDTEFSRSBAaWQgSU5ULCBAbXNfc3FsIE5WQVJDSEFSKDIwMDApO1wiLFxuICAgICAgXCJERUNMQVJFIEBjYXNjYWRlIFRBQkxFIChcIixcbiAgICAgIFwiaWQgSU5UIE5PVCBOVUxMIElERU5USVRZIFBSSU1BUlkgS0VZLFwiLFxuICAgICAgXCJtc19zcWwgTlZBUkNIQVIoMjAwMCkgTk9UIE5VTEwgKTtcIixcbiAgICAgIFwiSU5TRVJUIElOVE8gQGNhc2NhZGUgKCBtc19zcWwgKVwiLFxuICAgICAgXCJTRUxFQ1QgQ0FTRSBXSEVOIG8udHlwZSBJTiAoJ0YnLCdQSycpXCIsXG4gICAgICBcIlRIRU4gTidBTFRFUiBUQUJMRSBbJysgcy5uYW1lICsgTiddLlsnICsgcC5uYW1lICsgTiddIERST1AgQ09OU1RSQUlOVCBbJyArIG8ubmFtZSArIE4nXSdcIixcbiAgICAgIFwiRUxTRSBOJ0RST1AgVEFCTEUgWycrIHMubmFtZSArIE4nXS5bJyArIG8ubmFtZSArIE4nXScgRU5EXCIsXG4gICAgICBcIkZST00gc3lzLm9iamVjdHMgb1wiLFxuICAgICAgXCJKT0lOIHN5cy5zY2hlbWFzIHMgb24gby5zY2hlbWFfaWQgPSBzLnNjaGVtYV9pZFwiLFxuICAgICAgXCJMRUZUIE9VVEVSIEpPSU4gc3lzLm9iamVjdHMgcCBvbiBvLnBhcmVudF9vYmplY3RfaWQgPSBwLm9iamVjdF9pZFwiLFxuICAgICAgXCJXSEVSRSBvLnR5cGUgSU4gKCdGJywgJ1BLJywgJ1UnKSBBTkQgcy5uYW1lID0gXCIsXG4gICAgICBxdW90ZWRTY2hlbWEsXG4gICAgICBcIk9SREVSIEJZIG8udHlwZSBBU0M7XCIsXG4gICAgICBcIlNFTEVDVCBUT1AgMSBAaWQgPSBpZCwgQG1zX3NxbCA9IG1zX3NxbCBGUk9NIEBjYXNjYWRlIE9SREVSIEJZIGlkO1wiLFxuICAgICAgXCJXSElMRSBAaWQgSVMgTk9UIE5VTExcIixcbiAgICAgIFwiQkVHSU5cIixcbiAgICAgIFwiQkVHSU4gVFJZIEVYRUMgc3BfZXhlY3V0ZXNxbCBAbXNfc3FsOyBFTkQgVFJZXCIsXG4gICAgICBcIkJFR0lOIENBVENIIEJSRUFLOyBUSFJPVzsgRU5EIENBVENIO1wiLFxuICAgICAgXCJERUxFVEUgRlJPTSBAY2FzY2FkZSBXSEVSRSBpZCA9IEBpZDtcIixcbiAgICAgIFwiU0VMRUNUIEBpZCA9IE5VTEwsIEBtc19zcWwgPSBOVUxMO1wiLFxuICAgICAgXCJTRUxFQ1QgVE9QIDEgQGlkID0gaWQsIEBtc19zcWwgPSBtc19zcWwgRlJPTSBAY2FzY2FkZSBPUkRFUiBCWSBpZDtcIixcbiAgICAgIFwiRU5EXCIsXG4gICAgICBcIkVYRUMgc3BfZXhlY3V0ZXNxbCBOJ0RST1AgU0NIRU1BXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihzY2hlbWEpLFxuICAgICAgXCI7J1wiLFxuICAgICAgXCJFTkQ7XCJcbiAgICBdLmpvaW4oXCIgXCIpO1xuICB9XG4gIHNob3dTY2hlbWFzUXVlcnkoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICdTRUxFQ1QgXCJuYW1lXCIgYXMgXCJzY2hlbWFfbmFtZVwiIEZST00gc3lzLnNjaGVtYXMgYXMgcycsXG4gICAgICAnV0hFUkUgXCJzXCIuXCJuYW1lXCIgTk9UIElOICgnLFxuICAgICAgXCInSU5GT1JNQVRJT05fU0NIRU1BJywgJ2RibycsICdndWVzdCcsICdzeXMnLCAnYXJjaGl2ZSdcIixcbiAgICAgIFwiKVwiLFxuICAgICAgXCJBTkRcIixcbiAgICAgICdcInNcIi5cIm5hbWVcIiBOT1QgTElLRScsXG4gICAgICBcIidkYl8lJ1wiXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgfVxuICB2ZXJzaW9uUXVlcnkoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiREVDTEFSRSBAbXNfdmVyIE5WQVJDSEFSKDIwKTtcIixcbiAgICAgIFwiU0VUIEBtc192ZXIgPSBSRVZFUlNFKENPTlZFUlQoTlZBUkNIQVIoMjApLCBTRVJWRVJQUk9QRVJUWSgnUHJvZHVjdFZlcnNpb24nKSkpO1wiLFxuICAgICAgXCJTRUxFQ1QgUkVWRVJTRShTVUJTVFJJTkcoQG1zX3ZlciwgQ0hBUklOREVYKCcuJywgQG1zX3ZlcikrMSwgMjApKSBBUyAndmVyc2lvbidcIlxuICAgIF0uam9pbihcIiBcIik7XG4gIH1cbiAgY3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwcmltYXJ5S2V5cyA9IFtdLCBmb3JlaWduS2V5cyA9IHt9LCBhdHRyaWJ1dGVzQ2xhdXNlUGFydHMgPSBbXTtcbiAgICBsZXQgY29tbWVudFN0ciA9IFwiXCI7XG4gICAgZm9yIChjb25zdCBhdHRyIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgYXR0cikpIHtcbiAgICAgICAgbGV0IGRhdGFUeXBlID0gYXR0cmlidXRlc1thdHRyXTtcbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJDT01NRU5UIFwiKSkge1xuICAgICAgICAgIGNvbnN0IGNvbW1lbnRNYXRjaCA9IGRhdGFUeXBlLm1hdGNoKC9eKC4rKSAoQ09NTUVOVC4qKSQvKTtcbiAgICAgICAgICBjb25zdCBjb21tZW50VGV4dCA9IGNvbW1lbnRNYXRjaFsyXS5yZXBsYWNlKFwiQ09NTUVOVFwiLCBcIlwiKS50cmltKCk7XG4gICAgICAgICAgY29tbWVudFN0ciArPSB0aGlzLmNvbW1lbnRUZW1wbGF0ZShjb21tZW50VGV4dCwgdGFibGVOYW1lLCBhdHRyKTtcbiAgICAgICAgICBkYXRhVHlwZSA9IGNvbW1lbnRNYXRjaFsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJQUklNQVJZIEtFWVwiKSkge1xuICAgICAgICAgIHByaW1hcnlLZXlzLnB1c2goYXR0cik7XG4gICAgICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiUkVGRVJFTkNFU1wiKSkge1xuICAgICAgICAgICAgbWF0Y2ggPSBkYXRhVHlwZS5tYXRjaCgvXiguKykgKFJFRkVSRU5DRVMuKikkLyk7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzQ2xhdXNlUGFydHMucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHttYXRjaFsxXS5yZXBsYWNlKFwiUFJJTUFSWSBLRVlcIiwgXCJcIil9YCk7XG4gICAgICAgICAgICBmb3JlaWduS2V5c1thdHRyXSA9IG1hdGNoWzJdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzQ2xhdXNlUGFydHMucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHtkYXRhVHlwZS5yZXBsYWNlKFwiUFJJTUFSWSBLRVlcIiwgXCJcIil9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiUkVGRVJFTkNFU1wiKSkge1xuICAgICAgICAgIG1hdGNoID0gZGF0YVR5cGUubWF0Y2goL14oLispIChSRUZFUkVOQ0VTLiopJC8pO1xuICAgICAgICAgIGF0dHJpYnV0ZXNDbGF1c2VQYXJ0cy5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke21hdGNoWzFdfWApO1xuICAgICAgICAgIGZvcmVpZ25LZXlzW2F0dHJdID0gbWF0Y2hbMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXR0cmlidXRlc0NsYXVzZVBhcnRzLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7ZGF0YVR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGtTdHJpbmcgPSBwcmltYXJ5S2V5cy5tYXAoKHBrKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihwaykpLmpvaW4oXCIsIFwiKTtcbiAgICBpZiAob3B0aW9ucy51bmlxdWVLZXlzKSB7XG4gICAgICBfLmVhY2gob3B0aW9ucy51bmlxdWVLZXlzLCAoY29sdW1ucywgaW5kZXhOYW1lKSA9PiB7XG4gICAgICAgIGlmIChjb2x1bW5zLmN1c3RvbUluZGV4KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbmRleE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGluZGV4TmFtZSA9IGB1bmlxXyR7dGFibGVOYW1lfV8ke2NvbHVtbnMuZmllbGRzLmpvaW4oXCJfXCIpfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYnV0ZXNDbGF1c2VQYXJ0cy5wdXNoKGBDT05TVFJBSU5UICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaW5kZXhOYW1lKX0gVU5JUVVFICgke2NvbHVtbnMuZmllbGRzLm1hcCgoZmllbGQpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKSkuam9pbihcIiwgXCIpfSlgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwa1N0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICBhdHRyaWJ1dGVzQ2xhdXNlUGFydHMucHVzaChgUFJJTUFSWSBLRVkgKCR7cGtTdHJpbmd9KWApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZrZXkgaW4gZm9yZWlnbktleXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZm9yZWlnbktleXMsIGZrZXkpKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNDbGF1c2VQYXJ0cy5wdXNoKGBGT1JFSUdOIEtFWSAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihma2V5KX0pICR7Zm9yZWlnbktleXNbZmtleV19YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHF1b3RlZFRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIGBJRiBPQkpFQ1RfSUQoJyR7cXVvdGVkVGFibGVOYW1lfScsICdVJykgSVMgTlVMTGAsXG4gICAgICBgQ1JFQVRFIFRBQkxFICR7cXVvdGVkVGFibGVOYW1lfSAoJHthdHRyaWJ1dGVzQ2xhdXNlUGFydHMuam9pbihcIiwgXCIpfSlgLFxuICAgICAgXCI7XCIsXG4gICAgICBjb21tZW50U3RyXG4gICAgXSk7XG4gIH1cbiAgZGVzY3JpYmVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgc2NoZW1hKSB7XG4gICAgbGV0IHNxbCA9IFtcbiAgICAgIFwiU0VMRUNUXCIsXG4gICAgICBcImMuQ09MVU1OX05BTUUgQVMgJ05hbWUnLFwiLFxuICAgICAgXCJjLkRBVEFfVFlQRSBBUyAnVHlwZScsXCIsXG4gICAgICBcImMuQ0hBUkFDVEVSX01BWElNVU1fTEVOR1RIIEFTICdMZW5ndGgnLFwiLFxuICAgICAgXCJjLklTX05VTExBQkxFIGFzICdJc051bGwnLFwiLFxuICAgICAgXCJDT0xVTU5fREVGQVVMVCBBUyAnRGVmYXVsdCcsXCIsXG4gICAgICBcInBrLkNPTlNUUkFJTlRfVFlQRSBBUyAnQ29uc3RyYWludCcsXCIsXG4gICAgICBcIkNPTFVNTlBST1BFUlRZKE9CSkVDVF9JRCgnWycgKyBjLlRBQkxFX1NDSEVNQSArICddLlsnICsgYy5UQUJMRV9OQU1FICsgJ10nKSwgYy5DT0xVTU5fTkFNRSwgJ0lzSWRlbnRpdHknKSBhcyAnSXNJZGVudGl0eScsXCIsXG4gICAgICBcIkNBU1QocHJvcC52YWx1ZSBBUyBOVkFSQ0hBUikgQVMgJ0NvbW1lbnQnXCIsXG4gICAgICBcIkZST01cIixcbiAgICAgIFwiSU5GT1JNQVRJT05fU0NIRU1BLlRBQkxFUyB0XCIsXG4gICAgICBcIklOTkVSIEpPSU5cIixcbiAgICAgIFwiSU5GT1JNQVRJT05fU0NIRU1BLkNPTFVNTlMgYyBPTiB0LlRBQkxFX05BTUUgPSBjLlRBQkxFX05BTUUgQU5EIHQuVEFCTEVfU0NIRU1BID0gYy5UQUJMRV9TQ0hFTUFcIixcbiAgICAgIFwiTEVGVCBKT0lOIChTRUxFQ1QgdGMudGFibGVfc2NoZW1hLCB0Yy50YWJsZV9uYW1lLCBcIixcbiAgICAgIFwiY3UuY29sdW1uX25hbWUsIHRjLkNPTlNUUkFJTlRfVFlQRSBcIixcbiAgICAgIFwiRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuVEFCTEVfQ09OU1RSQUlOVFMgdGMgXCIsXG4gICAgICBcIkpPSU4gSU5GT1JNQVRJT05fU0NIRU1BLktFWV9DT0xVTU5fVVNBR0UgIGN1IFwiLFxuICAgICAgXCJPTiB0Yy50YWJsZV9zY2hlbWE9Y3UudGFibGVfc2NoZW1hIGFuZCB0Yy50YWJsZV9uYW1lPWN1LnRhYmxlX25hbWUgXCIsXG4gICAgICBcImFuZCB0Yy5jb25zdHJhaW50X25hbWU9Y3UuY29uc3RyYWludF9uYW1lIFwiLFxuICAgICAgXCJhbmQgdGMuQ09OU1RSQUlOVF9UWVBFPSdQUklNQVJZIEtFWScpIHBrIFwiLFxuICAgICAgXCJPTiBway50YWJsZV9zY2hlbWE9Yy50YWJsZV9zY2hlbWEgXCIsXG4gICAgICBcIkFORCBway50YWJsZV9uYW1lPWMudGFibGVfbmFtZSBcIixcbiAgICAgIFwiQU5EIHBrLmNvbHVtbl9uYW1lPWMuY29sdW1uX25hbWUgXCIsXG4gICAgICBcIklOTkVSIEpPSU4gc3lzLmNvbHVtbnMgQVMgc2NcIixcbiAgICAgIFwiT04gc2Mub2JqZWN0X2lkID0gT0JKRUNUX0lEKCdbJyArIHQuVEFCTEVfU0NIRU1BICsgJ10uWycgKyB0LlRBQkxFX05BTUUgKyAnXScpIEFORCBzYy5uYW1lID0gYy5jb2x1bW5fbmFtZVwiLFxuICAgICAgXCJMRUZUIEpPSU4gc3lzLmV4dGVuZGVkX3Byb3BlcnRpZXMgcHJvcCBPTiBwcm9wLm1ham9yX2lkID0gc2Mub2JqZWN0X2lkXCIsXG4gICAgICBcIkFORCBwcm9wLm1pbm9yX2lkID0gc2MuY29sdW1uX2lkXCIsXG4gICAgICBcIkFORCBwcm9wLm5hbWUgPSAnTVNfRGVzY3JpcHRpb24nXCIsXG4gICAgICBcIldIRVJFIHQuVEFCTEVfTkFNRSA9XCIsXG4gICAgICB3cmFwU2luZ2xlUXVvdGUodGFibGVOYW1lKVxuICAgIF0uam9pbihcIiBcIik7XG4gICAgaWYgKHNjaGVtYSkge1xuICAgICAgc3FsICs9IGBBTkQgdC5UQUJMRV9TQ0hFTUEgPSR7d3JhcFNpbmdsZVF1b3RlKHNjaGVtYSl9YDtcbiAgICB9XG4gICAgcmV0dXJuIHNxbDtcbiAgfVxuICByZW5hbWVUYWJsZVF1ZXJ5KGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICByZXR1cm4gYEVYRUMgc3BfcmVuYW1lICR7dGhpcy5xdW90ZVRhYmxlKGJlZm9yZSl9LCAke3RoaXMucXVvdGVUYWJsZShhZnRlcil9O2A7XG4gIH1cbiAgc2hvd1RhYmxlc1F1ZXJ5KCkge1xuICAgIHJldHVybiBcIlNFTEVDVCBUQUJMRV9OQU1FLCBUQUJMRV9TQ0hFTUEgRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuVEFCTEVTIFdIRVJFIFRBQkxFX1RZUEUgPSAnQkFTRSBUQUJMRSc7XCI7XG4gIH1cbiAgdGFibGVFeGlzdHNRdWVyeSh0YWJsZSkge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZTtcbiAgICBjb25zdCBzY2hlbWFOYW1lID0gdGFibGUuc2NoZW1hIHx8IFwiZGJvXCI7XG4gICAgcmV0dXJuIGBTRUxFQ1QgVEFCTEVfTkFNRSwgVEFCTEVfU0NIRU1BIEZST00gSU5GT1JNQVRJT05fU0NIRU1BLlRBQkxFUyBXSEVSRSBUQUJMRV9UWVBFID0gJ0JBU0UgVEFCTEUnIEFORCBUQUJMRV9OQU1FID0gJHt0aGlzLmVzY2FwZSh0YWJsZU5hbWUpfSBBTkQgVEFCTEVfU0NIRU1BID0gJHt0aGlzLmVzY2FwZShzY2hlbWFOYW1lKX1gO1xuICB9XG4gIGRyb3BUYWJsZVF1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIGNvbnN0IHF1b3RlVGJsID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgYElGIE9CSkVDVF9JRCgnJHtxdW90ZVRibH0nLCAnVScpIElTIE5PVCBOVUxMYCxcbiAgICAgIFwiRFJPUCBUQUJMRVwiLFxuICAgICAgcXVvdGVUYmwsXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIGFkZENvbHVtblF1ZXJ5KHRhYmxlLCBrZXksIGRhdGFUeXBlKSB7XG4gICAgZGF0YVR5cGUuZmllbGQgPSBrZXk7XG4gICAgbGV0IGNvbW1lbnRTdHIgPSBcIlwiO1xuICAgIGlmIChkYXRhVHlwZS5jb21tZW50ICYmIF8uaXNTdHJpbmcoZGF0YVR5cGUuY29tbWVudCkpIHtcbiAgICAgIGNvbW1lbnRTdHIgPSB0aGlzLmNvbW1lbnRUZW1wbGF0ZShkYXRhVHlwZS5jb21tZW50LCB0YWJsZSwga2V5KTtcbiAgICAgIGRlbGV0ZSBkYXRhVHlwZVtcImNvbW1lbnRcIl07XG4gICAgfVxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQUxURVIgVEFCTEVcIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZSksXG4gICAgICBcIkFERFwiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KSxcbiAgICAgIHRoaXMuYXR0cmlidXRlVG9TUUwoZGF0YVR5cGUsIHsgY29udGV4dDogXCJhZGRDb2x1bW5cIiB9KSxcbiAgICAgIFwiO1wiLFxuICAgICAgY29tbWVudFN0clxuICAgIF0pO1xuICB9XG4gIGNvbW1lbnRUZW1wbGF0ZShjb21tZW50LCB0YWJsZSwgY29sdW1uKSB7XG4gICAgcmV0dXJuIGAgRVhFQyBzcF9hZGRleHRlbmRlZHByb3BlcnR5IEBuYW1lID0gTidNU19EZXNjcmlwdGlvbicsIEB2YWx1ZSA9ICR7dGhpcy5lc2NhcGUoY29tbWVudCl9LCBAbGV2ZWwwdHlwZSA9IE4nU2NoZW1hJywgQGxldmVsMG5hbWUgPSAnZGJvJywgQGxldmVsMXR5cGUgPSBOJ1RhYmxlJywgQGxldmVsMW5hbWUgPSAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRhYmxlKX0sIEBsZXZlbDJ0eXBlID0gTidDb2x1bW4nLCBAbGV2ZWwybmFtZSA9ICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoY29sdW1uKX07YDtcbiAgfVxuICByZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIFwiRFJPUCBDT0xVTU5cIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBjaGFuZ2VDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBhdHRyU3RyaW5nID0gW10sIGNvbnN0cmFpbnRTdHJpbmcgPSBbXTtcbiAgICBsZXQgY29tbWVudFN0cmluZyA9IFwiXCI7XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IHF1b3RlZEF0dHJOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSk7XG4gICAgICBsZXQgZGVmaW5pdGlvbiA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBpZiAoZGVmaW5pdGlvbi5pbmNsdWRlcyhcIkNPTU1FTlQgXCIpKSB7XG4gICAgICAgIGNvbnN0IGNvbW1lbnRNYXRjaCA9IGRlZmluaXRpb24ubWF0Y2goL14oLispIChDT01NRU5ULiopJC8pO1xuICAgICAgICBjb25zdCBjb21tZW50VGV4dCA9IGNvbW1lbnRNYXRjaFsyXS5yZXBsYWNlKFwiQ09NTUVOVFwiLCBcIlwiKS50cmltKCk7XG4gICAgICAgIGNvbW1lbnRTdHJpbmcgKz0gdGhpcy5jb21tZW50VGVtcGxhdGUoY29tbWVudFRleHQsIHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIGRlZmluaXRpb24gPSBjb21tZW50TWF0Y2hbMV07XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5pdGlvbi5pbmNsdWRlcyhcIlJFRkVSRU5DRVNcIikpIHtcbiAgICAgICAgY29uc3RyYWludFN0cmluZy5wdXNoKGBGT1JFSUdOIEtFWSAoJHtxdW90ZWRBdHRyTmFtZX0pICR7ZGVmaW5pdGlvbi5yZXBsYWNlKC8uKz8oPz1SRUZFUkVOQ0VTKS8sIFwiXCIpfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0clN0cmluZy5wdXNoKGAke3F1b3RlZEF0dHJOYW1lfSAke2RlZmluaXRpb259YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQUxURVIgVEFCTEVcIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgYXR0clN0cmluZy5sZW5ndGggJiYgYEFMVEVSIENPTFVNTiAke2F0dHJTdHJpbmcuam9pbihcIiwgXCIpfWAsXG4gICAgICBjb25zdHJhaW50U3RyaW5nLmxlbmd0aCAmJiBgQUREICR7Y29uc3RyYWludFN0cmluZy5qb2luKFwiLCBcIil9YCxcbiAgICAgIFwiO1wiLFxuICAgICAgY29tbWVudFN0cmluZ1xuICAgIF0pO1xuICB9XG4gIHJlbmFtZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0ckJlZm9yZSwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IG5ld05hbWUgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKVswXTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkVYRUMgc3BfcmVuYW1lXCIsXG4gICAgICBgJyR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9LiR7YXR0ckJlZm9yZX0nLGAsXG4gICAgICBgJyR7bmV3TmFtZX0nLGAsXG4gICAgICBcIidDT0xVTU4nXCIsXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIGJ1bGtJbnNlcnRRdWVyeSh0YWJsZU5hbWUsIGF0dHJWYWx1ZUhhc2hlcywgb3B0aW9ucywgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHF1b3RlZFRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwge307XG4gICAgY29uc3QgdHVwbGVzID0gW107XG4gICAgY29uc3QgYWxsQXR0cmlidXRlcyA9IFtdO1xuICAgIGNvbnN0IGFsbFF1ZXJpZXMgPSBbXTtcbiAgICBsZXQgbmVlZElkZW50aXR5SW5zZXJ0V3JhcHBlciA9IGZhbHNlLCBvdXRwdXRGcmFnbWVudCA9IFwiXCI7XG4gICAgaWYgKG9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICBjb25zdCByZXR1cm5WYWx1ZXMgPSB0aGlzLmdlbmVyYXRlUmV0dXJuVmFsdWVzKGF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgICAgb3V0cHV0RnJhZ21lbnQgPSByZXR1cm5WYWx1ZXMub3V0cHV0RnJhZ21lbnQ7XG4gICAgfVxuICAgIGNvbnN0IGVtcHR5UXVlcnkgPSBgSU5TRVJUIElOVE8gJHtxdW90ZWRUYWJsZX0ke291dHB1dEZyYWdtZW50fSBERUZBVUxUIFZBTFVFU2A7XG4gICAgYXR0clZhbHVlSGFzaGVzLmZvckVhY2goKGF0dHJWYWx1ZUhhc2gpID0+IHtcbiAgICAgIGNvbnN0IGZpZWxkcyA9IE9iamVjdC5rZXlzKGF0dHJWYWx1ZUhhc2gpO1xuICAgICAgY29uc3QgZmlyc3RBdHRyID0gYXR0cmlidXRlc1tmaWVsZHNbMF1dO1xuICAgICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDEgJiYgZmlyc3RBdHRyICYmIGZpcnN0QXR0ci5hdXRvSW5jcmVtZW50ICYmIGF0dHJWYWx1ZUhhc2hbZmllbGRzWzBdXSA9PT0gbnVsbCkge1xuICAgICAgICBhbGxRdWVyaWVzLnB1c2goZW1wdHlRdWVyeSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF8uZm9yT3duKGF0dHJWYWx1ZUhhc2gsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiBhdHRyaWJ1dGVzW2tleV0gJiYgYXR0cmlidXRlc1trZXldLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgICAgICBuZWVkSWRlbnRpdHlJbnNlcnRXcmFwcGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFsbEF0dHJpYnV0ZXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiBhdHRyaWJ1dGVzW2tleV0gJiYgYXR0cmlidXRlc1trZXldLmF1dG9JbmNyZW1lbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgYWxsQXR0cmlidXRlcy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChhbGxBdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGF0dHJWYWx1ZUhhc2hlcy5mb3JFYWNoKChhdHRyVmFsdWVIYXNoKSA9PiB7XG4gICAgICAgIHR1cGxlcy5wdXNoKGAoJHthbGxBdHRyaWJ1dGVzLm1hcCgoa2V5KSA9PiB0aGlzLmVzY2FwZShhdHRyVmFsdWVIYXNoW2tleV0pKS5qb2luKFwiLFwiKX0pYCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHF1b3RlZEF0dHJpYnV0ZXMgPSBhbGxBdHRyaWJ1dGVzLm1hcCgoYXR0cikgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cikpLmpvaW4oXCIsXCIpO1xuICAgICAgYWxsUXVlcmllcy5wdXNoKCh0dXBsZVN0cikgPT4gYElOU0VSVCBJTlRPICR7cXVvdGVkVGFibGV9ICgke3F1b3RlZEF0dHJpYnV0ZXN9KSR7b3V0cHV0RnJhZ21lbnR9IFZBTFVFUyAke3R1cGxlU3RyfTtgKTtcbiAgICB9XG4gICAgY29uc3QgY29tbWFuZHMgPSBbXTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBjb25zdCBiYXRjaCA9IE1hdGguZmxvb3IoMjUwIC8gKGFsbEF0dHJpYnV0ZXMubGVuZ3RoICsgMSkpICsgMTtcbiAgICB3aGlsZSAob2Zmc2V0IDwgTWF0aC5tYXgodHVwbGVzLmxlbmd0aCwgMSkpIHtcbiAgICAgIGNvbnN0IHR1cGxlU3RyID0gdHVwbGVzLnNsaWNlKG9mZnNldCwgTWF0aC5taW4odHVwbGVzLmxlbmd0aCwgb2Zmc2V0ICsgYmF0Y2gpKTtcbiAgICAgIGxldCBnZW5lcmF0ZWRRdWVyeSA9IGFsbFF1ZXJpZXMubWFwKCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiA/IHYgOiB2KHR1cGxlU3RyKSkuam9pbihcIjtcIik7XG4gICAgICBpZiAobmVlZElkZW50aXR5SW5zZXJ0V3JhcHBlcikge1xuICAgICAgICBnZW5lcmF0ZWRRdWVyeSA9IGBTRVQgSURFTlRJVFlfSU5TRVJUICR7cXVvdGVkVGFibGV9IE9OOyAke2dlbmVyYXRlZFF1ZXJ5fTsgU0VUIElERU5USVRZX0lOU0VSVCAke3F1b3RlZFRhYmxlfSBPRkY7YDtcbiAgICAgIH1cbiAgICAgIGNvbW1hbmRzLnB1c2goZ2VuZXJhdGVkUXVlcnkpO1xuICAgICAgb2Zmc2V0ICs9IGJhdGNoO1xuICAgIH1cbiAgICByZXR1cm4gY29tbWFuZHMuam9pbihcIjtcIik7XG4gIH1cbiAgdXBkYXRlUXVlcnkodGFibGVOYW1lLCBhdHRyVmFsdWVIYXNoLCB3aGVyZSwgb3B0aW9ucywgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHNxbCA9IHN1cGVyLnVwZGF0ZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0clZhbHVlSGFzaCwgd2hlcmUsIG9wdGlvbnMsIGF0dHJpYnV0ZXMpO1xuICAgIGlmIChvcHRpb25zLmxpbWl0KSB7XG4gICAgICBjb25zdCB1cGRhdGVBcmdzID0gYFVQREFURSBUT1AoJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX0pYDtcbiAgICAgIHNxbC5xdWVyeSA9IHNxbC5xdWVyeS5yZXBsYWNlKFwiVVBEQVRFXCIsIHVwZGF0ZUFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gc3FsO1xuICB9XG4gIHVwc2VydFF1ZXJ5KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCB1cGRhdGVWYWx1ZXMsIHdoZXJlLCBtb2RlbCkge1xuICAgIGNvbnN0IHRhcmdldFRhYmxlQWxpYXMgPSB0aGlzLnF1b3RlVGFibGUoYCR7dGFibGVOYW1lfV90YXJnZXRgKTtcbiAgICBjb25zdCBzb3VyY2VUYWJsZUFsaWFzID0gdGhpcy5xdW90ZVRhYmxlKGAke3RhYmxlTmFtZX1fc291cmNlYCk7XG4gICAgY29uc3QgcHJpbWFyeUtleXNBdHRycyA9IFtdO1xuICAgIGNvbnN0IGlkZW50aXR5QXR0cnMgPSBbXTtcbiAgICBjb25zdCB1bmlxdWVBdHRycyA9IFtdO1xuICAgIGNvbnN0IHRhYmxlTmFtZVF1b3RlZCA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIGxldCBuZWVkSWRlbnRpdHlJbnNlcnRXcmFwcGVyID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbW9kZWwucmF3QXR0cmlidXRlcykge1xuICAgICAgaWYgKG1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS5wcmltYXJ5S2V5KSB7XG4gICAgICAgIHByaW1hcnlLZXlzQXR0cnMucHVzaChtb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0uZmllbGQgfHwga2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0udW5pcXVlKSB7XG4gICAgICAgIHVuaXF1ZUF0dHJzLnB1c2gobW9kZWwucmF3QXR0cmlidXRlc1trZXldLmZpZWxkIHx8IGtleSk7XG4gICAgICB9XG4gICAgICBpZiAobW9kZWwucmF3QXR0cmlidXRlc1trZXldLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgICAgaWRlbnRpdHlBdHRycy5wdXNoKG1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS5maWVsZCB8fCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mIG1vZGVsLl9pbmRleGVzKSB7XG4gICAgICBpZiAoaW5kZXgudW5pcXVlICYmIGluZGV4LmZpZWxkcykge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGluZGV4LmZpZWxkcykge1xuICAgICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIiA/IGZpZWxkIDogZmllbGQubmFtZSB8fCBmaWVsZC5hdHRyaWJ1dGU7XG4gICAgICAgICAgaWYgKCF1bmlxdWVBdHRycy5pbmNsdWRlcyhmaWVsZE5hbWUpICYmIG1vZGVsLnJhd0F0dHJpYnV0ZXNbZmllbGROYW1lXSkge1xuICAgICAgICAgICAgdW5pcXVlQXR0cnMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1cGRhdGVLZXlzID0gT2JqZWN0LmtleXModXBkYXRlVmFsdWVzKTtcbiAgICBjb25zdCBpbnNlcnRLZXlzID0gT2JqZWN0LmtleXMoaW5zZXJ0VmFsdWVzKTtcbiAgICBjb25zdCBpbnNlcnRLZXlzUXVvdGVkID0gaW5zZXJ0S2V5cy5tYXAoKGtleSkgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KSkuam9pbihcIiwgXCIpO1xuICAgIGNvbnN0IGluc2VydFZhbHVlc0VzY2FwZWQgPSBpbnNlcnRLZXlzLm1hcCgoa2V5KSA9PiB0aGlzLmVzY2FwZShpbnNlcnRWYWx1ZXNba2V5XSkpLmpvaW4oXCIsIFwiKTtcbiAgICBjb25zdCBzb3VyY2VUYWJsZVF1ZXJ5ID0gYFZBTFVFUygke2luc2VydFZhbHVlc0VzY2FwZWR9KWA7XG4gICAgbGV0IGpvaW5Db25kaXRpb247XG4gICAgaWRlbnRpdHlBdHRycy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmIChpbnNlcnRWYWx1ZXNba2V5XSAmJiBpbnNlcnRWYWx1ZXNba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICBuZWVkSWRlbnRpdHlJbnNlcnRXcmFwcGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBjbGF1c2VzID0gd2hlcmVbT3Aub3JdLmZpbHRlcigoY2xhdXNlKSA9PiB7XG4gICAgICBsZXQgdmFsaWQgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY2xhdXNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhdXNlW2tleV0gPT09IFwidW5kZWZpbmVkXCIgfHwgY2xhdXNlW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9KTtcbiAgICBjb25zdCBnZXRKb2luU25pcHBldCA9IChhcnJheSkgPT4ge1xuICAgICAgcmV0dXJuIGFycmF5Lm1hcCgoa2V5KSA9PiB7XG4gICAgICAgIGtleSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSk7XG4gICAgICAgIHJldHVybiBgJHt0YXJnZXRUYWJsZUFsaWFzfS4ke2tleX0gPSAke3NvdXJjZVRhYmxlQWxpYXN9LiR7a2V5fWA7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChjbGF1c2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJpbWFyeSBLZXkgb3IgVW5pcXVlIGtleSBzaG91bGQgYmUgcGFzc2VkIHRvIHVwc2VydCBxdWVyeVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY2xhdXNlcykge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY2xhdXNlc1trZXldKTtcbiAgICAgICAgaWYgKHByaW1hcnlLZXlzQXR0cnMuaW5jbHVkZXMoa2V5c1swXSkpIHtcbiAgICAgICAgICBqb2luQ29uZGl0aW9uID0gZ2V0Sm9pblNuaXBwZXQocHJpbWFyeUtleXNBdHRycykuam9pbihcIiBBTkQgXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWpvaW5Db25kaXRpb24pIHtcbiAgICAgICAgam9pbkNvbmRpdGlvbiA9IGdldEpvaW5TbmlwcGV0KHVuaXF1ZUF0dHJzKS5qb2luKFwiIEFORCBcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlcmVkVXBkYXRlQ2xhdXNlcyA9IHVwZGF0ZUtleXMuZmlsdGVyKChrZXkpID0+ICFpZGVudGl0eUF0dHJzLmluY2x1ZGVzKGtleSkpLm1hcCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZXNjYXBlKHVwZGF0ZVZhbHVlc1trZXldKTtcbiAgICAgIGtleSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSk7XG4gICAgICByZXR1cm4gYCR7dGFyZ2V0VGFibGVBbGlhc30uJHtrZXl9ID0gJHt2YWx1ZX1gO1xuICAgIH0pO1xuICAgIGNvbnN0IHVwZGF0ZVNuaXBwZXQgPSBmaWx0ZXJlZFVwZGF0ZUNsYXVzZXMubGVuZ3RoID4gMCA/IGBXSEVOIE1BVENIRUQgVEhFTiBVUERBVEUgU0VUICR7ZmlsdGVyZWRVcGRhdGVDbGF1c2VzLmpvaW4oXCIsIFwiKX1gIDogXCJcIjtcbiAgICBjb25zdCBpbnNlcnRTbmlwcGV0ID0gYCgke2luc2VydEtleXNRdW90ZWR9KSBWQUxVRVMoJHtpbnNlcnRWYWx1ZXNFc2NhcGVkfSlgO1xuICAgIGxldCBxdWVyeSA9IGBNRVJHRSBJTlRPICR7dGFibGVOYW1lUXVvdGVkfSBXSVRIKEhPTERMT0NLKSBBUyAke3RhcmdldFRhYmxlQWxpYXN9IFVTSU5HICgke3NvdXJjZVRhYmxlUXVlcnl9KSBBUyAke3NvdXJjZVRhYmxlQWxpYXN9KCR7aW5zZXJ0S2V5c1F1b3RlZH0pIE9OICR7am9pbkNvbmRpdGlvbn1gO1xuICAgIHF1ZXJ5ICs9IGAgJHt1cGRhdGVTbmlwcGV0fSBXSEVOIE5PVCBNQVRDSEVEIFRIRU4gSU5TRVJUICR7aW5zZXJ0U25pcHBldH0gT1VUUFVUICRhY3Rpb24sIElOU0VSVEVELio7YDtcbiAgICBpZiAobmVlZElkZW50aXR5SW5zZXJ0V3JhcHBlcikge1xuICAgICAgcXVlcnkgPSBgU0VUIElERU5USVRZX0lOU0VSVCAke3RhYmxlTmFtZVF1b3RlZH0gT047ICR7cXVlcnl9IFNFVCBJREVOVElUWV9JTlNFUlQgJHt0YWJsZU5hbWVRdW90ZWR9IE9GRjtgO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cbiAgdHJ1bmNhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBgVFJVTkNBVEUgVEFCTEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX1gO1xuICB9XG4gIGRlbGV0ZVF1ZXJ5KHRhYmxlTmFtZSwgd2hlcmUsIG9wdGlvbnMgPSB7fSwgbW9kZWwpIHtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIGNvbnN0IHdoZXJlQ2xhdXNlID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnMod2hlcmUsIG51bGwsIG1vZGVsLCBvcHRpb25zKTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkRFTEVURVwiLFxuICAgICAgb3B0aW9ucy5saW1pdCAmJiBgVE9QKCR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9KWAsXG4gICAgICBcIkZST01cIixcbiAgICAgIHRhYmxlLFxuICAgICAgd2hlcmVDbGF1c2UgJiYgYFdIRVJFICR7d2hlcmVDbGF1c2V9YCxcbiAgICAgIFwiO1wiLFxuICAgICAgXCJTRUxFQ1QgQEBST1dDT1VOVCBBUyBBRkZFQ1RFRFJPV1NcIixcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgc2hvd0luZGV4ZXNRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gYEVYRUMgc3lzLnNwX2hlbHBpbmRleCBAb2JqbmFtZSA9IE4nJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0nO2A7XG4gIH1cbiAgc2hvd0NvbnN0cmFpbnRzUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIGBFWEVDIHNwX2hlbHBjb25zdHJhaW50IEBvYmpuYW1lID0gJHt0aGlzLmVzY2FwZSh0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSl9O2A7XG4gIH1cbiAgcmVtb3ZlSW5kZXhRdWVyeSh0YWJsZU5hbWUsIGluZGV4TmFtZU9yQXR0cmlidXRlcykge1xuICAgIGxldCBpbmRleE5hbWUgPSBpbmRleE5hbWVPckF0dHJpYnV0ZXM7XG4gICAgaWYgKHR5cGVvZiBpbmRleE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGluZGV4TmFtZSA9IFV0aWxzLnVuZGVyc2NvcmUoYCR7dGFibGVOYW1lfV8ke2luZGV4TmFtZU9yQXR0cmlidXRlcy5qb2luKFwiX1wiKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGBEUk9QIElOREVYICR7dGhpcy5xdW90ZUlkZW50aWZpZXJzKGluZGV4TmFtZSl9IE9OICR7dGhpcy5xdW90ZUlkZW50aWZpZXJzKHRhYmxlTmFtZSl9YDtcbiAgfVxuICBhdHRyaWJ1dGVUb1NRTChhdHRyaWJ1dGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIV8uaXNQbGFpbk9iamVjdChhdHRyaWJ1dGUpKSB7XG4gICAgICBhdHRyaWJ1dGUgPSB7XG4gICAgICAgIHR5cGU6IGF0dHJpYnV0ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzKSB7XG4gICAgICBpZiAoYXR0cmlidXRlLk1vZGVsICYmIGF0dHJpYnV0ZS5Nb2RlbC50YWJsZU5hbWUgPT09IGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsKSB7XG4gICAgICAgIHRoaXMuc2VxdWVsaXplLmxvZyhcIk1TU1FMIGRvZXMgbm90IHN1cHBvcnQgc2VsZiByZWZlcmVuY2lhbCBjb25zdHJhaW50cywgd2Ugd2lsbCByZW1vdmUgaXQgYnV0IHdlIHJlY29tbWVuZCByZXN0cnVjdHVyaW5nIHlvdXIgcXVlcnlcIik7XG4gICAgICAgIGF0dHJpYnV0ZS5vbkRlbGV0ZSA9IFwiXCI7XG4gICAgICAgIGF0dHJpYnV0ZS5vblVwZGF0ZSA9IFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB0ZW1wbGF0ZTtcbiAgICBpZiAoYXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSkge1xuICAgICAgaWYgKGF0dHJpYnV0ZS50eXBlLnZhbHVlcyAmJiAhYXR0cmlidXRlLnZhbHVlcylcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlcyA9IGF0dHJpYnV0ZS50eXBlLnZhbHVlcztcbiAgICAgIHRlbXBsYXRlID0gYXR0cmlidXRlLnR5cGUudG9TcWwoKTtcbiAgICAgIHRlbXBsYXRlICs9IGAgQ0hFQ0sgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlLmZpZWxkKX0gSU4oJHthdHRyaWJ1dGUudmFsdWVzLm1hcCgodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXNjYXBlKHZhbHVlKTtcbiAgICAgIH0pLmpvaW4oXCIsIFwiKX0pKWA7XG4gICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfVxuICAgIHRlbXBsYXRlID0gYXR0cmlidXRlLnR5cGUudG9TdHJpbmcoKTtcbiAgICBpZiAoYXR0cmlidXRlLmFsbG93TnVsbCA9PT0gZmFsc2UpIHtcbiAgICAgIHRlbXBsYXRlICs9IFwiIE5PVCBOVUxMXCI7XG4gICAgfSBlbHNlIGlmICghYXR0cmlidXRlLnByaW1hcnlLZXkgJiYgIVV0aWxzLmRlZmF1bHRWYWx1ZVNjaGVtYWJsZShhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlKSkge1xuICAgICAgdGVtcGxhdGUgKz0gXCIgTlVMTFwiO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgIHRlbXBsYXRlICs9IFwiIElERU5USVRZKDEsMSlcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS50eXBlICE9PSBcIlRFWFRcIiAmJiBhdHRyaWJ1dGUudHlwZS5fYmluYXJ5ICE9PSB0cnVlICYmIFV0aWxzLmRlZmF1bHRWYWx1ZVNjaGVtYWJsZShhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlKSkge1xuICAgICAgdGVtcGxhdGUgKz0gYCBERUZBVUxUICR7dGhpcy5lc2NhcGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSl9YDtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS51bmlxdWUgPT09IHRydWUpIHtcbiAgICAgIHRlbXBsYXRlICs9IFwiIFVOSVFVRVwiO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLnByaW1hcnlLZXkpIHtcbiAgICAgIHRlbXBsYXRlICs9IFwiIFBSSU1BUlkgS0VZXCI7XG4gICAgfVxuICAgIGlmICgoIW9wdGlvbnMgfHwgIW9wdGlvbnMud2l0aG91dEZvcmVpZ25LZXlDb25zdHJhaW50cykgJiYgYXR0cmlidXRlLnJlZmVyZW5jZXMpIHtcbiAgICAgIHRlbXBsYXRlICs9IGAgUkVGRVJFTkNFUyAke3RoaXMucXVvdGVUYWJsZShhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbCl9YDtcbiAgICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcy5rZXkpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGUucmVmZXJlbmNlcy5rZXkpfSlgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihcImlkXCIpfSlgO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZS5vbkRlbGV0ZSkge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgIE9OIERFTEVURSAke2F0dHJpYnV0ZS5vbkRlbGV0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlLm9uVXBkYXRlKSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgT04gVVBEQVRFICR7YXR0cmlidXRlLm9uVXBkYXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5jb21tZW50ICYmIHR5cGVvZiBhdHRyaWJ1dGUuY29tbWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGVtcGxhdGUgKz0gYCBDT01NRU5UICR7YXR0cmlidXRlLmNvbW1lbnR9YDtcbiAgICB9XG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9XG4gIGF0dHJpYnV0ZXNUb1NRTChhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge30sIGV4aXN0aW5nQ29uc3RyYWludHMgPSBbXTtcbiAgICBsZXQga2V5LCBhdHRyaWJ1dGU7XG4gICAgZm9yIChrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgYXR0cmlidXRlID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzKSB7XG4gICAgICAgIGlmIChleGlzdGluZ0NvbnN0cmFpbnRzLmluY2x1ZGVzKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgYXR0cmlidXRlLm9uRGVsZXRlID0gXCJcIjtcbiAgICAgICAgICBhdHRyaWJ1dGUub25VcGRhdGUgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4aXN0aW5nQ29uc3RyYWludHMucHVzaChhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbC50b1N0cmluZygpKTtcbiAgICAgICAgICBhdHRyaWJ1dGUub25VcGRhdGUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoa2V5ICYmICFhdHRyaWJ1dGUuZmllbGQpXG4gICAgICAgIGF0dHJpYnV0ZS5maWVsZCA9IGtleTtcbiAgICAgIHJlc3VsdFthdHRyaWJ1dGUuZmllbGQgfHwga2V5XSA9IHRoaXMuYXR0cmlidXRlVG9TUUwoYXR0cmlidXRlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjcmVhdGVUcmlnZ2VyKCkge1xuICAgIHRocm93TWV0aG9kVW5kZWZpbmVkKFwiY3JlYXRlVHJpZ2dlclwiKTtcbiAgfVxuICBkcm9wVHJpZ2dlcigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZChcImRyb3BUcmlnZ2VyXCIpO1xuICB9XG4gIHJlbmFtZVRyaWdnZXIoKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoXCJyZW5hbWVUcmlnZ2VyXCIpO1xuICB9XG4gIGNyZWF0ZUZ1bmN0aW9uKCkge1xuICAgIHRocm93TWV0aG9kVW5kZWZpbmVkKFwiY3JlYXRlRnVuY3Rpb25cIik7XG4gIH1cbiAgZHJvcEZ1bmN0aW9uKCkge1xuICAgIHRocm93TWV0aG9kVW5kZWZpbmVkKFwiZHJvcEZ1bmN0aW9uXCIpO1xuICB9XG4gIHJlbmFtZUZ1bmN0aW9uKCkge1xuICAgIHRocm93TWV0aG9kVW5kZWZpbmVkKFwicmVuYW1lRnVuY3Rpb25cIik7XG4gIH1cbiAgX2dldEZvcmVpZ25LZXlzUXVlcnlQcmVmaXgoY2F0YWxvZ05hbWUpIHtcbiAgICByZXR1cm4gYCR7XCJTRUxFQ1QgY29uc3RyYWludF9uYW1lID0gT0JKLk5BTUUsIGNvbnN0cmFpbnROYW1lID0gT0JKLk5BTUUsIFwifSR7Y2F0YWxvZ05hbWUgPyBgY29uc3RyYWludENhdGFsb2cgPSAnJHtjYXRhbG9nTmFtZX0nLCBgIDogXCJcIn1jb25zdHJhaW50U2NoZW1hID0gU0NIRU1BX05BTUUoT0JKLlNDSEVNQV9JRCksIHRhYmxlTmFtZSA9IFRCLk5BTUUsIHRhYmxlU2NoZW1hID0gU0NIRU1BX05BTUUoVEIuU0NIRU1BX0lEKSwgJHtjYXRhbG9nTmFtZSA/IGB0YWJsZUNhdGFsb2cgPSAnJHtjYXRhbG9nTmFtZX0nLCBgIDogXCJcIn1jb2x1bW5OYW1lID0gQ09MLk5BTUUsIHJlZmVyZW5jZWRUYWJsZVNjaGVtYSA9IFNDSEVNQV9OQU1FKFJUQi5TQ0hFTUFfSUQpLCAke2NhdGFsb2dOYW1lID8gYHJlZmVyZW5jZWRDYXRhbG9nID0gJyR7Y2F0YWxvZ05hbWV9JywgYCA6IFwiXCJ9cmVmZXJlbmNlZFRhYmxlTmFtZSA9IFJUQi5OQU1FLCByZWZlcmVuY2VkQ29sdW1uTmFtZSA9IFJDT0wuTkFNRSBGUk9NIHN5cy5mb3JlaWduX2tleV9jb2x1bW5zIEZLQyBJTk5FUiBKT0lOIHN5cy5vYmplY3RzIE9CSiBPTiBPQkouT0JKRUNUX0lEID0gRktDLkNPTlNUUkFJTlRfT0JKRUNUX0lEIElOTkVSIEpPSU4gc3lzLnRhYmxlcyBUQiBPTiBUQi5PQkpFQ1RfSUQgPSBGS0MuUEFSRU5UX09CSkVDVF9JRCBJTk5FUiBKT0lOIHN5cy5jb2x1bW5zIENPTCBPTiBDT0wuQ09MVU1OX0lEID0gUEFSRU5UX0NPTFVNTl9JRCBBTkQgQ09MLk9CSkVDVF9JRCA9IFRCLk9CSkVDVF9JRCBJTk5FUiBKT0lOIHN5cy50YWJsZXMgUlRCIE9OIFJUQi5PQkpFQ1RfSUQgPSBGS0MuUkVGRVJFTkNFRF9PQkpFQ1RfSUQgSU5ORVIgSk9JTiBzeXMuY29sdW1ucyBSQ09MIE9OIFJDT0wuQ09MVU1OX0lEID0gUkVGRVJFTkNFRF9DT0xVTU5fSUQgQU5EIFJDT0wuT0JKRUNUX0lEID0gUlRCLk9CSkVDVF9JRGA7XG4gIH1cbiAgZ2V0Rm9yZWlnbktleXNRdWVyeSh0YWJsZSwgY2F0YWxvZ05hbWUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZS50YWJsZU5hbWUgfHwgdGFibGU7XG4gICAgbGV0IHNxbCA9IGAke3RoaXMuX2dldEZvcmVpZ25LZXlzUXVlcnlQcmVmaXgoY2F0YWxvZ05hbWUpfSBXSEVSRSBUQi5OQU1FID0ke3dyYXBTaW5nbGVRdW90ZSh0YWJsZU5hbWUpfWA7XG4gICAgaWYgKHRhYmxlLnNjaGVtYSkge1xuICAgICAgc3FsICs9IGAgQU5EIFNDSEVNQV9OQU1FKFRCLlNDSEVNQV9JRCkgPSR7d3JhcFNpbmdsZVF1b3RlKHRhYmxlLnNjaGVtYSl9YDtcbiAgICB9XG4gICAgcmV0dXJuIHNxbDtcbiAgfVxuICBnZXRGb3JlaWduS2V5UXVlcnkodGFibGUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZS50YWJsZU5hbWUgfHwgdGFibGU7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgdGhpcy5fZ2V0Rm9yZWlnbktleXNRdWVyeVByZWZpeCgpLFxuICAgICAgXCJXSEVSRVwiLFxuICAgICAgYFRCLk5BTUUgPSR7d3JhcFNpbmdsZVF1b3RlKHRhYmxlTmFtZSl9YCxcbiAgICAgIFwiQU5EXCIsXG4gICAgICBgQ09MLk5BTUUgPSR7d3JhcFNpbmdsZVF1b3RlKGF0dHJpYnV0ZU5hbWUpfWAsXG4gICAgICB0YWJsZS5zY2hlbWEgJiYgYEFORCBTQ0hFTUFfTkFNRShUQi5TQ0hFTUFfSUQpID0ke3dyYXBTaW5nbGVRdW90ZSh0YWJsZS5zY2hlbWEpfWBcbiAgICBdKTtcbiAgfVxuICBnZXRQcmltYXJ5S2V5Q29uc3RyYWludFF1ZXJ5KHRhYmxlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gd3JhcFNpbmdsZVF1b3RlKHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZSk7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJTRUxFQ1QgSy5UQUJMRV9OQU1FIEFTIHRhYmxlTmFtZSxcIixcbiAgICAgIFwiSy5DT0xVTU5fTkFNRSBBUyBjb2x1bW5OYW1lLFwiLFxuICAgICAgXCJLLkNPTlNUUkFJTlRfTkFNRSBBUyBjb25zdHJhaW50TmFtZVwiLFxuICAgICAgXCJGUk9NIElORk9STUFUSU9OX1NDSEVNQS5UQUJMRV9DT05TVFJBSU5UUyBBUyBDXCIsXG4gICAgICBcIkpPSU4gSU5GT1JNQVRJT05fU0NIRU1BLktFWV9DT0xVTU5fVVNBR0UgQVMgS1wiLFxuICAgICAgXCJPTiBDLlRBQkxFX05BTUUgPSBLLlRBQkxFX05BTUVcIixcbiAgICAgIFwiQU5EIEMuQ09OU1RSQUlOVF9DQVRBTE9HID0gSy5DT05TVFJBSU5UX0NBVEFMT0dcIixcbiAgICAgIFwiQU5EIEMuQ09OU1RSQUlOVF9TQ0hFTUEgPSBLLkNPTlNUUkFJTlRfU0NIRU1BXCIsXG4gICAgICBcIkFORCBDLkNPTlNUUkFJTlRfTkFNRSA9IEsuQ09OU1RSQUlOVF9OQU1FXCIsXG4gICAgICBcIldIRVJFIEMuQ09OU1RSQUlOVF9UWVBFID0gJ1BSSU1BUlkgS0VZJ1wiLFxuICAgICAgYEFORCBLLkNPTFVNTl9OQU1FID0gJHt3cmFwU2luZ2xlUXVvdGUoYXR0cmlidXRlTmFtZSl9YCxcbiAgICAgIGBBTkQgSy5UQUJMRV9OQU1FID0gJHt0YWJsZU5hbWV9YCxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgZHJvcEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIGZvcmVpZ25LZXkpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIFwiRFJPUFwiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoZm9yZWlnbktleSlcbiAgICBdKTtcbiAgfVxuICBnZXREZWZhdWx0Q29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIGNvbnN0IHF1b3RlZFRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJTRUxFQ1QgbmFtZSBGUk9NIHN5cy5kZWZhdWx0X2NvbnN0cmFpbnRzXCIsXG4gICAgICBgV0hFUkUgUEFSRU5UX09CSkVDVF9JRCA9IE9CSkVDVF9JRCgnJHtxdW90ZWRUYWJsZX0nLCAnVScpYCxcbiAgICAgIGBBTkQgUEFSRU5UX0NPTFVNTl9JRCA9IChTRUxFQ1QgY29sdW1uX2lkIEZST00gc3lzLmNvbHVtbnMgV0hFUkUgTkFNRSA9ICgnJHthdHRyaWJ1dGVOYW1lfScpYCxcbiAgICAgIGBBTkQgb2JqZWN0X2lkID0gT0JKRUNUX0lEKCcke3F1b3RlZFRhYmxlfScsICdVJykpYCxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgZHJvcENvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lKSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBcIkRST1AgQ09OU1RSQUlOVFwiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoY29uc3RyYWludE5hbWUpLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBzZXRJc29sYXRpb25MZXZlbFF1ZXJ5KCkge1xuICB9XG4gIGdlbmVyYXRlVHJhbnNhY3Rpb25JZCgpIHtcbiAgICByZXR1cm4gcmFuZG9tQnl0ZXMoMTApLnRvU3RyaW5nKFwiaGV4XCIpO1xuICB9XG4gIHN0YXJ0VHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIHJldHVybiBgU0FWRSBUUkFOU0FDVElPTiAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRyYW5zYWN0aW9uLm5hbWUpfTtgO1xuICAgIH1cbiAgICByZXR1cm4gXCJCRUdJTiBUUkFOU0FDVElPTjtcIjtcbiAgfVxuICBjb21taXRUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gXCJDT01NSVQgVFJBTlNBQ1RJT047XCI7XG4gIH1cbiAgcm9sbGJhY2tUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgcmV0dXJuIGBST0xMQkFDSyBUUkFOU0FDVElPTiAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRyYW5zYWN0aW9uLm5hbWUpfTtgO1xuICAgIH1cbiAgICByZXR1cm4gXCJST0xMQkFDSyBUUkFOU0FDVElPTjtcIjtcbiAgfVxuICBzZWxlY3RGcm9tVGFibGVGcmFnbWVudChvcHRpb25zLCBtb2RlbCwgYXR0cmlidXRlcywgdGFibGVzLCBtYWluVGFibGVBcywgd2hlcmUpIHtcbiAgICB0aGlzLl90aHJvd09uRW1wdHlBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIHsgbW9kZWxOYW1lOiBtb2RlbCAmJiBtb2RlbC5uYW1lLCBhczogbWFpblRhYmxlQXMgfSk7XG4gICAgY29uc3QgZGJWZXJzaW9uID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb247XG4gICAgY29uc3QgaXNTUUxTZXJ2ZXIyMDA4ID0gc2VtdmVyLnZhbGlkKGRiVmVyc2lvbikgJiYgc2VtdmVyLmx0KGRiVmVyc2lvbiwgXCIxMS4wLjBcIik7XG4gICAgaWYgKGlzU1FMU2VydmVyMjAwOCAmJiBvcHRpb25zLm9mZnNldCkge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQgfHwgMDtcbiAgICAgIGNvbnN0IGlzU3ViUXVlcnkgPSBvcHRpb25zLmhhc0luY2x1ZGVXaGVyZSB8fCBvcHRpb25zLmhhc0luY2x1ZGVSZXF1aXJlZCB8fCBvcHRpb25zLmhhc011bHRpQXNzb2NpYXRpb247XG4gICAgICBsZXQgb3JkZXJzID0geyBtYWluUXVlcnlPcmRlcjogW10gfTtcbiAgICAgIGlmIChvcHRpb25zLm9yZGVyKSB7XG4gICAgICAgIG9yZGVycyA9IHRoaXMuZ2V0UXVlcnlPcmRlcnMob3B0aW9ucywgbW9kZWwsIGlzU3ViUXVlcnkpO1xuICAgICAgfVxuICAgICAgaWYgKG9yZGVycy5tYWluUXVlcnlPcmRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgb3JkZXJzLm1haW5RdWVyeU9yZGVyLnB1c2godGhpcy5xdW90ZUlkZW50aWZpZXIobW9kZWwucHJpbWFyeUtleUZpZWxkKSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0bXBUYWJsZSA9IG1haW5UYWJsZUFzIHx8IFwiT2Zmc2V0VGFibGVcIjtcbiAgICAgIGlmIChvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgICAgY29uc3Qgc3ViUXVlcnkgPSBvcHRpb25zLnN1YlF1ZXJ5ID09PSB2b2lkIDAgPyBvcHRpb25zLmxpbWl0ICYmIG9wdGlvbnMuaGFzTXVsdGlBc3NvY2lhdGlvbiA6IG9wdGlvbnMuc3ViUXVlcnk7XG4gICAgICAgIGNvbnN0IG1haW5UYWJsZSA9IHtcbiAgICAgICAgICBuYW1lOiBtYWluVGFibGVBcyxcbiAgICAgICAgICBxdW90ZWROYW1lOiBudWxsLFxuICAgICAgICAgIGFzOiBudWxsLFxuICAgICAgICAgIG1vZGVsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRvcExldmVsSW5mbyA9IHtcbiAgICAgICAgICBuYW1lczogbWFpblRhYmxlLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgc3ViUXVlcnlcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IG1haW5Kb2luUXVlcmllcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGluY2x1ZGUgb2Ygb3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICAgICAgaWYgKGluY2x1ZGUuc2VwYXJhdGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBqb2luUXVlcmllcyA9IHRoaXMuZ2VuZXJhdGVJbmNsdWRlKGluY2x1ZGUsIHsgZXh0ZXJuYWxBczogbWFpblRhYmxlQXMsIGludGVybmFsQXM6IG1haW5UYWJsZUFzIH0sIHRvcExldmVsSW5mbyk7XG4gICAgICAgICAgbWFpbkpvaW5RdWVyaWVzID0gbWFpbkpvaW5RdWVyaWVzLmNvbmNhdChqb2luUXVlcmllcy5tYWluUXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICAgICBcIlNFTEVDVCBUT1AgMTAwIFBFUkNFTlRcIixcbiAgICAgICAgICBhdHRyaWJ1dGVzLmpvaW4oXCIsIFwiKSxcbiAgICAgICAgICBcIkZST00gKFwiLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIFwiU0VMRUNUXCIsXG4gICAgICAgICAgICBvcHRpb25zLmxpbWl0ICYmIGBUT1AgJHtvcHRpb25zLmxpbWl0fWAsXG4gICAgICAgICAgICBcIiogRlJPTSAoXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIFwiU0VMRUNUIFJPV19OVU1CRVIoKSBPVkVSIChcIixcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiT1JERVIgQllcIixcbiAgICAgICAgICAgICAgICBvcmRlcnMubWFpblF1ZXJ5T3JkZXIuam9pbihcIiwgXCIpXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIGApIGFzIHJvd19udW0sICR7dG1wVGFibGV9LiogRlJPTSAoYCxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiU0VMRUNUIERJU1RJTkNUXCIsXG4gICAgICAgICAgICAgICAgYCR7dG1wVGFibGV9LiogRlJPTSAke3RhYmxlc30gQVMgJHt0bXBUYWJsZX1gLFxuICAgICAgICAgICAgICAgIG1haW5Kb2luUXVlcmllcyxcbiAgICAgICAgICAgICAgICB3aGVyZSAmJiBgV0hFUkUgJHt3aGVyZX1gXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIGApIEFTICR7dG1wVGFibGV9YFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGApIEFTICR7dG1wVGFibGV9IFdIRVJFIHJvd19udW0gPiAke29mZnNldH1gXG4gICAgICAgICAgXSxcbiAgICAgICAgICBgKSBBUyAke3RtcFRhYmxlfWBcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAgIFwiU0VMRUNUIFRPUCAxMDAgUEVSQ0VOVFwiLFxuICAgICAgICBhdHRyaWJ1dGVzLmpvaW4oXCIsIFwiKSxcbiAgICAgICAgXCJGUk9NIChcIixcbiAgICAgICAgW1xuICAgICAgICAgIFwiU0VMRUNUXCIsXG4gICAgICAgICAgb3B0aW9ucy5saW1pdCAmJiBgVE9QICR7b3B0aW9ucy5saW1pdH1gLFxuICAgICAgICAgIFwiKiBGUk9NIChcIixcbiAgICAgICAgICBbXG4gICAgICAgICAgICBcIlNFTEVDVCBST1dfTlVNQkVSKCkgT1ZFUiAoXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIFwiT1JERVIgQllcIixcbiAgICAgICAgICAgICAgb3JkZXJzLm1haW5RdWVyeU9yZGVyLmpvaW4oXCIsIFwiKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGApIGFzIHJvd19udW0sICogRlJPTSAke3RhYmxlc30gQVMgJHt0bXBUYWJsZX1gLFxuICAgICAgICAgICAgd2hlcmUgJiYgYFdIRVJFICR7d2hlcmV9YFxuICAgICAgICAgIF0sXG4gICAgICAgICAgYCkgQVMgJHt0bXBUYWJsZX0gV0hFUkUgcm93X251bSA+ICR7b2Zmc2V0fWBcbiAgICAgICAgXSxcbiAgICAgICAgYCkgQVMgJHt0bXBUYWJsZX1gXG4gICAgICBdKTtcbiAgICB9XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJTRUxFQ1RcIixcbiAgICAgIGlzU1FMU2VydmVyMjAwOCAmJiBvcHRpb25zLmxpbWl0ICYmIGBUT1AgJHtvcHRpb25zLmxpbWl0fWAsXG4gICAgICBhdHRyaWJ1dGVzLmpvaW4oXCIsIFwiKSxcbiAgICAgIGBGUk9NICR7dGFibGVzfWAsXG4gICAgICBtYWluVGFibGVBcyAmJiBgQVMgJHttYWluVGFibGVBc31gLFxuICAgICAgb3B0aW9ucy50YWJsZUhpbnQgJiYgVGFibGVIaW50c1tvcHRpb25zLnRhYmxlSGludF0gJiYgYFdJVEggKCR7VGFibGVIaW50c1tvcHRpb25zLnRhYmxlSGludF19KWBcbiAgICBdKTtcbiAgfVxuICBhZGRMaW1pdEFuZE9mZnNldChvcHRpb25zLCBtb2RlbCkge1xuICAgIGlmIChzZW12ZXIudmFsaWQodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24pICYmIHNlbXZlci5sdCh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbiwgXCIxMS4wLjBcIikpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdCBvZmZzZXQgPSBvcHRpb25zLm9mZnNldCB8fCAwO1xuICAgIGNvbnN0IGlzU3ViUXVlcnkgPSBvcHRpb25zLnN1YlF1ZXJ5ID09PSB2b2lkIDAgPyBvcHRpb25zLmhhc0luY2x1ZGVXaGVyZSB8fCBvcHRpb25zLmhhc0luY2x1ZGVSZXF1aXJlZCB8fCBvcHRpb25zLmhhc011bHRpQXNzb2NpYXRpb24gOiBvcHRpb25zLnN1YlF1ZXJ5O1xuICAgIGxldCBmcmFnbWVudCA9IFwiXCI7XG4gICAgbGV0IG9yZGVycyA9IHt9O1xuICAgIGlmIChvcHRpb25zLm9yZGVyKSB7XG4gICAgICBvcmRlcnMgPSB0aGlzLmdldFF1ZXJ5T3JkZXJzKG9wdGlvbnMsIG1vZGVsLCBpc1N1YlF1ZXJ5KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGltaXQgfHwgb3B0aW9ucy5vZmZzZXQpIHtcbiAgICAgIGlmICghb3B0aW9ucy5vcmRlciB8fCBvcHRpb25zLm9yZGVyLmxlbmd0aCA9PT0gMCB8fCBvcHRpb25zLmluY2x1ZGUgJiYgb3JkZXJzLnN1YlF1ZXJ5T3JkZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGxldCBwcmltYXJ5S2V5ID0gbW9kZWwucHJpbWFyeUtleUZpZWxkO1xuICAgICAgICBjb25zdCB0YWJsZVBrRnJhZ21lbnQgPSBgJHt0aGlzLnF1b3RlVGFibGUob3B0aW9ucy50YWJsZUFzIHx8IG1vZGVsLm5hbWUpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKHByaW1hcnlLZXkpfWA7XG4gICAgICAgIGNvbnN0IGFsaWFzZWRBdHRyaWJ1dGUgPSAob3B0aW9ucy5hdHRyaWJ1dGVzIHx8IFtdKS5maW5kKChhdHRyKSA9PiBBcnJheS5pc0FycmF5KGF0dHIpICYmIGF0dHJbMV0gJiYgKGF0dHJbMF0gPT09IHByaW1hcnlLZXkgfHwgYXR0clsxXSA9PT0gcHJpbWFyeUtleSkpO1xuICAgICAgICBpZiAoYWxpYXNlZEF0dHJpYnV0ZSkge1xuICAgICAgICAgIGNvbnN0IG1vZGVsTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMudGFibGVBcyB8fCBtb2RlbC5uYW1lKTtcbiAgICAgICAgICBjb25zdCBhbGlhcyA9IHRoaXMuX2dldEFsaWFzRm9yRmllbGQobW9kZWxOYW1lLCBhbGlhc2VkQXR0cmlidXRlWzFdLCBvcHRpb25zKTtcbiAgICAgICAgICBwcmltYXJ5S2V5ID0gbmV3IFV0aWxzLkNvbChhbGlhcyB8fCBhbGlhc2VkQXR0cmlidXRlWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMub3JkZXIgfHwgIW9wdGlvbnMub3JkZXIubGVuZ3RoKSB7XG4gICAgICAgICAgZnJhZ21lbnQgKz0gYCBPUkRFUiBCWSAke3RhYmxlUGtGcmFnbWVudH1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG9yZGVyRmllbGROYW1lcyA9IChvcHRpb25zLm9yZGVyIHx8IFtdKS5tYXAoKG9yZGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEFycmF5LmlzQXJyYXkob3JkZXIpID8gb3JkZXJbMF0gOiBvcmRlcjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLkNvbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuY29sO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuTGl0ZXJhbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHByaW1hcnlLZXlGaWVsZEFscmVhZHlQcmVzZW50ID0gb3JkZXJGaWVsZE5hbWVzLnNvbWUoKGZpZWxkTmFtZSkgPT4gZmllbGROYW1lID09PSAocHJpbWFyeUtleS5jb2wgfHwgcHJpbWFyeUtleSkpO1xuICAgICAgICAgIGlmICghcHJpbWFyeUtleUZpZWxkQWxyZWFkeVByZXNlbnQpIHtcbiAgICAgICAgICAgIGZyYWdtZW50ICs9IG9wdGlvbnMub3JkZXIgJiYgIWlzU3ViUXVlcnkgPyBcIiwgXCIgOiBcIiBPUkRFUiBCWSBcIjtcbiAgICAgICAgICAgIGZyYWdtZW50ICs9IHRhYmxlUGtGcmFnbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm9mZnNldCB8fCBvcHRpb25zLmxpbWl0KSB7XG4gICAgICAgIGZyYWdtZW50ICs9IGAgT0ZGU0VUICR7dGhpcy5lc2NhcGUob2Zmc2V0KX0gUk9XU2A7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5saW1pdCkge1xuICAgICAgICBmcmFnbWVudCArPSBgIEZFVENIIE5FWFQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX0gUk9XUyBPTkxZYDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9XG4gIGJvb2xlYW5WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA/IDEgOiAwO1xuICB9XG4gIHF1b3RlSWRlbnRpZmllcihpZGVudGlmaWVyLCBmb3JjZSkge1xuICAgIHJldHVybiBgWyR7aWRlbnRpZmllci5yZXBsYWNlKC9bW1xcXSddKy9nLCBcIlwiKX1dYDtcbiAgfVxufVxuZnVuY3Rpb24gd3JhcFNpbmdsZVF1b3RlKGlkZW50aWZpZXIpIHtcbiAgcmV0dXJuIFV0aWxzLmFkZFRpY2tzKFV0aWxzLnJlbW92ZVRpY2tzKGlkZW50aWZpZXIsIFwiJ1wiKSwgXCInXCIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBNU1NRTFF1ZXJ5R2VuZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnktZ2VuZXJhdG9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/mssql/query-generator.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/mssql/query-interface.js":
/*!***********************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/mssql/query-interface.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(action-browser)/../node_modules/sequelize/lib/query-types.js\");\nconst Op = __webpack_require__(/*! ../../operators */ \"(action-browser)/../node_modules/sequelize/lib/operators.js\");\nconst { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nclass MSSqlQueryInterface extends QueryInterface {\n  async removeColumn(tableName, attributeName, options) {\n    options = __spreadValues({ raw: true }, options || {});\n    const findConstraintSql = this.queryGenerator.getDefaultConstraintQuery(tableName, attributeName);\n    const [results0] = await this.sequelize.query(findConstraintSql, options);\n    if (results0.length) {\n      const dropConstraintSql = this.queryGenerator.dropConstraintQuery(tableName, results0[0].name);\n      await this.sequelize.query(dropConstraintSql, options);\n    }\n    const findForeignKeySql = this.queryGenerator.getForeignKeyQuery(tableName, attributeName);\n    const [results] = await this.sequelize.query(findForeignKeySql, options);\n    if (results.length) {\n      const dropForeignKeySql = this.queryGenerator.dropForeignKeyQuery(tableName, results[0].constraint_name);\n      await this.sequelize.query(dropForeignKeySql, options);\n    }\n    const primaryKeyConstraintSql = this.queryGenerator.getPrimaryKeyConstraintQuery(tableName, attributeName);\n    const [result] = await this.sequelize.query(primaryKeyConstraintSql, options);\n    if (result.length) {\n      const dropConstraintSql = this.queryGenerator.dropConstraintQuery(tableName, result[0].constraintName);\n      await this.sequelize.query(dropConstraintSql, options);\n    }\n    const removeSql = this.queryGenerator.removeColumnQuery(tableName, attributeName);\n    return this.sequelize.query(removeSql, options);\n  }\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    const model = options.model;\n    const wheres = [];\n    options = __spreadValues({}, options);\n    if (!Utils.isWhereEmpty(where)) {\n      wheres.push(where);\n    }\n    let indexes = Object.values(model.uniqueKeys).map((item) => item.fields);\n    indexes = indexes.concat(Object.values(model._indexes).filter((item) => item.unique).map((item) => item.fields));\n    const attributes = Object.keys(insertValues);\n    for (const index of indexes) {\n      if (_.intersection(attributes, index).length === index.length) {\n        where = {};\n        for (const field of index) {\n          where[field] = insertValues[field];\n        }\n        wheres.push(where);\n      }\n    }\n    where = { [Op.or]: wheres };\n    options.type = QueryTypes.UPSERT;\n    options.raw = true;\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    return await this.sequelize.query(sql, options);\n  }\n}\nexports.MSSqlQueryInterface = MSSqlQueryInterface;\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9xdWVyeS1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLGlFQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyw0RUFBYTtBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDOUMsV0FBVyxtQkFBTyxDQUFDLG9GQUFpQjtBQUNwQyxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsd0hBQTZCO0FBQ2hFO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVyxlQUFlO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL3F1ZXJ5LWludGVyZmFjZS5qcz81YTA4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vcXVlcnktdHlwZXNcIik7XG5jb25zdCBPcCA9IHJlcXVpcmUoXCIuLi8uLi9vcGVyYXRvcnNcIik7XG5jb25zdCB7IFF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnktaW50ZXJmYWNlXCIpO1xuY2xhc3MgTVNTcWxRdWVyeUludGVyZmFjZSBleHRlbmRzIFF1ZXJ5SW50ZXJmYWNlIHtcbiAgYXN5bmMgcmVtb3ZlQ29sdW1uKHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7IHJhdzogdHJ1ZSB9LCBvcHRpb25zIHx8IHt9KTtcbiAgICBjb25zdCBmaW5kQ29uc3RyYWludFNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZ2V0RGVmYXVsdENvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgIGNvbnN0IFtyZXN1bHRzMF0gPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShmaW5kQ29uc3RyYWludFNxbCwgb3B0aW9ucyk7XG4gICAgaWYgKHJlc3VsdHMwLmxlbmd0aCkge1xuICAgICAgY29uc3QgZHJvcENvbnN0cmFpbnRTcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCByZXN1bHRzMFswXS5uYW1lKTtcbiAgICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGRyb3BDb25zdHJhaW50U3FsLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgZmluZEZvcmVpZ25LZXlTcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmdldEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgIGNvbnN0IFtyZXN1bHRzXSA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGZpbmRGb3JlaWduS2V5U3FsLCBvcHRpb25zKTtcbiAgICBpZiAocmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGRyb3BGb3JlaWduS2V5U3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wRm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZSwgcmVzdWx0c1swXS5jb25zdHJhaW50X25hbWUpO1xuICAgICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoZHJvcEZvcmVpZ25LZXlTcWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBwcmltYXJ5S2V5Q29uc3RyYWludFNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZ2V0UHJpbWFyeUtleUNvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgIGNvbnN0IFtyZXN1bHRdID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkocHJpbWFyeUtleUNvbnN0cmFpbnRTcWwsIG9wdGlvbnMpO1xuICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBkcm9wQ29uc3RyYWludFNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcENvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIHJlc3VsdFswXS5jb25zdHJhaW50TmFtZSk7XG4gICAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShkcm9wQ29uc3RyYWludFNxbCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IHJlbW92ZVNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucXVlcnkocmVtb3ZlU3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyB1cHNlcnQodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIHVwZGF0ZVZhbHVlcywgd2hlcmUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgY29uc3Qgd2hlcmVzID0gW107XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKTtcbiAgICBpZiAoIVV0aWxzLmlzV2hlcmVFbXB0eSh3aGVyZSkpIHtcbiAgICAgIHdoZXJlcy5wdXNoKHdoZXJlKTtcbiAgICB9XG4gICAgbGV0IGluZGV4ZXMgPSBPYmplY3QudmFsdWVzKG1vZGVsLnVuaXF1ZUtleXMpLm1hcCgoaXRlbSkgPT4gaXRlbS5maWVsZHMpO1xuICAgIGluZGV4ZXMgPSBpbmRleGVzLmNvbmNhdChPYmplY3QudmFsdWVzKG1vZGVsLl9pbmRleGVzKS5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0udW5pcXVlKS5tYXAoKGl0ZW0pID0+IGl0ZW0uZmllbGRzKSk7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKGluc2VydFZhbHVlcyk7XG4gICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzKSB7XG4gICAgICBpZiAoXy5pbnRlcnNlY3Rpb24oYXR0cmlidXRlcywgaW5kZXgpLmxlbmd0aCA9PT0gaW5kZXgubGVuZ3RoKSB7XG4gICAgICAgIHdoZXJlID0ge307XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgaW5kZXgpIHtcbiAgICAgICAgICB3aGVyZVtmaWVsZF0gPSBpbnNlcnRWYWx1ZXNbZmllbGRdO1xuICAgICAgICB9XG4gICAgICAgIHdoZXJlcy5wdXNoKHdoZXJlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2hlcmUgPSB7IFtPcC5vcl06IHdoZXJlcyB9O1xuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuVVBTRVJUO1xuICAgIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnVwc2VydFF1ZXJ5KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCB1cGRhdGVWYWx1ZXMsIHdoZXJlLCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbn1cbmV4cG9ydHMuTVNTcWxRdWVyeUludGVyZmFjZSA9IE1TU3FsUXVlcnlJbnRlcmZhY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS1pbnRlcmZhY2UuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/mssql/query-interface.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/mssql/query.js":
/*!*************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/mssql/query.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(action-browser)/../node_modules/sequelize/lib/dialects/parserStore.js\")(\"mssql\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(action-browser)/../node_modules/sequelize/lib/utils/logger.js\");\nconst debug = logger.debugContext(\"sql:mssql\");\nconst minSafeIntegerAsBigInt = BigInt(Number.MIN_SAFE_INTEGER);\nconst maxSafeIntegerAsBigInt = BigInt(Number.MAX_SAFE_INTEGER);\nfunction getScale(aNum) {\n  if (!Number.isFinite(aNum))\n    return 0;\n  let e = 1;\n  while (Math.round(aNum * e) / e !== aNum)\n    e *= 10;\n  return Math.log10(e);\n}\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return \"id\";\n  }\n  getSQLTypeFromJsType(value, TYPES) {\n    const paramType = { type: TYPES.NVarChar, typeOptions: {}, value };\n    if (typeof value === \"number\") {\n      if (Number.isInteger(value)) {\n        if (value >= -2147483648 && value <= 2147483647) {\n          paramType.type = TYPES.Int;\n        } else {\n          paramType.type = TYPES.BigInt;\n        }\n      } else {\n        paramType.type = TYPES.Numeric;\n        paramType.typeOptions = { precision: 30, scale: getScale(value) };\n      }\n    } else if (typeof value === \"bigint\") {\n      if (value < minSafeIntegerAsBigInt || value > maxSafeIntegerAsBigInt) {\n        paramType.type = TYPES.VarChar;\n        paramType.value = value.toString();\n      } else {\n        return this.getSQLTypeFromJsType(Number(value), TYPES);\n      }\n    } else if (typeof value === \"boolean\") {\n      paramType.type = TYPES.Bit;\n    }\n    if (Buffer.isBuffer(value)) {\n      paramType.type = TYPES.VarBinary;\n    }\n    return paramType;\n  }\n  async _run(connection, sql, parameters, errStack) {\n    this.sql = sql;\n    const { options } = this;\n    const complete = this._logQuery(sql, debug, parameters);\n    const query = new Promise((resolve, reject) => {\n      if (sql.startsWith(\"BEGIN TRANSACTION\")) {\n        return connection.beginTransaction((error) => error ? reject(error) : resolve([]), options.transaction.name, connection.lib.ISOLATION_LEVEL[options.isolationLevel]);\n      }\n      if (sql.startsWith(\"COMMIT TRANSACTION\")) {\n        return connection.commitTransaction((error) => error ? reject(error) : resolve([]));\n      }\n      if (sql.startsWith(\"ROLLBACK TRANSACTION\")) {\n        return connection.rollbackTransaction((error) => error ? reject(error) : resolve([]), options.transaction.name);\n      }\n      if (sql.startsWith(\"SAVE TRANSACTION\")) {\n        return connection.saveTransaction((error) => error ? reject(error) : resolve([]), options.transaction.name);\n      }\n      const rows2 = [];\n      const request = new connection.lib.Request(sql, (err, rowCount2) => err ? reject(err) : resolve([rows2, rowCount2]));\n      if (parameters) {\n        _.forOwn(parameters, (value, key) => {\n          const paramType = this.getSQLTypeFromJsType(value, connection.lib.TYPES);\n          request.addParameter(key, paramType.type, value, paramType.typeOptions);\n        });\n      }\n      request.on(\"row\", (columns) => {\n        rows2.push(columns);\n      });\n      connection.execSql(request);\n    });\n    let rows, rowCount;\n    try {\n      [rows, rowCount] = await query;\n    } catch (err) {\n      err.sql = sql;\n      err.parameters = parameters;\n      throw this.formatError(err, errStack);\n    }\n    complete();\n    if (Array.isArray(rows)) {\n      rows = rows.map((columns) => {\n        const row = {};\n        for (const column of columns) {\n          const typeid = column.metadata.type.id;\n          const parse = parserStore.get(typeid);\n          let value = column.value;\n          if (value !== null & !!parse) {\n            value = parse(value);\n          }\n          row[column.metadata.colName] = value;\n        }\n        return row;\n      });\n    }\n    return this.formatResults(rows, rowCount);\n  }\n  run(sql, parameters) {\n    const errForStack = new Error();\n    return this.connection.queue.enqueue(() => this._run(this.connection, sql, parameters, errForStack.stack));\n  }\n  static formatBindParameters(sql, values, dialect) {\n    const bindParam = {};\n    const replacementFunc = (match, key, values2) => {\n      if (values2[key] !== void 0) {\n        bindParam[key] = values2[key];\n        return `@${key}`;\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, bindParam];\n  }\n  formatResults(data, rowCount) {\n    if (this.isInsertQuery(data)) {\n      this.handleInsertQuery(data);\n      return [this.instance || data, rowCount];\n    }\n    if (this.isShowTablesQuery()) {\n      return this.handleShowTablesQuery(data);\n    }\n    if (this.isDescribeQuery()) {\n      const result = {};\n      for (const _result of data) {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", \"\").replace(\"')\", \"\").replace(/'/g, \"\");\n        }\n        result[_result.Name] = {\n          type: _result.Type.toUpperCase(),\n          allowNull: _result.IsNull === \"YES\" ? true : false,\n          defaultValue: _result.Default,\n          primaryKey: _result.Constraint === \"PRIMARY KEY\",\n          autoIncrement: _result.IsIdentity === 1,\n          comment: _result.Comment\n        };\n        if (result[_result.Name].type.includes(\"CHAR\") && _result.Length) {\n          if (_result.Length === -1) {\n            result[_result.Name].type += \"(MAX)\";\n          } else {\n            result[_result.Name].type += `(${_result.Length})`;\n          }\n        }\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      return this.handleSelectQuery(data);\n    }\n    if (this.isShowIndexesQuery()) {\n      return this.handleShowIndexesQuery(data);\n    }\n    if (this.isCallQuery()) {\n      return data[0];\n    }\n    if (this.isBulkUpdateQuery()) {\n      if (this.options.returning) {\n        return this.handleSelectQuery(data);\n      }\n      return rowCount;\n    }\n    if (this.isBulkDeleteQuery()) {\n      return data[0] ? data[0].AFFECTEDROWS : 0;\n    }\n    if (this.isVersionQuery()) {\n      return data[0].version;\n    }\n    if (this.isForeignKeysQuery()) {\n      return data;\n    }\n    if (this.isUpsertQuery()) {\n      if (data && data.length === 0) {\n        return [this.instance || data, false];\n      }\n      this.handleInsertQuery(data);\n      return [this.instance || data, data[0].$action === \"INSERT\"];\n    }\n    if (this.isUpdateQuery()) {\n      return [this.instance || data, rowCount];\n    }\n    if (this.isShowConstraintsQuery()) {\n      return this.handleShowConstraintsQuery(data);\n    }\n    if (this.isRawQuery()) {\n      return [data, rowCount];\n    }\n    return data;\n  }\n  handleShowTablesQuery(results) {\n    return results.map((resultSet) => {\n      return {\n        tableName: resultSet.TABLE_NAME,\n        schema: resultSet.TABLE_SCHEMA\n      };\n    });\n  }\n  handleShowConstraintsQuery(data) {\n    return data.slice(1).map((result) => {\n      const constraint = {};\n      for (const key in result) {\n        constraint[_.camelCase(key)] = result[key];\n      }\n      return constraint;\n    });\n  }\n  formatError(err, errStack) {\n    let match;\n    match = err.message.match(/Violation of (?:UNIQUE|PRIMARY) KEY constraint '([^']*)'. Cannot insert duplicate key in object '.*'.(:? The duplicate key value is \\((.*)\\).)?/);\n    match = match || err.message.match(/Cannot insert duplicate key row in object .* with unique index '(.*)'/);\n    if (match && match.length > 1) {\n      let fields = {};\n      const uniqueKey = this.model && this.model.uniqueKeys[match[1]];\n      let message = \"Validation error\";\n      if (uniqueKey && !!uniqueKey.msg) {\n        message = uniqueKey.msg;\n      }\n      if (match[3]) {\n        const values = match[3].split(\",\").map((part) => part.trim());\n        if (uniqueKey) {\n          fields = _.zipObject(uniqueKey.fields, values);\n        } else {\n          fields[match[1]] = match[3];\n        }\n      }\n      const errors = [];\n      _.forOwn(fields, (value, field) => {\n        errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, value, this.instance, \"not_unique\"));\n      });\n      return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n    }\n    match = err.message.match(/Failed on step '(.*)'.Could not create constraint. See previous errors./) || err.message.match(/The DELETE statement conflicted with the REFERENCE constraint \"(.*)\". The conflict occurred in database \"(.*)\", table \"(.*)\", column '(.*)'./) || err.message.match(/The (?:INSERT|MERGE|UPDATE) statement conflicted with the FOREIGN KEY constraint \"(.*)\". The conflict occurred in database \"(.*)\", table \"(.*)\", column '(.*)'./);\n    if (match && match.length > 0) {\n      return new sequelizeErrors.ForeignKeyConstraintError({\n        fields: null,\n        index: match[1],\n        parent: err,\n        stack: errStack\n      });\n    }\n    match = err.message.match(/Could not drop constraint. See previous errors./);\n    if (match && match.length > 0) {\n      let constraint = err.sql.match(/(?:constraint|index) \\[(.+?)\\]/i);\n      constraint = constraint ? constraint[1] : void 0;\n      let table = err.sql.match(/table \\[(.+?)\\]/i);\n      table = table ? table[1] : void 0;\n      return new sequelizeErrors.UnknownConstraintError({\n        message: match[1],\n        constraint,\n        table,\n        parent: err,\n        stack: errStack\n      });\n    }\n    return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n  }\n  isShowOrDescribeQuery() {\n    let result = false;\n    result = result || this.sql.toLowerCase().startsWith(\"select c.column_name as 'name', c.data_type as 'type', c.is_nullable as 'isnull'\");\n    result = result || this.sql.toLowerCase().startsWith(\"select tablename = t.name, name = ind.name,\");\n    result = result || this.sql.toLowerCase().startsWith(\"exec sys.sp_helpindex @objname\");\n    return result;\n  }\n  isShowIndexesQuery() {\n    return this.sql.toLowerCase().startsWith(\"exec sys.sp_helpindex @objname\");\n  }\n  handleShowIndexesQuery(data) {\n    data = data.reduce((acc, item) => {\n      if (!(item.index_name in acc)) {\n        acc[item.index_name] = item;\n        item.fields = [];\n      }\n      item.index_keys.split(\",\").forEach((column) => {\n        let columnName = column.trim();\n        if (columnName.includes(\"(-)\")) {\n          columnName = columnName.replace(\"(-)\", \"\");\n        }\n        acc[item.index_name].fields.push({\n          attribute: columnName,\n          length: void 0,\n          order: column.includes(\"(-)\") ? \"DESC\" : \"ASC\",\n          collate: void 0\n        });\n      });\n      delete item.index_keys;\n      return acc;\n    }, {});\n    return _.map(data, (item) => ({\n      primary: item.index_name.toLowerCase().startsWith(\"pk\"),\n      fields: item.fields,\n      name: item.index_name,\n      tableName: void 0,\n      unique: item.index_description.toLowerCase().includes(\"unique\"),\n      type: void 0\n    }));\n  }\n  handleInsertQuery(results, metaData) {\n    if (this.instance) {\n      const autoIncrementAttribute = this.model.autoIncrementAttribute;\n      let id = null;\n      let autoIncrementAttributeAlias = null;\n      if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementAttribute) && this.model.rawAttributes[autoIncrementAttribute].field !== void 0)\n        autoIncrementAttributeAlias = this.model.rawAttributes[autoIncrementAttribute].field;\n      id = id || results && results[0][this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      id = id || results && results[0][autoIncrementAttribute];\n      id = id || autoIncrementAttributeAlias && results && results[0][autoIncrementAttributeAlias];\n      this.instance[autoIncrementAttribute] = id;\n      if (this.instance.dataValues) {\n        for (const key in results[0]) {\n          if (Object.prototype.hasOwnProperty.call(results[0], key)) {\n            const record = results[0][key];\n            const attr = _.find(this.model.rawAttributes, (attribute) => attribute.fieldName === key || attribute.field === key);\n            this.instance.dataValues[attr && attr.fieldName || key] = record;\n          }\n        }\n      }\n    }\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports[\"default\"] = Query;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9xdWVyeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHNCQUFzQixtQkFBTyxDQUFDLG9HQUFtQjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQyxvRkFBYztBQUM5QyxvQkFBb0IsbUJBQU8sQ0FBQyw4RkFBZ0I7QUFDNUMsVUFBVSxtQkFBTyxDQUFDLGlFQUFRO0FBQzFCLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsMEZBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFDQUFxQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLDZDQUE2QyxlQUFlO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AseURBQXlELHVEQUF1RDtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9xdWVyeS5qcz8wYWI1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgQWJzdHJhY3RRdWVyeSA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9xdWVyeVwiKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCBwYXJzZXJTdG9yZSA9IHJlcXVpcmUoXCIuLi9wYXJzZXJTdG9yZVwiKShcIm1zc3FsXCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2xvZ2dlclwiKTtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dChcInNxbDptc3NxbFwiKTtcbmNvbnN0IG1pblNhZmVJbnRlZ2VyQXNCaWdJbnQgPSBCaWdJbnQoTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpO1xuY29uc3QgbWF4U2FmZUludGVnZXJBc0JpZ0ludCA9IEJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7XG5mdW5jdGlvbiBnZXRTY2FsZShhTnVtKSB7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGFOdW0pKVxuICAgIHJldHVybiAwO1xuICBsZXQgZSA9IDE7XG4gIHdoaWxlIChNYXRoLnJvdW5kKGFOdW0gKiBlKSAvIGUgIT09IGFOdW0pXG4gICAgZSAqPSAxMDtcbiAgcmV0dXJuIE1hdGgubG9nMTAoZSk7XG59XG5jbGFzcyBRdWVyeSBleHRlbmRzIEFic3RyYWN0UXVlcnkge1xuICBnZXRJbnNlcnRJZEZpZWxkKCkge1xuICAgIHJldHVybiBcImlkXCI7XG4gIH1cbiAgZ2V0U1FMVHlwZUZyb21Kc1R5cGUodmFsdWUsIFRZUEVTKSB7XG4gICAgY29uc3QgcGFyYW1UeXBlID0geyB0eXBlOiBUWVBFUy5OVmFyQ2hhciwgdHlwZU9wdGlvbnM6IHt9LCB2YWx1ZSB9O1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICBpZiAodmFsdWUgPj0gLTIxNDc0ODM2NDggJiYgdmFsdWUgPD0gMjE0NzQ4MzY0Nykge1xuICAgICAgICAgIHBhcmFtVHlwZS50eXBlID0gVFlQRVMuSW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmFtVHlwZS50eXBlID0gVFlQRVMuQmlnSW50O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbVR5cGUudHlwZSA9IFRZUEVTLk51bWVyaWM7XG4gICAgICAgIHBhcmFtVHlwZS50eXBlT3B0aW9ucyA9IHsgcHJlY2lzaW9uOiAzMCwgc2NhbGU6IGdldFNjYWxlKHZhbHVlKSB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICBpZiAodmFsdWUgPCBtaW5TYWZlSW50ZWdlckFzQmlnSW50IHx8IHZhbHVlID4gbWF4U2FmZUludGVnZXJBc0JpZ0ludCkge1xuICAgICAgICBwYXJhbVR5cGUudHlwZSA9IFRZUEVTLlZhckNoYXI7XG4gICAgICAgIHBhcmFtVHlwZS52YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTUUxUeXBlRnJvbUpzVHlwZShOdW1iZXIodmFsdWUpLCBUWVBFUyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBwYXJhbVR5cGUudHlwZSA9IFRZUEVTLkJpdDtcbiAgICB9XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHBhcmFtVHlwZS50eXBlID0gVFlQRVMuVmFyQmluYXJ5O1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1UeXBlO1xuICB9XG4gIGFzeW5jIF9ydW4oY29ubmVjdGlvbiwgc3FsLCBwYXJhbWV0ZXJzLCBlcnJTdGFjaykge1xuICAgIHRoaXMuc3FsID0gc3FsO1xuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcztcbiAgICBjb25zdCBjb21wbGV0ZSA9IHRoaXMuX2xvZ1F1ZXJ5KHNxbCwgZGVidWcsIHBhcmFtZXRlcnMpO1xuICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHNxbC5zdGFydHNXaXRoKFwiQkVHSU4gVFJBTlNBQ1RJT05cIikpIHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uYmVnaW5UcmFuc2FjdGlvbigoZXJyb3IpID0+IGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUoW10pLCBvcHRpb25zLnRyYW5zYWN0aW9uLm5hbWUsIGNvbm5lY3Rpb24ubGliLklTT0xBVElPTl9MRVZFTFtvcHRpb25zLmlzb2xhdGlvbkxldmVsXSk7XG4gICAgICB9XG4gICAgICBpZiAoc3FsLnN0YXJ0c1dpdGgoXCJDT01NSVQgVFJBTlNBQ1RJT05cIikpIHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uY29tbWl0VHJhbnNhY3Rpb24oKGVycm9yKSA9PiBlcnJvciA/IHJlamVjdChlcnJvcikgOiByZXNvbHZlKFtdKSk7XG4gICAgICB9XG4gICAgICBpZiAoc3FsLnN0YXJ0c1dpdGgoXCJST0xMQkFDSyBUUkFOU0FDVElPTlwiKSkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5yb2xsYmFja1RyYW5zYWN0aW9uKChlcnJvcikgPT4gZXJyb3IgPyByZWplY3QoZXJyb3IpIDogcmVzb2x2ZShbXSksIG9wdGlvbnMudHJhbnNhY3Rpb24ubmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3FsLnN0YXJ0c1dpdGgoXCJTQVZFIFRSQU5TQUNUSU9OXCIpKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uLnNhdmVUcmFuc2FjdGlvbigoZXJyb3IpID0+IGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUoW10pLCBvcHRpb25zLnRyYW5zYWN0aW9uLm5hbWUpO1xuICAgICAgfVxuICAgICAgY29uc3Qgcm93czIgPSBbXTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgY29ubmVjdGlvbi5saWIuUmVxdWVzdChzcWwsIChlcnIsIHJvd0NvdW50MikgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKFtyb3dzMiwgcm93Q291bnQyXSkpO1xuICAgICAgaWYgKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgXy5mb3JPd24ocGFyYW1ldGVycywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICBjb25zdCBwYXJhbVR5cGUgPSB0aGlzLmdldFNRTFR5cGVGcm9tSnNUeXBlKHZhbHVlLCBjb25uZWN0aW9uLmxpYi5UWVBFUyk7XG4gICAgICAgICAgcmVxdWVzdC5hZGRQYXJhbWV0ZXIoa2V5LCBwYXJhbVR5cGUudHlwZSwgdmFsdWUsIHBhcmFtVHlwZS50eXBlT3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmVxdWVzdC5vbihcInJvd1wiLCAoY29sdW1ucykgPT4ge1xuICAgICAgICByb3dzMi5wdXNoKGNvbHVtbnMpO1xuICAgICAgfSk7XG4gICAgICBjb25uZWN0aW9uLmV4ZWNTcWwocmVxdWVzdCk7XG4gICAgfSk7XG4gICAgbGV0IHJvd3MsIHJvd0NvdW50O1xuICAgIHRyeSB7XG4gICAgICBbcm93cywgcm93Q291bnRdID0gYXdhaXQgcXVlcnk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnIuc3FsID0gc3FsO1xuICAgICAgZXJyLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgdGhyb3cgdGhpcy5mb3JtYXRFcnJvcihlcnIsIGVyclN0YWNrKTtcbiAgICB9XG4gICAgY29tcGxldGUoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyb3dzKSkge1xuICAgICAgcm93cyA9IHJvd3MubWFwKChjb2x1bW5zKSA9PiB7XG4gICAgICAgIGNvbnN0IHJvdyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGNvbHVtbiBvZiBjb2x1bW5zKSB7XG4gICAgICAgICAgY29uc3QgdHlwZWlkID0gY29sdW1uLm1ldGFkYXRhLnR5cGUuaWQ7XG4gICAgICAgICAgY29uc3QgcGFyc2UgPSBwYXJzZXJTdG9yZS5nZXQodHlwZWlkKTtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBjb2x1bW4udmFsdWU7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYgISFwYXJzZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvd1tjb2x1bW4ubWV0YWRhdGEuY29sTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZvcm1hdFJlc3VsdHMocm93cywgcm93Q291bnQpO1xuICB9XG4gIHJ1bihzcWwsIHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBlcnJGb3JTdGFjayA9IG5ldyBFcnJvcigpO1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24ucXVldWUuZW5xdWV1ZSgoKSA9PiB0aGlzLl9ydW4odGhpcy5jb25uZWN0aW9uLCBzcWwsIHBhcmFtZXRlcnMsIGVyckZvclN0YWNrLnN0YWNrKSk7XG4gIH1cbiAgc3RhdGljIGZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0KSB7XG4gICAgY29uc3QgYmluZFBhcmFtID0ge307XG4gICAgY29uc3QgcmVwbGFjZW1lbnRGdW5jID0gKG1hdGNoLCBrZXksIHZhbHVlczIpID0+IHtcbiAgICAgIGlmICh2YWx1ZXMyW2tleV0gIT09IHZvaWQgMCkge1xuICAgICAgICBiaW5kUGFyYW1ba2V5XSA9IHZhbHVlczJba2V5XTtcbiAgICAgICAgcmV0dXJuIGBAJHtrZXl9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcbiAgICBzcWwgPSBBYnN0cmFjdFF1ZXJ5LmZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0LCByZXBsYWNlbWVudEZ1bmMpWzBdO1xuICAgIHJldHVybiBbc3FsLCBiaW5kUGFyYW1dO1xuICB9XG4gIGZvcm1hdFJlc3VsdHMoZGF0YSwgcm93Q291bnQpIHtcbiAgICBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KGRhdGEpKSB7XG4gICAgICB0aGlzLmhhbmRsZUluc2VydFF1ZXJ5KGRhdGEpO1xuICAgICAgcmV0dXJuIFt0aGlzLmluc3RhbmNlIHx8IGRhdGEsIHJvd0NvdW50XTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93VGFibGVzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2hvd1RhYmxlc1F1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0Rlc2NyaWJlUXVlcnkoKSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IF9yZXN1bHQgb2YgZGF0YSkge1xuICAgICAgICBpZiAoX3Jlc3VsdC5EZWZhdWx0KSB7XG4gICAgICAgICAgX3Jlc3VsdC5EZWZhdWx0ID0gX3Jlc3VsdC5EZWZhdWx0LnJlcGxhY2UoXCIoJ1wiLCBcIlwiKS5yZXBsYWNlKFwiJylcIiwgXCJcIikucmVwbGFjZSgvJy9nLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbX3Jlc3VsdC5OYW1lXSA9IHtcbiAgICAgICAgICB0eXBlOiBfcmVzdWx0LlR5cGUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICBhbGxvd051bGw6IF9yZXN1bHQuSXNOdWxsID09PSBcIllFU1wiID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogX3Jlc3VsdC5EZWZhdWx0LFxuICAgICAgICAgIHByaW1hcnlLZXk6IF9yZXN1bHQuQ29uc3RyYWludCA9PT0gXCJQUklNQVJZIEtFWVwiLFxuICAgICAgICAgIGF1dG9JbmNyZW1lbnQ6IF9yZXN1bHQuSXNJZGVudGl0eSA9PT0gMSxcbiAgICAgICAgICBjb21tZW50OiBfcmVzdWx0LkNvbW1lbnRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJlc3VsdFtfcmVzdWx0Lk5hbWVdLnR5cGUuaW5jbHVkZXMoXCJDSEFSXCIpICYmIF9yZXN1bHQuTGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKF9yZXN1bHQuTGVuZ3RoID09PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0W19yZXN1bHQuTmFtZV0udHlwZSArPSBcIihNQVgpXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtfcmVzdWx0Lk5hbWVdLnR5cGUgKz0gYCgke19yZXN1bHQuTGVuZ3RofSlgO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTZWxlY3RRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZWxlY3RRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93SW5kZXhlc1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNob3dJbmRleGVzUXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQ2FsbFF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhWzBdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0J1bGtVcGRhdGVRdWVyeSgpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJldHVybmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZWxlY3RRdWVyeShkYXRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3dDb3VudDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNCdWxrRGVsZXRlUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGFbMF0gPyBkYXRhWzBdLkFGRkVDVEVEUk9XUyA6IDA7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVmVyc2lvblF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhWzBdLnZlcnNpb247XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRm9yZWlnbktleXNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNVcHNlcnRRdWVyeSgpKSB7XG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuaW5zdGFuY2UgfHwgZGF0YSwgZmFsc2VdO1xuICAgICAgfVxuICAgICAgdGhpcy5oYW5kbGVJbnNlcnRRdWVyeShkYXRhKTtcbiAgICAgIHJldHVybiBbdGhpcy5pbnN0YW5jZSB8fCBkYXRhLCBkYXRhWzBdLiRhY3Rpb24gPT09IFwiSU5TRVJUXCJdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1VwZGF0ZVF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbdGhpcy5pbnN0YW5jZSB8fCBkYXRhLCByb3dDb3VudF07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd0NvbnN0cmFpbnRzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2hvd0NvbnN0cmFpbnRzUXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzUmF3UXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFtkYXRhLCByb3dDb3VudF07XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGhhbmRsZVNob3dUYWJsZXNRdWVyeShyZXN1bHRzKSB7XG4gICAgcmV0dXJuIHJlc3VsdHMubWFwKChyZXN1bHRTZXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhYmxlTmFtZTogcmVzdWx0U2V0LlRBQkxFX05BTUUsXG4gICAgICAgIHNjaGVtYTogcmVzdWx0U2V0LlRBQkxFX1NDSEVNQVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVTaG93Q29uc3RyYWludHNRdWVyeShkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2UoMSkubWFwKChyZXN1bHQpID0+IHtcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnQgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdCkge1xuICAgICAgICBjb25zdHJhaW50W18uY2FtZWxDYXNlKGtleSldID0gcmVzdWx0W2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uc3RyYWludDtcbiAgICB9KTtcbiAgfVxuICBmb3JtYXRFcnJvcihlcnIsIGVyclN0YWNrKSB7XG4gICAgbGV0IG1hdGNoO1xuICAgIG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL1Zpb2xhdGlvbiBvZiAoPzpVTklRVUV8UFJJTUFSWSkgS0VZIGNvbnN0cmFpbnQgJyhbXiddKiknLiBDYW5ub3QgaW5zZXJ0IGR1cGxpY2F0ZSBrZXkgaW4gb2JqZWN0ICcuKicuKDo/IFRoZSBkdXBsaWNhdGUga2V5IHZhbHVlIGlzIFxcKCguKilcXCkuKT8vKTtcbiAgICBtYXRjaCA9IG1hdGNoIHx8IGVyci5tZXNzYWdlLm1hdGNoKC9DYW5ub3QgaW5zZXJ0IGR1cGxpY2F0ZSBrZXkgcm93IGluIG9iamVjdCAuKiB3aXRoIHVuaXF1ZSBpbmRleCAnKC4qKScvKTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgbGV0IGZpZWxkcyA9IHt9O1xuICAgICAgY29uc3QgdW5pcXVlS2V5ID0gdGhpcy5tb2RlbCAmJiB0aGlzLm1vZGVsLnVuaXF1ZUtleXNbbWF0Y2hbMV1dO1xuICAgICAgbGV0IG1lc3NhZ2UgPSBcIlZhbGlkYXRpb24gZXJyb3JcIjtcbiAgICAgIGlmICh1bmlxdWVLZXkgJiYgISF1bmlxdWVLZXkubXNnKSB7XG4gICAgICAgIG1lc3NhZ2UgPSB1bmlxdWVLZXkubXNnO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IG1hdGNoWzNdLnNwbGl0KFwiLFwiKS5tYXAoKHBhcnQpID0+IHBhcnQudHJpbSgpKTtcbiAgICAgICAgaWYgKHVuaXF1ZUtleSkge1xuICAgICAgICAgIGZpZWxkcyA9IF8uemlwT2JqZWN0KHVuaXF1ZUtleS5maWVsZHMsIHZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmllbGRzW21hdGNoWzFdXSA9IG1hdGNoWzNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgIF8uZm9yT3duKGZpZWxkcywgKHZhbHVlLCBmaWVsZCkgPT4ge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvckl0ZW0odGhpcy5nZXRVbmlxdWVDb25zdHJhaW50RXJyb3JNZXNzYWdlKGZpZWxkKSwgXCJ1bmlxdWUgdmlvbGF0aW9uXCIsIGZpZWxkLCB2YWx1ZSwgdGhpcy5pbnN0YW5jZSwgXCJub3RfdW5pcXVlXCIpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5pcXVlQ29uc3RyYWludEVycm9yKHsgbWVzc2FnZSwgZXJyb3JzLCBwYXJlbnQ6IGVyciwgZmllbGRzLCBzdGFjazogZXJyU3RhY2sgfSk7XG4gICAgfVxuICAgIG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL0ZhaWxlZCBvbiBzdGVwICcoLiopJy5Db3VsZCBub3QgY3JlYXRlIGNvbnN0cmFpbnQuIFNlZSBwcmV2aW91cyBlcnJvcnMuLykgfHwgZXJyLm1lc3NhZ2UubWF0Y2goL1RoZSBERUxFVEUgc3RhdGVtZW50IGNvbmZsaWN0ZWQgd2l0aCB0aGUgUkVGRVJFTkNFIGNvbnN0cmFpbnQgXCIoLiopXCIuIFRoZSBjb25mbGljdCBvY2N1cnJlZCBpbiBkYXRhYmFzZSBcIiguKilcIiwgdGFibGUgXCIoLiopXCIsIGNvbHVtbiAnKC4qKScuLykgfHwgZXJyLm1lc3NhZ2UubWF0Y2goL1RoZSAoPzpJTlNFUlR8TUVSR0V8VVBEQVRFKSBzdGF0ZW1lbnQgY29uZmxpY3RlZCB3aXRoIHRoZSBGT1JFSUdOIEtFWSBjb25zdHJhaW50IFwiKC4qKVwiLiBUaGUgY29uZmxpY3Qgb2NjdXJyZWQgaW4gZGF0YWJhc2UgXCIoLiopXCIsIHRhYmxlIFwiKC4qKVwiLCBjb2x1bW4gJyguKiknLi8pO1xuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5Gb3JlaWduS2V5Q29uc3RyYWludEVycm9yKHtcbiAgICAgICAgZmllbGRzOiBudWxsLFxuICAgICAgICBpbmRleDogbWF0Y2hbMV0sXG4gICAgICAgIHBhcmVudDogZXJyLFxuICAgICAgICBzdGFjazogZXJyU3RhY2tcbiAgICAgIH0pO1xuICAgIH1cbiAgICBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9Db3VsZCBub3QgZHJvcCBjb25zdHJhaW50LiBTZWUgcHJldmlvdXMgZXJyb3JzLi8pO1xuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICBsZXQgY29uc3RyYWludCA9IGVyci5zcWwubWF0Y2goLyg/OmNvbnN0cmFpbnR8aW5kZXgpIFxcWyguKz8pXFxdL2kpO1xuICAgICAgY29uc3RyYWludCA9IGNvbnN0cmFpbnQgPyBjb25zdHJhaW50WzFdIDogdm9pZCAwO1xuICAgICAgbGV0IHRhYmxlID0gZXJyLnNxbC5tYXRjaCgvdGFibGUgXFxbKC4rPylcXF0vaSk7XG4gICAgICB0YWJsZSA9IHRhYmxlID8gdGFibGVbMV0gOiB2b2lkIDA7XG4gICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5Vbmtub3duQ29uc3RyYWludEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogbWF0Y2hbMV0sXG4gICAgICAgIGNvbnN0cmFpbnQsXG4gICAgICAgIHRhYmxlLFxuICAgICAgICBwYXJlbnQ6IGVycixcbiAgICAgICAgc3RhY2s6IGVyclN0YWNrXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRGF0YWJhc2VFcnJvcihlcnIsIHsgc3RhY2s6IGVyclN0YWNrIH0pO1xuICB9XG4gIGlzU2hvd09yRGVzY3JpYmVRdWVyeSgpIHtcbiAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcInNlbGVjdCBjLmNvbHVtbl9uYW1lIGFzICduYW1lJywgYy5kYXRhX3R5cGUgYXMgJ3R5cGUnLCBjLmlzX251bGxhYmxlIGFzICdpc251bGwnXCIpO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJzZWxlY3QgdGFibGVuYW1lID0gdC5uYW1lLCBuYW1lID0gaW5kLm5hbWUsXCIpO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJleGVjIHN5cy5zcF9oZWxwaW5kZXggQG9iam5hbWVcIik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpc1Nob3dJbmRleGVzUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcImV4ZWMgc3lzLnNwX2hlbHBpbmRleCBAb2JqbmFtZVwiKTtcbiAgfVxuICBoYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KGRhdGEpIHtcbiAgICBkYXRhID0gZGF0YS5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgICAgaWYgKCEoaXRlbS5pbmRleF9uYW1lIGluIGFjYykpIHtcbiAgICAgICAgYWNjW2l0ZW0uaW5kZXhfbmFtZV0gPSBpdGVtO1xuICAgICAgICBpdGVtLmZpZWxkcyA9IFtdO1xuICAgICAgfVxuICAgICAgaXRlbS5pbmRleF9rZXlzLnNwbGl0KFwiLFwiKS5mb3JFYWNoKChjb2x1bW4pID0+IHtcbiAgICAgICAgbGV0IGNvbHVtbk5hbWUgPSBjb2x1bW4udHJpbSgpO1xuICAgICAgICBpZiAoY29sdW1uTmFtZS5pbmNsdWRlcyhcIigtKVwiKSkge1xuICAgICAgICAgIGNvbHVtbk5hbWUgPSBjb2x1bW5OYW1lLnJlcGxhY2UoXCIoLSlcIiwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgYWNjW2l0ZW0uaW5kZXhfbmFtZV0uZmllbGRzLnB1c2goe1xuICAgICAgICAgIGF0dHJpYnV0ZTogY29sdW1uTmFtZSxcbiAgICAgICAgICBsZW5ndGg6IHZvaWQgMCxcbiAgICAgICAgICBvcmRlcjogY29sdW1uLmluY2x1ZGVzKFwiKC0pXCIpID8gXCJERVNDXCIgOiBcIkFTQ1wiLFxuICAgICAgICAgIGNvbGxhdGU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIGl0ZW0uaW5kZXhfa2V5cztcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBfLm1hcChkYXRhLCAoaXRlbSkgPT4gKHtcbiAgICAgIHByaW1hcnk6IGl0ZW0uaW5kZXhfbmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJwa1wiKSxcbiAgICAgIGZpZWxkczogaXRlbS5maWVsZHMsXG4gICAgICBuYW1lOiBpdGVtLmluZGV4X25hbWUsXG4gICAgICB0YWJsZU5hbWU6IHZvaWQgMCxcbiAgICAgIHVuaXF1ZTogaXRlbS5pbmRleF9kZXNjcmlwdGlvbi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwidW5pcXVlXCIpLFxuICAgICAgdHlwZTogdm9pZCAwXG4gICAgfSkpO1xuICB9XG4gIGhhbmRsZUluc2VydFF1ZXJ5KHJlc3VsdHMsIG1ldGFEYXRhKSB7XG4gICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgIGNvbnN0IGF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUgPSB0aGlzLm1vZGVsLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGU7XG4gICAgICBsZXQgaWQgPSBudWxsO1xuICAgICAgbGV0IGF1dG9JbmNyZW1lbnRBdHRyaWJ1dGVBbGlhcyA9IG51bGw7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMubW9kZWwucmF3QXR0cmlidXRlcywgYXV0b0luY3JlbWVudEF0dHJpYnV0ZSkgJiYgdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2F1dG9JbmNyZW1lbnRBdHRyaWJ1dGVdLmZpZWxkICE9PSB2b2lkIDApXG4gICAgICAgIGF1dG9JbmNyZW1lbnRBdHRyaWJ1dGVBbGlhcyA9IHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1thdXRvSW5jcmVtZW50QXR0cmlidXRlXS5maWVsZDtcbiAgICAgIGlkID0gaWQgfHwgcmVzdWx0cyAmJiByZXN1bHRzWzBdW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcbiAgICAgIGlkID0gaWQgfHwgbWV0YURhdGEgJiYgbWV0YURhdGFbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuICAgICAgaWQgPSBpZCB8fCByZXN1bHRzICYmIHJlc3VsdHNbMF1bYXV0b0luY3JlbWVudEF0dHJpYnV0ZV07XG4gICAgICBpZCA9IGlkIHx8IGF1dG9JbmNyZW1lbnRBdHRyaWJ1dGVBbGlhcyAmJiByZXN1bHRzICYmIHJlc3VsdHNbMF1bYXV0b0luY3JlbWVudEF0dHJpYnV0ZUFsaWFzXTtcbiAgICAgIHRoaXMuaW5zdGFuY2VbYXV0b0luY3JlbWVudEF0dHJpYnV0ZV0gPSBpZDtcbiAgICAgIGlmICh0aGlzLmluc3RhbmNlLmRhdGFWYWx1ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0c1swXSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0c1swXSwga2V5KSkge1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkID0gcmVzdWx0c1swXVtrZXldO1xuICAgICAgICAgICAgY29uc3QgYXR0ciA9IF8uZmluZCh0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXMsIChhdHRyaWJ1dGUpID0+IGF0dHJpYnV0ZS5maWVsZE5hbWUgPT09IGtleSB8fCBhdHRyaWJ1dGUuZmllbGQgPT09IGtleSk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLmRhdGFWYWx1ZXNbYXR0ciAmJiBhdHRyLmZpZWxkTmFtZSB8fCBrZXldID0gcmVjb3JkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeTtcbm1vZHVsZS5leHBvcnRzLlF1ZXJ5ID0gUXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gUXVlcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/mssql/query.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/mysql/connection-manager.js":
/*!**************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/mysql/connection-manager.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst SequelizeErrors = __webpack_require__(/*! ../../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(action-browser)/../node_modules/sequelize/lib/utils/logger.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\").mysql);\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(action-browser)/../node_modules/moment-timezone/index.js\");\nconst debug = logger.debugContext(\"connection:mysql\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(action-browser)/../node_modules/sequelize/lib/dialects/parserStore.js\")(\"mysql\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"mysql2\");\n    this.refreshTypeParser(DataTypes);\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n  async connect(config) {\n    const connectionConfig = __spreadValues({\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      flags: \"-FOUND_ROWS\",\n      password: config.password,\n      database: config.database,\n      timezone: this.sequelize.options.timezone,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true\n    }, config.dialectOptions);\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        const connection2 = this.lib.createConnection(connectionConfig);\n        const errorHandler = (e) => {\n          connection2.removeListener(\"connect\", connectHandler);\n          connection2.removeListener(\"error\", connectHandler);\n          reject(e);\n        };\n        const connectHandler = () => {\n          connection2.removeListener(\"error\", errorHandler);\n          resolve(connection2);\n        };\n        connection2.on(\"error\", errorHandler);\n        connection2.once(\"connect\", connectHandler);\n      });\n      debug(\"connection acquired\");\n      connection.on(\"error\", (error) => {\n        switch (error.code) {\n          case \"ESOCKET\":\n          case \"ECONNRESET\":\n          case \"EPIPE\":\n          case \"PROTOCOL_CONNECTION_LOST\":\n            this.pool.destroy(connection);\n        }\n      });\n      if (!this.sequelize.config.keepDefaultTimezone) {\n        let tzOffset = this.sequelize.options.timezone;\n        tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format(\"Z\") : tzOffset;\n        await promisify((cb) => connection.query(`SET time_zone = '${tzOffset}'`, cb))();\n      }\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case \"ECONNREFUSED\":\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case \"ER_ACCESS_DENIED_ERROR\":\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case \"ENOTFOUND\":\n          throw new SequelizeErrors.HostNotFoundError(err);\n        case \"EHOSTUNREACH\":\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case \"EINVAL\":\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n  async disconnect(connection) {\n    if (connection._closing) {\n      debug(\"connection tried to disconnect but was already at CLOSED state\");\n      return;\n    }\n    return await promisify((callback) => connection.end(callback))();\n  }\n  validate(connection) {\n    return connection && !connection._fatalError && !connection._protocolError && !connection._closing && !connection.stream.destroyed;\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9jb25uZWN0aW9uLW1hbmFnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1CQUFPLENBQUMsOEhBQWdDO0FBQzFFLHdCQUF3QixtQkFBTyxDQUFDLG9GQUFjO0FBQzlDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsMEZBQW9CO0FBQy9DLGtCQUFrQixtSEFBaUM7QUFDbkQsaUJBQWlCLG1CQUFPLENBQUMsa0ZBQWlCO0FBQzFDO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsOEZBQWdCO0FBQzVDLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsa0JBQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFNBQVM7QUFDOUU7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyx5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXlzcWwvY29ubmVjdGlvbi1tYW5hZ2VyLmpzPzMzNTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG5jb25zdCBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L2Nvbm5lY3Rpb24tbWFuYWdlclwiKTtcbmNvbnN0IFNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2xvZ2dlclwiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpLm15c3FsO1xuY29uc3QgbW9tZW50VHogPSByZXF1aXJlKFwibW9tZW50LXRpbWV6b25lXCIpO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KFwiY29ubmVjdGlvbjpteXNxbFwiKTtcbmNvbnN0IHBhcnNlclN0b3JlID0gcmVxdWlyZShcIi4uL3BhcnNlclN0b3JlXCIpKFwibXlzcWxcIik7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZShcInV0aWxcIik7XG5jbGFzcyBDb25uZWN0aW9uTWFuYWdlciBleHRlbmRzIEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihkaWFsZWN0LCBzZXF1ZWxpemUpIHtcbiAgICBzZXF1ZWxpemUuY29uZmlnLnBvcnQgPSBzZXF1ZWxpemUuY29uZmlnLnBvcnQgfHwgMzMwNjtcbiAgICBzdXBlcihkaWFsZWN0LCBzZXF1ZWxpemUpO1xuICAgIHRoaXMubGliID0gdGhpcy5fbG9hZERpYWxlY3RNb2R1bGUoXCJteXNxbDJcIik7XG4gICAgdGhpcy5yZWZyZXNoVHlwZVBhcnNlcihEYXRhVHlwZXMpO1xuICB9XG4gIF9yZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZSkge1xuICAgIHBhcnNlclN0b3JlLnJlZnJlc2goZGF0YVR5cGUpO1xuICB9XG4gIF9jbGVhclR5cGVQYXJzZXIoKSB7XG4gICAgcGFyc2VyU3RvcmUuY2xlYXIoKTtcbiAgfVxuICBzdGF0aWMgX3R5cGVjYXN0KGZpZWxkLCBuZXh0KSB7XG4gICAgaWYgKHBhcnNlclN0b3JlLmdldChmaWVsZC50eXBlKSkge1xuICAgICAgcmV0dXJuIHBhcnNlclN0b3JlLmdldChmaWVsZC50eXBlKShmaWVsZCwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucywgbmV4dCk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0KCk7XG4gIH1cbiAgYXN5bmMgY29ubmVjdChjb25maWcpIHtcbiAgICBjb25zdCBjb25uZWN0aW9uQ29uZmlnID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgaG9zdDogY29uZmlnLmhvc3QsXG4gICAgICBwb3J0OiBjb25maWcucG9ydCxcbiAgICAgIHVzZXI6IGNvbmZpZy51c2VybmFtZSxcbiAgICAgIGZsYWdzOiBcIi1GT1VORF9ST1dTXCIsXG4gICAgICBwYXNzd29yZDogY29uZmlnLnBhc3N3b3JkLFxuICAgICAgZGF0YWJhc2U6IGNvbmZpZy5kYXRhYmFzZSxcbiAgICAgIHRpbWV6b25lOiB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnRpbWV6b25lLFxuICAgICAgdHlwZUNhc3Q6IENvbm5lY3Rpb25NYW5hZ2VyLl90eXBlY2FzdC5iaW5kKHRoaXMpLFxuICAgICAgYmlnTnVtYmVyU3RyaW5nczogZmFsc2UsXG4gICAgICBzdXBwb3J0QmlnTnVtYmVyczogdHJ1ZVxuICAgIH0sIGNvbmZpZy5kaWFsZWN0T3B0aW9ucyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24yID0gdGhpcy5saWIuY3JlYXRlQ29ubmVjdGlvbihjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKGUpID0+IHtcbiAgICAgICAgICBjb25uZWN0aW9uMi5yZW1vdmVMaXN0ZW5lcihcImNvbm5lY3RcIiwgY29ubmVjdEhhbmRsZXIpO1xuICAgICAgICAgIGNvbm5lY3Rpb24yLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgY29ubmVjdEhhbmRsZXIpO1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29ubmVjdEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgY29ubmVjdGlvbjIucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgIHJlc29sdmUoY29ubmVjdGlvbjIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25uZWN0aW9uMi5vbihcImVycm9yXCIsIGVycm9ySGFuZGxlcik7XG4gICAgICAgIGNvbm5lY3Rpb24yLm9uY2UoXCJjb25uZWN0XCIsIGNvbm5lY3RIYW5kbGVyKTtcbiAgICAgIH0pO1xuICAgICAgZGVidWcoXCJjb25uZWN0aW9uIGFjcXVpcmVkXCIpO1xuICAgICAgY29ubmVjdGlvbi5vbihcImVycm9yXCIsIChlcnJvcikgPT4ge1xuICAgICAgICBzd2l0Y2ggKGVycm9yLmNvZGUpIHtcbiAgICAgICAgICBjYXNlIFwiRVNPQ0tFVFwiOlxuICAgICAgICAgIGNhc2UgXCJFQ09OTlJFU0VUXCI6XG4gICAgICAgICAgY2FzZSBcIkVQSVBFXCI6XG4gICAgICAgICAgY2FzZSBcIlBST1RPQ09MX0NPTk5FQ1RJT05fTE9TVFwiOlxuICAgICAgICAgICAgdGhpcy5wb29sLmRlc3Ryb3koY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCF0aGlzLnNlcXVlbGl6ZS5jb25maWcua2VlcERlZmF1bHRUaW1lem9uZSkge1xuICAgICAgICBsZXQgdHpPZmZzZXQgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnRpbWV6b25lO1xuICAgICAgICB0ek9mZnNldCA9IC9cXC8vLnRlc3QodHpPZmZzZXQpID8gbW9tZW50VHoudHoodHpPZmZzZXQpLmZvcm1hdChcIlpcIikgOiB0ek9mZnNldDtcbiAgICAgICAgYXdhaXQgcHJvbWlzaWZ5KChjYikgPT4gY29ubmVjdGlvbi5xdWVyeShgU0VUIHRpbWVfem9uZSA9ICcke3R6T2Zmc2V0fSdgLCBjYikpKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcbiAgICAgICAgY2FzZSBcIkVDT05OUkVGVVNFRFwiOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvblJlZnVzZWRFcnJvcihlcnIpO1xuICAgICAgICBjYXNlIFwiRVJfQUNDRVNTX0RFTklFRF9FUlJPUlwiOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuQWNjZXNzRGVuaWVkRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSBcIkVOT1RGT1VORFwiOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuSG9zdE5vdEZvdW5kRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSBcIkVIT1NUVU5SRUFDSFwiOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuSG9zdE5vdFJlYWNoYWJsZUVycm9yKGVycik7XG4gICAgICAgIGNhc2UgXCJFSU5WQUxcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkludmFsaWRDb25uZWN0aW9uRXJyb3IoZXJyKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBkaXNjb25uZWN0KGNvbm5lY3Rpb24pIHtcbiAgICBpZiAoY29ubmVjdGlvbi5fY2xvc2luZykge1xuICAgICAgZGVidWcoXCJjb25uZWN0aW9uIHRyaWVkIHRvIGRpc2Nvbm5lY3QgYnV0IHdhcyBhbHJlYWR5IGF0IENMT1NFRCBzdGF0ZVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHByb21pc2lmeSgoY2FsbGJhY2spID0+IGNvbm5lY3Rpb24uZW5kKGNhbGxiYWNrKSkoKTtcbiAgfVxuICB2YWxpZGF0ZShjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb24gJiYgIWNvbm5lY3Rpb24uX2ZhdGFsRXJyb3IgJiYgIWNvbm5lY3Rpb24uX3Byb3RvY29sRXJyb3IgJiYgIWNvbm5lY3Rpb24uX2Nsb3NpbmcgJiYgIWNvbm5lY3Rpb24uc3RyZWFtLmRlc3Ryb3llZDtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25NYW5hZ2VyID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdGlvbk1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aW9uLW1hbmFnZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/mysql/connection-manager.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/mysql/data-types.js":
/*!******************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/mysql/data-types.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst wkx = __webpack_require__(/*! wkx */ \"(action-browser)/../node_modules/wkx/lib/wkx.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(action-browser)/../node_modules/moment-timezone/index.js\");\nconst moment = __webpack_require__(/*! moment */ \"(action-browser)/../node_modules/moment/moment.js\");\nmodule.exports = (BaseTypes) => {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = \"https://dev.mysql.com/doc/refman/5.7/en/data-types.html\";\n  BaseTypes.DATE.types.mysql = [\"DATETIME\"];\n  BaseTypes.STRING.types.mysql = [\"VAR_STRING\"];\n  BaseTypes.CHAR.types.mysql = [\"STRING\"];\n  BaseTypes.TEXT.types.mysql = [\"BLOB\"];\n  BaseTypes.TINYINT.types.mysql = [\"TINY\"];\n  BaseTypes.SMALLINT.types.mysql = [\"SHORT\"];\n  BaseTypes.MEDIUMINT.types.mysql = [\"INT24\"];\n  BaseTypes.INTEGER.types.mysql = [\"LONG\"];\n  BaseTypes.BIGINT.types.mysql = [\"LONGLONG\"];\n  BaseTypes.FLOAT.types.mysql = [\"FLOAT\"];\n  BaseTypes.TIME.types.mysql = [\"TIME\"];\n  BaseTypes.DATEONLY.types.mysql = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.mysql = [\"TINY\"];\n  BaseTypes.BLOB.types.mysql = [\"TINYBLOB\", \"BLOB\", \"LONGBLOB\"];\n  BaseTypes.DECIMAL.types.mysql = [\"NEWDECIMAL\"];\n  BaseTypes.UUID.types.mysql = false;\n  BaseTypes.ENUM.types.mysql = false;\n  BaseTypes.REAL.types.mysql = [\"DOUBLE\"];\n  BaseTypes.DOUBLE.types.mysql = [\"DOUBLE\"];\n  BaseTypes.GEOMETRY.types.mysql = [\"GEOMETRY\"];\n  BaseTypes.JSON.types.mysql = [\"JSON\"];\n  class DECIMAL extends BaseTypes.DECIMAL {\n    toSql() {\n      let definition = super.toSql();\n      if (this._unsigned) {\n        definition += \" UNSIGNED\";\n      }\n      if (this._zerofill) {\n        definition += \" ZEROFILL\";\n      }\n      return definition;\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return this._length ? `DATETIME(${this._length})` : \"DATETIME\";\n    }\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n      if (this._length) {\n        return date.format(\"YYYY-MM-DD HH:mm:ss.SSS\");\n      }\n      return date.format(\"YYYY-MM-DD HH:mm:ss\");\n    }\n    static parse(value, options) {\n      value = value.string();\n      if (value === null) {\n        return value;\n      }\n      if (momentTz.tz.zone(options.timezone)) {\n        value = momentTz.tz(value, options.timezone).toDate();\n      } else {\n        value = new Date(`${value} ${options.timezone}`);\n      }\n      return value;\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return value.string();\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"CHAR(36) BINARY\";\n    }\n  }\n  const SUPPORTED_GEOMETRY_TYPES = [\"POINT\", \"LINESTRING\", \"POLYGON\"];\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    constructor(type, srid) {\n      super(type, srid);\n      if (_.isEmpty(this.type)) {\n        this.sqlType = this.key;\n        return;\n      }\n      if (SUPPORTED_GEOMETRY_TYPES.includes(this.type)) {\n        this.sqlType = this.type;\n        return;\n      }\n      throw new Error(`Supported geometry types are: ${SUPPORTED_GEOMETRY_TYPES.join(\", \")}`);\n    }\n    static parse(value) {\n      value = value.buffer();\n      if (!value || value.length === 0) {\n        return null;\n      }\n      value = value.slice(4);\n      return wkx.Geometry.parse(value).toGeoJSON({ shortCrs: true });\n    }\n    toSql() {\n      return this.sqlType;\n    }\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql(options) {\n      return `ENUM(${this.values.map((value) => options.escape(value)).join(\", \")})`;\n    }\n  }\n  class JSONTYPE extends BaseTypes.JSON {\n    _stringify(value, options) {\n      return options.operation === \"where\" && typeof value === \"string\" ? value : JSON.stringify(value);\n    }\n  }\n  return {\n    ENUM,\n    DATE,\n    DATEONLY,\n    UUID,\n    GEOMETRY,\n    DECIMAL,\n    JSON: JSONTYPE\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9kYXRhLXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsWUFBWSxtQkFBTyxDQUFDLDREQUFLO0FBQ3pCLFVBQVUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMxQixpQkFBaUIsbUJBQU8sQ0FBQyxrRkFBaUI7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLGlFQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGFBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiw0QkFBNEIsT0FBTyxFQUFFLGlCQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELG9DQUFvQztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkRBQTZEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9kYXRhLXR5cGVzLmpzP2IzZmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB3a3ggPSByZXF1aXJlKFwid2t4XCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBtb21lbnRUeiA9IHJlcXVpcmUoXCJtb21lbnQtdGltZXpvbmVcIik7XG5jb25zdCBtb21lbnQgPSByZXF1aXJlKFwibW9tZW50XCIpO1xubW9kdWxlLmV4cG9ydHMgPSAoQmFzZVR5cGVzKSA9PiB7XG4gIEJhc2VUeXBlcy5BQlNUUkFDVC5wcm90b3R5cGUuZGlhbGVjdFR5cGVzID0gXCJodHRwczovL2Rldi5teXNxbC5jb20vZG9jL3JlZm1hbi81LjcvZW4vZGF0YS10eXBlcy5odG1sXCI7XG4gIEJhc2VUeXBlcy5EQVRFLnR5cGVzLm15c3FsID0gW1wiREFURVRJTUVcIl07XG4gIEJhc2VUeXBlcy5TVFJJTkcudHlwZXMubXlzcWwgPSBbXCJWQVJfU1RSSU5HXCJdO1xuICBCYXNlVHlwZXMuQ0hBUi50eXBlcy5teXNxbCA9IFtcIlNUUklOR1wiXTtcbiAgQmFzZVR5cGVzLlRFWFQudHlwZXMubXlzcWwgPSBbXCJCTE9CXCJdO1xuICBCYXNlVHlwZXMuVElOWUlOVC50eXBlcy5teXNxbCA9IFtcIlRJTllcIl07XG4gIEJhc2VUeXBlcy5TTUFMTElOVC50eXBlcy5teXNxbCA9IFtcIlNIT1JUXCJdO1xuICBCYXNlVHlwZXMuTUVESVVNSU5ULnR5cGVzLm15c3FsID0gW1wiSU5UMjRcIl07XG4gIEJhc2VUeXBlcy5JTlRFR0VSLnR5cGVzLm15c3FsID0gW1wiTE9OR1wiXTtcbiAgQmFzZVR5cGVzLkJJR0lOVC50eXBlcy5teXNxbCA9IFtcIkxPTkdMT05HXCJdO1xuICBCYXNlVHlwZXMuRkxPQVQudHlwZXMubXlzcWwgPSBbXCJGTE9BVFwiXTtcbiAgQmFzZVR5cGVzLlRJTUUudHlwZXMubXlzcWwgPSBbXCJUSU1FXCJdO1xuICBCYXNlVHlwZXMuREFURU9OTFkudHlwZXMubXlzcWwgPSBbXCJEQVRFXCJdO1xuICBCYXNlVHlwZXMuQk9PTEVBTi50eXBlcy5teXNxbCA9IFtcIlRJTllcIl07XG4gIEJhc2VUeXBlcy5CTE9CLnR5cGVzLm15c3FsID0gW1wiVElOWUJMT0JcIiwgXCJCTE9CXCIsIFwiTE9OR0JMT0JcIl07XG4gIEJhc2VUeXBlcy5ERUNJTUFMLnR5cGVzLm15c3FsID0gW1wiTkVXREVDSU1BTFwiXTtcbiAgQmFzZVR5cGVzLlVVSUQudHlwZXMubXlzcWwgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLkVOVU0udHlwZXMubXlzcWwgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLlJFQUwudHlwZXMubXlzcWwgPSBbXCJET1VCTEVcIl07XG4gIEJhc2VUeXBlcy5ET1VCTEUudHlwZXMubXlzcWwgPSBbXCJET1VCTEVcIl07XG4gIEJhc2VUeXBlcy5HRU9NRVRSWS50eXBlcy5teXNxbCA9IFtcIkdFT01FVFJZXCJdO1xuICBCYXNlVHlwZXMuSlNPTi50eXBlcy5teXNxbCA9IFtcIkpTT05cIl07XG4gIGNsYXNzIERFQ0lNQUwgZXh0ZW5kcyBCYXNlVHlwZXMuREVDSU1BTCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBsZXQgZGVmaW5pdGlvbiA9IHN1cGVyLnRvU3FsKCk7XG4gICAgICBpZiAodGhpcy5fdW5zaWduZWQpIHtcbiAgICAgICAgZGVmaW5pdGlvbiArPSBcIiBVTlNJR05FRFwiO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3plcm9maWxsKSB7XG4gICAgICAgIGRlZmluaXRpb24gKz0gXCIgWkVST0ZJTExcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgIH1cbiAgfVxuICBjbGFzcyBEQVRFIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEUge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aCA/IGBEQVRFVElNRSgke3RoaXMuX2xlbmd0aH0pYCA6IFwiREFURVRJTUVcIjtcbiAgICB9XG4gICAgX3N0cmluZ2lmeShkYXRlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW1vbWVudC5pc01vbWVudChkYXRlKSkge1xuICAgICAgICBkYXRlID0gdGhpcy5fYXBwbHlUaW1lem9uZShkYXRlLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZm9ybWF0KFwiWVlZWS1NTS1ERCBISDptbTpzcy5TU1NcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0ZS5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tOnNzXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuc3RyaW5nKCk7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKG1vbWVudFR6LnR6LnpvbmUob3B0aW9ucy50aW1lem9uZSkpIHtcbiAgICAgICAgdmFsdWUgPSBtb21lbnRUei50eih2YWx1ZSwgb3B0aW9ucy50aW1lem9uZSkudG9EYXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKGAke3ZhbHVlfSAke29wdGlvbnMudGltZXpvbmV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIGNsYXNzIERBVEVPTkxZIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEVPTkxZIHtcbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5zdHJpbmcoKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgVVVJRCBleHRlbmRzIEJhc2VUeXBlcy5VVUlEIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIkNIQVIoMzYpIEJJTkFSWVwiO1xuICAgIH1cbiAgfVxuICBjb25zdCBTVVBQT1JURURfR0VPTUVUUllfVFlQRVMgPSBbXCJQT0lOVFwiLCBcIkxJTkVTVFJJTkdcIiwgXCJQT0xZR09OXCJdO1xuICBjbGFzcyBHRU9NRVRSWSBleHRlbmRzIEJhc2VUeXBlcy5HRU9NRVRSWSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgc3JpZCkge1xuICAgICAgc3VwZXIodHlwZSwgc3JpZCk7XG4gICAgICBpZiAoXy5pc0VtcHR5KHRoaXMudHlwZSkpIHtcbiAgICAgICAgdGhpcy5zcWxUeXBlID0gdGhpcy5rZXk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChTVVBQT1JURURfR0VPTUVUUllfVFlQRVMuaW5jbHVkZXModGhpcy50eXBlKSkge1xuICAgICAgICB0aGlzLnNxbFR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgU3VwcG9ydGVkIGdlb21ldHJ5IHR5cGVzIGFyZTogJHtTVVBQT1JURURfR0VPTUVUUllfVFlQRVMuam9pbihcIiwgXCIpfWApO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuYnVmZmVyKCk7XG4gICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoNCk7XG4gICAgICByZXR1cm4gd2t4Lkdlb21ldHJ5LnBhcnNlKHZhbHVlKS50b0dlb0pTT04oeyBzaG9ydENyczogdHJ1ZSB9KTtcbiAgICB9XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcWxUeXBlO1xuICAgIH1cbiAgfVxuICBjbGFzcyBFTlVNIGV4dGVuZHMgQmFzZVR5cGVzLkVOVU0ge1xuICAgIHRvU3FsKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBgRU5VTSgke3RoaXMudmFsdWVzLm1hcCgodmFsdWUpID0+IG9wdGlvbnMuZXNjYXBlKHZhbHVlKSkuam9pbihcIiwgXCIpfSlgO1xuICAgIH1cbiAgfVxuICBjbGFzcyBKU09OVFlQRSBleHRlbmRzIEJhc2VUeXBlcy5KU09OIHtcbiAgICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5vcGVyYXRpb24gPT09IFwid2hlcmVcIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBFTlVNLFxuICAgIERBVEUsXG4gICAgREFURU9OTFksXG4gICAgVVVJRCxcbiAgICBHRU9NRVRSWSxcbiAgICBERUNJTUFMLFxuICAgIEpTT046IEpTT05UWVBFXG4gIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS10eXBlcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/mysql/data-types.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/mysql/index.js":
/*!*************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/mysql/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst AbstractDialect = __webpack_require__(/*! ../abstract */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst ConnectionManager = __webpack_require__(/*! ./connection-manager */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mysql/connection-manager.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mysql/query.js\");\nconst QueryGenerator = __webpack_require__(/*! ./query-generator */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mysql/query-generator.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\").mysql);\nconst { MySQLQueryInterface } = __webpack_require__(/*! ./query-interface */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mysql/query-interface.js\");\nclass MysqlDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new MySQLQueryInterface(sequelize, this.queryGenerator);\n  }\n  canBackslashEscape() {\n    return true;\n  }\n}\nMysqlDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  \"VALUES ()\": true,\n  \"LIMIT ON UPDATE\": true,\n  lock: true,\n  forShare: \"LOCK IN SHARE MODE\",\n  settingIsolationLevelDuringTransaction: false,\n  inserts: {\n    ignoreDuplicates: \" IGNORE\",\n    updateOnDuplicate: \" ON DUPLICATE KEY UPDATE\"\n  },\n  index: {\n    collate: false,\n    length: true,\n    parser: true,\n    type: true,\n    using: 1\n  },\n  constraints: {\n    dropConstraint: false,\n    check: false\n  },\n  indexViaAlter: true,\n  indexHints: true,\n  NUMERIC: true,\n  GEOMETRY: true,\n  JSON: true,\n  REGEXP: true\n});\nMysqlDialect.prototype.defaultVersion = \"5.7.0\";\nMysqlDialect.prototype.Query = Query;\nMysqlDialect.prototype.QueryGenerator = QueryGenerator;\nMysqlDialect.prototype.DataTypes = DataTypes;\nMysqlDialect.prototype.name = \"mysql\";\nMysqlDialect.prototype.TICK_CHAR = \"`\";\nMysqlDialect.prototype.TICK_CHAR_LEFT = MysqlDialect.prototype.TICK_CHAR;\nMysqlDialect.prototype.TICK_CHAR_RIGHT = MysqlDialect.prototype.TICK_CHAR;\nmodule.exports = MysqlDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFVBQVUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMxQix3QkFBd0IsbUJBQU8sQ0FBQyw4RkFBYTtBQUM3QywwQkFBMEIsbUJBQU8sQ0FBQyxpSEFBc0I7QUFDeEQsY0FBYyxtQkFBTyxDQUFDLHVGQUFTO0FBQy9CLHVCQUF1QixtQkFBTyxDQUFDLDJHQUFtQjtBQUNsRCxrQkFBa0IsbUhBQWlDO0FBQ25ELFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQywyR0FBbUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXlzcWwvaW5kZXguanM/MzhkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgQWJzdHJhY3REaWFsZWN0ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0XCIpO1xuY29uc3QgQ29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi9jb25uZWN0aW9uLW1hbmFnZXJcIik7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoXCIuL3F1ZXJ5XCIpO1xuY29uc3QgUXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKFwiLi9xdWVyeS1nZW5lcmF0b3JcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKS5teXNxbDtcbmNvbnN0IHsgTXlTUUxRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZShcIi4vcXVlcnktaW50ZXJmYWNlXCIpO1xuY2xhc3MgTXlzcWxEaWFsZWN0IGV4dGVuZHMgQWJzdHJhY3REaWFsZWN0IHtcbiAgY29uc3RydWN0b3Ioc2VxdWVsaXplKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gbmV3IENvbm5lY3Rpb25NYW5hZ2VyKHRoaXMsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5xdWVyeUdlbmVyYXRvciA9IG5ldyBRdWVyeUdlbmVyYXRvcih7XG4gICAgICBfZGlhbGVjdDogdGhpcyxcbiAgICAgIHNlcXVlbGl6ZVxuICAgIH0pO1xuICAgIHRoaXMucXVlcnlJbnRlcmZhY2UgPSBuZXcgTXlTUUxRdWVyeUludGVyZmFjZShzZXF1ZWxpemUsIHRoaXMucXVlcnlHZW5lcmF0b3IpO1xuICB9XG4gIGNhbkJhY2tzbGFzaEVzY2FwZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyA9IF8ubWVyZ2UoXy5jbG9uZURlZXAoQWJzdHJhY3REaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyksIHtcbiAgXCJWQUxVRVMgKClcIjogdHJ1ZSxcbiAgXCJMSU1JVCBPTiBVUERBVEVcIjogdHJ1ZSxcbiAgbG9jazogdHJ1ZSxcbiAgZm9yU2hhcmU6IFwiTE9DSyBJTiBTSEFSRSBNT0RFXCIsXG4gIHNldHRpbmdJc29sYXRpb25MZXZlbER1cmluZ1RyYW5zYWN0aW9uOiBmYWxzZSxcbiAgaW5zZXJ0czoge1xuICAgIGlnbm9yZUR1cGxpY2F0ZXM6IFwiIElHTk9SRVwiLFxuICAgIHVwZGF0ZU9uRHVwbGljYXRlOiBcIiBPTiBEVVBMSUNBVEUgS0VZIFVQREFURVwiXG4gIH0sXG4gIGluZGV4OiB7XG4gICAgY29sbGF0ZTogZmFsc2UsXG4gICAgbGVuZ3RoOiB0cnVlLFxuICAgIHBhcnNlcjogdHJ1ZSxcbiAgICB0eXBlOiB0cnVlLFxuICAgIHVzaW5nOiAxXG4gIH0sXG4gIGNvbnN0cmFpbnRzOiB7XG4gICAgZHJvcENvbnN0cmFpbnQ6IGZhbHNlLFxuICAgIGNoZWNrOiBmYWxzZVxuICB9LFxuICBpbmRleFZpYUFsdGVyOiB0cnVlLFxuICBpbmRleEhpbnRzOiB0cnVlLFxuICBOVU1FUklDOiB0cnVlLFxuICBHRU9NRVRSWTogdHJ1ZSxcbiAgSlNPTjogdHJ1ZSxcbiAgUkVHRVhQOiB0cnVlXG59KTtcbk15c3FsRGlhbGVjdC5wcm90b3R5cGUuZGVmYXVsdFZlcnNpb24gPSBcIjUuNy4wXCI7XG5NeXNxbERpYWxlY3QucHJvdG90eXBlLlF1ZXJ5ID0gUXVlcnk7XG5NeXNxbERpYWxlY3QucHJvdG90eXBlLlF1ZXJ5R2VuZXJhdG9yID0gUXVlcnlHZW5lcmF0b3I7XG5NeXNxbERpYWxlY3QucHJvdG90eXBlLkRhdGFUeXBlcyA9IERhdGFUeXBlcztcbk15c3FsRGlhbGVjdC5wcm90b3R5cGUubmFtZSA9IFwibXlzcWxcIjtcbk15c3FsRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSID0gXCJgXCI7XG5NeXNxbERpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9MRUZUID0gTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVI7XG5NeXNxbERpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9SSUdIVCA9IE15c3FsRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSO1xubW9kdWxlLmV4cG9ydHMgPSBNeXNxbERpYWxlY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/mysql/index.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/mysql/query-generator.js":
/*!***********************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/mysql/query-generator.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-generator.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst Op = __webpack_require__(/*! ../../operators */ \"(action-browser)/../node_modules/sequelize/lib/operators.js\");\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst FOREIGN_KEY_FIELDS = [\n  \"CONSTRAINT_NAME as constraint_name\",\n  \"CONSTRAINT_NAME as constraintName\",\n  \"CONSTRAINT_SCHEMA as constraintSchema\",\n  \"CONSTRAINT_SCHEMA as constraintCatalog\",\n  \"TABLE_NAME as tableName\",\n  \"TABLE_SCHEMA as tableSchema\",\n  \"TABLE_SCHEMA as tableCatalog\",\n  \"COLUMN_NAME as columnName\",\n  \"REFERENCED_TABLE_SCHEMA as referencedTableSchema\",\n  \"REFERENCED_TABLE_SCHEMA as referencedTableCatalog\",\n  \"REFERENCED_TABLE_NAME as referencedTableName\",\n  \"REFERENCED_COLUMN_NAME as referencedColumnName\"\n].join(\",\");\nconst typeWithoutDefault = /* @__PURE__ */ new Set([\"BLOB\", \"TEXT\", \"GEOMETRY\", \"JSON\"]);\nclass MySQLQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n    this.OperatorMap = __spreadProps(__spreadValues({}, this.OperatorMap), {\n      [Op.regexp]: \"REGEXP\",\n      [Op.notRegexp]: \"NOT REGEXP\"\n    });\n  }\n  createDatabaseQuery(databaseName, options) {\n    options = __spreadValues({\n      charset: null,\n      collate: null\n    }, options);\n    return Utils.joinSQLFragments([\n      \"CREATE DATABASE IF NOT EXISTS\",\n      this.quoteIdentifier(databaseName),\n      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,\n      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,\n      \";\"\n    ]);\n  }\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;\n  }\n  createSchema() {\n    return \"SHOW TABLES\";\n  }\n  showSchemasQuery() {\n    return \"SHOW TABLES\";\n  }\n  versionQuery() {\n    return \"SELECT VERSION() as `version`\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    options = __spreadValues({\n      engine: \"InnoDB\",\n      charset: null,\n      rowFormat: null\n    }, options);\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr))\n        continue;\n      const dataType = attributes[attr];\n      let match;\n      if (dataType.includes(\"PRIMARY KEY\")) {\n        primaryKeys.push(attr);\n        if (dataType.includes(\"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace(\"PRIMARY KEY\", \"\")}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace(\"PRIMARY KEY\", \"\")}`);\n        }\n      } else if (dataType.includes(\"REFERENCES\")) {\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(\", \");\n    const pkString = primaryKeys.map((pk) => this.quoteIdentifier(pk)).join(\", \");\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== \"string\") {\n            indexName = `uniq_${tableName}_${columns.fields.join(\"_\")}`;\n          }\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n    return Utils.joinSQLFragments([\n      \"CREATE TABLE IF NOT EXISTS\",\n      table,\n      `(${attributesClause})`,\n      `ENGINE=${options.engine}`,\n      options.comment && typeof options.comment === \"string\" && `COMMENT ${this.escape(options.comment)}`,\n      options.charset && `DEFAULT CHARSET=${options.charset}`,\n      options.collate && `COLLATE ${options.collate}`,\n      options.initialAutoIncrement && `AUTO_INCREMENT=${options.initialAutoIncrement}`,\n      options.rowFormat && `ROW_FORMAT=${options.rowFormat}`,\n      \";\"\n    ]);\n  }\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(this.addSchema({\n      tableName,\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter\n    }));\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n  showTablesQuery(database) {\n    let query = \"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'\";\n    if (database) {\n      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;\n    } else {\n      query += \" AND TABLE_SCHEMA NOT IN ('MYSQL', 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA', 'SYS', 'mysql', 'information_schema', 'performance_schema', 'sys')\";\n    }\n    return `${query};`;\n  }\n  tableExistsQuery(table) {\n    const tableName = this.escape(this.quoteTable(table).slice(1, -1));\n    return `SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = ${tableName} AND TABLE_SCHEMA = ${this.escape(this.sequelize.config.database)}`;\n  }\n  addColumnQuery(table, key, dataType) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(table),\n      \"ADD\",\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, {\n        context: \"addColumn\",\n        tableName: table,\n        foreignKey: key\n      }),\n      \";\"\n    ]);\n  }\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP\",\n      this.quoteIdentifier(attributeName),\n      \";\"\n    ]);\n  }\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n    for (const attributeName in attributes) {\n      let definition = attributes[attributeName];\n      if (definition.includes(\"REFERENCES\")) {\n        const attrName = this.quoteIdentifier(attributeName);\n        definition = definition.replace(/.+?(?=REFERENCES)/, \"\");\n        constraintString.push(`FOREIGN KEY (${attrName}) ${definition}`);\n      } else {\n        attrString.push(`\\`${attributeName}\\` \\`${attributeName}\\` ${definition}`);\n      }\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      attrString.length && `CHANGE ${attrString.join(\", \")}`,\n      constraintString.length && `ADD ${constraintString.join(\", \")}`,\n      \";\"\n    ]);\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`\\`${attrBefore}\\` \\`${attrName}\\` ${definition}`);\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"CHANGE\",\n      attrString.join(\", \"),\n      \";\"\n    ]);\n  }\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map((condition) => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(\" AND \");\n      }\n      if (smth.path) {\n        let str;\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n        if (smth.value) {\n          str += util.format(\" = %s\", this.escape(smth.value));\n        }\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = \"datetime\";\n      } else if (smth.json && /boolean/i.test(smth.type)) {\n        smth.type = \"char\";\n      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {\n        smth.type = \"decimal\";\n      } else if (/text/i.test(smth.type)) {\n        smth.type = \"char\";\n      }\n    }\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n  _toJSONValue(value) {\n    if (typeof value === \"boolean\") {\n      return value.toString();\n    }\n    if (value === null) {\n      return \"null\";\n    }\n    return value;\n  }\n  truncateTableQuery(tableName) {\n    return `TRUNCATE ${this.quoteTable(tableName)}`;\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    let limit = \"\";\n    let query = `DELETE FROM ${this.quoteTable(tableName)}`;\n    if (options.limit) {\n      limit = ` LIMIT ${this.escape(options.limit)}`;\n    }\n    where = this.getWhereConditions(where, null, model, options);\n    if (where) {\n      query += ` WHERE ${where}`;\n    }\n    return query + limit;\n  }\n  showIndexesQuery(tableName, options) {\n    return Utils.joinSQLFragments([\n      `SHOW INDEX FROM ${this.quoteTable(tableName)}`,\n      options && options.database && `FROM \\`${options.database}\\``\n    ]);\n  }\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    return Utils.joinSQLFragments([\n      \"SELECT CONSTRAINT_CATALOG AS constraintCatalog,\",\n      \"CONSTRAINT_NAME AS constraintName,\",\n      \"CONSTRAINT_SCHEMA AS constraintSchema,\",\n      \"CONSTRAINT_TYPE AS constraintType,\",\n      \"TABLE_NAME AS tableName,\",\n      \"TABLE_SCHEMA AS tableSchema\",\n      \"from INFORMATION_SCHEMA.TABLE_CONSTRAINTS\",\n      `WHERE table_name='${tableName}'`,\n      constraintName && `AND constraint_name = '${constraintName}'`,\n      schemaName && `AND TABLE_SCHEMA = '${schemaName}'`,\n      \";\"\n    ]);\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return Utils.joinSQLFragments([\n      \"DROP INDEX\",\n      this.quoteIdentifier(indexName),\n      \"ON\",\n      this.quoteTable(tableName)\n    ]);\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });\n    let template = attributeString;\n    if (attribute.allowNull === false) {\n      template += \" NOT NULL\";\n    }\n    if (attribute.autoIncrement) {\n      template += \" auto_increment\";\n    }\n    if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.unique === true) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n    if (attribute.first) {\n      template += \" FIRST\";\n    }\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      if (options && options.context === \"addColumn\" && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {};\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n    return result;\n  }\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n      break;\n    }\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n    return hasJsonFunction;\n  }\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\n      \"SELECT\",\n      FOREIGN_KEY_FIELDS,\n      `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`,\n      `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`,\n      \"AND REFERENCED_TABLE_NAME IS NOT NULL\",\n      \";\"\n    ]);\n  }\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : \"\";\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n    return Utils.joinSQLFragments([\n      \"SELECT\",\n      FOREIGN_KEY_FIELDS,\n      \"FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE\",\n      \"WHERE (\",\n      [\n        `REFERENCED_TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`\n      ],\n      \") OR (\",\n      [\n        `TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND COLUMN_NAME = ${quotedColumnName}`,\n        \"AND REFERENCED_TABLE_NAME IS NOT NULL\"\n      ],\n      \")\"\n    ]);\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP FOREIGN KEY\",\n      this.quoteIdentifier(foreignKey),\n      \";\"\n    ]);\n  }\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, \"`\"), \"`\");\n  }\n}\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, \"'\");\n}\nmodule.exports = MySQLQueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9xdWVyeS1nZW5lcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLGlFQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyw0RUFBYTtBQUNuQywrQkFBK0IsbUJBQU8sQ0FBQyx3SEFBNkI7QUFDcEUsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyxvRkFBaUI7QUFDcEMsOENBQThDLElBQUksa0JBQWtCLElBQUk7QUFDeEUsd0RBQXdELEVBQUU7QUFDMUQsMERBQTBELEVBQUUsc0JBQXNCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDZCQUE2QjtBQUMvRSw0Q0FBNEMsNkJBQTZCO0FBQ3pFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0NBQW9DO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCLEVBQUUsb0NBQW9DO0FBQzVGO0FBQ0EsVUFBVTtBQUNWLDBCQUEwQiw0QkFBNEIsRUFBRSxvQ0FBb0M7QUFDNUY7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3QkFBd0IsNEJBQTRCLEVBQUUsU0FBUztBQUMvRDtBQUNBLFFBQVE7QUFDUix3QkFBd0IsNEJBQTRCLEVBQUUsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxHQUFHLHlCQUF5QjtBQUN0RTtBQUNBLDBDQUEwQyxpQ0FBaUMsR0FBRyxzRUFBc0U7QUFDcEo7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywyQkFBMkIsSUFBSSxrQkFBa0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCLGdCQUFnQixlQUFlO0FBQy9CLDJFQUEyRSw2QkFBNkI7QUFDeEcsNENBQTRDLGdCQUFnQjtBQUM1RCxvQ0FBb0MsZ0JBQWdCO0FBQ3BELHdEQUF3RCw2QkFBNkI7QUFDckYseUNBQXlDLGtCQUFrQjtBQUMzRCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVELE1BQU07QUFDTjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSCxXQUFXLHFCQUFxQiw0Q0FBNEM7QUFDNUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTLElBQUksV0FBVztBQUN0RSxRQUFRO0FBQ1IsNkJBQTZCLGNBQWMsT0FBTyxjQUFjLEtBQUssV0FBVztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNCQUFzQjtBQUMzRCx3Q0FBd0MsNEJBQTRCO0FBQ3BFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVyxPQUFPLFNBQVMsS0FBSyxXQUFXO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLHlFQUF5RSxLQUFLLGdCQUFnQjtBQUMxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBLDRDQUE0QztBQUM1QztBQUNBLCtCQUErQiwyQkFBMkI7QUFDMUQ7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkJBQTJCO0FBQ3BELCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQyxrREFBa0QsZUFBZTtBQUNqRSwyQ0FBMkMsV0FBVztBQUN0RCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLEdBQUcsZ0NBQWdDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZ0NBQWdDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0NBQW9DO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0JBQStCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0NBQXNDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGtCQUFrQixHQUFHLFNBQVM7QUFDN0Usd0NBQXdDLFFBQVEsZUFBZSxTQUFTO0FBQ3hFO0FBQ0EsaUNBQWlDLDRDQUE0QztBQUM3RTtBQUNBLHlCQUF5QiwrQ0FBK0M7QUFDeEUsUUFBUTtBQUNSLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBLGtDQUFrQyxpQ0FBaUM7QUFDbkU7QUFDQTtBQUNBLGtDQUFrQyxpQ0FBaUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVLDZCQUE2QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsS0FBSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLFVBQVU7QUFDaEYsK0RBQStELFdBQVc7QUFDMUU7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCx5REFBeUQsaUJBQWlCO0FBQzFFLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4Qyw4Q0FBOEMsaUJBQWlCO0FBQy9ELDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL215c3FsL3F1ZXJ5LWdlbmVyYXRvci5qcz9kYzYzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuY29uc3QgQWJzdHJhY3RRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3JcIik7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBPcCA9IHJlcXVpcmUoXCIuLi8uLi9vcGVyYXRvcnNcIik7XG5jb25zdCBKU09OX0ZVTkNUSU9OX1JFR0VYID0gL15cXHMqKCg/OlthLXpdK18pezAsMn1qc29uYj8oPzpfW2Etel0rKXswLDJ9KVxcKFteKV0qXFwpL2k7XG5jb25zdCBKU09OX09QRVJBVE9SX1JFR0VYID0gL15cXHMqKC0+Pj98QD58PEB8XFw/W3wmXT98XFx8ezJ9fCMtKS9pO1xuY29uc3QgVE9LRU5fQ0FQVFVSRV9SRUdFWCA9IC9eXFxzKigoPzooW2BcIiddKSg/Oig/IVxcMikufFxcMnsyfSkqXFwyKXxbXFx3XFxkXFxzXSt8WygpLiw7Ky1dKS9pO1xuY29uc3QgRk9SRUlHTl9LRVlfRklFTERTID0gW1xuICBcIkNPTlNUUkFJTlRfTkFNRSBhcyBjb25zdHJhaW50X25hbWVcIixcbiAgXCJDT05TVFJBSU5UX05BTUUgYXMgY29uc3RyYWludE5hbWVcIixcbiAgXCJDT05TVFJBSU5UX1NDSEVNQSBhcyBjb25zdHJhaW50U2NoZW1hXCIsXG4gIFwiQ09OU1RSQUlOVF9TQ0hFTUEgYXMgY29uc3RyYWludENhdGFsb2dcIixcbiAgXCJUQUJMRV9OQU1FIGFzIHRhYmxlTmFtZVwiLFxuICBcIlRBQkxFX1NDSEVNQSBhcyB0YWJsZVNjaGVtYVwiLFxuICBcIlRBQkxFX1NDSEVNQSBhcyB0YWJsZUNhdGFsb2dcIixcbiAgXCJDT0xVTU5fTkFNRSBhcyBjb2x1bW5OYW1lXCIsXG4gIFwiUkVGRVJFTkNFRF9UQUJMRV9TQ0hFTUEgYXMgcmVmZXJlbmNlZFRhYmxlU2NoZW1hXCIsXG4gIFwiUkVGRVJFTkNFRF9UQUJMRV9TQ0hFTUEgYXMgcmVmZXJlbmNlZFRhYmxlQ2F0YWxvZ1wiLFxuICBcIlJFRkVSRU5DRURfVEFCTEVfTkFNRSBhcyByZWZlcmVuY2VkVGFibGVOYW1lXCIsXG4gIFwiUkVGRVJFTkNFRF9DT0xVTU5fTkFNRSBhcyByZWZlcmVuY2VkQ29sdW1uTmFtZVwiXG5dLmpvaW4oXCIsXCIpO1xuY29uc3QgdHlwZVdpdGhvdXREZWZhdWx0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiQkxPQlwiLCBcIlRFWFRcIiwgXCJHRU9NRVRSWVwiLCBcIkpTT05cIl0pO1xuY2xhc3MgTXlTUUxRdWVyeUdlbmVyYXRvciBleHRlbmRzIEFic3RyYWN0UXVlcnlHZW5lcmF0b3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy5PcGVyYXRvck1hcCA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuT3BlcmF0b3JNYXApLCB7XG4gICAgICBbT3AucmVnZXhwXTogXCJSRUdFWFBcIixcbiAgICAgIFtPcC5ub3RSZWdleHBdOiBcIk5PVCBSRUdFWFBcIlxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZURhdGFiYXNlUXVlcnkoZGF0YWJhc2VOYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGNoYXJzZXQ6IG51bGwsXG4gICAgICBjb2xsYXRlOiBudWxsXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJDUkVBVEUgREFUQUJBU0UgSUYgTk9UIEVYSVNUU1wiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoZGF0YWJhc2VOYW1lKSxcbiAgICAgIG9wdGlvbnMuY2hhcnNldCAmJiBgREVGQVVMVCBDSEFSQUNURVIgU0VUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5jaGFyc2V0KX1gLFxuICAgICAgb3B0aW9ucy5jb2xsYXRlICYmIGBERUZBVUxUIENPTExBVEUgJHt0aGlzLmVzY2FwZShvcHRpb25zLmNvbGxhdGUpfWAsXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIGRyb3BEYXRhYmFzZVF1ZXJ5KGRhdGFiYXNlTmFtZSkge1xuICAgIHJldHVybiBgRFJPUCBEQVRBQkFTRSBJRiBFWElTVFMgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihkYXRhYmFzZU5hbWUpfTtgO1xuICB9XG4gIGNyZWF0ZVNjaGVtYSgpIHtcbiAgICByZXR1cm4gXCJTSE9XIFRBQkxFU1wiO1xuICB9XG4gIHNob3dTY2hlbWFzUXVlcnkoKSB7XG4gICAgcmV0dXJuIFwiU0hPVyBUQUJMRVNcIjtcbiAgfVxuICB2ZXJzaW9uUXVlcnkoKSB7XG4gICAgcmV0dXJuIFwiU0VMRUNUIFZFUlNJT04oKSBhcyBgdmVyc2lvbmBcIjtcbiAgfVxuICBjcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBlbmdpbmU6IFwiSW5ub0RCXCIsXG4gICAgICBjaGFyc2V0OiBudWxsLFxuICAgICAgcm93Rm9ybWF0OiBudWxsXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgY29uc3QgcHJpbWFyeUtleXMgPSBbXTtcbiAgICBjb25zdCBmb3JlaWduS2V5cyA9IHt9O1xuICAgIGNvbnN0IGF0dHJTdHIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGF0dHIgaW4gYXR0cmlidXRlcykge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgYXR0cikpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgZGF0YVR5cGUgPSBhdHRyaWJ1dGVzW2F0dHJdO1xuICAgICAgbGV0IG1hdGNoO1xuICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiUFJJTUFSWSBLRVlcIikpIHtcbiAgICAgICAgcHJpbWFyeUtleXMucHVzaChhdHRyKTtcbiAgICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiUkVGRVJFTkNFU1wiKSkge1xuICAgICAgICAgIG1hdGNoID0gZGF0YVR5cGUubWF0Y2goL14oLispIChSRUZFUkVOQ0VTLiopJC8pO1xuICAgICAgICAgIGF0dHJTdHIucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHttYXRjaFsxXS5yZXBsYWNlKFwiUFJJTUFSWSBLRVlcIiwgXCJcIil9YCk7XG4gICAgICAgICAgZm9yZWlnbktleXNbYXR0cl0gPSBtYXRjaFsyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRyU3RyLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7ZGF0YVR5cGUucmVwbGFjZShcIlBSSU1BUlkgS0VZXCIsIFwiXCIpfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiUkVGRVJFTkNFU1wiKSkge1xuICAgICAgICBtYXRjaCA9IGRhdGFUeXBlLm1hdGNoKC9eKC4rKSAoUkVGRVJFTkNFUy4qKSQvKTtcbiAgICAgICAgYXR0clN0ci5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke21hdGNoWzFdfWApO1xuICAgICAgICBmb3JlaWduS2V5c1thdHRyXSA9IG1hdGNoWzJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0clN0ci5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke2RhdGFUeXBlfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0YWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIGxldCBhdHRyaWJ1dGVzQ2xhdXNlID0gYXR0clN0ci5qb2luKFwiLCBcIik7XG4gICAgY29uc3QgcGtTdHJpbmcgPSBwcmltYXJ5S2V5cy5tYXAoKHBrKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihwaykpLmpvaW4oXCIsIFwiKTtcbiAgICBpZiAob3B0aW9ucy51bmlxdWVLZXlzKSB7XG4gICAgICBfLmVhY2gob3B0aW9ucy51bmlxdWVLZXlzLCAoY29sdW1ucywgaW5kZXhOYW1lKSA9PiB7XG4gICAgICAgIGlmIChjb2x1bW5zLmN1c3RvbUluZGV4KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbmRleE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGluZGV4TmFtZSA9IGB1bmlxXyR7dGFibGVOYW1lfV8ke2NvbHVtbnMuZmllbGRzLmpvaW4oXCJfXCIpfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYnV0ZXNDbGF1c2UgKz0gYCwgVU5JUVVFICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaW5kZXhOYW1lKX0gKCR7Y29sdW1ucy5maWVsZHMubWFwKChmaWVsZCkgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQpKS5qb2luKFwiLCBcIil9KWA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGtTdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgYXR0cmlidXRlc0NsYXVzZSArPSBgLCBQUklNQVJZIEtFWSAoJHtwa1N0cmluZ30pYDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBma2V5IGluIGZvcmVpZ25LZXlzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZvcmVpZ25LZXlzLCBma2V5KSkge1xuICAgICAgICBhdHRyaWJ1dGVzQ2xhdXNlICs9IGAsIEZPUkVJR04gS0VZICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGZrZXkpfSkgJHtmb3JlaWduS2V5c1tma2V5XX1gO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkNSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTXCIsXG4gICAgICB0YWJsZSxcbiAgICAgIGAoJHthdHRyaWJ1dGVzQ2xhdXNlfSlgLFxuICAgICAgYEVOR0lORT0ke29wdGlvbnMuZW5naW5lfWAsXG4gICAgICBvcHRpb25zLmNvbW1lbnQgJiYgdHlwZW9mIG9wdGlvbnMuY29tbWVudCA9PT0gXCJzdHJpbmdcIiAmJiBgQ09NTUVOVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMuY29tbWVudCl9YCxcbiAgICAgIG9wdGlvbnMuY2hhcnNldCAmJiBgREVGQVVMVCBDSEFSU0VUPSR7b3B0aW9ucy5jaGFyc2V0fWAsXG4gICAgICBvcHRpb25zLmNvbGxhdGUgJiYgYENPTExBVEUgJHtvcHRpb25zLmNvbGxhdGV9YCxcbiAgICAgIG9wdGlvbnMuaW5pdGlhbEF1dG9JbmNyZW1lbnQgJiYgYEFVVE9fSU5DUkVNRU5UPSR7b3B0aW9ucy5pbml0aWFsQXV0b0luY3JlbWVudH1gLFxuICAgICAgb3B0aW9ucy5yb3dGb3JtYXQgJiYgYFJPV19GT1JNQVQ9JHtvcHRpb25zLnJvd0Zvcm1hdH1gLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBkZXNjcmliZVRhYmxlUXVlcnkodGFibGVOYW1lLCBzY2hlbWEsIHNjaGVtYURlbGltaXRlcikge1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRoaXMuYWRkU2NoZW1hKHtcbiAgICAgIHRhYmxlTmFtZSxcbiAgICAgIF9zY2hlbWE6IHNjaGVtYSxcbiAgICAgIF9zY2hlbWFEZWxpbWl0ZXI6IHNjaGVtYURlbGltaXRlclxuICAgIH0pKTtcbiAgICByZXR1cm4gYFNIT1cgRlVMTCBDT0xVTU5TIEZST00gJHt0YWJsZX07YDtcbiAgfVxuICBzaG93VGFibGVzUXVlcnkoZGF0YWJhc2UpIHtcbiAgICBsZXQgcXVlcnkgPSBcIlNFTEVDVCBUQUJMRV9OQU1FIEZST00gSU5GT1JNQVRJT05fU0NIRU1BLlRBQkxFUyBXSEVSRSBUQUJMRV9UWVBFID0gJ0JBU0UgVEFCTEUnXCI7XG4gICAgaWYgKGRhdGFiYXNlKSB7XG4gICAgICBxdWVyeSArPSBgIEFORCBUQUJMRV9TQ0hFTUEgPSAke3RoaXMuZXNjYXBlKGRhdGFiYXNlKX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeSArPSBcIiBBTkQgVEFCTEVfU0NIRU1BIE5PVCBJTiAoJ01ZU1FMJywgJ0lORk9STUFUSU9OX1NDSEVNQScsICdQRVJGT1JNQU5DRV9TQ0hFTUEnLCAnU1lTJywgJ215c3FsJywgJ2luZm9ybWF0aW9uX3NjaGVtYScsICdwZXJmb3JtYW5jZV9zY2hlbWEnLCAnc3lzJylcIjtcbiAgICB9XG4gICAgcmV0dXJuIGAke3F1ZXJ5fTtgO1xuICB9XG4gIHRhYmxlRXhpc3RzUXVlcnkodGFibGUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0aGlzLmVzY2FwZSh0aGlzLnF1b3RlVGFibGUodGFibGUpLnNsaWNlKDEsIC0xKSk7XG4gICAgcmV0dXJuIGBTRUxFQ1QgVEFCTEVfTkFNRSBGUk9NIElORk9STUFUSU9OX1NDSEVNQS5UQUJMRVMgV0hFUkUgVEFCTEVfVFlQRSA9ICdCQVNFIFRBQkxFJyBBTkQgVEFCTEVfTkFNRSA9ICR7dGFibGVOYW1lfSBBTkQgVEFCTEVfU0NIRU1BID0gJHt0aGlzLmVzY2FwZSh0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGF0YWJhc2UpfWA7XG4gIH1cbiAgYWRkQ29sdW1uUXVlcnkodGFibGUsIGtleSwgZGF0YVR5cGUpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGUpLFxuICAgICAgXCJBRERcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSksXG4gICAgICB0aGlzLmF0dHJpYnV0ZVRvU1FMKGRhdGFUeXBlLCB7XG4gICAgICAgIGNvbnRleHQ6IFwiYWRkQ29sdW1uXCIsXG4gICAgICAgIHRhYmxlTmFtZTogdGFibGUsXG4gICAgICAgIGZvcmVpZ25LZXk6IGtleVxuICAgICAgfSksXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIHJlbW92ZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQUxURVIgVEFCTEVcIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgXCJEUk9QXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKSxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgY2hhbmdlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgYXR0clN0cmluZyA9IFtdO1xuICAgIGNvbnN0IGNvbnN0cmFpbnRTdHJpbmcgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgbGV0IGRlZmluaXRpb24gPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgaWYgKGRlZmluaXRpb24uaW5jbHVkZXMoXCJSRUZFUkVOQ0VTXCIpKSB7XG4gICAgICAgIGNvbnN0IGF0dHJOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uLnJlcGxhY2UoLy4rPyg/PVJFRkVSRU5DRVMpLywgXCJcIik7XG4gICAgICAgIGNvbnN0cmFpbnRTdHJpbmcucHVzaChgRk9SRUlHTiBLRVkgKCR7YXR0ck5hbWV9KSAke2RlZmluaXRpb259YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyU3RyaW5nLnB1c2goYFxcYCR7YXR0cmlidXRlTmFtZX1cXGAgXFxgJHthdHRyaWJ1dGVOYW1lfVxcYCAke2RlZmluaXRpb259YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQUxURVIgVEFCTEVcIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgYXR0clN0cmluZy5sZW5ndGggJiYgYENIQU5HRSAke2F0dHJTdHJpbmcuam9pbihcIiwgXCIpfWAsXG4gICAgICBjb25zdHJhaW50U3RyaW5nLmxlbmd0aCAmJiBgQUREICR7Y29uc3RyYWludFN0cmluZy5qb2luKFwiLCBcIil9YCxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgcmVuYW1lQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyQmVmb3JlLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgYXR0clN0cmluZyA9IFtdO1xuICAgIGZvciAoY29uc3QgYXR0ck5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IGF0dHJpYnV0ZXNbYXR0ck5hbWVdO1xuICAgICAgYXR0clN0cmluZy5wdXNoKGBcXGAke2F0dHJCZWZvcmV9XFxgIFxcYCR7YXR0ck5hbWV9XFxgICR7ZGVmaW5pdGlvbn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBcIkNIQU5HRVwiLFxuICAgICAgYXR0clN0cmluZy5qb2luKFwiLCBcIiksXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIGhhbmRsZVNlcXVlbGl6ZU1ldGhvZChzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpIHtcbiAgICBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkpzb24pIHtcbiAgICAgIGlmIChzbXRoLmNvbmRpdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZGl0aW9ucyA9IHRoaXMucGFyc2VDb25kaXRpb25PYmplY3Qoc210aC5jb25kaXRpb25zKS5tYXAoKGNvbmRpdGlvbikgPT4gYCR7dGhpcy5qc29uUGF0aEV4dHJhY3Rpb25RdWVyeShjb25kaXRpb24ucGF0aFswXSwgXy50YWlsKGNvbmRpdGlvbi5wYXRoKSl9ID0gJyR7Y29uZGl0aW9uLnZhbHVlfSdgKTtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbnMuam9pbihcIiBBTkQgXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHNtdGgucGF0aCkge1xuICAgICAgICBsZXQgc3RyO1xuICAgICAgICBpZiAodGhpcy5fY2hlY2tWYWxpZEpzb25TdGF0ZW1lbnQoc210aC5wYXRoKSkge1xuICAgICAgICAgIHN0ciA9IHNtdGgucGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwYXRocyA9IF8udG9QYXRoKHNtdGgucGF0aCk7XG4gICAgICAgICAgY29uc3QgY29sdW1uID0gcGF0aHMuc2hpZnQoKTtcbiAgICAgICAgICBzdHIgPSB0aGlzLmpzb25QYXRoRXh0cmFjdGlvblF1ZXJ5KGNvbHVtbiwgcGF0aHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbXRoLnZhbHVlKSB7XG4gICAgICAgICAgc3RyICs9IHV0aWwuZm9ybWF0KFwiID0gJXNcIiwgdGhpcy5lc2NhcGUoc210aC52YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuQ2FzdCkge1xuICAgICAgaWYgKC90aW1lc3RhbXAvaS50ZXN0KHNtdGgudHlwZSkpIHtcbiAgICAgICAgc210aC50eXBlID0gXCJkYXRldGltZVwiO1xuICAgICAgfSBlbHNlIGlmIChzbXRoLmpzb24gJiYgL2Jvb2xlYW4vaS50ZXN0KHNtdGgudHlwZSkpIHtcbiAgICAgICAgc210aC50eXBlID0gXCJjaGFyXCI7XG4gICAgICB9IGVsc2UgaWYgKC9kb3VibGUgcHJlY2lzaW9uL2kudGVzdChzbXRoLnR5cGUpIHx8IC9ib29sZWFuL2kudGVzdChzbXRoLnR5cGUpIHx8IC9pbnRlZ2VyL2kudGVzdChzbXRoLnR5cGUpKSB7XG4gICAgICAgIHNtdGgudHlwZSA9IFwiZGVjaW1hbFwiO1xuICAgICAgfSBlbHNlIGlmICgvdGV4dC9pLnRlc3Qoc210aC50eXBlKSkge1xuICAgICAgICBzbXRoLnR5cGUgPSBcImNoYXJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICB9XG4gIF90b0pTT05WYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB0cnVuY2F0ZVRhYmxlUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIGBUUlVOQ0FURSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfWA7XG4gIH1cbiAgZGVsZXRlUXVlcnkodGFibGVOYW1lLCB3aGVyZSwgb3B0aW9ucyA9IHt9LCBtb2RlbCkge1xuICAgIGxldCBsaW1pdCA9IFwiXCI7XG4gICAgbGV0IHF1ZXJ5ID0gYERFTEVURSBGUk9NICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9YDtcbiAgICBpZiAob3B0aW9ucy5saW1pdCkge1xuICAgICAgbGltaXQgPSBgIExJTUlUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9YDtcbiAgICB9XG4gICAgd2hlcmUgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyh3aGVyZSwgbnVsbCwgbW9kZWwsIG9wdGlvbnMpO1xuICAgIGlmICh3aGVyZSkge1xuICAgICAgcXVlcnkgKz0gYCBXSEVSRSAke3doZXJlfWA7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeSArIGxpbWl0O1xuICB9XG4gIHNob3dJbmRleGVzUXVlcnkodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgYFNIT1cgSU5ERVggRlJPTSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfWAsXG4gICAgICBvcHRpb25zICYmIG9wdGlvbnMuZGF0YWJhc2UgJiYgYEZST00gXFxgJHtvcHRpb25zLmRhdGFiYXNlfVxcYGBcbiAgICBdKTtcbiAgfVxuICBzaG93Q29uc3RyYWludHNRdWVyeSh0YWJsZSwgY29uc3RyYWludE5hbWUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZS50YWJsZU5hbWUgfHwgdGFibGU7XG4gICAgY29uc3Qgc2NoZW1hTmFtZSA9IHRhYmxlLnNjaGVtYTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIlNFTEVDVCBDT05TVFJBSU5UX0NBVEFMT0cgQVMgY29uc3RyYWludENhdGFsb2csXCIsXG4gICAgICBcIkNPTlNUUkFJTlRfTkFNRSBBUyBjb25zdHJhaW50TmFtZSxcIixcbiAgICAgIFwiQ09OU1RSQUlOVF9TQ0hFTUEgQVMgY29uc3RyYWludFNjaGVtYSxcIixcbiAgICAgIFwiQ09OU1RSQUlOVF9UWVBFIEFTIGNvbnN0cmFpbnRUeXBlLFwiLFxuICAgICAgXCJUQUJMRV9OQU1FIEFTIHRhYmxlTmFtZSxcIixcbiAgICAgIFwiVEFCTEVfU0NIRU1BIEFTIHRhYmxlU2NoZW1hXCIsXG4gICAgICBcImZyb20gSU5GT1JNQVRJT05fU0NIRU1BLlRBQkxFX0NPTlNUUkFJTlRTXCIsXG4gICAgICBgV0hFUkUgdGFibGVfbmFtZT0nJHt0YWJsZU5hbWV9J2AsXG4gICAgICBjb25zdHJhaW50TmFtZSAmJiBgQU5EIGNvbnN0cmFpbnRfbmFtZSA9ICcke2NvbnN0cmFpbnROYW1lfSdgLFxuICAgICAgc2NoZW1hTmFtZSAmJiBgQU5EIFRBQkxFX1NDSEVNQSA9ICcke3NjaGVtYU5hbWV9J2AsXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIHJlbW92ZUluZGV4UXVlcnkodGFibGVOYW1lLCBpbmRleE5hbWVPckF0dHJpYnV0ZXMpIHtcbiAgICBsZXQgaW5kZXhOYW1lID0gaW5kZXhOYW1lT3JBdHRyaWJ1dGVzO1xuICAgIGlmICh0eXBlb2YgaW5kZXhOYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBpbmRleE5hbWUgPSBVdGlscy51bmRlcnNjb3JlKGAke3RhYmxlTmFtZX1fJHtpbmRleE5hbWVPckF0dHJpYnV0ZXMuam9pbihcIl9cIil9YCk7XG4gICAgfVxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiRFJPUCBJTkRFWFwiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoaW5kZXhOYW1lKSxcbiAgICAgIFwiT05cIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpXG4gICAgXSk7XG4gIH1cbiAgYXR0cmlidXRlVG9TUUwoYXR0cmlidXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFfLmlzUGxhaW5PYmplY3QoYXR0cmlidXRlKSkge1xuICAgICAgYXR0cmlidXRlID0ge1xuICAgICAgICB0eXBlOiBhdHRyaWJ1dGVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGF0dHJpYnV0ZVN0cmluZyA9IGF0dHJpYnV0ZS50eXBlLnRvU3RyaW5nKHsgZXNjYXBlOiB0aGlzLmVzY2FwZS5iaW5kKHRoaXMpIH0pO1xuICAgIGxldCB0ZW1wbGF0ZSA9IGF0dHJpYnV0ZVN0cmluZztcbiAgICBpZiAoYXR0cmlidXRlLmFsbG93TnVsbCA9PT0gZmFsc2UpIHtcbiAgICAgIHRlbXBsYXRlICs9IFwiIE5PVCBOVUxMXCI7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUuYXV0b0luY3JlbWVudCkge1xuICAgICAgdGVtcGxhdGUgKz0gXCIgYXV0b19pbmNyZW1lbnRcIjtcbiAgICB9XG4gICAgaWYgKCF0eXBlV2l0aG91dERlZmF1bHQuaGFzKGF0dHJpYnV0ZVN0cmluZykgJiYgYXR0cmlidXRlLnR5cGUuX2JpbmFyeSAhPT0gdHJ1ZSAmJiBVdGlscy5kZWZhdWx0VmFsdWVTY2hlbWFibGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgIHRlbXBsYXRlICs9IGAgREVGQVVMVCAke3RoaXMuZXNjYXBlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpfWA7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUudW5pcXVlID09PSB0cnVlKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBVTklRVUVcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5wcmltYXJ5S2V5KSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBQUklNQVJZIEtFWVwiO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLmNvbW1lbnQpIHtcbiAgICAgIHRlbXBsYXRlICs9IGAgQ09NTUVOVCAke3RoaXMuZXNjYXBlKGF0dHJpYnV0ZS5jb21tZW50KX1gO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLmZpcnN0KSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBGSVJTVFwiO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLmFmdGVyKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBgIEFGVEVSICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlLmFmdGVyKX1gO1xuICAgIH1cbiAgICBpZiAoKCFvcHRpb25zIHx8ICFvcHRpb25zLndpdGhvdXRGb3JlaWduS2V5Q29uc3RyYWludHMpICYmIGF0dHJpYnV0ZS5yZWZlcmVuY2VzKSB7XG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbnRleHQgPT09IFwiYWRkQ29sdW1uXCIgJiYgb3B0aW9ucy5mb3JlaWduS2V5KSB7XG4gICAgICAgIGNvbnN0IGF0dHJOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIob3B0aW9ucy5mb3JlaWduS2V5KTtcbiAgICAgICAgY29uc3QgZmtOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoYCR7b3B0aW9ucy50YWJsZU5hbWV9XyR7YXR0ck5hbWV9X2ZvcmVpZ25faWR4YCk7XG4gICAgICAgIHRlbXBsYXRlICs9IGAsIEFERCBDT05TVFJBSU5UICR7ZmtOYW1lfSBGT1JFSUdOIEtFWSAoJHthdHRyTmFtZX0pYDtcbiAgICAgIH1cbiAgICAgIHRlbXBsYXRlICs9IGAgUkVGRVJFTkNFUyAke3RoaXMucXVvdGVUYWJsZShhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbCl9YDtcbiAgICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcy5rZXkpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGUucmVmZXJlbmNlcy5rZXkpfSlgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihcImlkXCIpfSlgO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZS5vbkRlbGV0ZSkge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgIE9OIERFTEVURSAke2F0dHJpYnV0ZS5vbkRlbGV0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlLm9uVXBkYXRlKSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgT04gVVBEQVRFICR7YXR0cmlidXRlLm9uVXBkYXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9XG4gIGF0dHJpYnV0ZXNUb1NRTChhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgcmVzdWx0W2F0dHJpYnV0ZS5maWVsZCB8fCBrZXldID0gdGhpcy5hdHRyaWJ1dGVUb1NRTChhdHRyaWJ1dGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIF9jaGVja1ZhbGlkSnNvblN0YXRlbWVudChzdG10KSB7XG4gICAgaWYgKHR5cGVvZiBzdG10ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBjdXJyZW50SW5kZXggPSAwO1xuICAgIGxldCBvcGVuaW5nQnJhY2tldHMgPSAwO1xuICAgIGxldCBjbG9zaW5nQnJhY2tldHMgPSAwO1xuICAgIGxldCBoYXNKc29uRnVuY3Rpb24gPSBmYWxzZTtcbiAgICBsZXQgaGFzSW52YWxpZFRva2VuID0gZmFsc2U7XG4gICAgd2hpbGUgKGN1cnJlbnRJbmRleCA8IHN0bXQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzdHJpbmcgPSBzdG10LnN1YnN0cihjdXJyZW50SW5kZXgpO1xuICAgICAgY29uc3QgZnVuY3Rpb25NYXRjaGVzID0gSlNPTl9GVU5DVElPTl9SRUdFWC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAoZnVuY3Rpb25NYXRjaGVzKSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSBmdW5jdGlvbk1hdGNoZXNbMF0uaW5kZXhPZihcIihcIik7XG4gICAgICAgIGhhc0pzb25GdW5jdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3BlcmF0b3JNYXRjaGVzID0gSlNPTl9PUEVSQVRPUl9SRUdFWC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAob3BlcmF0b3JNYXRjaGVzKSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSBvcGVyYXRvck1hdGNoZXNbMF0ubGVuZ3RoO1xuICAgICAgICBoYXNKc29uRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRva2VuTWF0Y2hlcyA9IFRPS0VOX0NBUFRVUkVfUkVHRVguZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKHRva2VuTWF0Y2hlcykge1xuICAgICAgICBjb25zdCBjYXB0dXJlZFRva2VuID0gdG9rZW5NYXRjaGVzWzFdO1xuICAgICAgICBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gXCIoXCIpIHtcbiAgICAgICAgICBvcGVuaW5nQnJhY2tldHMrKztcbiAgICAgICAgfSBlbHNlIGlmIChjYXB0dXJlZFRva2VuID09PSBcIilcIikge1xuICAgICAgICAgIGNsb3NpbmdCcmFja2V0cysrO1xuICAgICAgICB9IGVsc2UgaWYgKGNhcHR1cmVkVG9rZW4gPT09IFwiO1wiKSB7XG4gICAgICAgICAgaGFzSW52YWxpZFRva2VuID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50SW5kZXggKz0gdG9rZW5NYXRjaGVzWzBdLmxlbmd0aDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGhhc0pzb25GdW5jdGlvbiAmJiAoaGFzSW52YWxpZFRva2VuIHx8IG9wZW5pbmdCcmFja2V0cyAhPT0gY2xvc2luZ0JyYWNrZXRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGpzb24gc3RhdGVtZW50OiAke3N0bXR9YCk7XG4gICAgfVxuICAgIHJldHVybiBoYXNKc29uRnVuY3Rpb247XG4gIH1cbiAgZ2V0Rm9yZWlnbktleXNRdWVyeSh0YWJsZSwgc2NoZW1hTmFtZSkge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIlNFTEVDVFwiLFxuICAgICAgRk9SRUlHTl9LRVlfRklFTERTLFxuICAgICAgYEZST00gSU5GT1JNQVRJT05fU0NIRU1BLktFWV9DT0xVTU5fVVNBR0Ugd2hlcmUgVEFCTEVfTkFNRSA9ICcke3RhYmxlTmFtZX0nYCxcbiAgICAgIGBBTkQgQ09OU1RSQUlOVF9OQU1FIT0nUFJJTUFSWScgQU5EIENPTlNUUkFJTlRfU0NIRU1BPScke3NjaGVtYU5hbWV9J2AsXG4gICAgICBcIkFORCBSRUZFUkVOQ0VEX1RBQkxFX05BTUUgSVMgTk9UIE5VTExcIixcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgZ2V0Rm9yZWlnbktleVF1ZXJ5KHRhYmxlLCBjb2x1bW5OYW1lKSB7XG4gICAgY29uc3QgcXVvdGVkU2NoZW1hTmFtZSA9IHRhYmxlLnNjaGVtYSA/IHdyYXBTaW5nbGVRdW90ZSh0YWJsZS5zY2hlbWEpIDogXCJcIjtcbiAgICBjb25zdCBxdW90ZWRUYWJsZU5hbWUgPSB3cmFwU2luZ2xlUXVvdGUodGFibGUudGFibGVOYW1lIHx8IHRhYmxlKTtcbiAgICBjb25zdCBxdW90ZWRDb2x1bW5OYW1lID0gd3JhcFNpbmdsZVF1b3RlKGNvbHVtbk5hbWUpO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiU0VMRUNUXCIsXG4gICAgICBGT1JFSUdOX0tFWV9GSUVMRFMsXG4gICAgICBcIkZST00gSU5GT1JNQVRJT05fU0NIRU1BLktFWV9DT0xVTU5fVVNBR0VcIixcbiAgICAgIFwiV0hFUkUgKFwiLFxuICAgICAgW1xuICAgICAgICBgUkVGRVJFTkNFRF9UQUJMRV9OQU1FID0gJHtxdW90ZWRUYWJsZU5hbWV9YCxcbiAgICAgICAgdGFibGUuc2NoZW1hICYmIGBBTkQgUkVGRVJFTkNFRF9UQUJMRV9TQ0hFTUEgPSAke3F1b3RlZFNjaGVtYU5hbWV9YCxcbiAgICAgICAgYEFORCBSRUZFUkVOQ0VEX0NPTFVNTl9OQU1FID0gJHtxdW90ZWRDb2x1bW5OYW1lfWBcbiAgICAgIF0sXG4gICAgICBcIikgT1IgKFwiLFxuICAgICAgW1xuICAgICAgICBgVEFCTEVfTkFNRSA9ICR7cXVvdGVkVGFibGVOYW1lfWAsXG4gICAgICAgIHRhYmxlLnNjaGVtYSAmJiBgQU5EIFRBQkxFX1NDSEVNQSA9ICR7cXVvdGVkU2NoZW1hTmFtZX1gLFxuICAgICAgICBgQU5EIENPTFVNTl9OQU1FID0gJHtxdW90ZWRDb2x1bW5OYW1lfWAsXG4gICAgICAgIFwiQU5EIFJFRkVSRU5DRURfVEFCTEVfTkFNRSBJUyBOT1QgTlVMTFwiXG4gICAgICBdLFxuICAgICAgXCIpXCJcbiAgICBdKTtcbiAgfVxuICBkcm9wRm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZSwgZm9yZWlnbktleSkge1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQUxURVIgVEFCTEVcIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgXCJEUk9QIEZPUkVJR04gS0VZXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihmb3JlaWduS2V5KSxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgcXVvdGVJZGVudGlmaWVyKGlkZW50aWZpZXIsIGZvcmNlKSB7XG4gICAgcmV0dXJuIFV0aWxzLmFkZFRpY2tzKFV0aWxzLnJlbW92ZVRpY2tzKGlkZW50aWZpZXIsIFwiYFwiKSwgXCJgXCIpO1xuICB9XG59XG5mdW5jdGlvbiB3cmFwU2luZ2xlUXVvdGUoaWRlbnRpZmllcikge1xuICByZXR1cm4gVXRpbHMuYWRkVGlja3MoaWRlbnRpZmllciwgXCInXCIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBNeVNRTFF1ZXJ5R2VuZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnktZ2VuZXJhdG9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/mysql/query-generator.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/mysql/query-interface.js":
/*!***********************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/mysql/query-interface.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(action-browser)/../node_modules/sequelize/lib/query-types.js\");\nclass MySQLQueryInterface extends QueryInterface {\n  async removeColumn(tableName, columnName, options) {\n    options = options || {};\n    const [results] = await this.sequelize.query(this.queryGenerator.getForeignKeyQuery(tableName.tableName ? tableName : {\n      tableName,\n      schema: this.sequelize.config.database\n    }, columnName), __spreadValues({ raw: true }, options));\n    if (results.length && results[0].constraint_name !== \"PRIMARY\") {\n      await Promise.all(results.map((constraint) => this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, constraint.constraint_name), __spreadValues({ raw: true }, options))));\n    }\n    return await this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, columnName), __spreadValues({ raw: true }, options));\n  }\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = Object.values(options.model.primaryKeys).map((item) => item.field);\n    const model = options.model;\n    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async removeConstraint(tableName, constraintName, options) {\n    const sql = this.queryGenerator.showConstraintsQuery(tableName.tableName ? tableName : {\n      tableName,\n      schema: this.sequelize.config.database\n    }, constraintName);\n    const constraints = await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      type: this.sequelize.QueryTypes.SHOWCONSTRAINTS\n    }));\n    const constraint = constraints[0];\n    let query;\n    if (!constraint || !constraint.constraintType) {\n      throw new sequelizeErrors.UnknownConstraintError({\n        message: `Constraint ${constraintName} on table ${tableName} does not exist`,\n        constraint: constraintName,\n        table: tableName\n      });\n    }\n    if (constraint.constraintType === \"FOREIGN KEY\") {\n      query = this.queryGenerator.dropForeignKeyQuery(tableName, constraintName);\n    } else {\n      query = this.queryGenerator.removeIndexQuery(constraint.tableName, constraint.constraintName);\n    }\n    return await this.sequelize.query(query, options);\n  }\n}\nexports.MySQLQueryInterface = MySQLQueryInterface;\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9xdWVyeS1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsb0ZBQWM7QUFDOUMsUUFBUSxpQkFBaUIsRUFBRSxtQkFBTyxDQUFDLHdIQUE2QjtBQUNoRSxtQkFBbUIsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnQ0FBZ0MsV0FBVztBQUNoRDtBQUNBLDBLQUEwSyxXQUFXO0FBQ3JMO0FBQ0EscUhBQXFILFdBQVc7QUFDaEk7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHVGQUF1RjtBQUN2RjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0IsV0FBVyxXQUFXO0FBQ3JFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXlzcWwvcXVlcnktaW50ZXJmYWNlLmpzPzUwN2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCB7IFF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnktaW50ZXJmYWNlXCIpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9xdWVyeS10eXBlc1wiKTtcbmNsYXNzIE15U1FMUXVlcnlJbnRlcmZhY2UgZXh0ZW5kcyBRdWVyeUludGVyZmFjZSB7XG4gIGFzeW5jIHJlbW92ZUNvbHVtbih0YWJsZU5hbWUsIGNvbHVtbk5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBbcmVzdWx0c10gPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLmdldEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUudGFibGVOYW1lID8gdGFibGVOYW1lIDoge1xuICAgICAgdGFibGVOYW1lLFxuICAgICAgc2NoZW1hOiB0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGF0YWJhc2VcbiAgICB9LCBjb2x1bW5OYW1lKSwgX19zcHJlYWRWYWx1ZXMoeyByYXc6IHRydWUgfSwgb3B0aW9ucykpO1xuICAgIGlmIChyZXN1bHRzLmxlbmd0aCAmJiByZXN1bHRzWzBdLmNvbnN0cmFpbnRfbmFtZSAhPT0gXCJQUklNQVJZXCIpIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJlc3VsdHMubWFwKChjb25zdHJhaW50KSA9PiB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLCBjb25zdHJhaW50LmNvbnN0cmFpbnRfbmFtZSksIF9fc3ByZWFkVmFsdWVzKHsgcmF3OiB0cnVlIH0sIG9wdGlvbnMpKSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5yZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGNvbHVtbk5hbWUpLCBfX3NwcmVhZFZhbHVlcyh7IHJhdzogdHJ1ZSB9LCBvcHRpb25zKSk7XG4gIH1cbiAgYXN5bmMgdXBzZXJ0KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCB1cGRhdGVWYWx1ZXMsIHdoZXJlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKTtcbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLlVQU0VSVDtcbiAgICBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlID0gT2JqZWN0LmtleXModXBkYXRlVmFsdWVzKTtcbiAgICBvcHRpb25zLnVwc2VydEtleXMgPSBPYmplY3QudmFsdWVzKG9wdGlvbnMubW9kZWwucHJpbWFyeUtleXMpLm1hcCgoaXRlbSkgPT4gaXRlbS5maWVsZCk7XG4gICAgY29uc3QgbW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuaW5zZXJ0UXVlcnkodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIG1vZGVsLnJhd0F0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIHJlbW92ZUNvbnN0cmFpbnQodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3Iuc2hvd0NvbnN0cmFpbnRzUXVlcnkodGFibGVOYW1lLnRhYmxlTmFtZSA/IHRhYmxlTmFtZSA6IHtcbiAgICAgIHRhYmxlTmFtZSxcbiAgICAgIHNjaGVtYTogdGhpcy5zZXF1ZWxpemUuY29uZmlnLmRhdGFiYXNlXG4gICAgfSwgY29uc3RyYWludE5hbWUpO1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwge1xuICAgICAgdHlwZTogdGhpcy5zZXF1ZWxpemUuUXVlcnlUeXBlcy5TSE9XQ09OU1RSQUlOVFNcbiAgICB9KSk7XG4gICAgY29uc3QgY29uc3RyYWludCA9IGNvbnN0cmFpbnRzWzBdO1xuICAgIGxldCBxdWVyeTtcbiAgICBpZiAoIWNvbnN0cmFpbnQgfHwgIWNvbnN0cmFpbnQuY29uc3RyYWludFR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5rbm93bkNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBDb25zdHJhaW50ICR7Y29uc3RyYWludE5hbWV9IG9uIHRhYmxlICR7dGFibGVOYW1lfSBkb2VzIG5vdCBleGlzdGAsXG4gICAgICAgIGNvbnN0cmFpbnQ6IGNvbnN0cmFpbnROYW1lLFxuICAgICAgICB0YWJsZTogdGFibGVOYW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGNvbnN0cmFpbnQuY29uc3RyYWludFR5cGUgPT09IFwiRk9SRUlHTiBLRVlcIikge1xuICAgICAgcXVlcnkgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5ID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yZW1vdmVJbmRleFF1ZXJ5KGNvbnN0cmFpbnQudGFibGVOYW1lLCBjb25zdHJhaW50LmNvbnN0cmFpbnROYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHF1ZXJ5LCBvcHRpb25zKTtcbiAgfVxufVxuZXhwb3J0cy5NeVNRTFF1ZXJ5SW50ZXJmYWNlID0gTXlTUUxRdWVyeUludGVyZmFjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWludGVyZmFjZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/mysql/query-interface.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/mysql/query.js":
/*!*************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/mysql/query.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(action-browser)/../node_modules/sequelize/lib/utils/logger.js\");\nconst ER_DUP_ENTRY = 1062;\nconst ER_DEADLOCK = 1213;\nconst ER_ROW_IS_REFERENCED = 1451;\nconst ER_NO_REFERENCED_ROW = 1452;\nconst debug = logger.debugContext(\"sql:mysql\");\nclass Query extends AbstractQuery {\n  constructor(connection, sequelize, options) {\n    super(connection, sequelize, __spreadValues({ showWarnings: false }, options));\n  }\n  static formatBindParameters(sql, values, dialect) {\n    const bindParam = [];\n    const replacementFunc = (match, key, values_) => {\n      if (values_[key] !== void 0) {\n        bindParam.push(values_[key]);\n        return \"?\";\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, bindParam.length > 0 ? bindParam : void 0];\n  }\n  async run(sql, parameters) {\n    this.sql = sql;\n    const { connection, options } = this;\n    const showWarnings = this.sequelize.options.showWarnings || options.showWarnings;\n    const complete = this._logQuery(sql, debug, parameters);\n    if (parameters) {\n      debug(\"parameters(%j)\", parameters);\n    }\n    let results;\n    const errForStack = new Error();\n    try {\n      if (parameters && parameters.length) {\n        results = await new Promise((resolve, reject) => {\n          connection.execute(sql, parameters, (error, result) => error ? reject(error) : resolve(result)).setMaxListeners(100);\n        });\n      } else {\n        results = await new Promise((resolve, reject) => {\n          connection.query({ sql }, (error, result) => error ? reject(error) : resolve(result)).setMaxListeners(100);\n        });\n      }\n    } catch (error) {\n      if (options.transaction && error.errno === ER_DEADLOCK) {\n        try {\n          await options.transaction.rollback();\n        } catch (error_) {\n        }\n        options.transaction.finished = \"rollback\";\n      }\n      error.sql = sql;\n      error.parameters = parameters;\n      throw this.formatError(error, errForStack.stack);\n    } finally {\n      complete();\n    }\n    if (showWarnings && results && results.warningStatus > 0) {\n      await this.logWarnings(results);\n    }\n    return this.formatResults(results);\n  }\n  formatResults(data) {\n    let result = this.instance;\n    if (this.isInsertQuery(data)) {\n      this.handleInsertQuery(data);\n      if (!this.instance) {\n        if (data.constructor.name === \"ResultSetHeader\" && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n          const startId = data[this.getInsertIdField()];\n          result = [];\n          for (let i = startId; i < startId + data.affectedRows; i++) {\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\n          }\n        } else {\n          result = data[this.getInsertIdField()];\n        }\n      }\n    }\n    if (this.isSelectQuery()) {\n      return this.handleSelectQuery(data);\n    }\n    if (this.isShowTablesQuery()) {\n      return this.handleShowTablesQuery(data);\n    }\n    if (this.isDescribeQuery()) {\n      result = {};\n      for (const _result of data) {\n        const enumRegex = /^enum/i;\n        result[_result.Field] = {\n          type: enumRegex.test(_result.Type) ? _result.Type.replace(enumRegex, \"ENUM\") : _result.Type.toUpperCase(),\n          allowNull: _result.Null === \"YES\",\n          defaultValue: _result.Default,\n          primaryKey: _result.Key === \"PRI\",\n          autoIncrement: Object.prototype.hasOwnProperty.call(_result, \"Extra\") && _result.Extra.toLowerCase() === \"auto_increment\",\n          comment: _result.Comment ? _result.Comment : null\n        };\n      }\n      return result;\n    }\n    if (this.isShowIndexesQuery()) {\n      return this.handleShowIndexesQuery(data);\n    }\n    if (this.isCallQuery()) {\n      return data[0];\n    }\n    if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery()) {\n      return data.affectedRows;\n    }\n    if (this.isVersionQuery()) {\n      return data[0].version;\n    }\n    if (this.isForeignKeysQuery()) {\n      return data;\n    }\n    if (this.isUpsertQuery()) {\n      return [result, data.affectedRows === 1];\n    }\n    if (this.isInsertQuery() || this.isUpdateQuery()) {\n      return [result, data.affectedRows];\n    }\n    if (this.isShowConstraintsQuery()) {\n      return data;\n    }\n    if (this.isRawQuery()) {\n      return [data, data];\n    }\n    return result;\n  }\n  async logWarnings(results) {\n    const warningResults = await this.run(\"SHOW WARNINGS\");\n    const warningMessage = `MySQL Warnings (${this.connection.uuid || \"default\"}): `;\n    const messages = [];\n    for (const _warningRow of warningResults) {\n      if (_warningRow === void 0 || typeof _warningRow[Symbol.iterator] !== \"function\") {\n        continue;\n      }\n      for (const _warningResult of _warningRow) {\n        if (Object.prototype.hasOwnProperty.call(_warningResult, \"Message\")) {\n          messages.push(_warningResult.Message);\n        } else {\n          for (const _objectKey of _warningResult.keys()) {\n            messages.push([_objectKey, _warningResult[_objectKey]].join(\": \"));\n          }\n        }\n      }\n    }\n    this.sequelize.log(warningMessage + messages.join(\"; \"), this.options);\n    return results;\n  }\n  formatError(err, errStack) {\n    const errCode = err.errno || err.code;\n    switch (errCode) {\n      case ER_DUP_ENTRY: {\n        const match = err.message.match(/Duplicate entry '([\\s\\S]*)' for key '?((.|\\s)*?)'?$/);\n        let fields = {};\n        let message = \"Validation error\";\n        const values = match ? match[1].split(\"-\") : void 0;\n        const fieldKey = match ? match[2].split(\".\").pop() : void 0;\n        const fieldVal = match ? match[1] : void 0;\n        const uniqueKey = this.model && this.model.uniqueKeys[fieldKey];\n        if (uniqueKey) {\n          if (uniqueKey.msg)\n            message = uniqueKey.msg;\n          fields = _.zipObject(uniqueKey.fields, values);\n        } else {\n          fields[fieldKey] = fieldVal;\n        }\n        const errors = [];\n        _.forOwn(fields, (value, field) => {\n          errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, value, this.instance, \"not_unique\"));\n        });\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n      }\n      case ER_ROW_IS_REFERENCED:\n      case ER_NO_REFERENCED_ROW: {\n        const match = err.message.match(/CONSTRAINT ([`\"])(.*)\\1 FOREIGN KEY \\(\\1(.*)\\1\\) REFERENCES \\1(.*)\\1 \\(\\1(.*)\\1\\)/);\n        const quoteChar = match ? match[1] : \"`\";\n        const fields = match ? match[3].split(new RegExp(`${quoteChar}, *${quoteChar}`)) : void 0;\n        return new sequelizeErrors.ForeignKeyConstraintError({\n          reltype: String(errCode) === String(ER_ROW_IS_REFERENCED) ? \"parent\" : \"child\",\n          table: match ? match[4] : void 0,\n          fields,\n          value: fields && fields.length && this.instance && this.instance[fields[0]] || void 0,\n          index: match ? match[2] : void 0,\n          parent: err,\n          stack: errStack\n        });\n      }\n      default:\n        return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n    }\n  }\n  handleShowIndexesQuery(data) {\n    data = data.reduce((acc, item) => {\n      if (!(item.Key_name in acc)) {\n        acc[item.Key_name] = item;\n        item.fields = [];\n      }\n      acc[item.Key_name].fields[item.Seq_in_index - 1] = {\n        attribute: item.Column_name,\n        length: item.Sub_part || void 0,\n        order: item.Collation === \"A\" ? \"ASC\" : void 0\n      };\n      delete item.column_name;\n      return acc;\n    }, {});\n    return _.map(data, (item) => ({\n      primary: item.Key_name === \"PRIMARY\",\n      fields: item.fields,\n      name: item.Key_name,\n      tableName: item.Table,\n      unique: item.Non_unique !== 1,\n      type: item.Index_type\n    }));\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports[\"default\"] = Query;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9xdWVyeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxvR0FBbUI7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMsb0ZBQWM7QUFDOUMsVUFBVSxtQkFBTyxDQUFDLGlFQUFRO0FBQzFCLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsMEZBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBLDZCQUE2QixLQUFLO0FBQ2xDLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQ0FBaUM7QUFDakUsMEJBQTBCLHFFQUFxRTtBQUMvRjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtDQUFrQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkRBQTJELHVEQUF1RDtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFVBQVUsS0FBSyxVQUFVO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdEQUF3RCxpQkFBaUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9xdWVyeS5qcz84NzA0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xuY29uc3QgQWJzdHJhY3RRdWVyeSA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9xdWVyeVwiKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvbG9nZ2VyXCIpO1xuY29uc3QgRVJfRFVQX0VOVFJZID0gMTA2MjtcbmNvbnN0IEVSX0RFQURMT0NLID0gMTIxMztcbmNvbnN0IEVSX1JPV19JU19SRUZFUkVOQ0VEID0gMTQ1MTtcbmNvbnN0IEVSX05PX1JFRkVSRU5DRURfUk9XID0gMTQ1MjtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dChcInNxbDpteXNxbFwiKTtcbmNsYXNzIFF1ZXJ5IGV4dGVuZHMgQWJzdHJhY3RRdWVyeSB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24sIHNlcXVlbGl6ZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKGNvbm5lY3Rpb24sIHNlcXVlbGl6ZSwgX19zcHJlYWRWYWx1ZXMoeyBzaG93V2FybmluZ3M6IGZhbHNlIH0sIG9wdGlvbnMpKTtcbiAgfVxuICBzdGF0aWMgZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QpIHtcbiAgICBjb25zdCBiaW5kUGFyYW0gPSBbXTtcbiAgICBjb25zdCByZXBsYWNlbWVudEZ1bmMgPSAobWF0Y2gsIGtleSwgdmFsdWVzXykgPT4ge1xuICAgICAgaWYgKHZhbHVlc19ba2V5XSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGJpbmRQYXJhbS5wdXNoKHZhbHVlc19ba2V5XSk7XG4gICAgICAgIHJldHVybiBcIj9cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcbiAgICBzcWwgPSBBYnN0cmFjdFF1ZXJ5LmZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0LCByZXBsYWNlbWVudEZ1bmMpWzBdO1xuICAgIHJldHVybiBbc3FsLCBiaW5kUGFyYW0ubGVuZ3RoID4gMCA/IGJpbmRQYXJhbSA6IHZvaWQgMF07XG4gIH1cbiAgYXN5bmMgcnVuKHNxbCwgcGFyYW1ldGVycykge1xuICAgIHRoaXMuc3FsID0gc3FsO1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbiwgb3B0aW9ucyB9ID0gdGhpcztcbiAgICBjb25zdCBzaG93V2FybmluZ3MgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnNob3dXYXJuaW5ncyB8fCBvcHRpb25zLnNob3dXYXJuaW5ncztcbiAgICBjb25zdCBjb21wbGV0ZSA9IHRoaXMuX2xvZ1F1ZXJ5KHNxbCwgZGVidWcsIHBhcmFtZXRlcnMpO1xuICAgIGlmIChwYXJhbWV0ZXJzKSB7XG4gICAgICBkZWJ1ZyhcInBhcmFtZXRlcnMoJWopXCIsIHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0cztcbiAgICBjb25zdCBlcnJGb3JTdGFjayA9IG5ldyBFcnJvcigpO1xuICAgIHRyeSB7XG4gICAgICBpZiAocGFyYW1ldGVycyAmJiBwYXJhbWV0ZXJzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHRzID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNvbm5lY3Rpb24uZXhlY3V0ZShzcWwsIHBhcmFtZXRlcnMsIChlcnJvciwgcmVzdWx0KSA9PiBlcnJvciA/IHJlamVjdChlcnJvcikgOiByZXNvbHZlKHJlc3VsdCkpLnNldE1heExpc3RlbmVycygxMDApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29ubmVjdGlvbi5xdWVyeSh7IHNxbCB9LCAoZXJyb3IsIHJlc3VsdCkgPT4gZXJyb3IgPyByZWplY3QoZXJyb3IpIDogcmVzb2x2ZShyZXN1bHQpKS5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uICYmIGVycm9yLmVycm5vID09PSBFUl9ERUFETE9DSykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IG9wdGlvbnMudHJhbnNhY3Rpb24ucm9sbGJhY2soKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3JfKSB7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbi5maW5pc2hlZCA9IFwicm9sbGJhY2tcIjtcbiAgICAgIH1cbiAgICAgIGVycm9yLnNxbCA9IHNxbDtcbiAgICAgIGVycm9yLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgdGhyb3cgdGhpcy5mb3JtYXRFcnJvcihlcnJvciwgZXJyRm9yU3RhY2suc3RhY2spO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjb21wbGV0ZSgpO1xuICAgIH1cbiAgICBpZiAoc2hvd1dhcm5pbmdzICYmIHJlc3VsdHMgJiYgcmVzdWx0cy53YXJuaW5nU3RhdHVzID4gMCkge1xuICAgICAgYXdhaXQgdGhpcy5sb2dXYXJuaW5ncyhyZXN1bHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0UmVzdWx0cyhyZXN1bHRzKTtcbiAgfVxuICBmb3JtYXRSZXN1bHRzKGRhdGEpIHtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5pbnN0YW5jZTtcbiAgICBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KGRhdGEpKSB7XG4gICAgICB0aGlzLmhhbmRsZUluc2VydFF1ZXJ5KGRhdGEpO1xuICAgICAgaWYgKCF0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgIGlmIChkYXRhLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiUmVzdWx0U2V0SGVhZGVyXCIgJiYgdGhpcy5tb2RlbCAmJiB0aGlzLm1vZGVsLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUgJiYgdGhpcy5tb2RlbC5hdXRvSW5jcmVtZW50QXR0cmlidXRlID09PSB0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGUgJiYgdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZV0pIHtcbiAgICAgICAgICBjb25zdCBzdGFydElkID0gZGF0YVt0aGlzLmdldEluc2VydElkRmllbGQoKV07XG4gICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SWQ7IGkgPCBzdGFydElkICsgZGF0YS5hZmZlY3RlZFJvd3M7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBbdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZV0uZmllbGRdOiBpIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBkYXRhW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5pc1NlbGVjdFF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbGVjdFF1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dUYWJsZXNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTaG93VGFibGVzUXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRGVzY3JpYmVRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgX3Jlc3VsdCBvZiBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGVudW1SZWdleCA9IC9eZW51bS9pO1xuICAgICAgICByZXN1bHRbX3Jlc3VsdC5GaWVsZF0gPSB7XG4gICAgICAgICAgdHlwZTogZW51bVJlZ2V4LnRlc3QoX3Jlc3VsdC5UeXBlKSA/IF9yZXN1bHQuVHlwZS5yZXBsYWNlKGVudW1SZWdleCwgXCJFTlVNXCIpIDogX3Jlc3VsdC5UeXBlLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgYWxsb3dOdWxsOiBfcmVzdWx0Lk51bGwgPT09IFwiWUVTXCIsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBfcmVzdWx0LkRlZmF1bHQsXG4gICAgICAgICAgcHJpbWFyeUtleTogX3Jlc3VsdC5LZXkgPT09IFwiUFJJXCIsXG4gICAgICAgICAgYXV0b0luY3JlbWVudDogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9yZXN1bHQsIFwiRXh0cmFcIikgJiYgX3Jlc3VsdC5FeHRyYS50b0xvd2VyQ2FzZSgpID09PSBcImF1dG9faW5jcmVtZW50XCIsXG4gICAgICAgICAgY29tbWVudDogX3Jlc3VsdC5Db21tZW50ID8gX3Jlc3VsdC5Db21tZW50IDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93SW5kZXhlc1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNob3dJbmRleGVzUXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQ2FsbFF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhWzBdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0J1bGtVcGRhdGVRdWVyeSgpIHx8IHRoaXMuaXNCdWxrRGVsZXRlUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYWZmZWN0ZWRSb3dzO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1ZlcnNpb25RdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YVswXS52ZXJzaW9uO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0ZvcmVpZ25LZXlzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVXBzZXJ0UXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFtyZXN1bHQsIGRhdGEuYWZmZWN0ZWRSb3dzID09PSAxXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeSgpIHx8IHRoaXMuaXNVcGRhdGVRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW3Jlc3VsdCwgZGF0YS5hZmZlY3RlZFJvd3NdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dDb25zdHJhaW50c1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Jhd1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbZGF0YSwgZGF0YV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgbG9nV2FybmluZ3MocmVzdWx0cykge1xuICAgIGNvbnN0IHdhcm5pbmdSZXN1bHRzID0gYXdhaXQgdGhpcy5ydW4oXCJTSE9XIFdBUk5JTkdTXCIpO1xuICAgIGNvbnN0IHdhcm5pbmdNZXNzYWdlID0gYE15U1FMIFdhcm5pbmdzICgke3RoaXMuY29ubmVjdGlvbi51dWlkIHx8IFwiZGVmYXVsdFwifSk6IGA7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IF93YXJuaW5nUm93IG9mIHdhcm5pbmdSZXN1bHRzKSB7XG4gICAgICBpZiAoX3dhcm5pbmdSb3cgPT09IHZvaWQgMCB8fCB0eXBlb2YgX3dhcm5pbmdSb3dbU3ltYm9sLml0ZXJhdG9yXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBfd2FybmluZ1Jlc3VsdCBvZiBfd2FybmluZ1Jvdykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF93YXJuaW5nUmVzdWx0LCBcIk1lc3NhZ2VcIikpIHtcbiAgICAgICAgICBtZXNzYWdlcy5wdXNoKF93YXJuaW5nUmVzdWx0Lk1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgX29iamVjdEtleSBvZiBfd2FybmluZ1Jlc3VsdC5rZXlzKCkpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goW19vYmplY3RLZXksIF93YXJuaW5nUmVzdWx0W19vYmplY3RLZXldXS5qb2luKFwiOiBcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNlcXVlbGl6ZS5sb2cod2FybmluZ01lc3NhZ2UgKyBtZXNzYWdlcy5qb2luKFwiOyBcIiksIHRoaXMub3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgZm9ybWF0RXJyb3IoZXJyLCBlcnJTdGFjaykge1xuICAgIGNvbnN0IGVyckNvZGUgPSBlcnIuZXJybm8gfHwgZXJyLmNvZGU7XG4gICAgc3dpdGNoIChlcnJDb2RlKSB7XG4gICAgICBjYXNlIEVSX0RVUF9FTlRSWToge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9EdXBsaWNhdGUgZW50cnkgJyhbXFxzXFxTXSopJyBmb3Iga2V5ICc/KCgufFxccykqPyknPyQvKTtcbiAgICAgICAgbGV0IGZpZWxkcyA9IHt9O1xuICAgICAgICBsZXQgbWVzc2FnZSA9IFwiVmFsaWRhdGlvbiBlcnJvclwiO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KFwiLVwiKSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgZmllbGRLZXkgPSBtYXRjaCA/IG1hdGNoWzJdLnNwbGl0KFwiLlwiKS5wb3AoKSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgZmllbGRWYWwgPSBtYXRjaCA/IG1hdGNoWzFdIDogdm9pZCAwO1xuICAgICAgICBjb25zdCB1bmlxdWVLZXkgPSB0aGlzLm1vZGVsICYmIHRoaXMubW9kZWwudW5pcXVlS2V5c1tmaWVsZEtleV07XG4gICAgICAgIGlmICh1bmlxdWVLZXkpIHtcbiAgICAgICAgICBpZiAodW5pcXVlS2V5Lm1zZylcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB1bmlxdWVLZXkubXNnO1xuICAgICAgICAgIGZpZWxkcyA9IF8uemlwT2JqZWN0KHVuaXF1ZUtleS5maWVsZHMsIHZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmllbGRzW2ZpZWxkS2V5XSA9IGZpZWxkVmFsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBfLmZvck93bihmaWVsZHMsICh2YWx1ZSwgZmllbGQpID0+IHtcbiAgICAgICAgICBlcnJvcnMucHVzaChuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvckl0ZW0odGhpcy5nZXRVbmlxdWVDb25zdHJhaW50RXJyb3JNZXNzYWdlKGZpZWxkKSwgXCJ1bmlxdWUgdmlvbGF0aW9uXCIsIGZpZWxkLCB2YWx1ZSwgdGhpcy5pbnN0YW5jZSwgXCJub3RfdW5pcXVlXCIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvcih7IG1lc3NhZ2UsIGVycm9ycywgcGFyZW50OiBlcnIsIGZpZWxkcywgc3RhY2s6IGVyclN0YWNrIH0pO1xuICAgICAgfVxuICAgICAgY2FzZSBFUl9ST1dfSVNfUkVGRVJFTkNFRDpcbiAgICAgIGNhc2UgRVJfTk9fUkVGRVJFTkNFRF9ST1c6IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvQ09OU1RSQUlOVCAoW2BcIl0pKC4qKVxcMSBGT1JFSUdOIEtFWSBcXChcXDEoLiopXFwxXFwpIFJFRkVSRU5DRVMgXFwxKC4qKVxcMSBcXChcXDEoLiopXFwxXFwpLyk7XG4gICAgICAgIGNvbnN0IHF1b3RlQ2hhciA9IG1hdGNoID8gbWF0Y2hbMV0gOiBcImBcIjtcbiAgICAgICAgY29uc3QgZmllbGRzID0gbWF0Y2ggPyBtYXRjaFszXS5zcGxpdChuZXcgUmVnRXhwKGAke3F1b3RlQ2hhcn0sICoke3F1b3RlQ2hhcn1gKSkgOiB2b2lkIDA7XG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3Ioe1xuICAgICAgICAgIHJlbHR5cGU6IFN0cmluZyhlcnJDb2RlKSA9PT0gU3RyaW5nKEVSX1JPV19JU19SRUZFUkVOQ0VEKSA/IFwicGFyZW50XCIgOiBcImNoaWxkXCIsXG4gICAgICAgICAgdGFibGU6IG1hdGNoID8gbWF0Y2hbNF0gOiB2b2lkIDAsXG4gICAgICAgICAgZmllbGRzLFxuICAgICAgICAgIHZhbHVlOiBmaWVsZHMgJiYgZmllbGRzLmxlbmd0aCAmJiB0aGlzLmluc3RhbmNlICYmIHRoaXMuaW5zdGFuY2VbZmllbGRzWzBdXSB8fCB2b2lkIDAsXG4gICAgICAgICAgaW5kZXg6IG1hdGNoID8gbWF0Y2hbMl0gOiB2b2lkIDAsXG4gICAgICAgICAgcGFyZW50OiBlcnIsXG4gICAgICAgICAgc3RhY2s6IGVyclN0YWNrXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRGF0YWJhc2VFcnJvcihlcnIsIHsgc3RhY2s6IGVyclN0YWNrIH0pO1xuICAgIH1cbiAgfVxuICBoYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KGRhdGEpIHtcbiAgICBkYXRhID0gZGF0YS5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgICAgaWYgKCEoaXRlbS5LZXlfbmFtZSBpbiBhY2MpKSB7XG4gICAgICAgIGFjY1tpdGVtLktleV9uYW1lXSA9IGl0ZW07XG4gICAgICAgIGl0ZW0uZmllbGRzID0gW107XG4gICAgICB9XG4gICAgICBhY2NbaXRlbS5LZXlfbmFtZV0uZmllbGRzW2l0ZW0uU2VxX2luX2luZGV4IC0gMV0gPSB7XG4gICAgICAgIGF0dHJpYnV0ZTogaXRlbS5Db2x1bW5fbmFtZSxcbiAgICAgICAgbGVuZ3RoOiBpdGVtLlN1Yl9wYXJ0IHx8IHZvaWQgMCxcbiAgICAgICAgb3JkZXI6IGl0ZW0uQ29sbGF0aW9uID09PSBcIkFcIiA/IFwiQVNDXCIgOiB2b2lkIDBcbiAgICAgIH07XG4gICAgICBkZWxldGUgaXRlbS5jb2x1bW5fbmFtZTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBfLm1hcChkYXRhLCAoaXRlbSkgPT4gKHtcbiAgICAgIHByaW1hcnk6IGl0ZW0uS2V5X25hbWUgPT09IFwiUFJJTUFSWVwiLFxuICAgICAgZmllbGRzOiBpdGVtLmZpZWxkcyxcbiAgICAgIG5hbWU6IGl0ZW0uS2V5X25hbWUsXG4gICAgICB0YWJsZU5hbWU6IGl0ZW0uVGFibGUsXG4gICAgICB1bmlxdWU6IGl0ZW0uTm9uX3VuaXF1ZSAhPT0gMSxcbiAgICAgIHR5cGU6IGl0ZW0uSW5kZXhfdHlwZVxuICAgIH0pKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeTtcbm1vZHVsZS5leHBvcnRzLlF1ZXJ5ID0gUXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gUXVlcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/mysql/query.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/oracle/connection-manager.js":
/*!***************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/oracle/connection-manager.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  OracleConnectionManager: () => OracleConnectionManager\n});\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst SequelizeErrors = __webpack_require__(/*! ../../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(action-browser)/../node_modules/sequelize/lib/dialects/parserStore.js\")(\"oracle\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(action-browser)/../node_modules/sequelize/lib/utils/logger.js\");\nconst semver = __webpack_require__(/*! semver */ \"(action-browser)/../node_modules/semver/index.js\");\nconst debug = logger.debugContext(\"connection:oracle\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\").oracle);\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nclass OracleConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n    this.sequelize = sequelize;\n    this.sequelize.config.port = this.sequelize.config.port || 1521;\n    this.lib = this._loadDialectModule(\"oracledb\");\n    this.extendLib();\n    this.refreshTypeParser(DataTypes);\n  }\n  extendLib() {\n    if (this.sequelize.config && \"dialectOptions\" in this.sequelize.config) {\n      const dialectOptions = this.sequelize.config.dialectOptions;\n      if (dialectOptions && \"maxRows\" in dialectOptions) {\n        this.lib.maxRows = this.sequelize.config.dialectOptions.maxRows;\n      }\n      if (dialectOptions && \"fetchAsString\" in dialectOptions) {\n        this.lib.fetchAsString = this.sequelize.config.dialectOptions.fetchAsString;\n      } else {\n        this.lib.fetchAsString = [this.lib.CLOB];\n      }\n    }\n    this.lib.fetchAsBuffer = [this.lib.BLOB];\n  }\n  buildConnectString(config) {\n    if (!config.host || config.host.length === 0)\n      return config.database;\n    let connectString = config.host;\n    if (config.port && config.port > 0) {\n      connectString += `:${config.port}`;\n    } else {\n      connectString += \":1521\";\n    }\n    if (config.database && config.database.length > 0) {\n      connectString += `/${config.database}`;\n    }\n    return connectString;\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  async connect(config) {\n    const connectionConfig = __spreadValues({\n      user: config.username,\n      password: config.password,\n      externalAuth: config.externalAuth,\n      stmtCacheSize: 0,\n      connectString: this.buildConnectString(config)\n    }, config.dialectOptions);\n    try {\n      const connection = await this.lib.getConnection(connectionConfig);\n      this.sequelize.options.databaseVersion = semver.coerce(connection.oracleServerVersionString).version;\n      debug(\"connection acquired\");\n      connection.on(\"error\", (error) => {\n        switch (error.code) {\n          case \"ESOCKET\":\n          case \"ECONNRESET\":\n          case \"EPIPE\":\n          case \"PROTOCOL_CONNECTION_LOST\":\n            this.pool.destroy(connection);\n        }\n      });\n      return connection;\n    } catch (err) {\n      let errorCode = err.message.split(\":\");\n      errorCode = errorCode[0];\n      switch (errorCode) {\n        case \"ORA-12560\":\n        case \"ORA-12154\":\n        case \"ORA-12505\":\n        case \"ORA-12514\":\n        case \"NJS-511\":\n        case \"NJS-516\":\n        case \"NJS-517\":\n        case \"NJS-520\":\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case \"ORA-28000\":\n        case \"ORA-28040\":\n        case \"ORA-01017\":\n        case \"NJS-506\":\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case \"ORA-12541\":\n        case \"NJS-503\":\n        case \"NJS-508\":\n        case \"NJS-507\":\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case \"NJS-512\":\n        case \"NJS-515\":\n        case \"NJS-518\":\n        case \"NJS-519\":\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        case \"ORA-12170\":\n        case \"NJS-510\":\n          throw new SequelizeErrors.ConnectionTimedOutError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n  async disconnect(connection) {\n    if (!connection.isHealthy()) {\n      debug(\"connection tried to disconnect but was already at CLOSED state\");\n      return;\n    }\n    return await promisify((callback) => connection.close(callback))();\n  }\n  validate(connection) {\n    return connection && connection.isHealthy();\n  }\n}\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvY29ubmVjdGlvbi1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtDQUFrQyxtQkFBTyxDQUFDLDhIQUFnQztBQUMxRSx3QkFBd0IsbUJBQU8sQ0FBQyxvRkFBYztBQUM5QyxvQkFBb0IsbUJBQU8sQ0FBQyw4RkFBZ0I7QUFDNUMsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQywwRkFBb0I7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLGdFQUFRO0FBQy9CO0FBQ0Esa0JBQWtCLG9IQUFrQztBQUNwRCxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvY29ubmVjdGlvbi1tYW5hZ2VyLmpzP2FlYmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgT3JhY2xlQ29ubmVjdGlvbk1hbmFnZXI6ICgpID0+IE9yYWNsZUNvbm5lY3Rpb25NYW5hZ2VyXG59KTtcbmNvbnN0IEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvY29ubmVjdGlvbi1tYW5hZ2VyXCIpO1xuY29uc3QgU2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc1wiKTtcbmNvbnN0IHBhcnNlclN0b3JlID0gcmVxdWlyZShcIi4uL3BhcnNlclN0b3JlXCIpKFwib3JhY2xlXCIpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9sb2dnZXJcIik7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KFwiY29ubmVjdGlvbjpvcmFjbGVcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKS5vcmFjbGU7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZShcInV0aWxcIik7XG5jbGFzcyBPcmFjbGVDb25uZWN0aW9uTWFuYWdlciBleHRlbmRzIEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihkaWFsZWN0LCBzZXF1ZWxpemUpIHtcbiAgICBzdXBlcihkaWFsZWN0LCBzZXF1ZWxpemUpO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMuc2VxdWVsaXplLmNvbmZpZy5wb3J0ID0gdGhpcy5zZXF1ZWxpemUuY29uZmlnLnBvcnQgfHwgMTUyMTtcbiAgICB0aGlzLmxpYiA9IHRoaXMuX2xvYWREaWFsZWN0TW9kdWxlKFwib3JhY2xlZGJcIik7XG4gICAgdGhpcy5leHRlbmRMaWIoKTtcbiAgICB0aGlzLnJlZnJlc2hUeXBlUGFyc2VyKERhdGFUeXBlcyk7XG4gIH1cbiAgZXh0ZW5kTGliKCkge1xuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5jb25maWcgJiYgXCJkaWFsZWN0T3B0aW9uc1wiIGluIHRoaXMuc2VxdWVsaXplLmNvbmZpZykge1xuICAgICAgY29uc3QgZGlhbGVjdE9wdGlvbnMgPSB0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGlhbGVjdE9wdGlvbnM7XG4gICAgICBpZiAoZGlhbGVjdE9wdGlvbnMgJiYgXCJtYXhSb3dzXCIgaW4gZGlhbGVjdE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5saWIubWF4Um93cyA9IHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kaWFsZWN0T3B0aW9ucy5tYXhSb3dzO1xuICAgICAgfVxuICAgICAgaWYgKGRpYWxlY3RPcHRpb25zICYmIFwiZmV0Y2hBc1N0cmluZ1wiIGluIGRpYWxlY3RPcHRpb25zKSB7XG4gICAgICAgIHRoaXMubGliLmZldGNoQXNTdHJpbmcgPSB0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGlhbGVjdE9wdGlvbnMuZmV0Y2hBc1N0cmluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGliLmZldGNoQXNTdHJpbmcgPSBbdGhpcy5saWIuQ0xPQl07XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGliLmZldGNoQXNCdWZmZXIgPSBbdGhpcy5saWIuQkxPQl07XG4gIH1cbiAgYnVpbGRDb25uZWN0U3RyaW5nKGNvbmZpZykge1xuICAgIGlmICghY29uZmlnLmhvc3QgfHwgY29uZmlnLmhvc3QubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIGNvbmZpZy5kYXRhYmFzZTtcbiAgICBsZXQgY29ubmVjdFN0cmluZyA9IGNvbmZpZy5ob3N0O1xuICAgIGlmIChjb25maWcucG9ydCAmJiBjb25maWcucG9ydCA+IDApIHtcbiAgICAgIGNvbm5lY3RTdHJpbmcgKz0gYDoke2NvbmZpZy5wb3J0fWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbm5lY3RTdHJpbmcgKz0gXCI6MTUyMVwiO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmRhdGFiYXNlICYmIGNvbmZpZy5kYXRhYmFzZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25uZWN0U3RyaW5nICs9IGAvJHtjb25maWcuZGF0YWJhc2V9YDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbm5lY3RTdHJpbmc7XG4gIH1cbiAgX3JlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlKSB7XG4gICAgcGFyc2VyU3RvcmUucmVmcmVzaChkYXRhVHlwZSk7XG4gIH1cbiAgX2NsZWFyVHlwZVBhcnNlcigpIHtcbiAgICBwYXJzZXJTdG9yZS5jbGVhcigpO1xuICB9XG4gIGFzeW5jIGNvbm5lY3QoY29uZmlnKSB7XG4gICAgY29uc3QgY29ubmVjdGlvbkNvbmZpZyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIHVzZXI6IGNvbmZpZy51c2VybmFtZSxcbiAgICAgIHBhc3N3b3JkOiBjb25maWcucGFzc3dvcmQsXG4gICAgICBleHRlcm5hbEF1dGg6IGNvbmZpZy5leHRlcm5hbEF1dGgsXG4gICAgICBzdG10Q2FjaGVTaXplOiAwLFxuICAgICAgY29ubmVjdFN0cmluZzogdGhpcy5idWlsZENvbm5lY3RTdHJpbmcoY29uZmlnKVxuICAgIH0sIGNvbmZpZy5kaWFsZWN0T3B0aW9ucyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCB0aGlzLmxpYi5nZXRDb25uZWN0aW9uKGNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24gPSBzZW12ZXIuY29lcmNlKGNvbm5lY3Rpb24ub3JhY2xlU2VydmVyVmVyc2lvblN0cmluZykudmVyc2lvbjtcbiAgICAgIGRlYnVnKFwiY29ubmVjdGlvbiBhY3F1aXJlZFwiKTtcbiAgICAgIGNvbm5lY3Rpb24ub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHtcbiAgICAgICAgc3dpdGNoIChlcnJvci5jb2RlKSB7XG4gICAgICAgICAgY2FzZSBcIkVTT0NLRVRcIjpcbiAgICAgICAgICBjYXNlIFwiRUNPTk5SRVNFVFwiOlxuICAgICAgICAgIGNhc2UgXCJFUElQRVwiOlxuICAgICAgICAgIGNhc2UgXCJQUk9UT0NPTF9DT05ORUNUSU9OX0xPU1RcIjpcbiAgICAgICAgICAgIHRoaXMucG9vbC5kZXN0cm95KGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbGV0IGVycm9yQ29kZSA9IGVyci5tZXNzYWdlLnNwbGl0KFwiOlwiKTtcbiAgICAgIGVycm9yQ29kZSA9IGVycm9yQ29kZVswXTtcbiAgICAgIHN3aXRjaCAoZXJyb3JDb2RlKSB7XG4gICAgICAgIGNhc2UgXCJPUkEtMTI1NjBcIjpcbiAgICAgICAgY2FzZSBcIk9SQS0xMjE1NFwiOlxuICAgICAgICBjYXNlIFwiT1JBLTEyNTA1XCI6XG4gICAgICAgIGNhc2UgXCJPUkEtMTI1MTRcIjpcbiAgICAgICAgY2FzZSBcIk5KUy01MTFcIjpcbiAgICAgICAgY2FzZSBcIk5KUy01MTZcIjpcbiAgICAgICAgY2FzZSBcIk5KUy01MTdcIjpcbiAgICAgICAgY2FzZSBcIk5KUy01MjBcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25SZWZ1c2VkRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSBcIk9SQS0yODAwMFwiOlxuICAgICAgICBjYXNlIFwiT1JBLTI4MDQwXCI6XG4gICAgICAgIGNhc2UgXCJPUkEtMDEwMTdcIjpcbiAgICAgICAgY2FzZSBcIk5KUy01MDZcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkFjY2Vzc0RlbmllZEVycm9yKGVycik7XG4gICAgICAgIGNhc2UgXCJPUkEtMTI1NDFcIjpcbiAgICAgICAgY2FzZSBcIk5KUy01MDNcIjpcbiAgICAgICAgY2FzZSBcIk5KUy01MDhcIjpcbiAgICAgICAgY2FzZSBcIk5KUy01MDdcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkhvc3ROb3RSZWFjaGFibGVFcnJvcihlcnIpO1xuICAgICAgICBjYXNlIFwiTkpTLTUxMlwiOlxuICAgICAgICBjYXNlIFwiTkpTLTUxNVwiOlxuICAgICAgICBjYXNlIFwiTkpTLTUxOFwiOlxuICAgICAgICBjYXNlIFwiTkpTLTUxOVwiOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuSW52YWxpZENvbm5lY3Rpb25FcnJvcihlcnIpO1xuICAgICAgICBjYXNlIFwiT1JBLTEyMTcwXCI6XG4gICAgICAgIGNhc2UgXCJOSlMtNTEwXCI6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uVGltZWRPdXRFcnJvcihlcnIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvbkVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGRpc2Nvbm5lY3QoY29ubmVjdGlvbikge1xuICAgIGlmICghY29ubmVjdGlvbi5pc0hlYWx0aHkoKSkge1xuICAgICAgZGVidWcoXCJjb25uZWN0aW9uIHRyaWVkIHRvIGRpc2Nvbm5lY3QgYnV0IHdhcyBhbHJlYWR5IGF0IENMT1NFRCBzdGF0ZVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHByb21pc2lmeSgoY2FsbGJhY2spID0+IGNvbm5lY3Rpb24uY2xvc2UoY2FsbGJhY2spKSgpO1xuICB9XG4gIHZhbGlkYXRlKGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gY29ubmVjdGlvbiAmJiBjb25uZWN0aW9uLmlzSGVhbHRoeSgpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aW9uLW1hbmFnZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/oracle/connection-manager.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/oracle/data-types.js":
/*!*******************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/oracle/data-types.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst moment = __webpack_require__(/*! moment */ \"(action-browser)/../node_modules/moment/moment.js\");\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(action-browser)/../node_modules/moment-timezone/index.js\");\nmodule.exports = (BaseTypes) => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-D424D23B-0933-425F-BC69-9C0E6724693C\");\n  BaseTypes.DATE.types.oracle = [\"TIMESTAMP\", \"TIMESTAMP WITH LOCAL TIME ZONE\"];\n  BaseTypes.STRING.types.oracle = [\"VARCHAR2\", \"NVARCHAR2\"];\n  BaseTypes.CHAR.types.oracle = [\"CHAR\", \"RAW\"];\n  BaseTypes.TEXT.types.oracle = [\"CLOB\"];\n  BaseTypes.TINYINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.SMALLINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.MEDIUMINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.INTEGER.types.oracle = [\"INTEGER\"];\n  BaseTypes.BIGINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.FLOAT.types.oracle = [\"BINARY_FLOAT\"];\n  BaseTypes.DATEONLY.types.oracle = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.oracle = [\"CHAR(1)\"];\n  BaseTypes.BLOB.types.oracle = [\"BLOB\"];\n  BaseTypes.DECIMAL.types.oracle = [\"NUMBER\"];\n  BaseTypes.UUID.types.oracle = [\"VARCHAR2\"];\n  BaseTypes.ENUM.types.oracle = [\"VARCHAR2\"];\n  BaseTypes.REAL.types.oracle = [\"BINARY_DOUBLE\"];\n  BaseTypes.DOUBLE.types.oracle = [\"BINARY_DOUBLE\"];\n  BaseTypes.JSON.types.oracle = [\"BLOB\"];\n  BaseTypes.GEOMETRY.types.oracle = false;\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this.length > 4e3 || this._binary && this._length > 2e3) {\n        warn(\"Oracle supports length up to 32764 bytes or characters; Be sure that your administrator has extended the MAX_STRING_SIZE parameter. Check https://docs.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-7B72E154-677A-4342-A1EA-C74C1EA928E6\");\n      }\n      if (!this._binary) {\n        return `NVARCHAR2(${this._length})`;\n      }\n      return `RAW(${this._length})`;\n    }\n    _stringify(value, options) {\n      if (this._binary) {\n        return options.escape(value.toString(\"hex\"));\n      }\n      return options.escape(value);\n    }\n    _getBindDef(oracledb) {\n      if (this._binary) {\n        return { type: oracledb.DB_TYPE_RAW, maxSize: this._length };\n      }\n      return { type: oracledb.DB_TYPE_VARCHAR, maxSize: this._length };\n    }\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n  STRING.prototype.escape = false;\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"CHAR(1)\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_CHAR, maxSize: 1 };\n    }\n    _stringify(value) {\n      return value === true ? \"1\" : value === false ? \"0\" : value;\n    }\n    _sanitize(value) {\n      if (typeof value === \"string\") {\n        return value === \"1\" || value === \"true\" ? true : value === \"0\" || value === \"false\" ? false : value;\n      }\n      return super._sanitize(value);\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"VARCHAR2(36)\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_VARCHAR, maxSize: 36 };\n    }\n  }\n  class NOW extends BaseTypes.NOW {\n    toSql() {\n      return \"SYSDATE\";\n    }\n    _stringify() {\n      return \"SYSDATE\";\n    }\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return \"VARCHAR2(512)\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_VARCHAR, maxSize: 512 };\n    }\n  }\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      return \"CLOB\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_CLOB };\n    }\n  }\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        warn(\"Oracle CHAR.BINARY datatype is not of Fixed Length.\");\n        return `RAW(${this._length})`;\n      }\n      return super.toSql();\n    }\n    _getBindDef(oracledb) {\n      if (this._binary) {\n        return { type: oracledb.DB_TYPE_RAW, maxSize: this._length };\n      }\n      return { type: oracledb.DB_TYPE_CHAR, maxSize: this._length };\n    }\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return \"TIMESTAMP WITH LOCAL TIME ZONE\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_TIMESTAMP_LTZ };\n    }\n    _stringify(date, options) {\n      const format = \"YYYY-MM-DD HH24:MI:SS.FFTZH:TZM\";\n      date = this._applyTimezone(date, options);\n      const formatedDate = date.format(\"YYYY-MM-DD HH:mm:ss.SSS Z\");\n      return `TO_TIMESTAMP_TZ('${formatedDate}','${format}')`;\n    }\n    _applyTimezone(date, options) {\n      if (options.timezone) {\n        if (momentTz.tz.zone(options.timezone)) {\n          date = momentTz(date).tz(options.timezone);\n        } else {\n          date = moment(date).utcOffset(options.timezone);\n        }\n      } else {\n        date = momentTz(date);\n      }\n      return date;\n    }\n    static parse(value, options) {\n      if (value === null) {\n        return value;\n      }\n      if (options && moment.tz.zone(options.timezone)) {\n        value = moment.tz(value.toString(), options.timezone).toDate();\n      }\n      return value;\n    }\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n  DATE.prototype.escape = false;\n  class DECIMAL extends BaseTypes.DECIMAL {\n    toSql() {\n      let result = \"\";\n      if (this._length) {\n        result += `(${this._length}`;\n        if (typeof this._decimals === \"number\") {\n          result += `,${this._decimals}`;\n        }\n        result += \")\";\n      }\n      if (!this._length && this._precision) {\n        result += `(${this._precision}`;\n        if (typeof this._scale === \"number\") {\n          result += `,${this._scale}`;\n        }\n        result += \")\";\n      }\n      return `NUMBER${result}`;\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n  class TINYINT extends BaseTypes.TINYINT {\n    toSql() {\n      return \"NUMBER(3)\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n  class SMALLINT extends BaseTypes.SMALLINT {\n    toSql() {\n      if (this._length) {\n        return `NUMBER(${this._length},0)`;\n      }\n      return \"SMALLINT\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n  class MEDIUMINT extends BaseTypes.MEDIUMINT {\n    toSql() {\n      return \"NUMBER(8)\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      if (!(this instanceof BIGINT))\n        return new BIGINT(length);\n      BaseTypes.BIGINT.apply(this, arguments);\n      if (this._length || this.options.length || this._unsigned || this._zerofill) {\n        warn(\"Oracle does not support BIGINT with options\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n    }\n    toSql() {\n      return \"NUMBER(19)\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n    _sanitize(value) {\n      if (typeof value === \"bigint\" || typeof value === \"number\") {\n        return value.toString();\n      }\n      return value;\n    }\n  }\n  class NUMBER extends BaseTypes.NUMBER {\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n  class INTEGER extends BaseTypes.INTEGER {\n    toSql() {\n      if (this._length) {\n        return `NUMBER(${this._length},0)`;\n      }\n      return \"INTEGER\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n  class FLOAT extends BaseTypes.FLOAT {\n    toSql() {\n      return \"BINARY_FLOAT\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BINARY_FLOAT };\n    }\n  }\n  class REAL extends BaseTypes.REAL {\n    toSql() {\n      return \"BINARY_DOUBLE\";\n    }\n    _stringify(value) {\n      if (value === Number.POSITIVE_INFINITY) {\n        return \"inf\";\n      }\n      if (value === Number.NEGATIVE_INFINITY) {\n        return \"-inf\";\n      }\n      return value;\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BINARY_DOUBLE };\n    }\n  }\n  class BLOB extends BaseTypes.BLOB {\n    _hexify(hex) {\n      return `'${hex}'`;\n    }\n    toSql() {\n      return \"BLOB\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BLOB };\n    }\n  }\n  class JSONTYPE extends BaseTypes.JSON {\n    toSql() {\n      return \"BLOB\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BLOB };\n    }\n    _stringify(value, options) {\n      return options.operation === \"where\" && typeof value === \"string\" ? value : JSON.stringify(value);\n    }\n    _bindParam(value, options) {\n      return options.bindParam(Buffer.from(JSON.stringify(value)));\n    }\n  }\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (!(this instanceof DOUBLE))\n        return new BaseTypes.DOUBLE(length, decimals);\n      BaseTypes.DOUBLE.apply(this, arguments);\n      if (this._length || this._unsigned || this._zerofill) {\n        warn(\"Oracle does not support DOUBLE with options.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n      this.key = \"DOUBLE PRECISION\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BINARY_DOUBLE };\n    }\n    toSql() {\n      return \"BINARY_DOUBLE\";\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    parse(value) {\n      return moment(value).format(\"YYYY-MM-DD\");\n    }\n    _sanitize(value) {\n      if (value) {\n        return moment(value).format(\"YYYY-MM-DD\");\n      }\n      return value;\n    }\n    _stringify(date, options) {\n      if (date) {\n        const format = \"YYYY/MM/DD\";\n        return options.escape(`TO_DATE('${date}','${format}')`);\n      }\n      return options.escape(date);\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_DATE };\n    }\n    _bindParam(value, options) {\n      if (typeof value === \"string\") {\n        return options.bindParam(new Date(value));\n      }\n      return options.bindParam(value);\n    }\n  }\n  DATEONLY.prototype.escape = false;\n  return {\n    BOOLEAN,\n    \"DOUBLE PRECISION\": DOUBLE,\n    DOUBLE,\n    STRING,\n    TINYINT,\n    SMALLINT,\n    MEDIUMINT,\n    BIGINT,\n    NUMBER,\n    INTEGER,\n    FLOAT,\n    UUID,\n    DATEONLY,\n    DATE,\n    NOW,\n    BLOB,\n    ENUM,\n    TEXT,\n    CHAR,\n    JSON: JSONTYPE,\n    REAL,\n    DECIMAL\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvZGF0YS10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGVBQWUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyxrRkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhLEtBQUssT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEtBQUssS0FBSyxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvb3JhY2xlL2RhdGEtdHlwZXMuanM/NTdjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IG1vbWVudCA9IHJlcXVpcmUoXCJtb21lbnRcIik7XG5jb25zdCBtb21lbnRUeiA9IHJlcXVpcmUoXCJtb21lbnQtdGltZXpvbmVcIik7XG5tb2R1bGUuZXhwb3J0cyA9IChCYXNlVHlwZXMpID0+IHtcbiAgY29uc3Qgd2FybiA9IEJhc2VUeXBlcy5BQlNUUkFDVC53YXJuLmJpbmQodm9pZCAwLCBcImh0dHBzOi8vd3d3Lm9yYWNsZS5jb20vcGxzL3RvcGljL2xvb2t1cD9jdHg9ZGJsYXRlc3QmaWQ9R1VJRC1ENDI0RDIzQi0wOTMzLTQyNUYtQkM2OS05QzBFNjcyNDY5M0NcIik7XG4gIEJhc2VUeXBlcy5EQVRFLnR5cGVzLm9yYWNsZSA9IFtcIlRJTUVTVEFNUFwiLCBcIlRJTUVTVEFNUCBXSVRIIExPQ0FMIFRJTUUgWk9ORVwiXTtcbiAgQmFzZVR5cGVzLlNUUklORy50eXBlcy5vcmFjbGUgPSBbXCJWQVJDSEFSMlwiLCBcIk5WQVJDSEFSMlwiXTtcbiAgQmFzZVR5cGVzLkNIQVIudHlwZXMub3JhY2xlID0gW1wiQ0hBUlwiLCBcIlJBV1wiXTtcbiAgQmFzZVR5cGVzLlRFWFQudHlwZXMub3JhY2xlID0gW1wiQ0xPQlwiXTtcbiAgQmFzZVR5cGVzLlRJTllJTlQudHlwZXMub3JhY2xlID0gW1wiTlVNQkVSXCJdO1xuICBCYXNlVHlwZXMuU01BTExJTlQudHlwZXMub3JhY2xlID0gW1wiTlVNQkVSXCJdO1xuICBCYXNlVHlwZXMuTUVESVVNSU5ULnR5cGVzLm9yYWNsZSA9IFtcIk5VTUJFUlwiXTtcbiAgQmFzZVR5cGVzLklOVEVHRVIudHlwZXMub3JhY2xlID0gW1wiSU5URUdFUlwiXTtcbiAgQmFzZVR5cGVzLkJJR0lOVC50eXBlcy5vcmFjbGUgPSBbXCJOVU1CRVJcIl07XG4gIEJhc2VUeXBlcy5GTE9BVC50eXBlcy5vcmFjbGUgPSBbXCJCSU5BUllfRkxPQVRcIl07XG4gIEJhc2VUeXBlcy5EQVRFT05MWS50eXBlcy5vcmFjbGUgPSBbXCJEQVRFXCJdO1xuICBCYXNlVHlwZXMuQk9PTEVBTi50eXBlcy5vcmFjbGUgPSBbXCJDSEFSKDEpXCJdO1xuICBCYXNlVHlwZXMuQkxPQi50eXBlcy5vcmFjbGUgPSBbXCJCTE9CXCJdO1xuICBCYXNlVHlwZXMuREVDSU1BTC50eXBlcy5vcmFjbGUgPSBbXCJOVU1CRVJcIl07XG4gIEJhc2VUeXBlcy5VVUlELnR5cGVzLm9yYWNsZSA9IFtcIlZBUkNIQVIyXCJdO1xuICBCYXNlVHlwZXMuRU5VTS50eXBlcy5vcmFjbGUgPSBbXCJWQVJDSEFSMlwiXTtcbiAgQmFzZVR5cGVzLlJFQUwudHlwZXMub3JhY2xlID0gW1wiQklOQVJZX0RPVUJMRVwiXTtcbiAgQmFzZVR5cGVzLkRPVUJMRS50eXBlcy5vcmFjbGUgPSBbXCJCSU5BUllfRE9VQkxFXCJdO1xuICBCYXNlVHlwZXMuSlNPTi50eXBlcy5vcmFjbGUgPSBbXCJCTE9CXCJdO1xuICBCYXNlVHlwZXMuR0VPTUVUUlkudHlwZXMub3JhY2xlID0gZmFsc2U7XG4gIGNsYXNzIFNUUklORyBleHRlbmRzIEJhc2VUeXBlcy5TVFJJTkcge1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gNGUzIHx8IHRoaXMuX2JpbmFyeSAmJiB0aGlzLl9sZW5ndGggPiAyZTMpIHtcbiAgICAgICAgd2FybihcIk9yYWNsZSBzdXBwb3J0cyBsZW5ndGggdXAgdG8gMzI3NjQgYnl0ZXMgb3IgY2hhcmFjdGVyczsgQmUgc3VyZSB0aGF0IHlvdXIgYWRtaW5pc3RyYXRvciBoYXMgZXh0ZW5kZWQgdGhlIE1BWF9TVFJJTkdfU0laRSBwYXJhbWV0ZXIuIENoZWNrIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL3Bscy90b3BpYy9sb29rdXA/Y3R4PWRibGF0ZXN0JmlkPUdVSUQtN0I3MkUxNTQtNjc3QS00MzQyLUExRUEtQzc0QzFFQTkyOEU2XCIpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9iaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIGBOVkFSQ0hBUjIoJHt0aGlzLl9sZW5ndGh9KWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYFJBVygke3RoaXMuX2xlbmd0aH0pYDtcbiAgICB9XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuX2JpbmFyeSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5lc2NhcGUodmFsdWUudG9TdHJpbmcoXCJoZXhcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMuZXNjYXBlKHZhbHVlKTtcbiAgICB9XG4gICAgX2dldEJpbmREZWYob3JhY2xlZGIpIHtcbiAgICAgIGlmICh0aGlzLl9iaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9SQVcsIG1heFNpemU6IHRoaXMuX2xlbmd0aCB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9WQVJDSEFSLCBtYXhTaXplOiB0aGlzLl9sZW5ndGggfTtcbiAgICB9XG4gICAgX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuYmluZFBhcmFtKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgU1RSSU5HLnByb3RvdHlwZS5lc2NhcGUgPSBmYWxzZTtcbiAgY2xhc3MgQk9PTEVBTiBleHRlbmRzIEJhc2VUeXBlcy5CT09MRUFOIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIkNIQVIoMSlcIjtcbiAgICB9XG4gICAgX2dldEJpbmREZWYob3JhY2xlZGIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfQ0hBUiwgbWF4U2l6ZTogMSB9O1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgPyBcIjFcIiA6IHZhbHVlID09PSBmYWxzZSA/IFwiMFwiIDogdmFsdWU7XG4gICAgfVxuICAgIF9zYW5pdGl6ZSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IFwiMVwiIHx8IHZhbHVlID09PSBcInRydWVcIiA/IHRydWUgOiB2YWx1ZSA9PT0gXCIwXCIgfHwgdmFsdWUgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDogdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwZXIuX3Nhbml0aXplKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgVVVJRCBleHRlbmRzIEJhc2VUeXBlcy5VVUlEIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIlZBUkNIQVIyKDM2KVwiO1xuICAgIH1cbiAgICBfZ2V0QmluZERlZihvcmFjbGVkYikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9WQVJDSEFSLCBtYXhTaXplOiAzNiB9O1xuICAgIH1cbiAgfVxuICBjbGFzcyBOT1cgZXh0ZW5kcyBCYXNlVHlwZXMuTk9XIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIlNZU0RBVEVcIjtcbiAgICB9XG4gICAgX3N0cmluZ2lmeSgpIHtcbiAgICAgIHJldHVybiBcIlNZU0RBVEVcIjtcbiAgICB9XG4gIH1cbiAgY2xhc3MgRU5VTSBleHRlbmRzIEJhc2VUeXBlcy5FTlVNIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIlZBUkNIQVIyKDUxMilcIjtcbiAgICB9XG4gICAgX2dldEJpbmREZWYob3JhY2xlZGIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfVkFSQ0hBUiwgbWF4U2l6ZTogNTEyIH07XG4gICAgfVxuICB9XG4gIGNsYXNzIFRFWFQgZXh0ZW5kcyBCYXNlVHlwZXMuVEVYVCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJDTE9CXCI7XG4gICAgfVxuICAgIF9nZXRCaW5kRGVmKG9yYWNsZWRiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX0NMT0IgfTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgQ0hBUiBleHRlbmRzIEJhc2VUeXBlcy5DSEFSIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9iaW5hcnkpIHtcbiAgICAgICAgd2FybihcIk9yYWNsZSBDSEFSLkJJTkFSWSBkYXRhdHlwZSBpcyBub3Qgb2YgRml4ZWQgTGVuZ3RoLlwiKTtcbiAgICAgICAgcmV0dXJuIGBSQVcoJHt0aGlzLl9sZW5ndGh9KWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwZXIudG9TcWwoKTtcbiAgICB9XG4gICAgX2dldEJpbmREZWYob3JhY2xlZGIpIHtcbiAgICAgIGlmICh0aGlzLl9iaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9SQVcsIG1heFNpemU6IHRoaXMuX2xlbmd0aCB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9DSEFSLCBtYXhTaXplOiB0aGlzLl9sZW5ndGggfTtcbiAgICB9XG4gICAgX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuYmluZFBhcmFtKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgREFURSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIlRJTUVTVEFNUCBXSVRIIExPQ0FMIFRJTUUgWk9ORVwiO1xuICAgIH1cbiAgICBfZ2V0QmluZERlZihvcmFjbGVkYikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9USU1FU1RBTVBfTFRaIH07XG4gICAgfVxuICAgIF9zdHJpbmdpZnkoZGF0ZSwgb3B0aW9ucykge1xuICAgICAgY29uc3QgZm9ybWF0ID0gXCJZWVlZLU1NLUREIEhIMjQ6TUk6U1MuRkZUWkg6VFpNXCI7XG4gICAgICBkYXRlID0gdGhpcy5fYXBwbHlUaW1lem9uZShkYXRlLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IGZvcm1hdGVkRGF0ZSA9IGRhdGUuZm9ybWF0KFwiWVlZWS1NTS1ERCBISDptbTpzcy5TU1MgWlwiKTtcbiAgICAgIHJldHVybiBgVE9fVElNRVNUQU1QX1RaKCcke2Zvcm1hdGVkRGF0ZX0nLCcke2Zvcm1hdH0nKWA7XG4gICAgfVxuICAgIF9hcHBseVRpbWV6b25lKGRhdGUsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLnRpbWV6b25lKSB7XG4gICAgICAgIGlmIChtb21lbnRUei50ei56b25lKG9wdGlvbnMudGltZXpvbmUpKSB7XG4gICAgICAgICAgZGF0ZSA9IG1vbWVudFR6KGRhdGUpLnR6KG9wdGlvbnMudGltZXpvbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGUgPSBtb21lbnQoZGF0ZSkudXRjT2Zmc2V0KG9wdGlvbnMudGltZXpvbmUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlID0gbW9tZW50VHooZGF0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgJiYgbW9tZW50LnR6LnpvbmUob3B0aW9ucy50aW1lem9uZSkpIHtcbiAgICAgICAgdmFsdWUgPSBtb21lbnQudHoodmFsdWUudG9TdHJpbmcoKSwgb3B0aW9ucy50aW1lem9uZSkudG9EYXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIF9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmJpbmRQYXJhbSh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIERBVEUucHJvdG90eXBlLmVzY2FwZSA9IGZhbHNlO1xuICBjbGFzcyBERUNJTUFMIGV4dGVuZHMgQmFzZVR5cGVzLkRFQ0lNQUwge1xuICAgIHRvU3FsKCkge1xuICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCArPSBgKCR7dGhpcy5fbGVuZ3RofWA7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fZGVjaW1hbHMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICByZXN1bHQgKz0gYCwke3RoaXMuX2RlY2ltYWxzfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IFwiKVwiO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9sZW5ndGggJiYgdGhpcy5fcHJlY2lzaW9uKSB7XG4gICAgICAgIHJlc3VsdCArPSBgKCR7dGhpcy5fcHJlY2lzaW9ufWA7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fc2NhbGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICByZXN1bHQgKz0gYCwke3RoaXMuX3NjYWxlfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IFwiKVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGBOVU1CRVIke3Jlc3VsdH1gO1xuICAgIH1cbiAgICBfZ2V0QmluZERlZihvcmFjbGVkYikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9OVU1CRVIgfTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgVElOWUlOVCBleHRlbmRzIEJhc2VUeXBlcy5USU5ZSU5UIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIk5VTUJFUigzKVwiO1xuICAgIH1cbiAgICBfZ2V0QmluZERlZihvcmFjbGVkYikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9OVU1CRVIgfTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgU01BTExJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuU01BTExJTlQge1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICByZXR1cm4gYE5VTUJFUigke3RoaXMuX2xlbmd0aH0sMClgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiU01BTExJTlRcIjtcbiAgICB9XG4gICAgX2dldEJpbmREZWYob3JhY2xlZGIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfTlVNQkVSIH07XG4gICAgfVxuICB9XG4gIGNsYXNzIE1FRElVTUlOVCBleHRlbmRzIEJhc2VUeXBlcy5NRURJVU1JTlQge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiTlVNQkVSKDgpXCI7XG4gICAgfVxuICAgIF9nZXRCaW5kRGVmKG9yYWNsZWRiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX05VTUJFUiB9O1xuICAgIH1cbiAgfVxuICBjbGFzcyBCSUdJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuQklHSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQklHSU5UKSlcbiAgICAgICAgcmV0dXJuIG5ldyBCSUdJTlQobGVuZ3RoKTtcbiAgICAgIEJhc2VUeXBlcy5CSUdJTlQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGggfHwgdGhpcy5vcHRpb25zLmxlbmd0aCB8fCB0aGlzLl91bnNpZ25lZCB8fCB0aGlzLl96ZXJvZmlsbCkge1xuICAgICAgICB3YXJuKFwiT3JhY2xlIGRvZXMgbm90IHN1cHBvcnQgQklHSU5UIHdpdGggb3B0aW9uc1wiKTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm9wdGlvbnMubGVuZ3RoID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl91bnNpZ25lZCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5femVyb2ZpbGwgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiTlVNQkVSKDE5KVwiO1xuICAgIH1cbiAgICBfZ2V0QmluZERlZihvcmFjbGVkYikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9OVU1CRVIgfTtcbiAgICB9XG4gICAgX3Nhbml0aXplKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgTlVNQkVSIGV4dGVuZHMgQmFzZVR5cGVzLk5VTUJFUiB7XG4gICAgX2dldEJpbmREZWYob3JhY2xlZGIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfTlVNQkVSIH07XG4gICAgfVxuICB9XG4gIGNsYXNzIElOVEVHRVIgZXh0ZW5kcyBCYXNlVHlwZXMuSU5URUdFUiB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBgTlVNQkVSKCR7dGhpcy5fbGVuZ3RofSwwKWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJJTlRFR0VSXCI7XG4gICAgfVxuICAgIF9nZXRCaW5kRGVmKG9yYWNsZWRiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX05VTUJFUiB9O1xuICAgIH1cbiAgfVxuICBjbGFzcyBGTE9BVCBleHRlbmRzIEJhc2VUeXBlcy5GTE9BVCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJCSU5BUllfRkxPQVRcIjtcbiAgICB9XG4gICAgX2dldEJpbmREZWYob3JhY2xlZGIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfQklOQVJZX0ZMT0FUIH07XG4gICAgfVxuICB9XG4gIGNsYXNzIFJFQUwgZXh0ZW5kcyBCYXNlVHlwZXMuUkVBTCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJCSU5BUllfRE9VQkxFXCI7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICAgIHJldHVybiBcImluZlwiO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgcmV0dXJuIFwiLWluZlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBfZ2V0QmluZERlZihvcmFjbGVkYikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9CSU5BUllfRE9VQkxFIH07XG4gICAgfVxuICB9XG4gIGNsYXNzIEJMT0IgZXh0ZW5kcyBCYXNlVHlwZXMuQkxPQiB7XG4gICAgX2hleGlmeShoZXgpIHtcbiAgICAgIHJldHVybiBgJyR7aGV4fSdgO1xuICAgIH1cbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIkJMT0JcIjtcbiAgICB9XG4gICAgX2dldEJpbmREZWYob3JhY2xlZGIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfQkxPQiB9O1xuICAgIH1cbiAgfVxuICBjbGFzcyBKU09OVFlQRSBleHRlbmRzIEJhc2VUeXBlcy5KU09OIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIkJMT0JcIjtcbiAgICB9XG4gICAgX2dldEJpbmREZWYob3JhY2xlZGIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfQkxPQiB9O1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5vcGVyYXRpb24gPT09IFwid2hlcmVcIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuYmluZFBhcmFtKEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KHZhbHVlKSkpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBET1VCTEUgZXh0ZW5kcyBCYXNlVHlwZXMuRE9VQkxFIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGRlY2ltYWxzKSB7XG4gICAgICBzdXBlcihsZW5ndGgsIGRlY2ltYWxzKTtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBET1VCTEUpKVxuICAgICAgICByZXR1cm4gbmV3IEJhc2VUeXBlcy5ET1VCTEUobGVuZ3RoLCBkZWNpbWFscyk7XG4gICAgICBCYXNlVHlwZXMuRE9VQkxFLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoIHx8IHRoaXMuX3Vuc2lnbmVkIHx8IHRoaXMuX3plcm9maWxsKSB7XG4gICAgICAgIHdhcm4oXCJPcmFjbGUgZG9lcyBub3Qgc3VwcG9ydCBET1VCTEUgd2l0aCBvcHRpb25zLlwiKTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm9wdGlvbnMubGVuZ3RoID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl91bnNpZ25lZCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5femVyb2ZpbGwgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICB0aGlzLmtleSA9IFwiRE9VQkxFIFBSRUNJU0lPTlwiO1xuICAgIH1cbiAgICBfZ2V0QmluZERlZihvcmFjbGVkYikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9CSU5BUllfRE9VQkxFIH07XG4gICAgfVxuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiQklOQVJZX0RPVUJMRVwiO1xuICAgIH1cbiAgfVxuICBjbGFzcyBEQVRFT05MWSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFT05MWSB7XG4gICAgcGFyc2UodmFsdWUpIHtcbiAgICAgIHJldHVybiBtb21lbnQodmFsdWUpLmZvcm1hdChcIllZWVktTU0tRERcIik7XG4gICAgfVxuICAgIF9zYW5pdGl6ZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBtb21lbnQodmFsdWUpLmZvcm1hdChcIllZWVktTU0tRERcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkoZGF0ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKGRhdGUpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gXCJZWVlZL01NL0REXCI7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmVzY2FwZShgVE9fREFURSgnJHtkYXRlfScsJyR7Zm9ybWF0fScpYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5lc2NhcGUoZGF0ZSk7XG4gICAgfVxuICAgIF9nZXRCaW5kRGVmKG9yYWNsZWRiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX0RBVEUgfTtcbiAgICB9XG4gICAgX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5iaW5kUGFyYW0obmV3IERhdGUodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLmJpbmRQYXJhbSh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIERBVEVPTkxZLnByb3RvdHlwZS5lc2NhcGUgPSBmYWxzZTtcbiAgcmV0dXJuIHtcbiAgICBCT09MRUFOLFxuICAgIFwiRE9VQkxFIFBSRUNJU0lPTlwiOiBET1VCTEUsXG4gICAgRE9VQkxFLFxuICAgIFNUUklORyxcbiAgICBUSU5ZSU5ULFxuICAgIFNNQUxMSU5ULFxuICAgIE1FRElVTUlOVCxcbiAgICBCSUdJTlQsXG4gICAgTlVNQkVSLFxuICAgIElOVEVHRVIsXG4gICAgRkxPQVQsXG4gICAgVVVJRCxcbiAgICBEQVRFT05MWSxcbiAgICBEQVRFLFxuICAgIE5PVyxcbiAgICBCTE9CLFxuICAgIEVOVU0sXG4gICAgVEVYVCxcbiAgICBDSEFSLFxuICAgIEpTT046IEpTT05UWVBFLFxuICAgIFJFQUwsXG4gICAgREVDSU1BTFxuICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEtdHlwZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/oracle/data-types.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/oracle/index.js":
/*!**************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/oracle/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst { AbstractDialect } = __webpack_require__(/*! ../abstract */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst { OracleConnectionManager } = __webpack_require__(/*! ./connection-manager */ \"(action-browser)/../node_modules/sequelize/lib/dialects/oracle/connection-manager.js\");\nconst { OracleQuery } = __webpack_require__(/*! ./query */ \"(action-browser)/../node_modules/sequelize/lib/dialects/oracle/query.js\");\nconst { OracleQueryGenerator } = __webpack_require__(/*! ./query-generator */ \"(action-browser)/../node_modules/sequelize/lib/dialects/oracle/query-generator.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\").oracle);\nconst { OracleQueryInterface } = __webpack_require__(/*! ./query-interface */ \"(action-browser)/../node_modules/sequelize/lib/dialects/oracle/query-interface.js\");\nclass OracleDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new OracleConnectionManager(this, sequelize);\n    this.connectionManager.initPools();\n    this.queryGenerator = new OracleQueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new OracleQueryInterface(sequelize, this.queryGenerator);\n  }\n}\nOracleDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  \"VALUES ()\": true,\n  \"LIMIT ON UPDATE\": true,\n  IGNORE: \" IGNORE\",\n  lock: true,\n  lockOuterJoinFailure: true,\n  forShare: \"FOR UPDATE\",\n  skipLocked: true,\n  index: {\n    collate: false,\n    length: false,\n    parser: false,\n    type: false,\n    using: false\n  },\n  constraints: {\n    restrict: false\n  },\n  returnValues: false,\n  returnIntoValues: true,\n  \"ORDER NULLS\": true,\n  schemas: true,\n  updateOnDuplicate: false,\n  indexViaAlter: false,\n  NUMERIC: true,\n  JSON: true,\n  upserts: true,\n  bulkDefault: true,\n  topLevelOrderByRequired: true,\n  GEOMETRY: false\n});\nOracleDialect.prototype.defaultVersion = \"18.0.0\";\nOracleDialect.prototype.Query = OracleQuery;\nOracleDialect.prototype.queryGenerator = OracleQueryGenerator;\nOracleDialect.prototype.DataTypes = DataTypes;\nOracleDialect.prototype.name = \"oracle\";\nOracleDialect.prototype.TICK_CHAR = '\"';\nOracleDialect.prototype.TICK_CHAR_LEFT = OracleDialect.prototype.TICK_CHAR;\nOracleDialect.prototype.TICK_CHAR_RIGHT = OracleDialect.prototype.TICK_CHAR;\nmodule.exports = OracleDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixVQUFVLG1CQUFPLENBQUMsaUVBQVE7QUFDMUIsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLDhGQUFhO0FBQ2pELFFBQVEsMEJBQTBCLEVBQUUsbUJBQU8sQ0FBQyxrSEFBc0I7QUFDbEUsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQyx3RkFBUztBQUN6QyxRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsNEdBQW1CO0FBQzVELGtCQUFrQixvSEFBa0M7QUFDcEQsUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLDRHQUFtQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvaW5kZXguanM/YmI3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgeyBBYnN0cmFjdERpYWxlY3QgfSA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdFwiKTtcbmNvbnN0IHsgT3JhY2xlQ29ubmVjdGlvbk1hbmFnZXIgfSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24tbWFuYWdlclwiKTtcbmNvbnN0IHsgT3JhY2xlUXVlcnkgfSA9IHJlcXVpcmUoXCIuL3F1ZXJ5XCIpO1xuY29uc3QgeyBPcmFjbGVRdWVyeUdlbmVyYXRvciB9ID0gcmVxdWlyZShcIi4vcXVlcnktZ2VuZXJhdG9yXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIikub3JhY2xlO1xuY29uc3QgeyBPcmFjbGVRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZShcIi4vcXVlcnktaW50ZXJmYWNlXCIpO1xuY2xhc3MgT3JhY2xlRGlhbGVjdCBleHRlbmRzIEFic3RyYWN0RGlhbGVjdCB7XG4gIGNvbnN0cnVjdG9yKHNlcXVlbGl6ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBPcmFjbGVDb25uZWN0aW9uTWFuYWdlcih0aGlzLCBzZXF1ZWxpemUpO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuaW5pdFBvb2xzKCk7XG4gICAgdGhpcy5xdWVyeUdlbmVyYXRvciA9IG5ldyBPcmFjbGVRdWVyeUdlbmVyYXRvcih7XG4gICAgICBfZGlhbGVjdDogdGhpcyxcbiAgICAgIHNlcXVlbGl6ZVxuICAgIH0pO1xuICAgIHRoaXMucXVlcnlJbnRlcmZhY2UgPSBuZXcgT3JhY2xlUXVlcnlJbnRlcmZhY2Uoc2VxdWVsaXplLCB0aGlzLnF1ZXJ5R2VuZXJhdG9yKTtcbiAgfVxufVxuT3JhY2xlRGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMgPSBfLm1lcmdlKF8uY2xvbmVEZWVwKEFic3RyYWN0RGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMpLCB7XG4gIFwiVkFMVUVTICgpXCI6IHRydWUsXG4gIFwiTElNSVQgT04gVVBEQVRFXCI6IHRydWUsXG4gIElHTk9SRTogXCIgSUdOT1JFXCIsXG4gIGxvY2s6IHRydWUsXG4gIGxvY2tPdXRlckpvaW5GYWlsdXJlOiB0cnVlLFxuICBmb3JTaGFyZTogXCJGT1IgVVBEQVRFXCIsXG4gIHNraXBMb2NrZWQ6IHRydWUsXG4gIGluZGV4OiB7XG4gICAgY29sbGF0ZTogZmFsc2UsXG4gICAgbGVuZ3RoOiBmYWxzZSxcbiAgICBwYXJzZXI6IGZhbHNlLFxuICAgIHR5cGU6IGZhbHNlLFxuICAgIHVzaW5nOiBmYWxzZVxuICB9LFxuICBjb25zdHJhaW50czoge1xuICAgIHJlc3RyaWN0OiBmYWxzZVxuICB9LFxuICByZXR1cm5WYWx1ZXM6IGZhbHNlLFxuICByZXR1cm5JbnRvVmFsdWVzOiB0cnVlLFxuICBcIk9SREVSIE5VTExTXCI6IHRydWUsXG4gIHNjaGVtYXM6IHRydWUsXG4gIHVwZGF0ZU9uRHVwbGljYXRlOiBmYWxzZSxcbiAgaW5kZXhWaWFBbHRlcjogZmFsc2UsXG4gIE5VTUVSSUM6IHRydWUsXG4gIEpTT046IHRydWUsXG4gIHVwc2VydHM6IHRydWUsXG4gIGJ1bGtEZWZhdWx0OiB0cnVlLFxuICB0b3BMZXZlbE9yZGVyQnlSZXF1aXJlZDogdHJ1ZSxcbiAgR0VPTUVUUlk6IGZhbHNlXG59KTtcbk9yYWNsZURpYWxlY3QucHJvdG90eXBlLmRlZmF1bHRWZXJzaW9uID0gXCIxOC4wLjBcIjtcbk9yYWNsZURpYWxlY3QucHJvdG90eXBlLlF1ZXJ5ID0gT3JhY2xlUXVlcnk7XG5PcmFjbGVEaWFsZWN0LnByb3RvdHlwZS5xdWVyeUdlbmVyYXRvciA9IE9yYWNsZVF1ZXJ5R2VuZXJhdG9yO1xuT3JhY2xlRGlhbGVjdC5wcm90b3R5cGUuRGF0YVR5cGVzID0gRGF0YVR5cGVzO1xuT3JhY2xlRGlhbGVjdC5wcm90b3R5cGUubmFtZSA9IFwib3JhY2xlXCI7XG5PcmFjbGVEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVIgPSAnXCInO1xuT3JhY2xlRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX0xFRlQgPSBPcmFjbGVEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVI7XG5PcmFjbGVEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfUklHSFQgPSBPcmFjbGVEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVI7XG5tb2R1bGUuZXhwb3J0cyA9IE9yYWNsZURpYWxlY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/oracle/index.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/oracle/query-generator.js":
/*!************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/oracle/query-generator.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  OracleQueryGenerator: () => OracleQueryGenerator\n});\nconst Utils = __webpack_require__(/*! ../../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\");\nconst AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-generator.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst Transaction = __webpack_require__(/*! ../../transaction */ \"(action-browser)/../node_modules/sequelize/lib/transaction.js\");\nconst ORACLE_RESERVED_WORDS = [\"ACCESS\", \"ADD\", \"ALL\", \"ALTER\", \"AND\", \"ANY\", \"ARRAYLEN\", \"AS\", \"ASC\", \"AUDIT\", \"BETWEEN\", \"BY\", \"CHAR\", \"CHECK\", \"CLUSTER\", \"COLUMN\", \"COMMENT\", \"COMPRESS\", \"CONNECT\", \"CREATE\", \"CURRENT\", \"DATE\", \"DECIMAL\", \"DEFAULT\", \"DELETE\", \"DESC\", \"DISTINCT\", \"DROP\", \"ELSE\", \"EXCLUSIVE\", \"EXISTS\", \"FILE\", \"FLOAT\", \"FOR\", \"FROM\", \"GRANT\", \"GROUP\", \"HAVING\", \"IDENTIFIED\", \"IMMEDIATE\", \"IN\", \"INCREMENT\", \"INDEX\", \"INITIAL\", \"INSERT\", \"INTEGER\", \"INTERSECT\", \"INTO\", \"IS\", \"LEVEL\", \"LIKE\", \"LOCK\", \"LONG\", \"MAXEXTENTS\", \"MINUS\", \"MODE\", \"MODIFY\", \"NOAUDIT\", \"NOCOMPRESS\", \"NOT\", \"NOTFOUND\", \"NOWAIT\", \"NULL\", \"NUMBER\", \"OF\", \"OFFLINE\", \"ON\", \"ONLINE\", \"OPTION\", \"OR\", \"ORDER\", \"PCTFREE\", \"PRIOR\", \"PRIVILEGES\", \"PUBLIC\", \"RAW\", \"RENAME\", \"RESOURCE\", \"REVOKE\", \"ROW\", \"ROWID\", \"ROWLABEL\", \"ROWNUM\", \"ROWS\", \"SELECT\", \"SESSION\", \"SET\", \"SHARE\", \"SIZE\", \"SMALLINT\", \"SQLBUF\", \"START\", \"SUCCESSFUL\", \"SYNONYM\", \"SYSDATE\", \"TABLE\", \"THEN\", \"TO\", \"TRIGGER\", \"UID\", \"UNION\", \"UNIQUE\", \"UPDATE\", \"USER\", \"VALIDATE\", \"VALUES\", \"VARCHAR\", \"VARCHAR2\", \"VIEW\", \"WHENEVER\", \"WHERE\", \"WITH\"];\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nclass OracleQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n  }\n  getCatalogName(value) {\n    if (value) {\n      if (this.options.quoteIdentifiers === false) {\n        const quotedValue = this.quoteIdentifier(value);\n        if (quotedValue === value) {\n          value = value.toUpperCase();\n        }\n      }\n    }\n    return value;\n  }\n  getSchemaNameAndTableName(table) {\n    const tableName = this.getCatalogName(table.tableName || table);\n    const schemaName = this.getCatalogName(table.schema);\n    return [tableName, schemaName];\n  }\n  createSchema(schema) {\n    const quotedSchema = this.quoteIdentifier(schema);\n    return [\n      \"DECLARE\",\n      \"USER_FOUND BOOLEAN := FALSE;\",\n      \"BEGIN\",\n      \" BEGIN\",\n      \"   EXECUTE IMMEDIATE \",\n      this.escape(`CREATE USER ${quotedSchema} IDENTIFIED BY 12345 DEFAULT TABLESPACE USERS`),\n      \";\",\n      \"   EXCEPTION WHEN OTHERS THEN\",\n      \"     IF SQLCODE != -1920 THEN\",\n      \"       RAISE;\",\n      \"     ELSE\",\n      \"       USER_FOUND := TRUE;\",\n      \"     END IF;\",\n      \" END;\",\n      \" IF NOT USER_FOUND THEN\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`GRANT \"CONNECT\" TO ${quotedSchema}`),\n      \";\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`GRANT CREATE TABLE TO ${quotedSchema}`),\n      \";\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`GRANT CREATE VIEW TO ${quotedSchema}`),\n      \";\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`GRANT CREATE ANY TRIGGER TO ${quotedSchema}`),\n      \";\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`GRANT CREATE ANY PROCEDURE TO ${quotedSchema}`),\n      \";\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`GRANT CREATE SEQUENCE TO ${quotedSchema}`),\n      \";\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`GRANT CREATE SYNONYM TO ${quotedSchema}`),\n      \";\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`ALTER USER ${quotedSchema} QUOTA UNLIMITED ON USERS`),\n      \";\",\n      \" END IF;\",\n      \"END;\"\n    ].join(\" \");\n  }\n  showSchemasQuery() {\n    return `SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE COMMON = ('NO') AND USERNAME != user`;\n  }\n  dropSchema(schema) {\n    return [\n      \"BEGIN\",\n      \"EXECUTE IMMEDIATE \",\n      this.escape(`DROP USER ${this.quoteTable(schema)} CASCADE`),\n      \";\",\n      \"EXCEPTION WHEN OTHERS THEN\",\n      \"  IF SQLCODE != -1918 THEN\",\n      \"    RAISE;\",\n      \"  END IF;\",\n      \"END;\"\n    ].join(\" \");\n  }\n  versionQuery() {\n    return \"SELECT VERSION_FULL FROM PRODUCT_COMPONENT_VERSION WHERE PRODUCT LIKE 'Oracle%'\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    const primaryKeys = [], foreignKeys = Object.create(null), attrStr = [], checkStr = [];\n    const values = {\n      table: this.quoteTable(tableName)\n    };\n    for (let attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr))\n        continue;\n      const dataType = attributes[attr];\n      attr = this.quoteIdentifier(attr);\n      if (dataType.includes(\"PRIMARY KEY\")) {\n        primaryKeys.push(attr);\n        if (dataType.includes(\"REFERENCES\")) {\n          const match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${attr} ${match[1].replace(/PRIMARY KEY/, \"\")}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${attr} ${dataType.replace(/PRIMARY KEY/, \"\").trim()}`);\n        }\n      } else if (dataType.includes(\"REFERENCES\")) {\n        const match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${attr} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${attr} ${dataType}`);\n      }\n    }\n    values[\"attributes\"] = attrStr.join(\", \");\n    const pkString = primaryKeys.map((pk) => this.quoteIdentifier(pk)).join(\", \");\n    if (pkString.length > 0) {\n      values.attributes += `,PRIMARY KEY (${pkString})`;\n    }\n    for (const fkey in foreignKeys) {\n      if (!Object.prototype.hasOwnProperty.call(foreignKeys, fkey))\n        continue;\n      if (foreignKeys[fkey].indexOf(\"ON DELETE NO ACTION\") > -1) {\n        foreignKeys[fkey] = foreignKeys[fkey].replace(\"ON DELETE NO ACTION\", \"\");\n      }\n      values.attributes += `,FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n    }\n    if (checkStr.length > 0) {\n      values.attributes += `, ${checkStr.join(\", \")}`;\n    }\n    if (options && options.indexes && options.indexes.length > 0) {\n      const idxToDelete = [];\n      options.indexes.forEach((index, idx) => {\n        if (\"unique\" in index && (index.unique === true || index.unique.length > 0 && index.unique !== false)) {\n          const fields = index.fields.map((field) => {\n            if (typeof field === \"string\") {\n              return field;\n            }\n            return field.attribute;\n          });\n          let canContinue = true;\n          if (options.uniqueKeys) {\n            const keys = Object.keys(options.uniqueKeys);\n            for (let fieldIdx = 0; fieldIdx < keys.length; fieldIdx++) {\n              const currUnique = options.uniqueKeys[keys[fieldIdx]];\n              if (currUnique.fields.length === fields.length) {\n                for (let i = 0; i < currUnique.fields.length; i++) {\n                  const field = currUnique.fields[i];\n                  if (_.includes(fields, field)) {\n                    canContinue = false;\n                  } else {\n                    canContinue = true;\n                    break;\n                  }\n                }\n              }\n            }\n            if (canContinue) {\n              const indexName = \"name\" in index ? index.name : \"\";\n              const constraintToAdd = {\n                name: indexName,\n                fields\n              };\n              if (!(\"uniqueKeys\" in options)) {\n                options.uniqueKeys = {};\n              }\n              options.uniqueKeys[indexName] = constraintToAdd;\n              idxToDelete.push(idx);\n            } else {\n              idxToDelete.push(idx);\n            }\n          }\n        }\n      });\n      idxToDelete.forEach((idx) => {\n        options.indexes.splice(idx, 1);\n      });\n    }\n    if (options && !!options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        let canBeUniq = false;\n        primaryKeys.forEach((primaryKey) => {\n          primaryKey = primaryKey.replace(/\"/g, \"\");\n          if (!_.includes(columns.fields, primaryKey)) {\n            canBeUniq = true;\n          }\n        });\n        columns.fields.forEach((field) => {\n          let currField = \"\";\n          if (!_.isString(field)) {\n            currField = field.attribute.replace(/[.,\"\\s]/g, \"\");\n          } else {\n            currField = field.replace(/[.,\"\\s]/g, \"\");\n          }\n          if (currField in attributes) {\n            if (attributes[currField].toUpperCase().indexOf(\"UNIQUE\") > -1 && canBeUniq) {\n              const attrToReplace = attributes[currField].replace(\"UNIQUE\", \"\");\n              values.attributes = values.attributes.replace(attributes[currField], attrToReplace);\n            }\n          }\n        });\n        if (canBeUniq) {\n          const index = options.uniqueKeys[columns.name];\n          delete options.uniqueKeys[columns.name];\n          indexName = indexName.replace(/[.,\\s]/g, \"\");\n          columns.name = indexName;\n          options.uniqueKeys[indexName] = index;\n          if (indexName.length === 0) {\n            values.attributes += `,UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n          } else {\n            values.attributes += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n          }\n        }\n      });\n    }\n    const query = Utils.joinSQLFragments([\n      \"CREATE TABLE\",\n      values.table,\n      `(${values.attributes})`\n    ]);\n    return Utils.joinSQLFragments([\n      \"BEGIN\",\n      \"EXECUTE IMMEDIATE\",\n      `${this.escape(query)};`,\n      \"EXCEPTION WHEN OTHERS THEN\",\n      \"IF SQLCODE != -955 THEN\",\n      \"RAISE;\",\n      \"END IF;\",\n      \"END;\"\n    ]);\n  }\n  tableExistsQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    return `SELECT TABLE_NAME FROM ALL_TABLES WHERE TABLE_NAME = ${this.escape(tableName)} AND OWNER = ${table.schema ? this.escape(schemaName) : \"USER\"}`;\n  }\n  describeTableQuery(tableName, schema) {\n    const currTableName = this.getCatalogName(tableName.tableName || tableName);\n    schema = this.getCatalogName(schema);\n    return [\n      \"SELECT atc.COLUMN_NAME, atc.DATA_TYPE, atc.DATA_LENGTH, atc.CHAR_LENGTH, atc.DEFAULT_LENGTH, atc.NULLABLE, ucc.constraint_type \",\n      \"FROM all_tab_columns atc \",\n      \"LEFT OUTER JOIN \",\n      \"(SELECT acc.column_name, acc.table_name, ac.constraint_type FROM all_cons_columns acc INNER JOIN all_constraints ac ON acc.constraint_name = ac.constraint_name) ucc \",\n      \"ON (atc.table_name = ucc.table_name AND atc.COLUMN_NAME = ucc.COLUMN_NAME) \",\n      schema ? `WHERE (atc.OWNER = ${this.escape(schema)}) ` : \"WHERE atc.OWNER = USER \",\n      `AND (atc.TABLE_NAME = ${this.escape(currTableName)})`,\n      \"ORDER BY atc.COLUMN_NAME, CONSTRAINT_TYPE DESC\"\n    ].join(\"\");\n  }\n  renameTableQuery(before, after) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(before),\n      \"RENAME TO\",\n      this.quoteTable(after)\n    ]);\n  }\n  showConstraintsQuery(table) {\n    const tableName = this.getCatalogName(table.tableName || table);\n    return `SELECT CONSTRAINT_NAME constraint_name FROM user_cons_columns WHERE table_name = ${this.escape(tableName)}`;\n  }\n  showTablesQuery() {\n    return `SELECT owner as table_schema, table_name, 0 as lvl FROM all_tables where OWNER IN(SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE ORACLE_MAINTAINED = 'N')`;\n  }\n  dropTableQuery(tableName) {\n    return Utils.joinSQLFragments([\n      \"BEGIN \",\n      \"EXECUTE IMMEDIATE 'DROP TABLE\",\n      this.quoteTable(tableName),\n      \"CASCADE CONSTRAINTS PURGE';\",\n      \"EXCEPTION WHEN OTHERS THEN\",\n      \" IF SQLCODE != -942 THEN\",\n      \"   RAISE;\",\n      \" END IF;\",\n      \"END;\"\n    ]);\n  }\n  addIndexQuery(tableName, attributes, options, rawTablename) {\n    if (typeof tableName !== \"string\" && attributes.name) {\n      attributes.name = `${tableName.schema}.${attributes.name}`;\n    }\n    return super.addIndexQuery(tableName, attributes, options, rawTablename);\n  }\n  addConstraintQuery(tableName, options) {\n    options = options || {};\n    if (options.onUpdate) {\n      delete options.onUpdate;\n    }\n    if (options.onDelete && options.onDelete.toUpperCase() === \"NO ACTION\") {\n      delete options.onDelete;\n    }\n    const constraintSnippet = this.getConstraintSnippet(tableName, options);\n    tableName = this.quoteTable(tableName);\n    return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;\n  }\n  addColumnQuery(table, key, dataType) {\n    dataType.field = key;\n    const attribute = Utils.joinSQLFragments([\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, {\n        attributeName: key,\n        context: \"addColumn\"\n      })\n    ]);\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(table),\n      \"ADD\",\n      attribute\n    ]);\n  }\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP COLUMN\",\n      this.quoteIdentifier(attributeName),\n      \";\"\n    ]);\n  }\n  _alterForeignKeyConstraint(definition, table, attributeName) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const attributeNameConstant = this.escape(this.getCatalogName(attributeName));\n    const schemaNameConstant = table.schema ? this.escape(this.getCatalogName(schemaName)) : \"USER\";\n    const tableNameConstant = this.escape(this.getCatalogName(tableName));\n    const getConsNameQuery = [\n      \"SELECT constraint_name INTO cons_name\",\n      \"FROM (\",\n      \"  SELECT DISTINCT cc.owner, cc.table_name, cc.constraint_name, cc.column_name AS cons_columns\",\n      \"  FROM all_cons_columns cc, all_constraints c\",\n      \"  WHERE cc.owner = c.owner\",\n      \"  AND cc.table_name = c.table_name\",\n      \"  AND cc.constraint_name = c.constraint_name\",\n      \"  AND c.constraint_type = 'R'\",\n      \"  GROUP BY cc.owner, cc.table_name, cc.constraint_name, cc.column_name\",\n      \")\",\n      \"WHERE owner =\",\n      schemaNameConstant,\n      \"AND table_name =\",\n      tableNameConstant,\n      \"AND cons_columns =\",\n      attributeNameConstant,\n      \";\"\n    ].join(\" \");\n    const secondQuery = Utils.joinSQLFragments([\n      `ALTER TABLE ${this.quoteIdentifier(tableName)}`,\n      \"ADD FOREIGN KEY\",\n      `(${this.quoteIdentifier(attributeName)})`,\n      definition.replace(/.+?(?=REFERENCES)/, \"\")\n    ]);\n    return [\n      \"BEGIN\",\n      getConsNameQuery,\n      \"EXCEPTION\",\n      \"WHEN NO_DATA_FOUND THEN\",\n      \" CONS_NAME := NULL;\",\n      \"END;\",\n      \"IF CONS_NAME IS NOT NULL THEN\",\n      ` EXECUTE IMMEDIATE 'ALTER TABLE ${this.quoteTable(table)} DROP CONSTRAINT \"'||CONS_NAME||'\"';`,\n      \"END IF;\",\n      `EXECUTE IMMEDIATE ${this.escape(secondQuery)};`\n    ].join(\" \");\n  }\n  _modifyQuery(definition, table, attributeName) {\n    const query = Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(table),\n      \"MODIFY\",\n      this.quoteIdentifier(attributeName),\n      definition\n    ]);\n    const secondQuery = query.replace(\"NOT NULL\", \"\").replace(\"NULL\", \"\");\n    return [\n      \"BEGIN\",\n      `EXECUTE IMMEDIATE ${this.escape(query)};`,\n      \"EXCEPTION\",\n      \"WHEN OTHERS THEN\",\n      \" IF SQLCODE = -1442 OR SQLCODE = -1451 THEN\",\n      `   EXECUTE IMMEDIATE ${this.escape(secondQuery)};`,\n      \" ELSE\",\n      \"   RAISE;\",\n      \" END IF;\",\n      \"END;\"\n    ].join(\" \");\n  }\n  changeColumnQuery(table, attributes) {\n    const sql = [\n      \"DECLARE\",\n      \"CONS_NAME VARCHAR2(200);\",\n      \"BEGIN\"\n    ];\n    for (const attributeName in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attributeName))\n        continue;\n      const definition = attributes[attributeName];\n      if (definition.match(/REFERENCES/)) {\n        sql.push(this._alterForeignKeyConstraint(definition, table, attributeName));\n      } else {\n        sql.push(this._modifyQuery(definition, table, attributeName));\n      }\n    }\n    sql.push(\"END;\");\n    return sql.join(\" \");\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(newName)}`;\n  }\n  populateInsertQueryReturnIntoBinds(returningModelAttributes, returnTypes, inbindLength, returnAttributes, options) {\n    const oracledb = this.sequelize.connectionManager.lib;\n    const outBindAttributes = Object.create(null);\n    const outbind = [];\n    const outbindParam = this.bindParam(outbind, inbindLength);\n    returningModelAttributes.forEach((element, index) => {\n      if (element.startsWith('\"')) {\n        element = element.substring(1, element.length - 1);\n      }\n      outBindAttributes[element] = Object.assign(returnTypes[index]._getBindDef(oracledb), { dir: oracledb.BIND_OUT });\n      const returnAttribute = `${this.format(void 0, void 0, { context: \"INSERT\" }, outbindParam)}`;\n      returnAttributes.push(returnAttribute);\n    });\n    options.outBindAttributes = outBindAttributes;\n  }\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    const rawAttributes = model.rawAttributes;\n    const updateQuery = this.updateQuery(tableName, updateValues, where, options, rawAttributes);\n    options.bind = updateQuery.bind;\n    const insertQuery = this.insertQuery(tableName, insertValues, rawAttributes, options);\n    const sql = [\n      \"DECLARE \",\n      \"BEGIN \",\n      updateQuery.query ? [\n        updateQuery.query,\n        \"; \",\n        \" IF ( SQL%ROWCOUNT = 0 ) THEN \",\n        insertQuery.query,\n        \" :isUpdate := 0; \",\n        \"ELSE \",\n        \" :isUpdate := 1; \",\n        \" END IF; \"\n      ].join(\"\") : [\n        insertQuery.query,\n        \" :isUpdate := 0; \",\n        \"EXCEPTION WHEN OTHERS THEN\",\n        \" IF SQLCODE != -1 THEN\",\n        \"   RAISE;\",\n        \" END IF;\"\n      ].join(\"\"),\n      \"END;\"\n    ];\n    const query = sql.join(\"\");\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = updateQuery.bind || insertQuery.bind;\n    }\n    return result;\n  }\n  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n    options = options || {};\n    options.executeMany = true;\n    fieldMappedAttributes = fieldMappedAttributes || {};\n    const tuples = [];\n    const allColumns = {};\n    const inBindBindDefMap = {};\n    const outBindBindDefMap = {};\n    const oracledb = this.sequelize.connectionManager.lib;\n    for (const fieldValueHash of fieldValueHashes) {\n      _.forOwn(fieldValueHash, (value, key) => {\n        allColumns[key] = fieldMappedAttributes[key] && fieldMappedAttributes[key].autoIncrement === true && value === null;\n      });\n    }\n    let inBindPosition;\n    for (const fieldValueHash of fieldValueHashes) {\n      const tuple = [];\n      const inbindParam = options.bindParam === void 0 ? this.bindParam(tuple) : options.bindParam;\n      const tempBindPositions = Object.keys(allColumns).map((key) => {\n        if (allColumns[key] === true) {\n          if (fieldValueHash[key] !== null) {\n            throw Error(\"For an auto-increment column either all row must be null or non-null, a mix of null and non-null is not allowed!\");\n          }\n          return \"DEFAULT\";\n        }\n        return this.format(fieldValueHash[key], fieldMappedAttributes[key], { context: \"INSERT\" }, inbindParam);\n      });\n      if (!inBindPosition) {\n        inBindPosition = tempBindPositions;\n      }\n      tuples.push(tuple);\n    }\n    const returnColumn = [];\n    const returnColumnBindPositions = [];\n    const insertColumns = [];\n    for (const key of Object.keys(allColumns)) {\n      if (fieldMappedAttributes[key]) {\n        const bindDef = fieldMappedAttributes[key].type._getBindDef(oracledb);\n        if (allColumns[key]) {\n          bindDef.dir = oracledb.BIND_OUT;\n          outBindBindDefMap[key] = bindDef;\n          returnColumn.push(this.quoteIdentifier(key));\n          returnColumnBindPositions.push(`:${tuples[0].length + returnColumn.length}`);\n        } else {\n          bindDef.dir = oracledb.BIND_IN;\n          inBindBindDefMap[key] = bindDef;\n        }\n      }\n      insertColumns.push(this.quoteIdentifier(key));\n    }\n    let query = Utils.joinSQLFragments([\n      \"INSERT\",\n      \"INTO\",\n      this.quoteTable(tableName),\n      `(${insertColumns.join(\",\")})`,\n      \"VALUES\",\n      `(${inBindPosition})`\n    ]);\n    if (returnColumn.length > 0) {\n      options.outBindAttributes = outBindBindDefMap;\n      query = Utils.joinSQLFragments([\n        query,\n        \"RETURNING\",\n        `${returnColumn.join(\",\")}`,\n        \"INTO\",\n        `${returnColumnBindPositions}`\n      ]);\n    }\n    const result = { query };\n    result.bind = tuples;\n    options.inbindAttributes = inBindBindDefMap;\n    return result;\n  }\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n  deleteQuery(tableName, where, options, model) {\n    options = options || {};\n    const table = tableName;\n    where = this.getWhereConditions(where, null, model, options);\n    let queryTmpl;\n    if (options.limit) {\n      const whereTmpl = where ? ` AND ${where}` : \"\";\n      queryTmpl = `DELETE FROM ${this.quoteTable(table)} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(table)} WHERE rownum <= ${this.escape(options.limit)}${whereTmpl})`;\n    } else {\n      const whereTmpl = where ? ` WHERE ${where}` : \"\";\n      queryTmpl = `DELETE FROM ${this.quoteTable(table)}${whereTmpl}`;\n    }\n    return queryTmpl;\n  }\n  showIndexesQuery(table) {\n    const [tableName, owner] = this.getSchemaNameAndTableName(table);\n    const sql = [\n      \"SELECT i.index_name,i.table_name, i.column_name, u.uniqueness, i.descend, c.constraint_type \",\n      \"FROM all_ind_columns i \",\n      \"INNER JOIN all_indexes u \",\n      \"ON (u.table_name = i.table_name AND u.index_name = i.index_name) \",\n      \"LEFT OUTER JOIN all_constraints c \",\n      \"ON (c.table_name = i.table_name AND c.index_name = i.index_name) \",\n      `WHERE i.table_name = ${this.escape(tableName)}`,\n      \" AND u.table_owner = \",\n      owner ? this.escape(owner) : \"USER\",\n      \" ORDER BY index_name, column_position\"\n    ];\n    return sql.join(\"\");\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return `DROP INDEX ${this.quoteIdentifier(indexName)}`;\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    attribute.onUpdate = \"\";\n    if (attribute.references) {\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log(\"Oracle does not support self referencial constraints, we will remove it but we recommend restructuring your query\");\n        attribute.onDelete = \"\";\n      }\n    }\n    let template;\n    template = attribute.type.toSql ? attribute.type.toSql() : \"\";\n    if (attribute.type instanceof DataTypes.JSON) {\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IS JSON)`;\n      return template;\n    }\n    if (Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.allowNull === false) {\n      template += \" NOT NULL\";\n    }\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values)\n        attribute.values = attribute.type.values;\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IN(${_.map(attribute.values, (value) => {\n        return this.escape(value);\n      }).join(\", \")}))`;\n      return template;\n    }\n    if (attribute.type instanceof DataTypes.BOOLEAN) {\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IN('1', '0'))`;\n      return template;\n    }\n    if (attribute.autoIncrement) {\n      template = \" NUMBER(*,0) GENERATED BY DEFAULT ON NULL AS IDENTITY\";\n    } else if (attribute.type && attribute.type.key === DataTypes.DOUBLE.key) {\n      template = attribute.type.toSql();\n    } else if (attribute.type) {\n      let unsignedTemplate = \"\";\n      if (attribute.type._unsigned) {\n        attribute.type._unsigned = false;\n        unsignedTemplate += ` check(${this.quoteIdentifier(options.attributeName)} >= 0)`;\n      }\n      template = attribute.type.toString();\n      if (attribute.type && attribute.type !== \"TEXT\" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n        template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n      }\n      if (!attribute.autoIncrement) {\n        if (attribute.allowNull === false) {\n          template += \" NOT NULL\";\n        } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n          template += \" NULL\";\n        }\n      }\n      template += unsignedTemplate;\n    } else {\n      template = \"\";\n    }\n    if (attribute.unique === true && !attribute.primaryKey) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete && attribute.onDelete.toUpperCase() !== \"NO ACTION\") {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {};\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      const attributeName = attribute.field || key;\n      result[attributeName] = this.attributeToSQL(attribute, __spreadValues({ attributeName }, options));\n    }\n    return result;\n  }\n  createTrigger() {\n    throwMethodUndefined(\"createTrigger\");\n  }\n  dropTrigger() {\n    throwMethodUndefined(\"dropTrigger\");\n  }\n  renameTrigger() {\n    throwMethodUndefined(\"renameTrigger\");\n  }\n  createFunction() {\n    throwMethodUndefined(\"createFunction\");\n  }\n  dropFunction() {\n    throwMethodUndefined(\"dropFunction\");\n  }\n  renameFunction() {\n    throwMethodUndefined(\"renameFunction\");\n  }\n  getConstraintsOnColumn(table, column) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    column = this.getCatalogName(column);\n    const sql = [\n      \"SELECT CONSTRAINT_NAME FROM user_cons_columns WHERE TABLE_NAME = \",\n      this.escape(tableName),\n      \" and OWNER = \",\n      table.schema ? this.escape(schemaName) : \"USER\",\n      \" and COLUMN_NAME = \",\n      this.escape(column),\n      \" AND POSITION IS NOT NULL ORDER BY POSITION\"\n    ].join(\"\");\n    return sql;\n  }\n  getForeignKeysQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const sql = [\n      'SELECT DISTINCT  a.table_name \"tableName\", a.constraint_name \"constraintName\", a.owner \"owner\",  a.column_name \"columnName\",',\n      ' b.table_name \"referencedTableName\", b.column_name \"referencedColumnName\"',\n      \" FROM all_cons_columns a\",\n      \" JOIN all_constraints c ON a.owner = c.owner AND a.constraint_name = c.constraint_name\",\n      \" JOIN all_cons_columns b ON c.owner = b.owner AND c.r_constraint_name = b.constraint_name\",\n      \" WHERE c.constraint_type  = 'R'\",\n      \" AND a.table_name = \",\n      this.escape(tableName),\n      \" AND a.owner = \",\n      table.schema ? this.escape(schemaName) : \"USER\",\n      \" ORDER BY a.table_name, a.constraint_name\"\n    ].join(\"\");\n    return sql;\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return this.dropConstraintQuery(tableName, foreignKey);\n  }\n  getPrimaryKeyConstraintQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const sql = [\n      \"SELECT cols.column_name, atc.identity_column \",\n      \"FROM all_constraints cons, all_cons_columns cols \",\n      \"INNER JOIN all_tab_columns atc ON(atc.table_name = cols.table_name AND atc.COLUMN_NAME = cols.COLUMN_NAME )\",\n      \"WHERE cols.table_name = \",\n      this.escape(tableName),\n      \"AND cols.owner = \",\n      table.schema ? this.escape(schemaName) : \"USER \",\n      \"AND cons.constraint_type = 'P' \",\n      \"AND cons.constraint_name = cols.constraint_name \",\n      \"AND cons.owner = cols.owner \",\n      \"ORDER BY cols.table_name, cols.position\"\n    ].join(\"\");\n    return sql;\n  }\n  dropConstraintQuery(tableName, constraintName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${constraintName}`;\n  }\n  setIsolationLevelQuery(value, options) {\n    if (options.parent) {\n      return;\n    }\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return \"SET TRANSACTION ISOLATION LEVEL READ COMMITTED;\";\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return \"SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;\";\n      default:\n        throw new Error(`isolation level \"${value}\" is not supported`);\n    }\n  }\n  getAliasToken() {\n    return \"\";\n  }\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;\n    }\n    return \"BEGIN TRANSACTION\";\n  }\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n    return \"COMMIT TRANSACTION\";\n  }\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TO SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;\n    }\n    return \"ROLLBACK TRANSACTION\";\n  }\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    let str;\n    if (smth instanceof Utils.Json) {\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map((condition) => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(\" AND \");\n      }\n      if (smth.path) {\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n        if (smth.value) {\n          str += util.format(\" = %s\", this.escape(smth.value));\n        }\n        return str;\n      }\n    }\n    if (smth instanceof Utils.Cast) {\n      if (smth.val instanceof Utils.SequelizeMethod) {\n        str = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n        if (smth.type === \"boolean\") {\n          str = `(CASE WHEN ${str}='true' THEN 1 ELSE 0 END)`;\n          return `CAST(${str} AS NUMBER)`;\n        }\n        if (smth.type === \"timestamptz\" && /json_value\\(/.test(str)) {\n          str = str.slice(0, -1);\n          return `${str} RETURNING TIMESTAMP WITH TIME ZONE)`;\n        }\n      }\n    }\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n      break;\n    }\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n    return hasJsonFunction;\n  }\n  jsonPathExtractionQuery(column, path) {\n    let paths = _.toPath(path);\n    const quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n    paths = paths.map((subPath) => {\n      return /\\D/.test(subPath) ? Utils.addTicks(subPath, '\"') : subPath;\n    });\n    const pathStr = this.escape([\"$\"].concat(paths).join(\".\").replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (__, digit) => `[${digit}]`));\n    return `json_value(${quotedColumn},${pathStr})`;\n  }\n  addLimitAndOffset(options, model) {\n    let fragment = \"\";\n    const offset = options.offset || 0, isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n    let orders = {};\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n    if (options.limit || options.offset) {\n      if (!orders.mainQueryOrder || !orders.mainQueryOrder.length || isSubQuery && (!orders.subQueryOrder || !orders.subQueryOrder.length)) {\n        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(model.primaryKeyField)}`;\n        fragment += ` ORDER BY ${tablePkFragment}`;\n      }\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n    return fragment;\n  }\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n  quoteIdentifier(identifier, force = false) {\n    const optForceQuote = force;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n    const regExp = /^(([\\w][\\w\\d_]*))$/g;\n    if (optForceQuote !== true && optQuoteIdentifiers === false && regExp.test(rawIdentifier) && !ORACLE_RESERVED_WORDS.includes(rawIdentifier.toUpperCase())) {\n      return rawIdentifier;\n    }\n    return Utils.addTicks(rawIdentifier, '\"');\n  }\n  bindParam(bind, posOffset = 0) {\n    return (value) => {\n      bind.push(value);\n      return `:${bind.length + posOffset}`;\n    };\n  }\n  authTestQuery() {\n    return \"SELECT 1+1 AS result FROM DUAL\";\n  }\n}\nfunction throwMethodUndefined(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n}\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvcXVlcnktZ2VuZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGNBQWMsbUJBQU8sQ0FBQyw0RUFBYTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBa0I7QUFDNUMsK0JBQStCLG1CQUFPLENBQUMsd0hBQTZCO0FBQ3BFLFVBQVUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMxQixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0Isb0JBQW9CLG1CQUFPLENBQUMsd0ZBQW1CO0FBQy9DO0FBQ0EsOENBQThDLElBQUksa0JBQWtCLElBQUk7QUFDeEUsd0RBQXdELEVBQUU7QUFDMUQsMERBQTBELEVBQUUsc0JBQXNCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQyxRQUFRO0FBQ1I7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGlDQUFpQztBQUNqQyxtQkFBbUI7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYTtBQUNyRCxRQUFRO0FBQ1I7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RCxRQUFRO0FBQ1I7QUFDQSwwQ0FBMEMsYUFBYTtBQUN2RCxRQUFRO0FBQ1I7QUFDQSxpREFBaUQsYUFBYTtBQUM5RCxRQUFRO0FBQ1I7QUFDQSxtREFBbUQsYUFBYTtBQUNoRSxRQUFRO0FBQ1I7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRCxRQUFRO0FBQ1I7QUFDQSw2Q0FBNkMsYUFBYTtBQUMxRCxRQUFRO0FBQ1I7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QyxRQUFRO0FBQ1IsZUFBZTtBQUNmLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseUJBQXlCO0FBQ3hELFFBQVE7QUFDUjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTSxFQUFFLG9DQUFvQztBQUN0RTtBQUNBLFVBQVU7QUFDViwwQkFBMEIsTUFBTSxFQUFFLDJDQUEyQztBQUM3RTtBQUNBLFFBQVE7QUFDUjtBQUNBLHdCQUF3QixNQUFNLEVBQUUsU0FBUztBQUN6QztBQUNBLFFBQVE7QUFDUix3QkFBd0IsTUFBTSxFQUFFLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDJCQUEyQixJQUFJLGtCQUFrQjtBQUM3RjtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsd0JBQXdCO0FBQzNEO0FBQ0E7QUFDQSxnQ0FBZ0MsOEJBQThCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsc0VBQXNFO0FBQ25ILFlBQVk7QUFDWixpREFBaUQsaUNBQWlDLFVBQVUsc0VBQXNFO0FBQ2xLO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsY0FBYztBQUNkLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSx3QkFBd0IsY0FBYyxnREFBZ0Q7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0JBQW9CO0FBQ3pELCtCQUErQiwyQkFBMkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsdUJBQXVCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCLEdBQUcsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVcsTUFBTSxtQkFBbUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBLFVBQVUsb0NBQW9DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLFdBQVc7QUFDWDtBQUNBLHlDQUF5Qyx3QkFBd0IsbUNBQW1DO0FBQ3BHLGNBQWM7QUFDZCwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hEO0FBQ0EsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0QkFBNEIsZ0JBQWdCLGtDQUFrQyxLQUFLLDhCQUE4QjtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2Rix3QkFBd0I7QUFDckgsaUNBQWlDLDhCQUE4QixtQkFBbUIsZ0JBQWdCO0FBQ2xHO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMEJBQTBCO0FBQzFCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsbUJBQW1CO0FBQ2pHLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdUNBQXVDO0FBQ3BGLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0JBQXdCO0FBQ2xDO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0EsV0FBVywwQkFBMEI7QUFDckM7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJCQUEyQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDLGlDQUFpQyx3QkFBd0Isb0NBQW9DLHdCQUF3QixrQkFBa0IsMkJBQTJCLEVBQUUsVUFBVTtBQUM5SyxNQUFNO0FBQ04sMENBQTBDLE1BQU07QUFDaEQsaUNBQWlDLHVCQUF1QixFQUFFLFVBQVU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHVCQUF1QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxHQUFHLGdDQUFnQztBQUNuRjtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2Q0FBNkM7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9DQUFvQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2Q0FBNkMsS0FBSztBQUMvRTtBQUNBLE9BQU8sYUFBYTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkNBQTZDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2Q0FBNkM7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9DQUFvQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNENBQTRDO0FBQzdFO0FBQ0EseUJBQXlCLCtDQUErQztBQUN4RSxRQUFRO0FBQ1IseUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0Esa0NBQWtDLGlDQUFpQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsZUFBZTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0QkFBNEIsa0JBQWtCLGVBQWU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLDRDQUE0QyxNQUFNO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVDQUF1QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0Rix5RUFBeUUsS0FBSyxnQkFBZ0I7QUFDMUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLElBQUk7QUFDbEMseUJBQXlCLEtBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpSEFBaUgsTUFBTTtBQUN2SCx5QkFBeUIsYUFBYSxHQUFHLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsK0NBQStDLEdBQUcsNENBQTRDO0FBQ2pJLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBLG1DQUFtQyw0QkFBNEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVztBQUM1QztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL29yYWNsZS9xdWVyeS1nZW5lcmF0b3IuanM/NThlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBPcmFjbGVRdWVyeUdlbmVyYXRvcjogKCkgPT4gT3JhY2xlUXVlcnlHZW5lcmF0b3Jcbn0pO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKTtcbmNvbnN0IEFic3RyYWN0UXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnktZ2VuZXJhdG9yXCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoXCIuLi8uLi90cmFuc2FjdGlvblwiKTtcbmNvbnN0IE9SQUNMRV9SRVNFUlZFRF9XT1JEUyA9IFtcIkFDQ0VTU1wiLCBcIkFERFwiLCBcIkFMTFwiLCBcIkFMVEVSXCIsIFwiQU5EXCIsIFwiQU5ZXCIsIFwiQVJSQVlMRU5cIiwgXCJBU1wiLCBcIkFTQ1wiLCBcIkFVRElUXCIsIFwiQkVUV0VFTlwiLCBcIkJZXCIsIFwiQ0hBUlwiLCBcIkNIRUNLXCIsIFwiQ0xVU1RFUlwiLCBcIkNPTFVNTlwiLCBcIkNPTU1FTlRcIiwgXCJDT01QUkVTU1wiLCBcIkNPTk5FQ1RcIiwgXCJDUkVBVEVcIiwgXCJDVVJSRU5UXCIsIFwiREFURVwiLCBcIkRFQ0lNQUxcIiwgXCJERUZBVUxUXCIsIFwiREVMRVRFXCIsIFwiREVTQ1wiLCBcIkRJU1RJTkNUXCIsIFwiRFJPUFwiLCBcIkVMU0VcIiwgXCJFWENMVVNJVkVcIiwgXCJFWElTVFNcIiwgXCJGSUxFXCIsIFwiRkxPQVRcIiwgXCJGT1JcIiwgXCJGUk9NXCIsIFwiR1JBTlRcIiwgXCJHUk9VUFwiLCBcIkhBVklOR1wiLCBcIklERU5USUZJRURcIiwgXCJJTU1FRElBVEVcIiwgXCJJTlwiLCBcIklOQ1JFTUVOVFwiLCBcIklOREVYXCIsIFwiSU5JVElBTFwiLCBcIklOU0VSVFwiLCBcIklOVEVHRVJcIiwgXCJJTlRFUlNFQ1RcIiwgXCJJTlRPXCIsIFwiSVNcIiwgXCJMRVZFTFwiLCBcIkxJS0VcIiwgXCJMT0NLXCIsIFwiTE9OR1wiLCBcIk1BWEVYVEVOVFNcIiwgXCJNSU5VU1wiLCBcIk1PREVcIiwgXCJNT0RJRllcIiwgXCJOT0FVRElUXCIsIFwiTk9DT01QUkVTU1wiLCBcIk5PVFwiLCBcIk5PVEZPVU5EXCIsIFwiTk9XQUlUXCIsIFwiTlVMTFwiLCBcIk5VTUJFUlwiLCBcIk9GXCIsIFwiT0ZGTElORVwiLCBcIk9OXCIsIFwiT05MSU5FXCIsIFwiT1BUSU9OXCIsIFwiT1JcIiwgXCJPUkRFUlwiLCBcIlBDVEZSRUVcIiwgXCJQUklPUlwiLCBcIlBSSVZJTEVHRVNcIiwgXCJQVUJMSUNcIiwgXCJSQVdcIiwgXCJSRU5BTUVcIiwgXCJSRVNPVVJDRVwiLCBcIlJFVk9LRVwiLCBcIlJPV1wiLCBcIlJPV0lEXCIsIFwiUk9XTEFCRUxcIiwgXCJST1dOVU1cIiwgXCJST1dTXCIsIFwiU0VMRUNUXCIsIFwiU0VTU0lPTlwiLCBcIlNFVFwiLCBcIlNIQVJFXCIsIFwiU0laRVwiLCBcIlNNQUxMSU5UXCIsIFwiU1FMQlVGXCIsIFwiU1RBUlRcIiwgXCJTVUNDRVNTRlVMXCIsIFwiU1lOT05ZTVwiLCBcIlNZU0RBVEVcIiwgXCJUQUJMRVwiLCBcIlRIRU5cIiwgXCJUT1wiLCBcIlRSSUdHRVJcIiwgXCJVSURcIiwgXCJVTklPTlwiLCBcIlVOSVFVRVwiLCBcIlVQREFURVwiLCBcIlVTRVJcIiwgXCJWQUxJREFURVwiLCBcIlZBTFVFU1wiLCBcIlZBUkNIQVJcIiwgXCJWQVJDSEFSMlwiLCBcIlZJRVdcIiwgXCJXSEVORVZFUlwiLCBcIldIRVJFXCIsIFwiV0lUSFwiXTtcbmNvbnN0IEpTT05fRlVOQ1RJT05fUkVHRVggPSAvXlxccyooKD86W2Etel0rXyl7MCwyfWpzb25iPyg/Ol9bYS16XSspezAsMn0pXFwoW14pXSpcXCkvaTtcbmNvbnN0IEpTT05fT1BFUkFUT1JfUkVHRVggPSAvXlxccyooLT4+P3xAPnw8QHxcXD9bfCZdP3xcXHx7Mn18Iy0pL2k7XG5jb25zdCBUT0tFTl9DQVBUVVJFX1JFR0VYID0gL15cXHMqKCg/OihbYFwiJ10pKD86KD8hXFwyKS58XFwyezJ9KSpcXDIpfFtcXHdcXGRcXHNdK3xbKCkuLDsrLV0pL2k7XG5jbGFzcyBPcmFjbGVRdWVyeUdlbmVyYXRvciBleHRlbmRzIEFic3RyYWN0UXVlcnlHZW5lcmF0b3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cbiAgZ2V0Q2F0YWxvZ05hbWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucXVvdGVJZGVudGlmaWVycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgcXVvdGVkVmFsdWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcih2YWx1ZSk7XG4gICAgICAgIGlmIChxdW90ZWRWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGdldFNjaGVtYU5hbWVBbmRUYWJsZU5hbWUodGFibGUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0aGlzLmdldENhdGFsb2dOYW1lKHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZSk7XG4gICAgY29uc3Qgc2NoZW1hTmFtZSA9IHRoaXMuZ2V0Q2F0YWxvZ05hbWUodGFibGUuc2NoZW1hKTtcbiAgICByZXR1cm4gW3RhYmxlTmFtZSwgc2NoZW1hTmFtZV07XG4gIH1cbiAgY3JlYXRlU2NoZW1hKHNjaGVtYSkge1xuICAgIGNvbnN0IHF1b3RlZFNjaGVtYSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKHNjaGVtYSk7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiREVDTEFSRVwiLFxuICAgICAgXCJVU0VSX0ZPVU5EIEJPT0xFQU4gOj0gRkFMU0U7XCIsXG4gICAgICBcIkJFR0lOXCIsXG4gICAgICBcIiBCRUdJTlwiLFxuICAgICAgXCIgICBFWEVDVVRFIElNTUVESUFURSBcIixcbiAgICAgIHRoaXMuZXNjYXBlKGBDUkVBVEUgVVNFUiAke3F1b3RlZFNjaGVtYX0gSURFTlRJRklFRCBCWSAxMjM0NSBERUZBVUxUIFRBQkxFU1BBQ0UgVVNFUlNgKSxcbiAgICAgIFwiO1wiLFxuICAgICAgXCIgICBFWENFUFRJT04gV0hFTiBPVEhFUlMgVEhFTlwiLFxuICAgICAgXCIgICAgIElGIFNRTENPREUgIT0gLTE5MjAgVEhFTlwiLFxuICAgICAgXCIgICAgICAgUkFJU0U7XCIsXG4gICAgICBcIiAgICAgRUxTRVwiLFxuICAgICAgXCIgICAgICAgVVNFUl9GT1VORCA6PSBUUlVFO1wiLFxuICAgICAgXCIgICAgIEVORCBJRjtcIixcbiAgICAgIFwiIEVORDtcIixcbiAgICAgIFwiIElGIE5PVCBVU0VSX0ZPVU5EIFRIRU5cIixcbiAgICAgIFwiICAgIEVYRUNVVEUgSU1NRURJQVRFIFwiLFxuICAgICAgdGhpcy5lc2NhcGUoYEdSQU5UIFwiQ09OTkVDVFwiIFRPICR7cXVvdGVkU2NoZW1hfWApLFxuICAgICAgXCI7XCIsXG4gICAgICBcIiAgICBFWEVDVVRFIElNTUVESUFURSBcIixcbiAgICAgIHRoaXMuZXNjYXBlKGBHUkFOVCBDUkVBVEUgVEFCTEUgVE8gJHtxdW90ZWRTY2hlbWF9YCksXG4gICAgICBcIjtcIixcbiAgICAgIFwiICAgIEVYRUNVVEUgSU1NRURJQVRFIFwiLFxuICAgICAgdGhpcy5lc2NhcGUoYEdSQU5UIENSRUFURSBWSUVXIFRPICR7cXVvdGVkU2NoZW1hfWApLFxuICAgICAgXCI7XCIsXG4gICAgICBcIiAgICBFWEVDVVRFIElNTUVESUFURSBcIixcbiAgICAgIHRoaXMuZXNjYXBlKGBHUkFOVCBDUkVBVEUgQU5ZIFRSSUdHRVIgVE8gJHtxdW90ZWRTY2hlbWF9YCksXG4gICAgICBcIjtcIixcbiAgICAgIFwiICAgIEVYRUNVVEUgSU1NRURJQVRFIFwiLFxuICAgICAgdGhpcy5lc2NhcGUoYEdSQU5UIENSRUFURSBBTlkgUFJPQ0VEVVJFIFRPICR7cXVvdGVkU2NoZW1hfWApLFxuICAgICAgXCI7XCIsXG4gICAgICBcIiAgICBFWEVDVVRFIElNTUVESUFURSBcIixcbiAgICAgIHRoaXMuZXNjYXBlKGBHUkFOVCBDUkVBVEUgU0VRVUVOQ0UgVE8gJHtxdW90ZWRTY2hlbWF9YCksXG4gICAgICBcIjtcIixcbiAgICAgIFwiICAgIEVYRUNVVEUgSU1NRURJQVRFIFwiLFxuICAgICAgdGhpcy5lc2NhcGUoYEdSQU5UIENSRUFURSBTWU5PTllNIFRPICR7cXVvdGVkU2NoZW1hfWApLFxuICAgICAgXCI7XCIsXG4gICAgICBcIiAgICBFWEVDVVRFIElNTUVESUFURSBcIixcbiAgICAgIHRoaXMuZXNjYXBlKGBBTFRFUiBVU0VSICR7cXVvdGVkU2NoZW1hfSBRVU9UQSBVTkxJTUlURUQgT04gVVNFUlNgKSxcbiAgICAgIFwiO1wiLFxuICAgICAgXCIgRU5EIElGO1wiLFxuICAgICAgXCJFTkQ7XCJcbiAgICBdLmpvaW4oXCIgXCIpO1xuICB9XG4gIHNob3dTY2hlbWFzUXVlcnkoKSB7XG4gICAgcmV0dXJuIGBTRUxFQ1QgVVNFUk5BTUUgQVMgXCJzY2hlbWFfbmFtZVwiIEZST00gQUxMX1VTRVJTIFdIRVJFIENPTU1PTiA9ICgnTk8nKSBBTkQgVVNFUk5BTUUgIT0gdXNlcmA7XG4gIH1cbiAgZHJvcFNjaGVtYShzY2hlbWEpIHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJCRUdJTlwiLFxuICAgICAgXCJFWEVDVVRFIElNTUVESUFURSBcIixcbiAgICAgIHRoaXMuZXNjYXBlKGBEUk9QIFVTRVIgJHt0aGlzLnF1b3RlVGFibGUoc2NoZW1hKX0gQ0FTQ0FERWApLFxuICAgICAgXCI7XCIsXG4gICAgICBcIkVYQ0VQVElPTiBXSEVOIE9USEVSUyBUSEVOXCIsXG4gICAgICBcIiAgSUYgU1FMQ09ERSAhPSAtMTkxOCBUSEVOXCIsXG4gICAgICBcIiAgICBSQUlTRTtcIixcbiAgICAgIFwiICBFTkQgSUY7XCIsXG4gICAgICBcIkVORDtcIlxuICAgIF0uam9pbihcIiBcIik7XG4gIH1cbiAgdmVyc2lvblF1ZXJ5KCkge1xuICAgIHJldHVybiBcIlNFTEVDVCBWRVJTSU9OX0ZVTEwgRlJPTSBQUk9EVUNUX0NPTVBPTkVOVF9WRVJTSU9OIFdIRVJFIFBST0RVQ1QgTElLRSAnT3JhY2xlJSdcIjtcbiAgfVxuICBjcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHByaW1hcnlLZXlzID0gW10sIGZvcmVpZ25LZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgYXR0clN0ciA9IFtdLCBjaGVja1N0ciA9IFtdO1xuICAgIGNvbnN0IHZhbHVlcyA9IHtcbiAgICAgIHRhYmxlOiB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKVxuICAgIH07XG4gICAgZm9yIChsZXQgYXR0ciBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGVzLCBhdHRyKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IGF0dHJpYnV0ZXNbYXR0cl07XG4gICAgICBhdHRyID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cik7XG4gICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJQUklNQVJZIEtFWVwiKSkge1xuICAgICAgICBwcmltYXJ5S2V5cy5wdXNoKGF0dHIpO1xuICAgICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJSRUZFUkVOQ0VTXCIpKSB7XG4gICAgICAgICAgY29uc3QgbWF0Y2ggPSBkYXRhVHlwZS5tYXRjaCgvXiguKykgKFJFRkVSRU5DRVMuKikkLyk7XG4gICAgICAgICAgYXR0clN0ci5wdXNoKGAke2F0dHJ9ICR7bWF0Y2hbMV0ucmVwbGFjZSgvUFJJTUFSWSBLRVkvLCBcIlwiKX1gKTtcbiAgICAgICAgICBmb3JlaWduS2V5c1thdHRyXSA9IG1hdGNoWzJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0dHJTdHIucHVzaChgJHthdHRyfSAke2RhdGFUeXBlLnJlcGxhY2UoL1BSSU1BUlkgS0VZLywgXCJcIikudHJpbSgpfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiUkVGRVJFTkNFU1wiKSkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGRhdGFUeXBlLm1hdGNoKC9eKC4rKSAoUkVGRVJFTkNFUy4qKSQvKTtcbiAgICAgICAgYXR0clN0ci5wdXNoKGAke2F0dHJ9ICR7bWF0Y2hbMV19YCk7XG4gICAgICAgIGZvcmVpZ25LZXlzW2F0dHJdID0gbWF0Y2hbMl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyU3RyLnB1c2goYCR7YXR0cn0gJHtkYXRhVHlwZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsdWVzW1wiYXR0cmlidXRlc1wiXSA9IGF0dHJTdHIuam9pbihcIiwgXCIpO1xuICAgIGNvbnN0IHBrU3RyaW5nID0gcHJpbWFyeUtleXMubWFwKChwaykgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIocGspKS5qb2luKFwiLCBcIik7XG4gICAgaWYgKHBrU3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhbHVlcy5hdHRyaWJ1dGVzICs9IGAsUFJJTUFSWSBLRVkgKCR7cGtTdHJpbmd9KWA7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmtleSBpbiBmb3JlaWduS2V5cykge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZm9yZWlnbktleXMsIGZrZXkpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChmb3JlaWduS2V5c1tma2V5XS5pbmRleE9mKFwiT04gREVMRVRFIE5PIEFDVElPTlwiKSA+IC0xKSB7XG4gICAgICAgIGZvcmVpZ25LZXlzW2ZrZXldID0gZm9yZWlnbktleXNbZmtleV0ucmVwbGFjZShcIk9OIERFTEVURSBOTyBBQ1RJT05cIiwgXCJcIik7XG4gICAgICB9XG4gICAgICB2YWx1ZXMuYXR0cmlidXRlcyArPSBgLEZPUkVJR04gS0VZICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGZrZXkpfSkgJHtmb3JlaWduS2V5c1tma2V5XX1gO1xuICAgIH1cbiAgICBpZiAoY2hlY2tTdHIubGVuZ3RoID4gMCkge1xuICAgICAgdmFsdWVzLmF0dHJpYnV0ZXMgKz0gYCwgJHtjaGVja1N0ci5qb2luKFwiLCBcIil9YDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbmRleGVzICYmIG9wdGlvbnMuaW5kZXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBpZHhUb0RlbGV0ZSA9IFtdO1xuICAgICAgb3B0aW9ucy5pbmRleGVzLmZvckVhY2goKGluZGV4LCBpZHgpID0+IHtcbiAgICAgICAgaWYgKFwidW5pcXVlXCIgaW4gaW5kZXggJiYgKGluZGV4LnVuaXF1ZSA9PT0gdHJ1ZSB8fCBpbmRleC51bmlxdWUubGVuZ3RoID4gMCAmJiBpbmRleC51bmlxdWUgIT09IGZhbHNlKSkge1xuICAgICAgICAgIGNvbnN0IGZpZWxkcyA9IGluZGV4LmZpZWxkcy5tYXAoKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmaWVsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWVsZC5hdHRyaWJ1dGU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGV0IGNhbkNvbnRpbnVlID0gdHJ1ZTtcbiAgICAgICAgICBpZiAob3B0aW9ucy51bmlxdWVLZXlzKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucy51bmlxdWVLZXlzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGZpZWxkSWR4ID0gMDsgZmllbGRJZHggPCBrZXlzLmxlbmd0aDsgZmllbGRJZHgrKykge1xuICAgICAgICAgICAgICBjb25zdCBjdXJyVW5pcXVlID0gb3B0aW9ucy51bmlxdWVLZXlzW2tleXNbZmllbGRJZHhdXTtcbiAgICAgICAgICAgICAgaWYgKGN1cnJVbmlxdWUuZmllbGRzLmxlbmd0aCA9PT0gZmllbGRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyclVuaXF1ZS5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gY3VyclVuaXF1ZS5maWVsZHNbaV07XG4gICAgICAgICAgICAgICAgICBpZiAoXy5pbmNsdWRlcyhmaWVsZHMsIGZpZWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBjYW5Db250aW51ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuQ29udGludWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5Db250aW51ZSkge1xuICAgICAgICAgICAgICBjb25zdCBpbmRleE5hbWUgPSBcIm5hbWVcIiBpbiBpbmRleCA/IGluZGV4Lm5hbWUgOiBcIlwiO1xuICAgICAgICAgICAgICBjb25zdCBjb25zdHJhaW50VG9BZGQgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogaW5kZXhOYW1lLFxuICAgICAgICAgICAgICAgIGZpZWxkc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoIShcInVuaXF1ZUtleXNcIiBpbiBvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudW5pcXVlS2V5cyA9IHt9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9wdGlvbnMudW5pcXVlS2V5c1tpbmRleE5hbWVdID0gY29uc3RyYWludFRvQWRkO1xuICAgICAgICAgICAgICBpZHhUb0RlbGV0ZS5wdXNoKGlkeCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZHhUb0RlbGV0ZS5wdXNoKGlkeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlkeFRvRGVsZXRlLmZvckVhY2goKGlkeCkgPT4ge1xuICAgICAgICBvcHRpb25zLmluZGV4ZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgJiYgISFvcHRpb25zLnVuaXF1ZUtleXMpIHtcbiAgICAgIF8uZWFjaChvcHRpb25zLnVuaXF1ZUtleXMsIChjb2x1bW5zLCBpbmRleE5hbWUpID0+IHtcbiAgICAgICAgbGV0IGNhbkJlVW5pcSA9IGZhbHNlO1xuICAgICAgICBwcmltYXJ5S2V5cy5mb3JFYWNoKChwcmltYXJ5S2V5KSA9PiB7XG4gICAgICAgICAgcHJpbWFyeUtleSA9IHByaW1hcnlLZXkucmVwbGFjZSgvXCIvZywgXCJcIik7XG4gICAgICAgICAgaWYgKCFfLmluY2x1ZGVzKGNvbHVtbnMuZmllbGRzLCBwcmltYXJ5S2V5KSkge1xuICAgICAgICAgICAgY2FuQmVVbmlxID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb2x1bW5zLmZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgIGxldCBjdXJyRmllbGQgPSBcIlwiO1xuICAgICAgICAgIGlmICghXy5pc1N0cmluZyhmaWVsZCkpIHtcbiAgICAgICAgICAgIGN1cnJGaWVsZCA9IGZpZWxkLmF0dHJpYnV0ZS5yZXBsYWNlKC9bLixcIlxcc10vZywgXCJcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJGaWVsZCA9IGZpZWxkLnJlcGxhY2UoL1suLFwiXFxzXS9nLCBcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGN1cnJGaWVsZCBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlc1tjdXJyRmllbGRdLnRvVXBwZXJDYXNlKCkuaW5kZXhPZihcIlVOSVFVRVwiKSA+IC0xICYmIGNhbkJlVW5pcSkge1xuICAgICAgICAgICAgICBjb25zdCBhdHRyVG9SZXBsYWNlID0gYXR0cmlidXRlc1tjdXJyRmllbGRdLnJlcGxhY2UoXCJVTklRVUVcIiwgXCJcIik7XG4gICAgICAgICAgICAgIHZhbHVlcy5hdHRyaWJ1dGVzID0gdmFsdWVzLmF0dHJpYnV0ZXMucmVwbGFjZShhdHRyaWJ1dGVzW2N1cnJGaWVsZF0sIGF0dHJUb1JlcGxhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjYW5CZVVuaXEpIHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IG9wdGlvbnMudW5pcXVlS2V5c1tjb2x1bW5zLm5hbWVdO1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnVuaXF1ZUtleXNbY29sdW1ucy5uYW1lXTtcbiAgICAgICAgICBpbmRleE5hbWUgPSBpbmRleE5hbWUucmVwbGFjZSgvWy4sXFxzXS9nLCBcIlwiKTtcbiAgICAgICAgICBjb2x1bW5zLm5hbWUgPSBpbmRleE5hbWU7XG4gICAgICAgICAgb3B0aW9ucy51bmlxdWVLZXlzW2luZGV4TmFtZV0gPSBpbmRleDtcbiAgICAgICAgICBpZiAoaW5kZXhOYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdmFsdWVzLmF0dHJpYnV0ZXMgKz0gYCxVTklRVUUgKCR7Y29sdW1ucy5maWVsZHMubWFwKChmaWVsZCkgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQpKS5qb2luKFwiLCBcIil9KWA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlcy5hdHRyaWJ1dGVzICs9IGAsIENPTlNUUkFJTlQgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihpbmRleE5hbWUpfSBVTklRVUUgKCR7Y29sdW1ucy5maWVsZHMubWFwKChmaWVsZCkgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQpKS5qb2luKFwiLCBcIil9KWA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcXVlcnkgPSBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQ1JFQVRFIFRBQkxFXCIsXG4gICAgICB2YWx1ZXMudGFibGUsXG4gICAgICBgKCR7dmFsdWVzLmF0dHJpYnV0ZXN9KWBcbiAgICBdKTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkJFR0lOXCIsXG4gICAgICBcIkVYRUNVVEUgSU1NRURJQVRFXCIsXG4gICAgICBgJHt0aGlzLmVzY2FwZShxdWVyeSl9O2AsXG4gICAgICBcIkVYQ0VQVElPTiBXSEVOIE9USEVSUyBUSEVOXCIsXG4gICAgICBcIklGIFNRTENPREUgIT0gLTk1NSBUSEVOXCIsXG4gICAgICBcIlJBSVNFO1wiLFxuICAgICAgXCJFTkQgSUY7XCIsXG4gICAgICBcIkVORDtcIlxuICAgIF0pO1xuICB9XG4gIHRhYmxlRXhpc3RzUXVlcnkodGFibGUpIHtcbiAgICBjb25zdCBbdGFibGVOYW1lLCBzY2hlbWFOYW1lXSA9IHRoaXMuZ2V0U2NoZW1hTmFtZUFuZFRhYmxlTmFtZSh0YWJsZSk7XG4gICAgcmV0dXJuIGBTRUxFQ1QgVEFCTEVfTkFNRSBGUk9NIEFMTF9UQUJMRVMgV0hFUkUgVEFCTEVfTkFNRSA9ICR7dGhpcy5lc2NhcGUodGFibGVOYW1lKX0gQU5EIE9XTkVSID0gJHt0YWJsZS5zY2hlbWEgPyB0aGlzLmVzY2FwZShzY2hlbWFOYW1lKSA6IFwiVVNFUlwifWA7XG4gIH1cbiAgZGVzY3JpYmVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgc2NoZW1hKSB7XG4gICAgY29uc3QgY3VyclRhYmxlTmFtZSA9IHRoaXMuZ2V0Q2F0YWxvZ05hbWUodGFibGVOYW1lLnRhYmxlTmFtZSB8fCB0YWJsZU5hbWUpO1xuICAgIHNjaGVtYSA9IHRoaXMuZ2V0Q2F0YWxvZ05hbWUoc2NoZW1hKTtcbiAgICByZXR1cm4gW1xuICAgICAgXCJTRUxFQ1QgYXRjLkNPTFVNTl9OQU1FLCBhdGMuREFUQV9UWVBFLCBhdGMuREFUQV9MRU5HVEgsIGF0Yy5DSEFSX0xFTkdUSCwgYXRjLkRFRkFVTFRfTEVOR1RILCBhdGMuTlVMTEFCTEUsIHVjYy5jb25zdHJhaW50X3R5cGUgXCIsXG4gICAgICBcIkZST00gYWxsX3RhYl9jb2x1bW5zIGF0YyBcIixcbiAgICAgIFwiTEVGVCBPVVRFUiBKT0lOIFwiLFxuICAgICAgXCIoU0VMRUNUIGFjYy5jb2x1bW5fbmFtZSwgYWNjLnRhYmxlX25hbWUsIGFjLmNvbnN0cmFpbnRfdHlwZSBGUk9NIGFsbF9jb25zX2NvbHVtbnMgYWNjIElOTkVSIEpPSU4gYWxsX2NvbnN0cmFpbnRzIGFjIE9OIGFjYy5jb25zdHJhaW50X25hbWUgPSBhYy5jb25zdHJhaW50X25hbWUpIHVjYyBcIixcbiAgICAgIFwiT04gKGF0Yy50YWJsZV9uYW1lID0gdWNjLnRhYmxlX25hbWUgQU5EIGF0Yy5DT0xVTU5fTkFNRSA9IHVjYy5DT0xVTU5fTkFNRSkgXCIsXG4gICAgICBzY2hlbWEgPyBgV0hFUkUgKGF0Yy5PV05FUiA9ICR7dGhpcy5lc2NhcGUoc2NoZW1hKX0pIGAgOiBcIldIRVJFIGF0Yy5PV05FUiA9IFVTRVIgXCIsXG4gICAgICBgQU5EIChhdGMuVEFCTEVfTkFNRSA9ICR7dGhpcy5lc2NhcGUoY3VyclRhYmxlTmFtZSl9KWAsXG4gICAgICBcIk9SREVSIEJZIGF0Yy5DT0xVTU5fTkFNRSwgQ09OU1RSQUlOVF9UWVBFIERFU0NcIlxuICAgIF0uam9pbihcIlwiKTtcbiAgfVxuICByZW5hbWVUYWJsZVF1ZXJ5KGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUoYmVmb3JlKSxcbiAgICAgIFwiUkVOQU1FIFRPXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUoYWZ0ZXIpXG4gICAgXSk7XG4gIH1cbiAgc2hvd0NvbnN0cmFpbnRzUXVlcnkodGFibGUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0aGlzLmdldENhdGFsb2dOYW1lKHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZSk7XG4gICAgcmV0dXJuIGBTRUxFQ1QgQ09OU1RSQUlOVF9OQU1FIGNvbnN0cmFpbnRfbmFtZSBGUk9NIHVzZXJfY29uc19jb2x1bW5zIFdIRVJFIHRhYmxlX25hbWUgPSAke3RoaXMuZXNjYXBlKHRhYmxlTmFtZSl9YDtcbiAgfVxuICBzaG93VGFibGVzUXVlcnkoKSB7XG4gICAgcmV0dXJuIGBTRUxFQ1Qgb3duZXIgYXMgdGFibGVfc2NoZW1hLCB0YWJsZV9uYW1lLCAwIGFzIGx2bCBGUk9NIGFsbF90YWJsZXMgd2hlcmUgT1dORVIgSU4oU0VMRUNUIFVTRVJOQU1FIEFTIFwic2NoZW1hX25hbWVcIiBGUk9NIEFMTF9VU0VSUyBXSEVSRSBPUkFDTEVfTUFJTlRBSU5FRCA9ICdOJylgO1xuICB9XG4gIGRyb3BUYWJsZVF1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQkVHSU4gXCIsXG4gICAgICBcIkVYRUNVVEUgSU1NRURJQVRFICdEUk9QIFRBQkxFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIFwiQ0FTQ0FERSBDT05TVFJBSU5UUyBQVVJHRSc7XCIsXG4gICAgICBcIkVYQ0VQVElPTiBXSEVOIE9USEVSUyBUSEVOXCIsXG4gICAgICBcIiBJRiBTUUxDT0RFICE9IC05NDIgVEhFTlwiLFxuICAgICAgXCIgICBSQUlTRTtcIixcbiAgICAgIFwiIEVORCBJRjtcIixcbiAgICAgIFwiRU5EO1wiXG4gICAgXSk7XG4gIH1cbiAgYWRkSW5kZXhRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMsIHJhd1RhYmxlbmFtZSkge1xuICAgIGlmICh0eXBlb2YgdGFibGVOYW1lICE9PSBcInN0cmluZ1wiICYmIGF0dHJpYnV0ZXMubmFtZSkge1xuICAgICAgYXR0cmlidXRlcy5uYW1lID0gYCR7dGFibGVOYW1lLnNjaGVtYX0uJHthdHRyaWJ1dGVzLm5hbWV9YDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmFkZEluZGV4UXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zLCByYXdUYWJsZW5hbWUpO1xuICB9XG4gIGFkZENvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAob3B0aW9ucy5vblVwZGF0ZSkge1xuICAgICAgZGVsZXRlIG9wdGlvbnMub25VcGRhdGU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm9uRGVsZXRlICYmIG9wdGlvbnMub25EZWxldGUudG9VcHBlckNhc2UoKSA9PT0gXCJOTyBBQ1RJT05cIikge1xuICAgICAgZGVsZXRlIG9wdGlvbnMub25EZWxldGU7XG4gICAgfVxuICAgIGNvbnN0IGNvbnN0cmFpbnRTbmlwcGV0ID0gdGhpcy5nZXRDb25zdHJhaW50U25pcHBldCh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIHRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIHJldHVybiBgQUxURVIgVEFCTEUgJHt0YWJsZU5hbWV9IEFERCAke2NvbnN0cmFpbnRTbmlwcGV0fTtgO1xuICB9XG4gIGFkZENvbHVtblF1ZXJ5KHRhYmxlLCBrZXksIGRhdGFUeXBlKSB7XG4gICAgZGF0YVR5cGUuZmllbGQgPSBrZXk7XG4gICAgY29uc3QgYXR0cmlidXRlID0gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpLFxuICAgICAgdGhpcy5hdHRyaWJ1dGVUb1NRTChkYXRhVHlwZSwge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lOiBrZXksXG4gICAgICAgIGNvbnRleHQ6IFwiYWRkQ29sdW1uXCJcbiAgICAgIH0pXG4gICAgXSk7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlKSxcbiAgICAgIFwiQUREXCIsXG4gICAgICBhdHRyaWJ1dGVcbiAgICBdKTtcbiAgfVxuICByZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIFwiRFJPUCBDT0xVTU5cIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBfYWx0ZXJGb3JlaWduS2V5Q29uc3RyYWludChkZWZpbml0aW9uLCB0YWJsZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIGNvbnN0IFt0YWJsZU5hbWUsIHNjaGVtYU5hbWVdID0gdGhpcy5nZXRTY2hlbWFOYW1lQW5kVGFibGVOYW1lKHRhYmxlKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVOYW1lQ29uc3RhbnQgPSB0aGlzLmVzY2FwZSh0aGlzLmdldENhdGFsb2dOYW1lKGF0dHJpYnV0ZU5hbWUpKTtcbiAgICBjb25zdCBzY2hlbWFOYW1lQ29uc3RhbnQgPSB0YWJsZS5zY2hlbWEgPyB0aGlzLmVzY2FwZSh0aGlzLmdldENhdGFsb2dOYW1lKHNjaGVtYU5hbWUpKSA6IFwiVVNFUlwiO1xuICAgIGNvbnN0IHRhYmxlTmFtZUNvbnN0YW50ID0gdGhpcy5lc2NhcGUodGhpcy5nZXRDYXRhbG9nTmFtZSh0YWJsZU5hbWUpKTtcbiAgICBjb25zdCBnZXRDb25zTmFtZVF1ZXJ5ID0gW1xuICAgICAgXCJTRUxFQ1QgY29uc3RyYWludF9uYW1lIElOVE8gY29uc19uYW1lXCIsXG4gICAgICBcIkZST00gKFwiLFxuICAgICAgXCIgIFNFTEVDVCBESVNUSU5DVCBjYy5vd25lciwgY2MudGFibGVfbmFtZSwgY2MuY29uc3RyYWludF9uYW1lLCBjYy5jb2x1bW5fbmFtZSBBUyBjb25zX2NvbHVtbnNcIixcbiAgICAgIFwiICBGUk9NIGFsbF9jb25zX2NvbHVtbnMgY2MsIGFsbF9jb25zdHJhaW50cyBjXCIsXG4gICAgICBcIiAgV0hFUkUgY2Mub3duZXIgPSBjLm93bmVyXCIsXG4gICAgICBcIiAgQU5EIGNjLnRhYmxlX25hbWUgPSBjLnRhYmxlX25hbWVcIixcbiAgICAgIFwiICBBTkQgY2MuY29uc3RyYWludF9uYW1lID0gYy5jb25zdHJhaW50X25hbWVcIixcbiAgICAgIFwiICBBTkQgYy5jb25zdHJhaW50X3R5cGUgPSAnUidcIixcbiAgICAgIFwiICBHUk9VUCBCWSBjYy5vd25lciwgY2MudGFibGVfbmFtZSwgY2MuY29uc3RyYWludF9uYW1lLCBjYy5jb2x1bW5fbmFtZVwiLFxuICAgICAgXCIpXCIsXG4gICAgICBcIldIRVJFIG93bmVyID1cIixcbiAgICAgIHNjaGVtYU5hbWVDb25zdGFudCxcbiAgICAgIFwiQU5EIHRhYmxlX25hbWUgPVwiLFxuICAgICAgdGFibGVOYW1lQ29uc3RhbnQsXG4gICAgICBcIkFORCBjb25zX2NvbHVtbnMgPVwiLFxuICAgICAgYXR0cmlidXRlTmFtZUNvbnN0YW50LFxuICAgICAgXCI7XCJcbiAgICBdLmpvaW4oXCIgXCIpO1xuICAgIGNvbnN0IHNlY29uZFF1ZXJ5ID0gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBgQUxURVIgVEFCTEUgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0YWJsZU5hbWUpfWAsXG4gICAgICBcIkFERCBGT1JFSUdOIEtFWVwiLFxuICAgICAgYCgke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpfSlgLFxuICAgICAgZGVmaW5pdGlvbi5yZXBsYWNlKC8uKz8oPz1SRUZFUkVOQ0VTKS8sIFwiXCIpXG4gICAgXSk7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiQkVHSU5cIixcbiAgICAgIGdldENvbnNOYW1lUXVlcnksXG4gICAgICBcIkVYQ0VQVElPTlwiLFxuICAgICAgXCJXSEVOIE5PX0RBVEFfRk9VTkQgVEhFTlwiLFxuICAgICAgXCIgQ09OU19OQU1FIDo9IE5VTEw7XCIsXG4gICAgICBcIkVORDtcIixcbiAgICAgIFwiSUYgQ09OU19OQU1FIElTIE5PVCBOVUxMIFRIRU5cIixcbiAgICAgIGAgRVhFQ1VURSBJTU1FRElBVEUgJ0FMVEVSIFRBQkxFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlKX0gRFJPUCBDT05TVFJBSU5UIFwiJ3x8Q09OU19OQU1FfHwnXCInO2AsXG4gICAgICBcIkVORCBJRjtcIixcbiAgICAgIGBFWEVDVVRFIElNTUVESUFURSAke3RoaXMuZXNjYXBlKHNlY29uZFF1ZXJ5KX07YFxuICAgIF0uam9pbihcIiBcIik7XG4gIH1cbiAgX21vZGlmeVF1ZXJ5KGRlZmluaXRpb24sIHRhYmxlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgY29uc3QgcXVlcnkgPSBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQUxURVIgVEFCTEVcIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZSksXG4gICAgICBcIk1PRElGWVwiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSksXG4gICAgICBkZWZpbml0aW9uXG4gICAgXSk7XG4gICAgY29uc3Qgc2Vjb25kUXVlcnkgPSBxdWVyeS5yZXBsYWNlKFwiTk9UIE5VTExcIiwgXCJcIikucmVwbGFjZShcIk5VTExcIiwgXCJcIik7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiQkVHSU5cIixcbiAgICAgIGBFWEVDVVRFIElNTUVESUFURSAke3RoaXMuZXNjYXBlKHF1ZXJ5KX07YCxcbiAgICAgIFwiRVhDRVBUSU9OXCIsXG4gICAgICBcIldIRU4gT1RIRVJTIFRIRU5cIixcbiAgICAgIFwiIElGIFNRTENPREUgPSAtMTQ0MiBPUiBTUUxDT0RFID0gLTE0NTEgVEhFTlwiLFxuICAgICAgYCAgIEVYRUNVVEUgSU1NRURJQVRFICR7dGhpcy5lc2NhcGUoc2Vjb25kUXVlcnkpfTtgLFxuICAgICAgXCIgRUxTRVwiLFxuICAgICAgXCIgICBSQUlTRTtcIixcbiAgICAgIFwiIEVORCBJRjtcIixcbiAgICAgIFwiRU5EO1wiXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgfVxuICBjaGFuZ2VDb2x1bW5RdWVyeSh0YWJsZSwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHNxbCA9IFtcbiAgICAgIFwiREVDTEFSRVwiLFxuICAgICAgXCJDT05TX05BTUUgVkFSQ0hBUjIoMjAwKTtcIixcbiAgICAgIFwiQkVHSU5cIlxuICAgIF07XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZXMsIGF0dHJpYnV0ZU5hbWUpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgaWYgKGRlZmluaXRpb24ubWF0Y2goL1JFRkVSRU5DRVMvKSkge1xuICAgICAgICBzcWwucHVzaCh0aGlzLl9hbHRlckZvcmVpZ25LZXlDb25zdHJhaW50KGRlZmluaXRpb24sIHRhYmxlLCBhdHRyaWJ1dGVOYW1lKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcWwucHVzaCh0aGlzLl9tb2RpZnlRdWVyeShkZWZpbml0aW9uLCB0YWJsZSwgYXR0cmlidXRlTmFtZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBzcWwucHVzaChcIkVORDtcIik7XG4gICAgcmV0dXJuIHNxbC5qb2luKFwiIFwiKTtcbiAgfVxuICByZW5hbWVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJCZWZvcmUsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBuZXdOYW1lID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcylbMF07XG4gICAgcmV0dXJuIGBBTFRFUiBUQUJMRSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSBSRU5BTUUgQ09MVU1OICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0ckJlZm9yZSl9IFRPICR7dGhpcy5xdW90ZUlkZW50aWZpZXIobmV3TmFtZSl9YDtcbiAgfVxuICBwb3B1bGF0ZUluc2VydFF1ZXJ5UmV0dXJuSW50b0JpbmRzKHJldHVybmluZ01vZGVsQXR0cmlidXRlcywgcmV0dXJuVHlwZXMsIGluYmluZExlbmd0aCwgcmV0dXJuQXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IG9yYWNsZWRiID0gdGhpcy5zZXF1ZWxpemUuY29ubmVjdGlvbk1hbmFnZXIubGliO1xuICAgIGNvbnN0IG91dEJpbmRBdHRyaWJ1dGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBvdXRiaW5kID0gW107XG4gICAgY29uc3Qgb3V0YmluZFBhcmFtID0gdGhpcy5iaW5kUGFyYW0ob3V0YmluZCwgaW5iaW5kTGVuZ3RoKTtcbiAgICByZXR1cm5pbmdNb2RlbEF0dHJpYnV0ZXMuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChlbGVtZW50LnN0YXJ0c1dpdGgoJ1wiJykpIHtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQuc3Vic3RyaW5nKDEsIGVsZW1lbnQubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICBvdXRCaW5kQXR0cmlidXRlc1tlbGVtZW50XSA9IE9iamVjdC5hc3NpZ24ocmV0dXJuVHlwZXNbaW5kZXhdLl9nZXRCaW5kRGVmKG9yYWNsZWRiKSwgeyBkaXI6IG9yYWNsZWRiLkJJTkRfT1VUIH0pO1xuICAgICAgY29uc3QgcmV0dXJuQXR0cmlidXRlID0gYCR7dGhpcy5mb3JtYXQodm9pZCAwLCB2b2lkIDAsIHsgY29udGV4dDogXCJJTlNFUlRcIiB9LCBvdXRiaW5kUGFyYW0pfWA7XG4gICAgICByZXR1cm5BdHRyaWJ1dGVzLnB1c2gocmV0dXJuQXR0cmlidXRlKTtcbiAgICB9KTtcbiAgICBvcHRpb25zLm91dEJpbmRBdHRyaWJ1dGVzID0gb3V0QmluZEF0dHJpYnV0ZXM7XG4gIH1cbiAgdXBzZXJ0UXVlcnkodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIHVwZGF0ZVZhbHVlcywgd2hlcmUsIG1vZGVsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmF3QXR0cmlidXRlcyA9IG1vZGVsLnJhd0F0dHJpYnV0ZXM7XG4gICAgY29uc3QgdXBkYXRlUXVlcnkgPSB0aGlzLnVwZGF0ZVF1ZXJ5KHRhYmxlTmFtZSwgdXBkYXRlVmFsdWVzLCB3aGVyZSwgb3B0aW9ucywgcmF3QXR0cmlidXRlcyk7XG4gICAgb3B0aW9ucy5iaW5kID0gdXBkYXRlUXVlcnkuYmluZDtcbiAgICBjb25zdCBpbnNlcnRRdWVyeSA9IHRoaXMuaW5zZXJ0UXVlcnkodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIHJhd0F0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHNxbCA9IFtcbiAgICAgIFwiREVDTEFSRSBcIixcbiAgICAgIFwiQkVHSU4gXCIsXG4gICAgICB1cGRhdGVRdWVyeS5xdWVyeSA/IFtcbiAgICAgICAgdXBkYXRlUXVlcnkucXVlcnksXG4gICAgICAgIFwiOyBcIixcbiAgICAgICAgXCIgSUYgKCBTUUwlUk9XQ09VTlQgPSAwICkgVEhFTiBcIixcbiAgICAgICAgaW5zZXJ0UXVlcnkucXVlcnksXG4gICAgICAgIFwiIDppc1VwZGF0ZSA6PSAwOyBcIixcbiAgICAgICAgXCJFTFNFIFwiLFxuICAgICAgICBcIiA6aXNVcGRhdGUgOj0gMTsgXCIsXG4gICAgICAgIFwiIEVORCBJRjsgXCJcbiAgICAgIF0uam9pbihcIlwiKSA6IFtcbiAgICAgICAgaW5zZXJ0UXVlcnkucXVlcnksXG4gICAgICAgIFwiIDppc1VwZGF0ZSA6PSAwOyBcIixcbiAgICAgICAgXCJFWENFUFRJT04gV0hFTiBPVEhFUlMgVEhFTlwiLFxuICAgICAgICBcIiBJRiBTUUxDT0RFICE9IC0xIFRIRU5cIixcbiAgICAgICAgXCIgICBSQUlTRTtcIixcbiAgICAgICAgXCIgRU5EIElGO1wiXG4gICAgICBdLmpvaW4oXCJcIiksXG4gICAgICBcIkVORDtcIlxuICAgIF07XG4gICAgY29uc3QgcXVlcnkgPSBzcWwuam9pbihcIlwiKTtcbiAgICBjb25zdCByZXN1bHQgPSB7IHF1ZXJ5IH07XG4gICAgaWYgKG9wdGlvbnMuYmluZFBhcmFtICE9PSBmYWxzZSkge1xuICAgICAgcmVzdWx0LmJpbmQgPSB1cGRhdGVRdWVyeS5iaW5kIHx8IGluc2VydFF1ZXJ5LmJpbmQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYnVsa0luc2VydFF1ZXJ5KHRhYmxlTmFtZSwgZmllbGRWYWx1ZUhhc2hlcywgb3B0aW9ucywgZmllbGRNYXBwZWRBdHRyaWJ1dGVzKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5leGVjdXRlTWFueSA9IHRydWU7XG4gICAgZmllbGRNYXBwZWRBdHRyaWJ1dGVzID0gZmllbGRNYXBwZWRBdHRyaWJ1dGVzIHx8IHt9O1xuICAgIGNvbnN0IHR1cGxlcyA9IFtdO1xuICAgIGNvbnN0IGFsbENvbHVtbnMgPSB7fTtcbiAgICBjb25zdCBpbkJpbmRCaW5kRGVmTWFwID0ge307XG4gICAgY29uc3Qgb3V0QmluZEJpbmREZWZNYXAgPSB7fTtcbiAgICBjb25zdCBvcmFjbGVkYiA9IHRoaXMuc2VxdWVsaXplLmNvbm5lY3Rpb25NYW5hZ2VyLmxpYjtcbiAgICBmb3IgKGNvbnN0IGZpZWxkVmFsdWVIYXNoIG9mIGZpZWxkVmFsdWVIYXNoZXMpIHtcbiAgICAgIF8uZm9yT3duKGZpZWxkVmFsdWVIYXNoLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBhbGxDb2x1bW5zW2tleV0gPSBmaWVsZE1hcHBlZEF0dHJpYnV0ZXNba2V5XSAmJiBmaWVsZE1hcHBlZEF0dHJpYnV0ZXNba2V5XS5hdXRvSW5jcmVtZW50ID09PSB0cnVlICYmIHZhbHVlID09PSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBpbkJpbmRQb3NpdGlvbjtcbiAgICBmb3IgKGNvbnN0IGZpZWxkVmFsdWVIYXNoIG9mIGZpZWxkVmFsdWVIYXNoZXMpIHtcbiAgICAgIGNvbnN0IHR1cGxlID0gW107XG4gICAgICBjb25zdCBpbmJpbmRQYXJhbSA9IG9wdGlvbnMuYmluZFBhcmFtID09PSB2b2lkIDAgPyB0aGlzLmJpbmRQYXJhbSh0dXBsZSkgOiBvcHRpb25zLmJpbmRQYXJhbTtcbiAgICAgIGNvbnN0IHRlbXBCaW5kUG9zaXRpb25zID0gT2JqZWN0LmtleXMoYWxsQ29sdW1ucykubWFwKChrZXkpID0+IHtcbiAgICAgICAgaWYgKGFsbENvbHVtbnNba2V5XSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmIChmaWVsZFZhbHVlSGFzaFtrZXldICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkZvciBhbiBhdXRvLWluY3JlbWVudCBjb2x1bW4gZWl0aGVyIGFsbCByb3cgbXVzdCBiZSBudWxsIG9yIG5vbi1udWxsLCBhIG1peCBvZiBudWxsIGFuZCBub24tbnVsbCBpcyBub3QgYWxsb3dlZCFcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBcIkRFRkFVTFRcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoZmllbGRWYWx1ZUhhc2hba2V5XSwgZmllbGRNYXBwZWRBdHRyaWJ1dGVzW2tleV0sIHsgY29udGV4dDogXCJJTlNFUlRcIiB9LCBpbmJpbmRQYXJhbSk7XG4gICAgICB9KTtcbiAgICAgIGlmICghaW5CaW5kUG9zaXRpb24pIHtcbiAgICAgICAgaW5CaW5kUG9zaXRpb24gPSB0ZW1wQmluZFBvc2l0aW9ucztcbiAgICAgIH1cbiAgICAgIHR1cGxlcy5wdXNoKHR1cGxlKTtcbiAgICB9XG4gICAgY29uc3QgcmV0dXJuQ29sdW1uID0gW107XG4gICAgY29uc3QgcmV0dXJuQ29sdW1uQmluZFBvc2l0aW9ucyA9IFtdO1xuICAgIGNvbnN0IGluc2VydENvbHVtbnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhhbGxDb2x1bW5zKSkge1xuICAgICAgaWYgKGZpZWxkTWFwcGVkQXR0cmlidXRlc1trZXldKSB7XG4gICAgICAgIGNvbnN0IGJpbmREZWYgPSBmaWVsZE1hcHBlZEF0dHJpYnV0ZXNba2V5XS50eXBlLl9nZXRCaW5kRGVmKG9yYWNsZWRiKTtcbiAgICAgICAgaWYgKGFsbENvbHVtbnNba2V5XSkge1xuICAgICAgICAgIGJpbmREZWYuZGlyID0gb3JhY2xlZGIuQklORF9PVVQ7XG4gICAgICAgICAgb3V0QmluZEJpbmREZWZNYXBba2V5XSA9IGJpbmREZWY7XG4gICAgICAgICAgcmV0dXJuQ29sdW1uLnB1c2godGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KSk7XG4gICAgICAgICAgcmV0dXJuQ29sdW1uQmluZFBvc2l0aW9ucy5wdXNoKGA6JHt0dXBsZXNbMF0ubGVuZ3RoICsgcmV0dXJuQ29sdW1uLmxlbmd0aH1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiaW5kRGVmLmRpciA9IG9yYWNsZWRiLkJJTkRfSU47XG4gICAgICAgICAgaW5CaW5kQmluZERlZk1hcFtrZXldID0gYmluZERlZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5zZXJ0Q29sdW1ucy5wdXNoKHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSkpO1xuICAgIH1cbiAgICBsZXQgcXVlcnkgPSBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiSU5TRVJUXCIsXG4gICAgICBcIklOVE9cIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgYCgke2luc2VydENvbHVtbnMuam9pbihcIixcIil9KWAsXG4gICAgICBcIlZBTFVFU1wiLFxuICAgICAgYCgke2luQmluZFBvc2l0aW9ufSlgXG4gICAgXSk7XG4gICAgaWYgKHJldHVybkNvbHVtbi5sZW5ndGggPiAwKSB7XG4gICAgICBvcHRpb25zLm91dEJpbmRBdHRyaWJ1dGVzID0gb3V0QmluZEJpbmREZWZNYXA7XG4gICAgICBxdWVyeSA9IFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgICBxdWVyeSxcbiAgICAgICAgXCJSRVRVUk5JTkdcIixcbiAgICAgICAgYCR7cmV0dXJuQ29sdW1uLmpvaW4oXCIsXCIpfWAsXG4gICAgICAgIFwiSU5UT1wiLFxuICAgICAgICBgJHtyZXR1cm5Db2x1bW5CaW5kUG9zaXRpb25zfWBcbiAgICAgIF0pO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7IHF1ZXJ5IH07XG4gICAgcmVzdWx0LmJpbmQgPSB0dXBsZXM7XG4gICAgb3B0aW9ucy5pbmJpbmRBdHRyaWJ1dGVzID0gaW5CaW5kQmluZERlZk1hcDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHRydW5jYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gYFRSVU5DQVRFIFRBQkxFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9YDtcbiAgfVxuICBkZWxldGVRdWVyeSh0YWJsZU5hbWUsIHdoZXJlLCBvcHRpb25zLCBtb2RlbCkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHRhYmxlID0gdGFibGVOYW1lO1xuICAgIHdoZXJlID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnMod2hlcmUsIG51bGwsIG1vZGVsLCBvcHRpb25zKTtcbiAgICBsZXQgcXVlcnlUbXBsO1xuICAgIGlmIChvcHRpb25zLmxpbWl0KSB7XG4gICAgICBjb25zdCB3aGVyZVRtcGwgPSB3aGVyZSA/IGAgQU5EICR7d2hlcmV9YCA6IFwiXCI7XG4gICAgICBxdWVyeVRtcGwgPSBgREVMRVRFIEZST00gJHt0aGlzLnF1b3RlVGFibGUodGFibGUpfSBXSEVSRSByb3dpZCBJTiAoU0VMRUNUIHJvd2lkIEZST00gJHt0aGlzLnF1b3RlVGFibGUodGFibGUpfSBXSEVSRSByb3dudW0gPD0gJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX0ke3doZXJlVG1wbH0pYDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd2hlcmVUbXBsID0gd2hlcmUgPyBgIFdIRVJFICR7d2hlcmV9YCA6IFwiXCI7XG4gICAgICBxdWVyeVRtcGwgPSBgREVMRVRFIEZST00gJHt0aGlzLnF1b3RlVGFibGUodGFibGUpfSR7d2hlcmVUbXBsfWA7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeVRtcGw7XG4gIH1cbiAgc2hvd0luZGV4ZXNRdWVyeSh0YWJsZSkge1xuICAgIGNvbnN0IFt0YWJsZU5hbWUsIG93bmVyXSA9IHRoaXMuZ2V0U2NoZW1hTmFtZUFuZFRhYmxlTmFtZSh0YWJsZSk7XG4gICAgY29uc3Qgc3FsID0gW1xuICAgICAgXCJTRUxFQ1QgaS5pbmRleF9uYW1lLGkudGFibGVfbmFtZSwgaS5jb2x1bW5fbmFtZSwgdS51bmlxdWVuZXNzLCBpLmRlc2NlbmQsIGMuY29uc3RyYWludF90eXBlIFwiLFxuICAgICAgXCJGUk9NIGFsbF9pbmRfY29sdW1ucyBpIFwiLFxuICAgICAgXCJJTk5FUiBKT0lOIGFsbF9pbmRleGVzIHUgXCIsXG4gICAgICBcIk9OICh1LnRhYmxlX25hbWUgPSBpLnRhYmxlX25hbWUgQU5EIHUuaW5kZXhfbmFtZSA9IGkuaW5kZXhfbmFtZSkgXCIsXG4gICAgICBcIkxFRlQgT1VURVIgSk9JTiBhbGxfY29uc3RyYWludHMgYyBcIixcbiAgICAgIFwiT04gKGMudGFibGVfbmFtZSA9IGkudGFibGVfbmFtZSBBTkQgYy5pbmRleF9uYW1lID0gaS5pbmRleF9uYW1lKSBcIixcbiAgICAgIGBXSEVSRSBpLnRhYmxlX25hbWUgPSAke3RoaXMuZXNjYXBlKHRhYmxlTmFtZSl9YCxcbiAgICAgIFwiIEFORCB1LnRhYmxlX293bmVyID0gXCIsXG4gICAgICBvd25lciA/IHRoaXMuZXNjYXBlKG93bmVyKSA6IFwiVVNFUlwiLFxuICAgICAgXCIgT1JERVIgQlkgaW5kZXhfbmFtZSwgY29sdW1uX3Bvc2l0aW9uXCJcbiAgICBdO1xuICAgIHJldHVybiBzcWwuam9pbihcIlwiKTtcbiAgfVxuICByZW1vdmVJbmRleFF1ZXJ5KHRhYmxlTmFtZSwgaW5kZXhOYW1lT3JBdHRyaWJ1dGVzKSB7XG4gICAgbGV0IGluZGV4TmFtZSA9IGluZGV4TmFtZU9yQXR0cmlidXRlcztcbiAgICBpZiAodHlwZW9mIGluZGV4TmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgaW5kZXhOYW1lID0gVXRpbHMudW5kZXJzY29yZShgJHt0YWJsZU5hbWV9XyR7aW5kZXhOYW1lT3JBdHRyaWJ1dGVzLmpvaW4oXCJfXCIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gYERST1AgSU5ERVggJHt0aGlzLnF1b3RlSWRlbnRpZmllcihpbmRleE5hbWUpfWA7XG4gIH1cbiAgYXR0cmlidXRlVG9TUUwoYXR0cmlidXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFfLmlzUGxhaW5PYmplY3QoYXR0cmlidXRlKSkge1xuICAgICAgYXR0cmlidXRlID0ge1xuICAgICAgICB0eXBlOiBhdHRyaWJ1dGVcbiAgICAgIH07XG4gICAgfVxuICAgIGF0dHJpYnV0ZS5vblVwZGF0ZSA9IFwiXCI7XG4gICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzKSB7XG4gICAgICBpZiAoYXR0cmlidXRlLk1vZGVsICYmIGF0dHJpYnV0ZS5Nb2RlbC50YWJsZU5hbWUgPT09IGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsKSB7XG4gICAgICAgIHRoaXMuc2VxdWVsaXplLmxvZyhcIk9yYWNsZSBkb2VzIG5vdCBzdXBwb3J0IHNlbGYgcmVmZXJlbmNpYWwgY29uc3RyYWludHMsIHdlIHdpbGwgcmVtb3ZlIGl0IGJ1dCB3ZSByZWNvbW1lbmQgcmVzdHJ1Y3R1cmluZyB5b3VyIHF1ZXJ5XCIpO1xuICAgICAgICBhdHRyaWJ1dGUub25EZWxldGUgPSBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgdGVtcGxhdGU7XG4gICAgdGVtcGxhdGUgPSBhdHRyaWJ1dGUudHlwZS50b1NxbCA/IGF0dHJpYnV0ZS50eXBlLnRvU3FsKCkgOiBcIlwiO1xuICAgIGlmIChhdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5KU09OKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBgIENIRUNLICgke3RoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMuYXR0cmlidXRlTmFtZSl9IElTIEpTT04pYDtcbiAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgaWYgKFV0aWxzLmRlZmF1bHRWYWx1ZVNjaGVtYWJsZShhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlKSkge1xuICAgICAgdGVtcGxhdGUgKz0gYCBERUZBVUxUICR7dGhpcy5lc2NhcGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSl9YDtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5hbGxvd051bGwgPT09IGZhbHNlKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBOT1QgTlVMTFwiO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSkge1xuICAgICAgaWYgKGF0dHJpYnV0ZS50eXBlLnZhbHVlcyAmJiAhYXR0cmlidXRlLnZhbHVlcylcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlcyA9IGF0dHJpYnV0ZS50eXBlLnZhbHVlcztcbiAgICAgIHRlbXBsYXRlICs9IGAgQ0hFQ0sgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIob3B0aW9ucy5hdHRyaWJ1dGVOYW1lKX0gSU4oJHtfLm1hcChhdHRyaWJ1dGUudmFsdWVzLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXNjYXBlKHZhbHVlKTtcbiAgICAgIH0pLmpvaW4oXCIsIFwiKX0pKWA7XG4gICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5CT09MRUFOKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBgIENIRUNLICgke3RoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMuYXR0cmlidXRlTmFtZSl9IElOKCcxJywgJzAnKSlgO1xuICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgIHRlbXBsYXRlID0gXCIgTlVNQkVSKCosMCkgR0VORVJBVEVEIEJZIERFRkFVTFQgT04gTlVMTCBBUyBJREVOVElUWVwiO1xuICAgIH0gZWxzZSBpZiAoYXR0cmlidXRlLnR5cGUgJiYgYXR0cmlidXRlLnR5cGUua2V5ID09PSBEYXRhVHlwZXMuRE9VQkxFLmtleSkge1xuICAgICAgdGVtcGxhdGUgPSBhdHRyaWJ1dGUudHlwZS50b1NxbCgpO1xuICAgIH0gZWxzZSBpZiAoYXR0cmlidXRlLnR5cGUpIHtcbiAgICAgIGxldCB1bnNpZ25lZFRlbXBsYXRlID0gXCJcIjtcbiAgICAgIGlmIChhdHRyaWJ1dGUudHlwZS5fdW5zaWduZWQpIHtcbiAgICAgICAgYXR0cmlidXRlLnR5cGUuX3Vuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgIHVuc2lnbmVkVGVtcGxhdGUgKz0gYCBjaGVjaygke3RoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMuYXR0cmlidXRlTmFtZSl9ID49IDApYDtcbiAgICAgIH1cbiAgICAgIHRlbXBsYXRlID0gYXR0cmlidXRlLnR5cGUudG9TdHJpbmcoKTtcbiAgICAgIGlmIChhdHRyaWJ1dGUudHlwZSAmJiBhdHRyaWJ1dGUudHlwZSAhPT0gXCJURVhUXCIgJiYgYXR0cmlidXRlLnR5cGUuX2JpbmFyeSAhPT0gdHJ1ZSAmJiBVdGlscy5kZWZhdWx0VmFsdWVTY2hlbWFibGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCBERUZBVUxUICR7dGhpcy5lc2NhcGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSl9YDtcbiAgICAgIH1cbiAgICAgIGlmICghYXR0cmlidXRlLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5hbGxvd051bGwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGVtcGxhdGUgKz0gXCIgTk9UIE5VTExcIjtcbiAgICAgICAgfSBlbHNlIGlmICghYXR0cmlidXRlLnByaW1hcnlLZXkgJiYgIVV0aWxzLmRlZmF1bHRWYWx1ZVNjaGVtYWJsZShhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICAgIHRlbXBsYXRlICs9IFwiIE5VTExcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGVtcGxhdGUgKz0gdW5zaWduZWRUZW1wbGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGVtcGxhdGUgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLnVuaXF1ZSA9PT0gdHJ1ZSAmJiAhYXR0cmlidXRlLnByaW1hcnlLZXkpIHtcbiAgICAgIHRlbXBsYXRlICs9IFwiIFVOSVFVRVwiO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLnByaW1hcnlLZXkpIHtcbiAgICAgIHRlbXBsYXRlICs9IFwiIFBSSU1BUlkgS0VZXCI7XG4gICAgfVxuICAgIGlmICgoIW9wdGlvbnMgfHwgIW9wdGlvbnMud2l0aG91dEZvcmVpZ25LZXlDb25zdHJhaW50cykgJiYgYXR0cmlidXRlLnJlZmVyZW5jZXMpIHtcbiAgICAgIHRlbXBsYXRlICs9IGAgUkVGRVJFTkNFUyAke3RoaXMucXVvdGVUYWJsZShhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbCl9YDtcbiAgICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcy5rZXkpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGUucmVmZXJlbmNlcy5rZXkpfSlgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihcImlkXCIpfSlgO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZS5vbkRlbGV0ZSAmJiBhdHRyaWJ1dGUub25EZWxldGUudG9VcHBlckNhc2UoKSAhPT0gXCJOTyBBQ1RJT05cIikge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgIE9OIERFTEVURSAke2F0dHJpYnV0ZS5vbkRlbGV0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfVxuICBhdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGUuZmllbGQgfHwga2V5O1xuICAgICAgcmVzdWx0W2F0dHJpYnV0ZU5hbWVdID0gdGhpcy5hdHRyaWJ1dGVUb1NRTChhdHRyaWJ1dGUsIF9fc3ByZWFkVmFsdWVzKHsgYXR0cmlidXRlTmFtZSB9LCBvcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY3JlYXRlVHJpZ2dlcigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZChcImNyZWF0ZVRyaWdnZXJcIik7XG4gIH1cbiAgZHJvcFRyaWdnZXIoKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoXCJkcm9wVHJpZ2dlclwiKTtcbiAgfVxuICByZW5hbWVUcmlnZ2VyKCkge1xuICAgIHRocm93TWV0aG9kVW5kZWZpbmVkKFwicmVuYW1lVHJpZ2dlclwiKTtcbiAgfVxuICBjcmVhdGVGdW5jdGlvbigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZChcImNyZWF0ZUZ1bmN0aW9uXCIpO1xuICB9XG4gIGRyb3BGdW5jdGlvbigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZChcImRyb3BGdW5jdGlvblwiKTtcbiAgfVxuICByZW5hbWVGdW5jdGlvbigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZChcInJlbmFtZUZ1bmN0aW9uXCIpO1xuICB9XG4gIGdldENvbnN0cmFpbnRzT25Db2x1bW4odGFibGUsIGNvbHVtbikge1xuICAgIGNvbnN0IFt0YWJsZU5hbWUsIHNjaGVtYU5hbWVdID0gdGhpcy5nZXRTY2hlbWFOYW1lQW5kVGFibGVOYW1lKHRhYmxlKTtcbiAgICBjb2x1bW4gPSB0aGlzLmdldENhdGFsb2dOYW1lKGNvbHVtbik7XG4gICAgY29uc3Qgc3FsID0gW1xuICAgICAgXCJTRUxFQ1QgQ09OU1RSQUlOVF9OQU1FIEZST00gdXNlcl9jb25zX2NvbHVtbnMgV0hFUkUgVEFCTEVfTkFNRSA9IFwiLFxuICAgICAgdGhpcy5lc2NhcGUodGFibGVOYW1lKSxcbiAgICAgIFwiIGFuZCBPV05FUiA9IFwiLFxuICAgICAgdGFibGUuc2NoZW1hID8gdGhpcy5lc2NhcGUoc2NoZW1hTmFtZSkgOiBcIlVTRVJcIixcbiAgICAgIFwiIGFuZCBDT0xVTU5fTkFNRSA9IFwiLFxuICAgICAgdGhpcy5lc2NhcGUoY29sdW1uKSxcbiAgICAgIFwiIEFORCBQT1NJVElPTiBJUyBOT1QgTlVMTCBPUkRFUiBCWSBQT1NJVElPTlwiXG4gICAgXS5qb2luKFwiXCIpO1xuICAgIHJldHVybiBzcWw7XG4gIH1cbiAgZ2V0Rm9yZWlnbktleXNRdWVyeSh0YWJsZSkge1xuICAgIGNvbnN0IFt0YWJsZU5hbWUsIHNjaGVtYU5hbWVdID0gdGhpcy5nZXRTY2hlbWFOYW1lQW5kVGFibGVOYW1lKHRhYmxlKTtcbiAgICBjb25zdCBzcWwgPSBbXG4gICAgICAnU0VMRUNUIERJU1RJTkNUICBhLnRhYmxlX25hbWUgXCJ0YWJsZU5hbWVcIiwgYS5jb25zdHJhaW50X25hbWUgXCJjb25zdHJhaW50TmFtZVwiLCBhLm93bmVyIFwib3duZXJcIiwgIGEuY29sdW1uX25hbWUgXCJjb2x1bW5OYW1lXCIsJyxcbiAgICAgICcgYi50YWJsZV9uYW1lIFwicmVmZXJlbmNlZFRhYmxlTmFtZVwiLCBiLmNvbHVtbl9uYW1lIFwicmVmZXJlbmNlZENvbHVtbk5hbWVcIicsXG4gICAgICBcIiBGUk9NIGFsbF9jb25zX2NvbHVtbnMgYVwiLFxuICAgICAgXCIgSk9JTiBhbGxfY29uc3RyYWludHMgYyBPTiBhLm93bmVyID0gYy5vd25lciBBTkQgYS5jb25zdHJhaW50X25hbWUgPSBjLmNvbnN0cmFpbnRfbmFtZVwiLFxuICAgICAgXCIgSk9JTiBhbGxfY29uc19jb2x1bW5zIGIgT04gYy5vd25lciA9IGIub3duZXIgQU5EIGMucl9jb25zdHJhaW50X25hbWUgPSBiLmNvbnN0cmFpbnRfbmFtZVwiLFxuICAgICAgXCIgV0hFUkUgYy5jb25zdHJhaW50X3R5cGUgID0gJ1InXCIsXG4gICAgICBcIiBBTkQgYS50YWJsZV9uYW1lID0gXCIsXG4gICAgICB0aGlzLmVzY2FwZSh0YWJsZU5hbWUpLFxuICAgICAgXCIgQU5EIGEub3duZXIgPSBcIixcbiAgICAgIHRhYmxlLnNjaGVtYSA/IHRoaXMuZXNjYXBlKHNjaGVtYU5hbWUpIDogXCJVU0VSXCIsXG4gICAgICBcIiBPUkRFUiBCWSBhLnRhYmxlX25hbWUsIGEuY29uc3RyYWludF9uYW1lXCJcbiAgICBdLmpvaW4oXCJcIik7XG4gICAgcmV0dXJuIHNxbDtcbiAgfVxuICBkcm9wRm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZSwgZm9yZWlnbktleSkge1xuICAgIHJldHVybiB0aGlzLmRyb3BDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBmb3JlaWduS2V5KTtcbiAgfVxuICBnZXRQcmltYXJ5S2V5Q29uc3RyYWludFF1ZXJ5KHRhYmxlKSB7XG4gICAgY29uc3QgW3RhYmxlTmFtZSwgc2NoZW1hTmFtZV0gPSB0aGlzLmdldFNjaGVtYU5hbWVBbmRUYWJsZU5hbWUodGFibGUpO1xuICAgIGNvbnN0IHNxbCA9IFtcbiAgICAgIFwiU0VMRUNUIGNvbHMuY29sdW1uX25hbWUsIGF0Yy5pZGVudGl0eV9jb2x1bW4gXCIsXG4gICAgICBcIkZST00gYWxsX2NvbnN0cmFpbnRzIGNvbnMsIGFsbF9jb25zX2NvbHVtbnMgY29scyBcIixcbiAgICAgIFwiSU5ORVIgSk9JTiBhbGxfdGFiX2NvbHVtbnMgYXRjIE9OKGF0Yy50YWJsZV9uYW1lID0gY29scy50YWJsZV9uYW1lIEFORCBhdGMuQ09MVU1OX05BTUUgPSBjb2xzLkNPTFVNTl9OQU1FIClcIixcbiAgICAgIFwiV0hFUkUgY29scy50YWJsZV9uYW1lID0gXCIsXG4gICAgICB0aGlzLmVzY2FwZSh0YWJsZU5hbWUpLFxuICAgICAgXCJBTkQgY29scy5vd25lciA9IFwiLFxuICAgICAgdGFibGUuc2NoZW1hID8gdGhpcy5lc2NhcGUoc2NoZW1hTmFtZSkgOiBcIlVTRVIgXCIsXG4gICAgICBcIkFORCBjb25zLmNvbnN0cmFpbnRfdHlwZSA9ICdQJyBcIixcbiAgICAgIFwiQU5EIGNvbnMuY29uc3RyYWludF9uYW1lID0gY29scy5jb25zdHJhaW50X25hbWUgXCIsXG4gICAgICBcIkFORCBjb25zLm93bmVyID0gY29scy5vd25lciBcIixcbiAgICAgIFwiT1JERVIgQlkgY29scy50YWJsZV9uYW1lLCBjb2xzLnBvc2l0aW9uXCJcbiAgICBdLmpvaW4oXCJcIik7XG4gICAgcmV0dXJuIHNxbDtcbiAgfVxuICBkcm9wQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUpIHtcbiAgICByZXR1cm4gYEFMVEVSIFRBQkxFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9IERST1AgQ09OU1RSQUlOVCAke2NvbnN0cmFpbnROYW1lfWA7XG4gIH1cbiAgc2V0SXNvbGF0aW9uTGV2ZWxRdWVyeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uLklTT0xBVElPTl9MRVZFTFMuUkVBRF9VTkNPTU1JVFRFRDpcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb24uSVNPTEFUSU9OX0xFVkVMUy5SRUFEX0NPTU1JVFRFRDpcbiAgICAgICAgcmV0dXJuIFwiU0VUIFRSQU5TQUNUSU9OIElTT0xBVElPTiBMRVZFTCBSRUFEIENPTU1JVFRFRDtcIjtcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb24uSVNPTEFUSU9OX0xFVkVMUy5SRVBFQVRBQkxFX1JFQUQ6XG4gICAgICAgIHJldHVybiBcIlNFVCBUUkFOU0FDVElPTiBJU09MQVRJT04gTEVWRUwgU0VSSUFMSVpBQkxFO1wiO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpc29sYXRpb24gbGV2ZWwgXCIke3ZhbHVlfVwiIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICB9XG4gIH1cbiAgZ2V0QWxpYXNUb2tlbigpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBzdGFydFRyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICByZXR1cm4gYFNBVkVQT0lOVCAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRyYW5zYWN0aW9uLm5hbWUpfWA7XG4gICAgfVxuICAgIHJldHVybiBcIkJFR0lOIFRSQU5TQUNUSU9OXCI7XG4gIH1cbiAgY29tbWl0VHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIFwiQ09NTUlUIFRSQU5TQUNUSU9OXCI7XG4gIH1cbiAgcm9sbGJhY2tUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgcmV0dXJuIGBST0xMQkFDSyBUTyBTQVZFUE9JTlQgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0cmFuc2FjdGlvbi5uYW1lKX1gO1xuICAgIH1cbiAgICByZXR1cm4gXCJST0xMQkFDSyBUUkFOU0FDVElPTlwiO1xuICB9XG4gIGhhbmRsZVNlcXVlbGl6ZU1ldGhvZChzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpIHtcbiAgICBsZXQgc3RyO1xuICAgIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuSnNvbikge1xuICAgICAgaWYgKHNtdGguY29uZGl0aW9ucykge1xuICAgICAgICBjb25zdCBjb25kaXRpb25zID0gdGhpcy5wYXJzZUNvbmRpdGlvbk9iamVjdChzbXRoLmNvbmRpdGlvbnMpLm1hcCgoY29uZGl0aW9uKSA9PiBgJHt0aGlzLmpzb25QYXRoRXh0cmFjdGlvblF1ZXJ5KGNvbmRpdGlvbi5wYXRoWzBdLCBfLnRhaWwoY29uZGl0aW9uLnBhdGgpKX0gPSAnJHtjb25kaXRpb24udmFsdWV9J2ApO1xuICAgICAgICByZXR1cm4gY29uZGl0aW9ucy5qb2luKFwiIEFORCBcIik7XG4gICAgICB9XG4gICAgICBpZiAoc210aC5wYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaGVja1ZhbGlkSnNvblN0YXRlbWVudChzbXRoLnBhdGgpKSB7XG4gICAgICAgICAgc3RyID0gc210aC5wYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHBhdGhzID0gXy50b1BhdGgoc210aC5wYXRoKTtcbiAgICAgICAgICBjb25zdCBjb2x1bW4gPSBwYXRocy5zaGlmdCgpO1xuICAgICAgICAgIHN0ciA9IHRoaXMuanNvblBhdGhFeHRyYWN0aW9uUXVlcnkoY29sdW1uLCBwYXRocyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNtdGgudmFsdWUpIHtcbiAgICAgICAgICBzdHIgKz0gdXRpbC5mb3JtYXQoXCIgPSAlc1wiLCB0aGlzLmVzY2FwZShzbXRoLnZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNtdGggaW5zdGFuY2VvZiBVdGlscy5DYXN0KSB7XG4gICAgICBpZiAoc210aC52YWwgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgc3RyID0gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2Qoc210aC52YWwsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gICAgICAgIGlmIChzbXRoLnR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgc3RyID0gYChDQVNFIFdIRU4gJHtzdHJ9PSd0cnVlJyBUSEVOIDEgRUxTRSAwIEVORClgO1xuICAgICAgICAgIHJldHVybiBgQ0FTVCgke3N0cn0gQVMgTlVNQkVSKWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNtdGgudHlwZSA9PT0gXCJ0aW1lc3RhbXB0elwiICYmIC9qc29uX3ZhbHVlXFwoLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgIHJldHVybiBgJHtzdHJ9IFJFVFVSTklORyBUSU1FU1RBTVAgV0lUSCBUSU1FIFpPTkUpYDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuaGFuZGxlU2VxdWVsaXplTWV0aG9kKHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gIH1cbiAgX2NoZWNrVmFsaWRKc29uU3RhdGVtZW50KHN0bXQpIHtcbiAgICBpZiAodHlwZW9mIHN0bXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRJbmRleCA9IDA7XG4gICAgbGV0IG9wZW5pbmdCcmFja2V0cyA9IDA7XG4gICAgbGV0IGNsb3NpbmdCcmFja2V0cyA9IDA7XG4gICAgbGV0IGhhc0pzb25GdW5jdGlvbiA9IGZhbHNlO1xuICAgIGxldCBoYXNJbnZhbGlkVG9rZW4gPSBmYWxzZTtcbiAgICB3aGlsZSAoY3VycmVudEluZGV4IDwgc3RtdC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHN0cmluZyA9IHN0bXQuc3Vic3RyKGN1cnJlbnRJbmRleCk7XG4gICAgICBjb25zdCBmdW5jdGlvbk1hdGNoZXMgPSBKU09OX0ZVTkNUSU9OX1JFR0VYLmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmIChmdW5jdGlvbk1hdGNoZXMpIHtcbiAgICAgICAgY3VycmVudEluZGV4ICs9IGZ1bmN0aW9uTWF0Y2hlc1swXS5pbmRleE9mKFwiKFwiKTtcbiAgICAgICAgaGFzSnNvbkZ1bmN0aW9uID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvcGVyYXRvck1hdGNoZXMgPSBKU09OX09QRVJBVE9SX1JFR0VYLmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmIChvcGVyYXRvck1hdGNoZXMpIHtcbiAgICAgICAgY3VycmVudEluZGV4ICs9IG9wZXJhdG9yTWF0Y2hlc1swXS5sZW5ndGg7XG4gICAgICAgIGhhc0pzb25GdW5jdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9rZW5NYXRjaGVzID0gVE9LRU5fQ0FQVFVSRV9SRUdFWC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAodG9rZW5NYXRjaGVzKSB7XG4gICAgICAgIGNvbnN0IGNhcHR1cmVkVG9rZW4gPSB0b2tlbk1hdGNoZXNbMV07XG4gICAgICAgIGlmIChjYXB0dXJlZFRva2VuID09PSBcIihcIikge1xuICAgICAgICAgIG9wZW5pbmdCcmFja2V0cysrO1xuICAgICAgICB9IGVsc2UgaWYgKGNhcHR1cmVkVG9rZW4gPT09IFwiKVwiKSB7XG4gICAgICAgICAgY2xvc2luZ0JyYWNrZXRzKys7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gXCI7XCIpIHtcbiAgICAgICAgICBoYXNJbnZhbGlkVG9rZW4gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSB0b2tlbk1hdGNoZXNbMF0ubGVuZ3RoO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoaGFzSnNvbkZ1bmN0aW9uICYmIChoYXNJbnZhbGlkVG9rZW4gfHwgb3BlbmluZ0JyYWNrZXRzICE9PSBjbG9zaW5nQnJhY2tldHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQganNvbiBzdGF0ZW1lbnQ6ICR7c3RtdH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0pzb25GdW5jdGlvbjtcbiAgfVxuICBqc29uUGF0aEV4dHJhY3Rpb25RdWVyeShjb2x1bW4sIHBhdGgpIHtcbiAgICBsZXQgcGF0aHMgPSBfLnRvUGF0aChwYXRoKTtcbiAgICBjb25zdCBxdW90ZWRDb2x1bW4gPSB0aGlzLmlzSWRlbnRpZmllclF1b3RlZChjb2x1bW4pID8gY29sdW1uIDogdGhpcy5xdW90ZUlkZW50aWZpZXIoY29sdW1uKTtcbiAgICBwYXRocyA9IHBhdGhzLm1hcCgoc3ViUGF0aCkgPT4ge1xuICAgICAgcmV0dXJuIC9cXEQvLnRlc3Qoc3ViUGF0aCkgPyBVdGlscy5hZGRUaWNrcyhzdWJQYXRoLCAnXCInKSA6IHN1YlBhdGg7XG4gICAgfSk7XG4gICAgY29uc3QgcGF0aFN0ciA9IHRoaXMuZXNjYXBlKFtcIiRcIl0uY29uY2F0KHBhdGhzKS5qb2luKFwiLlwiKS5yZXBsYWNlKC9cXC4oXFxkKykoPzooPz1cXC4pfCQpL2csIChfXywgZGlnaXQpID0+IGBbJHtkaWdpdH1dYCkpO1xuICAgIHJldHVybiBganNvbl92YWx1ZSgke3F1b3RlZENvbHVtbn0sJHtwYXRoU3RyfSlgO1xuICB9XG4gIGFkZExpbWl0QW5kT2Zmc2V0KG9wdGlvbnMsIG1vZGVsKSB7XG4gICAgbGV0IGZyYWdtZW50ID0gXCJcIjtcbiAgICBjb25zdCBvZmZzZXQgPSBvcHRpb25zLm9mZnNldCB8fCAwLCBpc1N1YlF1ZXJ5ID0gb3B0aW9ucy5oYXNJbmNsdWRlV2hlcmUgfHwgb3B0aW9ucy5oYXNJbmNsdWRlUmVxdWlyZWQgfHwgb3B0aW9ucy5oYXNNdWx0aUFzc29jaWF0aW9uO1xuICAgIGxldCBvcmRlcnMgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5vcmRlcikge1xuICAgICAgb3JkZXJzID0gdGhpcy5nZXRRdWVyeU9yZGVycyhvcHRpb25zLCBtb2RlbCwgaXNTdWJRdWVyeSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxpbWl0IHx8IG9wdGlvbnMub2Zmc2V0KSB7XG4gICAgICBpZiAoIW9yZGVycy5tYWluUXVlcnlPcmRlciB8fCAhb3JkZXJzLm1haW5RdWVyeU9yZGVyLmxlbmd0aCB8fCBpc1N1YlF1ZXJ5ICYmICghb3JkZXJzLnN1YlF1ZXJ5T3JkZXIgfHwgIW9yZGVycy5zdWJRdWVyeU9yZGVyLmxlbmd0aCkpIHtcbiAgICAgICAgY29uc3QgdGFibGVQa0ZyYWdtZW50ID0gYCR7dGhpcy5xdW90ZVRhYmxlKG9wdGlvbnMudGFibGVBcyB8fCBtb2RlbC5uYW1lKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihtb2RlbC5wcmltYXJ5S2V5RmllbGQpfWA7XG4gICAgICAgIGZyYWdtZW50ICs9IGAgT1JERVIgQlkgJHt0YWJsZVBrRnJhZ21lbnR9YDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm9mZnNldCB8fCBvcHRpb25zLmxpbWl0KSB7XG4gICAgICAgIGZyYWdtZW50ICs9IGAgT0ZGU0VUICR7dGhpcy5lc2NhcGUob2Zmc2V0KX0gUk9XU2A7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5saW1pdCkge1xuICAgICAgICBmcmFnbWVudCArPSBgIEZFVENIIE5FWFQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX0gUk9XUyBPTkxZYDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9XG4gIGJvb2xlYW5WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA/IDEgOiAwO1xuICB9XG4gIHF1b3RlSWRlbnRpZmllcihpZGVudGlmaWVyLCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgY29uc3Qgb3B0Rm9yY2VRdW90ZSA9IGZvcmNlO1xuICAgIGNvbnN0IG9wdFF1b3RlSWRlbnRpZmllcnMgPSB0aGlzLm9wdGlvbnMucXVvdGVJZGVudGlmaWVycyAhPT0gZmFsc2U7XG4gICAgY29uc3QgcmF3SWRlbnRpZmllciA9IFV0aWxzLnJlbW92ZVRpY2tzKGlkZW50aWZpZXIsICdcIicpO1xuICAgIGNvbnN0IHJlZ0V4cCA9IC9eKChbXFx3XVtcXHdcXGRfXSopKSQvZztcbiAgICBpZiAob3B0Rm9yY2VRdW90ZSAhPT0gdHJ1ZSAmJiBvcHRRdW90ZUlkZW50aWZpZXJzID09PSBmYWxzZSAmJiByZWdFeHAudGVzdChyYXdJZGVudGlmaWVyKSAmJiAhT1JBQ0xFX1JFU0VSVkVEX1dPUkRTLmluY2x1ZGVzKHJhd0lkZW50aWZpZXIudG9VcHBlckNhc2UoKSkpIHtcbiAgICAgIHJldHVybiByYXdJZGVudGlmaWVyO1xuICAgIH1cbiAgICByZXR1cm4gVXRpbHMuYWRkVGlja3MocmF3SWRlbnRpZmllciwgJ1wiJyk7XG4gIH1cbiAgYmluZFBhcmFtKGJpbmQsIHBvc09mZnNldCA9IDApIHtcbiAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICBiaW5kLnB1c2godmFsdWUpO1xuICAgICAgcmV0dXJuIGA6JHtiaW5kLmxlbmd0aCArIHBvc09mZnNldH1gO1xuICAgIH07XG4gIH1cbiAgYXV0aFRlc3RRdWVyeSgpIHtcbiAgICByZXR1cm4gXCJTRUxFQ1QgMSsxIEFTIHJlc3VsdCBGUk9NIERVQUxcIjtcbiAgfVxufVxuZnVuY3Rpb24gdGhyb3dNZXRob2RVbmRlZmluZWQobWV0aG9kTmFtZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBtZXRob2QgXCIke21ldGhvZE5hbWV9XCIgaXMgbm90IGRlZmluZWQhIFBsZWFzZSBhZGQgaXQgdG8geW91ciBzcWwgZGlhbGVjdC5gKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWdlbmVyYXRvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/oracle/query-generator.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/oracle/query-interface.js":
/*!************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/oracle/query-interface.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  OracleQueryInterface: () => OracleQueryInterface\n});\nconst { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(action-browser)/../node_modules/sequelize/lib/query-types.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nclass OracleQueryInterface extends QueryInterface {\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    const model = options.model;\n    const primaryKeys = Object.values(model.primaryKeys).map((item) => item.field);\n    const uniqueKeys = Object.values(model.uniqueKeys).filter((c) => c.fields.length > 0).map((c) => c.fields);\n    const indexKeys = Object.values(model._indexes).filter((c) => c.unique && c.fields.length > 0).map((c) => c.fields);\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = [];\n    for (const field of options.updateOnDuplicate) {\n      const uniqueKey = uniqueKeys.find((fields) => fields.includes(field));\n      if (uniqueKey) {\n        options.upsertKeys = uniqueKey;\n        break;\n      }\n      const indexKey = indexKeys.find((fields) => fields.includes(field));\n      if (indexKey) {\n        options.upsertKeys = indexKey;\n        break;\n      }\n    }\n    if (options.upsertKeys.length === 0 || _.intersection(options.updateOnDuplicate, primaryKeys).length) {\n      options.upsertKeys = primaryKeys;\n    }\n    options.upsertKeys = _.uniq(options.upsertKeys);\n    let whereHasNull = false;\n    primaryKeys.forEach((element) => {\n      if (where[element] === null) {\n        whereHasNull = true;\n      }\n    });\n    if (whereHasNull === true) {\n      where = options.upsertKeys.reduce((result, attribute) => {\n        result[attribute] = insertValues[attribute];\n        return result;\n      }, {});\n    }\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    if (sql.bind) {\n      options.bind = void 0;\n    }\n    return await this.sequelize.query(sql, options);\n  }\n}\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvcXVlcnktaW50ZXJmYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyx3SEFBNkI7QUFDaEUsbUJBQW1CLG1CQUFPLENBQUMsd0ZBQW1CO0FBQzlDLFVBQVUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMxQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL29yYWNsZS9xdWVyeS1pbnRlcmZhY2UuanM/ZTAyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBPcmFjbGVRdWVyeUludGVyZmFjZTogKCkgPT4gT3JhY2xlUXVlcnlJbnRlcmZhY2Vcbn0pO1xuY29uc3QgeyBRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5LWludGVyZmFjZVwiKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vcXVlcnktdHlwZXNcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNsYXNzIE9yYWNsZVF1ZXJ5SW50ZXJmYWNlIGV4dGVuZHMgUXVlcnlJbnRlcmZhY2Uge1xuICBhc3luYyB1cHNlcnQodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIHVwZGF0ZVZhbHVlcywgd2hlcmUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xuICAgIGNvbnN0IG1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICBjb25zdCBwcmltYXJ5S2V5cyA9IE9iamVjdC52YWx1ZXMobW9kZWwucHJpbWFyeUtleXMpLm1hcCgoaXRlbSkgPT4gaXRlbS5maWVsZCk7XG4gICAgY29uc3QgdW5pcXVlS2V5cyA9IE9iamVjdC52YWx1ZXMobW9kZWwudW5pcXVlS2V5cykuZmlsdGVyKChjKSA9PiBjLmZpZWxkcy5sZW5ndGggPiAwKS5tYXAoKGMpID0+IGMuZmllbGRzKTtcbiAgICBjb25zdCBpbmRleEtleXMgPSBPYmplY3QudmFsdWVzKG1vZGVsLl9pbmRleGVzKS5maWx0ZXIoKGMpID0+IGMudW5pcXVlICYmIGMuZmllbGRzLmxlbmd0aCA+IDApLm1hcCgoYykgPT4gYy5maWVsZHMpO1xuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuVVBTRVJUO1xuICAgIG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUgPSBPYmplY3Qua2V5cyh1cGRhdGVWYWx1ZXMpO1xuICAgIG9wdGlvbnMudXBzZXJ0S2V5cyA9IFtdO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2Ygb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSkge1xuICAgICAgY29uc3QgdW5pcXVlS2V5ID0gdW5pcXVlS2V5cy5maW5kKChmaWVsZHMpID0+IGZpZWxkcy5pbmNsdWRlcyhmaWVsZCkpO1xuICAgICAgaWYgKHVuaXF1ZUtleSkge1xuICAgICAgICBvcHRpb25zLnVwc2VydEtleXMgPSB1bmlxdWVLZXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5kZXhLZXkgPSBpbmRleEtleXMuZmluZCgoZmllbGRzKSA9PiBmaWVsZHMuaW5jbHVkZXMoZmllbGQpKTtcbiAgICAgIGlmIChpbmRleEtleSkge1xuICAgICAgICBvcHRpb25zLnVwc2VydEtleXMgPSBpbmRleEtleTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnVwc2VydEtleXMubGVuZ3RoID09PSAwIHx8IF8uaW50ZXJzZWN0aW9uKG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUsIHByaW1hcnlLZXlzKS5sZW5ndGgpIHtcbiAgICAgIG9wdGlvbnMudXBzZXJ0S2V5cyA9IHByaW1hcnlLZXlzO1xuICAgIH1cbiAgICBvcHRpb25zLnVwc2VydEtleXMgPSBfLnVuaXEob3B0aW9ucy51cHNlcnRLZXlzKTtcbiAgICBsZXQgd2hlcmVIYXNOdWxsID0gZmFsc2U7XG4gICAgcHJpbWFyeUtleXMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgaWYgKHdoZXJlW2VsZW1lbnRdID09PSBudWxsKSB7XG4gICAgICAgIHdoZXJlSGFzTnVsbCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHdoZXJlSGFzTnVsbCA9PT0gdHJ1ZSkge1xuICAgICAgd2hlcmUgPSBvcHRpb25zLnVwc2VydEtleXMucmVkdWNlKChyZXN1bHQsIGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgICByZXN1bHRbYXR0cmlidXRlXSA9IGluc2VydFZhbHVlc1thdHRyaWJ1dGVdO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwge30pO1xuICAgIH1cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnVwc2VydFF1ZXJ5KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCB1cGRhdGVWYWx1ZXMsIHdoZXJlLCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgaWYgKHNxbC5iaW5kKSB7XG4gICAgICBvcHRpb25zLmJpbmQgPSB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS1pbnRlcmZhY2UuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/oracle/query-interface.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/oracle/query.js":
/*!**************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/oracle/query.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  OracleQuery: () => OracleQuery\n});\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst SequelizeErrors = __webpack_require__(/*! ../../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(action-browser)/../node_modules/sequelize/lib/dialects/parserStore.js\")(\"oracle\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(action-browser)/../node_modules/sequelize/lib/utils/logger.js\");\nconst debug = logger.debugContext(\"sql:oracle\");\nclass OracleQuery extends AbstractQuery {\n  constructor(connection, sequelize, options) {\n    super(connection, sequelize, options);\n    this.options = _.extend({\n      logging: console.log,\n      plain: false,\n      raw: false\n    }, options || {});\n    this.checkLoggingOption();\n    this.outFormat = options.outFormat || this.sequelize.connectionManager.lib.OBJECT;\n  }\n  getInsertIdField() {\n    return \"id\";\n  }\n  getExecOptions() {\n    const execOpts = { outFormat: this.outFormat, autoCommit: this.autoCommit };\n    const oracledb = this.sequelize.connectionManager.lib;\n    if (this.model && this.isSelectQuery()) {\n      const fInfo = {};\n      const keys = Object.keys(this.model.tableAttributes);\n      for (const key of keys) {\n        const keyValue = this.model.tableAttributes[key];\n        if (keyValue.type.key === \"DECIMAL\") {\n          fInfo[key] = { type: oracledb.STRING };\n        }\n        if (keyValue.type.key === \"BIGINT\") {\n          fInfo[key] = { type: oracledb.STRING };\n        }\n      }\n      if (fInfo) {\n        execOpts.fetchInfo = fInfo;\n      }\n    }\n    return execOpts;\n  }\n  _convertBindAttributes(bindingDictionary, oracledb) {\n    if (this.model && this.options[bindingDictionary]) {\n      const keys = Object.keys(this.model.tableAttributes);\n      for (const key of keys) {\n        const keyValue = this.model.tableAttributes[key];\n        if (keyValue.type.key === \"BIGINT\") {\n          const oldBinding = this.options[bindingDictionary][key];\n          if (oldBinding) {\n            this.options[bindingDictionary][key] = __spreadProps(__spreadValues({}, oldBinding), {\n              type: oracledb.STRING,\n              maxSize: 1e7\n            });\n          }\n        }\n      }\n    }\n  }\n  async run(sql, parameters) {\n    const oracledb = this.sequelize.connectionManager.lib;\n    const complete = this._logQuery(sql, debug, parameters);\n    const outParameters = [];\n    const bindParameters = [];\n    const bindDef = [];\n    if (!sql.match(/END;$/)) {\n      this.sql = sql.replace(/; *$/, \"\");\n    } else {\n      this.sql = sql;\n    }\n    if (this.options.outBindAttributes && (Array.isArray(parameters) || _.isPlainObject(parameters))) {\n      this._convertBindAttributes(\"outBindAttributes\", oracledb);\n      outParameters.push(...Object.values(this.options.outBindAttributes));\n      if (this.isUpsertQuery()) {\n        outParameters.push({ dir: oracledb.BIND_OUT });\n      }\n    }\n    this.bindParameters = outParameters;\n    if (Array.isArray(parameters) || _.isPlainObject(parameters)) {\n      if (this.options.executeMany) {\n        this._convertBindAttributes(\"inbindAttributes\", oracledb);\n        bindDef.push(...Object.values(this.options.inbindAttributes));\n        bindDef.push(...outParameters);\n        this.bindParameters = parameters;\n      } else if (this.isRawQuery()) {\n        this.bindParameters = parameters;\n      } else {\n        Object.values(parameters).forEach((value) => {\n          bindParameters.push(value);\n        });\n        bindParameters.push(...outParameters);\n        Object.assign(this.bindParameters, bindParameters);\n      }\n    }\n    if (this.sql.startsWith(\"BEGIN TRANSACTION\")) {\n      this.autocommit = false;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith(\"SET AUTOCOMMIT ON\")) {\n      this.autocommit = true;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith(\"SET AUTOCOMMIT OFF\")) {\n      this.autocommit = false;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith(\"DECLARE x NUMBER\")) {\n      if (this.autoCommit === void 0) {\n        if (this.connection.uuid) {\n          this.autoCommit = false;\n        } else {\n          this.autoCommit = true;\n        }\n      }\n      try {\n        await this.connection.execute(this.sql, this.bindParameters, { autoCommit: this.autoCommit });\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith(\"BEGIN\")) {\n      if (this.autoCommit === void 0) {\n        if (this.connection.uuid) {\n          this.autoCommit = false;\n        } else {\n          this.autoCommit = true;\n        }\n      }\n      try {\n        const result = await this.connection.execute(this.sql, this.bindParameters, {\n          outFormat: this.outFormat,\n          autoCommit: this.autoCommit\n        });\n        if (!Array.isArray(result.outBinds)) {\n          return [result.outBinds];\n        }\n        return result.outBinds;\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith(\"COMMIT TRANSACTION\")) {\n      try {\n        await this.connection.commit();\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith(\"ROLLBACK TRANSACTION\")) {\n      try {\n        await this.connection.rollback();\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith(\"SET TRANSACTION\")) {\n      try {\n        await this.connection.execute(this.sql, [], { autoCommit: false });\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.autoCommit === void 0) {\n      if (this.connection.uuid) {\n        this.autoCommit = false;\n      } else {\n        this.autoCommit = true;\n      }\n    }\n    if (\"inputParameters\" in this.options && this.options.inputParameters !== null) {\n      Object.assign(this.bindParameters, this.options.inputParameters);\n    }\n    const execOpts = this.getExecOptions();\n    if (this.options.executeMany && bindDef.length > 0) {\n      execOpts.bindDefs = bindDef;\n    }\n    const executePromise = this.options.executeMany ? this.connection.executeMany(this.sql, this.bindParameters, execOpts) : this.connection.execute(this.sql, this.bindParameters, execOpts);\n    try {\n      const result = await executePromise;\n      return this.formatResults(result);\n    } catch (error) {\n      throw this.formatError(error);\n    } finally {\n      complete();\n    }\n  }\n  static formatBindParameters(sql, values, dialect) {\n    const replacementFunc = (match, key, values2) => {\n      if (values2[key] !== void 0) {\n        return `:${key}`;\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, values];\n  }\n  _getAttributeMap(attrsMap, rawAttributes) {\n    attrsMap = Object.assign(attrsMap, _.reduce(rawAttributes, (mp, _2, key) => {\n      const catalogKey = this.sequelize.queryInterface.queryGenerator.getCatalogName(key);\n      mp[catalogKey] = key;\n      return mp;\n    }, {}));\n  }\n  _processRows(rows) {\n    let result = rows;\n    let attrsMap = {};\n    if (this.sequelize.options.quoteIdentifiers === false) {\n      attrsMap = _.reduce(this.options.attributes, (mp, v) => {\n        if (typeof v === \"object\") {\n          v = v[1];\n        }\n        const catalogv = this.sequelize.queryInterface.queryGenerator.getCatalogName(v);\n        mp[catalogv] = v;\n        return mp;\n      }, {});\n      if (this.model) {\n        this._getAttributeMap(attrsMap, this.model.rawAttributes);\n      }\n      if (this.options.aliasesMapping) {\n        const obj = Object.fromEntries(this.options.aliasesMapping);\n        rows = rows.map((row) => _.toPairs(row).reduce((acc, [key, value]) => {\n          const mapping = Object.values(obj).find((element) => {\n            const catalogElement = this.sequelize.queryInterface.queryGenerator.getCatalogName(element);\n            return catalogElement === key;\n          });\n          if (mapping)\n            acc[mapping || key] = value;\n          return acc;\n        }, {}));\n      }\n      result = rows.map((row) => {\n        return _.mapKeys(row, (value, key) => {\n          const targetAttr = attrsMap[key];\n          if (typeof targetAttr === \"string\" && targetAttr !== key) {\n            return targetAttr;\n          }\n          return key;\n        });\n      });\n    }\n    if (this.model) {\n      result = result.map((row) => {\n        return _.mapValues(row, (value, key) => {\n          if (this.model.rawAttributes[key] && this.model.rawAttributes[key].type) {\n            let typeid = this.model.rawAttributes[key].type.toLocaleString();\n            if (this.model.rawAttributes[key].type.key === \"JSON\") {\n              value = JSON.parse(value);\n            }\n            if (typeid.indexOf(\"(\") > -1 && this.model.rawAttributes[key].type.key !== \"BOOLEAN\") {\n              typeid = typeid.substr(0, typeid.indexOf(\"(\"));\n            }\n            const parse = parserStore.get(typeid);\n            if (value !== null & !!parse) {\n              value = parse(value);\n            }\n          }\n          return value;\n        });\n      });\n    }\n    return result;\n  }\n  formatResults(data) {\n    let result = this.instance;\n    if (this.isInsertQuery(data)) {\n      let insertData;\n      if (data.outBinds) {\n        const keys = Object.keys(this.options.outBindAttributes);\n        insertData = data.outBinds;\n        if (this.instance) {\n          insertData = [insertData];\n        }\n        const res = insertData.map((row) => {\n          const obj = {};\n          row.forEach((element, index) => {\n            obj[keys[index]] = element[0];\n          });\n          return obj;\n        });\n        insertData = res;\n        if (!this.instance) {\n          result = res;\n        }\n      }\n      this.handleInsertQuery(insertData);\n      return [result, data.rowsAffected];\n    }\n    if (this.isShowTablesQuery()) {\n      result = this.handleShowTablesQuery(data.rows);\n    } else if (this.isDescribeQuery()) {\n      result = {};\n      const table = Object.keys(this.sequelize.models);\n      const modelAttributes = {};\n      if (this.sequelize.models && table.length > 0) {\n        this._getAttributeMap(modelAttributes, this.sequelize.models[table[0]].rawAttributes);\n      }\n      data.rows.forEach((_result) => {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", \"\").replace(\"')\", \"\").replace(/'/g, \"\");\n        }\n        if (!(modelAttributes[_result.COLUMN_NAME] in result)) {\n          let key = modelAttributes[_result.COLUMN_NAME];\n          if (!key) {\n            key = _result.COLUMN_NAME;\n          }\n          result[key] = {\n            type: _result.DATA_TYPE.toUpperCase(),\n            allowNull: _result.NULLABLE === \"N\" ? false : true,\n            defaultValue: void 0,\n            primaryKey: _result.CONSTRAINT_TYPE === \"P\"\n          };\n        }\n      });\n    } else if (this.isShowIndexesQuery()) {\n      result = this.handleShowIndexesQuery(data.rows);\n    } else if (this.isSelectQuery()) {\n      const rows = data.rows;\n      const result2 = this._processRows(rows);\n      return this.handleSelectQuery(result2);\n    } else if (this.isCallQuery()) {\n      result = data.rows[0];\n    } else if (this.isUpdateQuery()) {\n      result = [result, data.rowsAffected];\n    } else if (this.isBulkUpdateQuery()) {\n      result = data.rowsAffected;\n    } else if (this.isBulkDeleteQuery()) {\n      result = data.rowsAffected;\n    } else if (this.isVersionQuery()) {\n      const version = data.rows[0].VERSION_FULL;\n      if (version) {\n        const versions = version.split(\".\");\n        result = `${versions[0]}.${versions[1]}.${versions[2]}`;\n      } else {\n        result = \"0.0.0\";\n      }\n    } else if (this.isForeignKeysQuery()) {\n      result = data.rows;\n    } else if (this.isUpsertQuery()) {\n      data = data.outBinds;\n      const keys = Object.keys(this.options.outBindAttributes);\n      const obj = {};\n      for (const k in keys) {\n        obj[keys[k]] = data[k];\n      }\n      obj.isUpdate = data[data.length - 1];\n      data = obj;\n      result = [{ isNewRecord: data.isUpdate, value: data }, data.isUpdate == 0];\n    } else if (this.isShowConstraintsQuery()) {\n      result = this.handleShowConstraintsQuery(data);\n    } else if (this.isRawQuery()) {\n      if (data && data.rows) {\n        return [data.rows, data.metaData];\n      }\n      return [data, data];\n    }\n    return result;\n  }\n  handleShowConstraintsQuery(data) {\n    return data.rows.map((result) => {\n      const constraint = {};\n      for (const key in result) {\n        constraint[_.camelCase(key)] = result[key].toLowerCase();\n      }\n      return constraint;\n    });\n  }\n  handleShowTablesQuery(results) {\n    return results.map((resultSet) => {\n      return {\n        tableName: resultSet.TABLE_NAME,\n        schema: resultSet.TABLE_SCHEMA\n      };\n    });\n  }\n  formatError(err) {\n    let match;\n    match = err.message.match(/unique constraint ([\\s\\S]*) violated/);\n    if (match && match.length > 1) {\n      match[1] = match[1].replace(\"(\", \"\").replace(\")\", \"\").split(\".\")[1];\n      const errors = [];\n      let fields = [], message = \"Validation error\", uniqueKey = null;\n      if (this.model) {\n        const uniqueKeys = Object.keys(this.model.uniqueKeys);\n        const currKey = uniqueKeys.find((key) => {\n          return key.toUpperCase() === match[1].toUpperCase() || key.toUpperCase() === `\"${match[1].toUpperCase()}\"`;\n        });\n        if (currKey) {\n          uniqueKey = this.model.uniqueKeys[currKey];\n          fields = uniqueKey.fields;\n        }\n        if (uniqueKey && !!uniqueKey.msg) {\n          message = uniqueKey.msg;\n        }\n        fields.forEach((field) => {\n          errors.push(new SequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, null));\n        });\n      }\n      return new SequelizeErrors.UniqueConstraintError({\n        message,\n        errors,\n        err,\n        fields\n      });\n    }\n    match = err.message.match(/ORA-02291/) || err.message.match(/ORA-02292/);\n    if (match && match.length > 0) {\n      return new SequelizeErrors.ForeignKeyConstraintError({\n        fields: null,\n        index: match[1],\n        parent: err\n      });\n    }\n    match = err.message.match(/ORA-02443/);\n    if (match && match.length > 0) {\n      return new SequelizeErrors.UnknownConstraintError(match[1]);\n    }\n    return new SequelizeErrors.DatabaseError(err);\n  }\n  isShowIndexesQuery() {\n    return this.sql.indexOf(\"SELECT i.index_name,i.table_name, i.column_name, u.uniqueness\") > -1;\n  }\n  isSelectCountQuery() {\n    return this.sql.toUpperCase().indexOf(\"SELECT COUNT(\") > -1;\n  }\n  handleShowIndexesQuery(data) {\n    const acc = [];\n    data.forEach((indexRecord) => {\n      if (!acc[indexRecord.INDEX_NAME]) {\n        acc[indexRecord.INDEX_NAME] = {\n          unique: indexRecord.UNIQUENESS === \"UNIQUE\" ? true : false,\n          primary: indexRecord.CONSTRAINT_TYPE === \"P\",\n          name: indexRecord.INDEX_NAME.toLowerCase(),\n          tableName: indexRecord.TABLE_NAME.toLowerCase(),\n          type: void 0\n        };\n        acc[indexRecord.INDEX_NAME].fields = [];\n      }\n      acc[indexRecord.INDEX_NAME].fields.push({\n        attribute: indexRecord.COLUMN_NAME,\n        length: void 0,\n        order: indexRecord.DESCEND,\n        collate: void 0\n      });\n    });\n    const returnIndexes = [];\n    const accKeys = Object.keys(acc);\n    for (const accKey of accKeys) {\n      const columns = {};\n      columns.fields = acc[accKey].fields;\n      if (acc[accKey].name.match(/sys_c[0-9]*/)) {\n        acc[accKey].name = Utils.nameIndex(columns, acc[accKey].tableName).name;\n      }\n      returnIndexes.push(acc[accKey]);\n    }\n    return returnIndexes;\n  }\n  handleInsertQuery(results, metaData) {\n    if (this.instance && results.length > 0) {\n      if (\"pkReturnVal\" in results[0]) {\n        results[0][this.model.primaryKeyAttribute] = results[0].pkReturnVal;\n        delete results[0].pkReturnVal;\n      }\n      const autoIncrementField = this.model.autoIncrementAttribute;\n      let autoIncrementFieldAlias = null, id = null;\n      if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementField) && this.model.rawAttributes[autoIncrementField].field !== void 0)\n        autoIncrementFieldAlias = this.model.rawAttributes[autoIncrementField].field;\n      id = id || results && results[0][this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      id = id || results && results[0][autoIncrementField];\n      id = id || autoIncrementFieldAlias && results && results[0][autoIncrementFieldAlias];\n      this.instance[autoIncrementField] = id;\n    }\n  }\n}\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0JBQXNCLG1CQUFPLENBQUMsb0dBQW1CO0FBQ2pELHdCQUF3QixtQkFBTyxDQUFDLG9GQUFjO0FBQzlDLG9CQUFvQixtQkFBTyxDQUFDLDhGQUFnQjtBQUM1QyxVQUFVLG1CQUFPLENBQUMsaUVBQVE7QUFDMUIsY0FBYyxtQkFBTyxDQUFDLDRFQUFhO0FBQ25DLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsMEZBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGVBQWU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsZ0NBQWdDO0FBQ2hDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0JBQXdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsNkJBQTZCO0FBQ3BHO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsbUJBQW1CO0FBQ3pFO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVksR0FBRyxZQUFZLEdBQUcsWUFBWTtBQUM5RCxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUF5QztBQUMzRCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLHVCQUF1QjtBQUNsSCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvb3JhY2xlL3F1ZXJ5LmpzPzNlZTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBPcmFjbGVRdWVyeTogKCkgPT4gT3JhY2xlUXVlcnlcbn0pO1xuY29uc3QgQWJzdHJhY3RRdWVyeSA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9xdWVyeVwiKTtcbmNvbnN0IFNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCBwYXJzZXJTdG9yZSA9IHJlcXVpcmUoXCIuLi9wYXJzZXJTdG9yZVwiKShcIm9yYWNsZVwiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2xvZ2dlclwiKTtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dChcInNxbDpvcmFjbGVcIik7XG5jbGFzcyBPcmFjbGVRdWVyeSBleHRlbmRzIEFic3RyYWN0UXVlcnkge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uLCBzZXF1ZWxpemUsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihjb25uZWN0aW9uLCBzZXF1ZWxpemUsIG9wdGlvbnMpO1xuICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHtcbiAgICAgIGxvZ2dpbmc6IGNvbnNvbGUubG9nLFxuICAgICAgcGxhaW46IGZhbHNlLFxuICAgICAgcmF3OiBmYWxzZVxuICAgIH0sIG9wdGlvbnMgfHwge30pO1xuICAgIHRoaXMuY2hlY2tMb2dnaW5nT3B0aW9uKCk7XG4gICAgdGhpcy5vdXRGb3JtYXQgPSBvcHRpb25zLm91dEZvcm1hdCB8fCB0aGlzLnNlcXVlbGl6ZS5jb25uZWN0aW9uTWFuYWdlci5saWIuT0JKRUNUO1xuICB9XG4gIGdldEluc2VydElkRmllbGQoKSB7XG4gICAgcmV0dXJuIFwiaWRcIjtcbiAgfVxuICBnZXRFeGVjT3B0aW9ucygpIHtcbiAgICBjb25zdCBleGVjT3B0cyA9IHsgb3V0Rm9ybWF0OiB0aGlzLm91dEZvcm1hdCwgYXV0b0NvbW1pdDogdGhpcy5hdXRvQ29tbWl0IH07XG4gICAgY29uc3Qgb3JhY2xlZGIgPSB0aGlzLnNlcXVlbGl6ZS5jb25uZWN0aW9uTWFuYWdlci5saWI7XG4gICAgaWYgKHRoaXMubW9kZWwgJiYgdGhpcy5pc1NlbGVjdFF1ZXJ5KCkpIHtcbiAgICAgIGNvbnN0IGZJbmZvID0ge307XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5tb2RlbC50YWJsZUF0dHJpYnV0ZXMpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBjb25zdCBrZXlWYWx1ZSA9IHRoaXMubW9kZWwudGFibGVBdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIGlmIChrZXlWYWx1ZS50eXBlLmtleSA9PT0gXCJERUNJTUFMXCIpIHtcbiAgICAgICAgICBmSW5mb1trZXldID0geyB0eXBlOiBvcmFjbGVkYi5TVFJJTkcgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5VmFsdWUudHlwZS5rZXkgPT09IFwiQklHSU5UXCIpIHtcbiAgICAgICAgICBmSW5mb1trZXldID0geyB0eXBlOiBvcmFjbGVkYi5TVFJJTkcgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZJbmZvKSB7XG4gICAgICAgIGV4ZWNPcHRzLmZldGNoSW5mbyA9IGZJbmZvO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhlY09wdHM7XG4gIH1cbiAgX2NvbnZlcnRCaW5kQXR0cmlidXRlcyhiaW5kaW5nRGljdGlvbmFyeSwgb3JhY2xlZGIpIHtcbiAgICBpZiAodGhpcy5tb2RlbCAmJiB0aGlzLm9wdGlvbnNbYmluZGluZ0RpY3Rpb25hcnldKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5tb2RlbC50YWJsZUF0dHJpYnV0ZXMpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBjb25zdCBrZXlWYWx1ZSA9IHRoaXMubW9kZWwudGFibGVBdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIGlmIChrZXlWYWx1ZS50eXBlLmtleSA9PT0gXCJCSUdJTlRcIikge1xuICAgICAgICAgIGNvbnN0IG9sZEJpbmRpbmcgPSB0aGlzLm9wdGlvbnNbYmluZGluZ0RpY3Rpb25hcnldW2tleV07XG4gICAgICAgICAgaWYgKG9sZEJpbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1tiaW5kaW5nRGljdGlvbmFyeV1ba2V5XSA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9sZEJpbmRpbmcpLCB7XG4gICAgICAgICAgICAgIHR5cGU6IG9yYWNsZWRiLlNUUklORyxcbiAgICAgICAgICAgICAgbWF4U2l6ZTogMWU3XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgcnVuKHNxbCwgcGFyYW1ldGVycykge1xuICAgIGNvbnN0IG9yYWNsZWRiID0gdGhpcy5zZXF1ZWxpemUuY29ubmVjdGlvbk1hbmFnZXIubGliO1xuICAgIGNvbnN0IGNvbXBsZXRlID0gdGhpcy5fbG9nUXVlcnkoc3FsLCBkZWJ1ZywgcGFyYW1ldGVycyk7XG4gICAgY29uc3Qgb3V0UGFyYW1ldGVycyA9IFtdO1xuICAgIGNvbnN0IGJpbmRQYXJhbWV0ZXJzID0gW107XG4gICAgY29uc3QgYmluZERlZiA9IFtdO1xuICAgIGlmICghc3FsLm1hdGNoKC9FTkQ7JC8pKSB7XG4gICAgICB0aGlzLnNxbCA9IHNxbC5yZXBsYWNlKC87ICokLywgXCJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3FsID0gc3FsO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLm91dEJpbmRBdHRyaWJ1dGVzICYmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnMpIHx8IF8uaXNQbGFpbk9iamVjdChwYXJhbWV0ZXJzKSkpIHtcbiAgICAgIHRoaXMuX2NvbnZlcnRCaW5kQXR0cmlidXRlcyhcIm91dEJpbmRBdHRyaWJ1dGVzXCIsIG9yYWNsZWRiKTtcbiAgICAgIG91dFBhcmFtZXRlcnMucHVzaCguLi5PYmplY3QudmFsdWVzKHRoaXMub3B0aW9ucy5vdXRCaW5kQXR0cmlidXRlcykpO1xuICAgICAgaWYgKHRoaXMuaXNVcHNlcnRRdWVyeSgpKSB7XG4gICAgICAgIG91dFBhcmFtZXRlcnMucHVzaCh7IGRpcjogb3JhY2xlZGIuQklORF9PVVQgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYmluZFBhcmFtZXRlcnMgPSBvdXRQYXJhbWV0ZXJzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnMpIHx8IF8uaXNQbGFpbk9iamVjdChwYXJhbWV0ZXJzKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leGVjdXRlTWFueSkge1xuICAgICAgICB0aGlzLl9jb252ZXJ0QmluZEF0dHJpYnV0ZXMoXCJpbmJpbmRBdHRyaWJ1dGVzXCIsIG9yYWNsZWRiKTtcbiAgICAgICAgYmluZERlZi5wdXNoKC4uLk9iamVjdC52YWx1ZXModGhpcy5vcHRpb25zLmluYmluZEF0dHJpYnV0ZXMpKTtcbiAgICAgICAgYmluZERlZi5wdXNoKC4uLm91dFBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLmJpbmRQYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1Jhd1F1ZXJ5KCkpIHtcbiAgICAgICAgdGhpcy5iaW5kUGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3QudmFsdWVzKHBhcmFtZXRlcnMpLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgYmluZFBhcmFtZXRlcnMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBiaW5kUGFyYW1ldGVycy5wdXNoKC4uLm91dFBhcmFtZXRlcnMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuYmluZFBhcmFtZXRlcnMsIGJpbmRQYXJhbWV0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc3FsLnN0YXJ0c1dpdGgoXCJCRUdJTiBUUkFOU0FDVElPTlwiKSkge1xuICAgICAgdGhpcy5hdXRvY29tbWl0ID0gZmFsc2U7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNxbC5zdGFydHNXaXRoKFwiU0VUIEFVVE9DT01NSVQgT05cIikpIHtcbiAgICAgIHRoaXMuYXV0b2NvbW1pdCA9IHRydWU7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNxbC5zdGFydHNXaXRoKFwiU0VUIEFVVE9DT01NSVQgT0ZGXCIpKSB7XG4gICAgICB0aGlzLmF1dG9jb21taXQgPSBmYWxzZTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3FsLnN0YXJ0c1dpdGgoXCJERUNMQVJFIHggTlVNQkVSXCIpKSB7XG4gICAgICBpZiAodGhpcy5hdXRvQ29tbWl0ID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbi51dWlkKSB7XG4gICAgICAgICAgdGhpcy5hdXRvQ29tbWl0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hdXRvQ29tbWl0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLmV4ZWN1dGUodGhpcy5zcWwsIHRoaXMuYmluZFBhcmFtZXRlcnMsIHsgYXV0b0NvbW1pdDogdGhpcy5hdXRvQ29tbWl0IH0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IHRoaXMuZm9ybWF0RXJyb3IoZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc3FsLnN0YXJ0c1dpdGgoXCJCRUdJTlwiKSkge1xuICAgICAgaWYgKHRoaXMuYXV0b0NvbW1pdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24udXVpZCkge1xuICAgICAgICAgIHRoaXMuYXV0b0NvbW1pdCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYXV0b0NvbW1pdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5leGVjdXRlKHRoaXMuc3FsLCB0aGlzLmJpbmRQYXJhbWV0ZXJzLCB7XG4gICAgICAgICAgb3V0Rm9ybWF0OiB0aGlzLm91dEZvcm1hdCxcbiAgICAgICAgICBhdXRvQ29tbWl0OiB0aGlzLmF1dG9Db21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHQub3V0QmluZHMpKSB7XG4gICAgICAgICAgcmV0dXJuIFtyZXN1bHQub3V0QmluZHNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQub3V0QmluZHM7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyB0aGlzLmZvcm1hdEVycm9yKGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnNxbC5zdGFydHNXaXRoKFwiQ09NTUlUIFRSQU5TQUNUSU9OXCIpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uY29tbWl0KCk7XG4gICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5mb3JtYXRFcnJvcihlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zcWwuc3RhcnRzV2l0aChcIlJPTExCQUNLIFRSQU5TQUNUSU9OXCIpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24ucm9sbGJhY2soKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyB0aGlzLmZvcm1hdEVycm9yKGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnNxbC5zdGFydHNXaXRoKFwiU0VUIFRSQU5TQUNUSU9OXCIpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZXhlY3V0ZSh0aGlzLnNxbCwgW10sIHsgYXV0b0NvbW1pdDogZmFsc2UgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5mb3JtYXRFcnJvcihlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5hdXRvQ29tbWl0ID09PSB2b2lkIDApIHtcbiAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24udXVpZCkge1xuICAgICAgICB0aGlzLmF1dG9Db21taXQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXV0b0NvbW1pdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChcImlucHV0UGFyYW1ldGVyc1wiIGluIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaW5wdXRQYXJhbWV0ZXJzICE9PSBudWxsKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMuYmluZFBhcmFtZXRlcnMsIHRoaXMub3B0aW9ucy5pbnB1dFBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBleGVjT3B0cyA9IHRoaXMuZ2V0RXhlY09wdGlvbnMoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmV4ZWN1dGVNYW55ICYmIGJpbmREZWYubGVuZ3RoID4gMCkge1xuICAgICAgZXhlY09wdHMuYmluZERlZnMgPSBiaW5kRGVmO1xuICAgIH1cbiAgICBjb25zdCBleGVjdXRlUHJvbWlzZSA9IHRoaXMub3B0aW9ucy5leGVjdXRlTWFueSA/IHRoaXMuY29ubmVjdGlvbi5leGVjdXRlTWFueSh0aGlzLnNxbCwgdGhpcy5iaW5kUGFyYW1ldGVycywgZXhlY09wdHMpIDogdGhpcy5jb25uZWN0aW9uLmV4ZWN1dGUodGhpcy5zcWwsIHRoaXMuYmluZFBhcmFtZXRlcnMsIGV4ZWNPcHRzKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhlY3V0ZVByb21pc2U7XG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXRSZXN1bHRzKHJlc3VsdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuZm9ybWF0RXJyb3IoZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QpIHtcbiAgICBjb25zdCByZXBsYWNlbWVudEZ1bmMgPSAobWF0Y2gsIGtleSwgdmFsdWVzMikgPT4ge1xuICAgICAgaWYgKHZhbHVlczJba2V5XSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBgOiR7a2V5fWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG4gICAgc3FsID0gQWJzdHJhY3RRdWVyeS5mb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCwgcmVwbGFjZW1lbnRGdW5jKVswXTtcbiAgICByZXR1cm4gW3NxbCwgdmFsdWVzXTtcbiAgfVxuICBfZ2V0QXR0cmlidXRlTWFwKGF0dHJzTWFwLCByYXdBdHRyaWJ1dGVzKSB7XG4gICAgYXR0cnNNYXAgPSBPYmplY3QuYXNzaWduKGF0dHJzTWFwLCBfLnJlZHVjZShyYXdBdHRyaWJ1dGVzLCAobXAsIF8yLCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IGNhdGFsb2dLZXkgPSB0aGlzLnNlcXVlbGl6ZS5xdWVyeUludGVyZmFjZS5xdWVyeUdlbmVyYXRvci5nZXRDYXRhbG9nTmFtZShrZXkpO1xuICAgICAgbXBbY2F0YWxvZ0tleV0gPSBrZXk7XG4gICAgICByZXR1cm4gbXA7XG4gICAgfSwge30pKTtcbiAgfVxuICBfcHJvY2Vzc1Jvd3Mocm93cykge1xuICAgIGxldCByZXN1bHQgPSByb3dzO1xuICAgIGxldCBhdHRyc01hcCA9IHt9O1xuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnF1b3RlSWRlbnRpZmllcnMgPT09IGZhbHNlKSB7XG4gICAgICBhdHRyc01hcCA9IF8ucmVkdWNlKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVzLCAobXAsIHYpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdiA9IHZbMV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2F0YWxvZ3YgPSB0aGlzLnNlcXVlbGl6ZS5xdWVyeUludGVyZmFjZS5xdWVyeUdlbmVyYXRvci5nZXRDYXRhbG9nTmFtZSh2KTtcbiAgICAgICAgbXBbY2F0YWxvZ3ZdID0gdjtcbiAgICAgICAgcmV0dXJuIG1wO1xuICAgICAgfSwge30pO1xuICAgICAgaWYgKHRoaXMubW9kZWwpIHtcbiAgICAgICAgdGhpcy5fZ2V0QXR0cmlidXRlTWFwKGF0dHJzTWFwLCB0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbGlhc2VzTWFwcGluZykge1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuZnJvbUVudHJpZXModGhpcy5vcHRpb25zLmFsaWFzZXNNYXBwaW5nKTtcbiAgICAgICAgcm93cyA9IHJvd3MubWFwKChyb3cpID0+IF8udG9QYWlycyhyb3cpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICBjb25zdCBtYXBwaW5nID0gT2JqZWN0LnZhbHVlcyhvYmopLmZpbmQoKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhdGFsb2dFbGVtZW50ID0gdGhpcy5zZXF1ZWxpemUucXVlcnlJbnRlcmZhY2UucXVlcnlHZW5lcmF0b3IuZ2V0Q2F0YWxvZ05hbWUoZWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gY2F0YWxvZ0VsZW1lbnQgPT09IGtleTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAobWFwcGluZylcbiAgICAgICAgICAgIGFjY1ttYXBwaW5nIHx8IGtleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSkpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gcm93cy5tYXAoKHJvdykgPT4ge1xuICAgICAgICByZXR1cm4gXy5tYXBLZXlzKHJvdywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRBdHRyID0gYXR0cnNNYXBba2V5XTtcbiAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldEF0dHIgPT09IFwic3RyaW5nXCIgJiYgdGFyZ2V0QXR0ciAhPT0ga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0QXR0cjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMubW9kZWwpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAoKHJvdykgPT4ge1xuICAgICAgICByZXR1cm4gXy5tYXBWYWx1ZXMocm93LCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XSAmJiB0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS50eXBlKSB7XG4gICAgICAgICAgICBsZXQgdHlwZWlkID0gdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0udHlwZS50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1trZXldLnR5cGUua2V5ID09PSBcIkpTT05cIikge1xuICAgICAgICAgICAgICB2YWx1ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVpZC5pbmRleE9mKFwiKFwiKSA+IC0xICYmIHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1trZXldLnR5cGUua2V5ICE9PSBcIkJPT0xFQU5cIikge1xuICAgICAgICAgICAgICB0eXBlaWQgPSB0eXBlaWQuc3Vic3RyKDAsIHR5cGVpZC5pbmRleE9mKFwiKFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJzZSA9IHBhcnNlclN0b3JlLmdldCh0eXBlaWQpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYgISFwYXJzZSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZvcm1hdFJlc3VsdHMoZGF0YSkge1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmluc3RhbmNlO1xuICAgIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkoZGF0YSkpIHtcbiAgICAgIGxldCBpbnNlcnREYXRhO1xuICAgICAgaWYgKGRhdGEub3V0QmluZHMpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5vdXRCaW5kQXR0cmlidXRlcyk7XG4gICAgICAgIGluc2VydERhdGEgPSBkYXRhLm91dEJpbmRzO1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgIGluc2VydERhdGEgPSBbaW5zZXJ0RGF0YV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gaW5zZXJ0RGF0YS5tYXAoKHJvdykgPT4ge1xuICAgICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICAgIHJvdy5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgb2JqW2tleXNbaW5kZXhdXSA9IGVsZW1lbnRbMF07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSk7XG4gICAgICAgIGluc2VydERhdGEgPSByZXM7XG4gICAgICAgIGlmICghdGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5oYW5kbGVJbnNlcnRRdWVyeShpbnNlcnREYXRhKTtcbiAgICAgIHJldHVybiBbcmVzdWx0LCBkYXRhLnJvd3NBZmZlY3RlZF07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd1RhYmxlc1F1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuaGFuZGxlU2hvd1RhYmxlc1F1ZXJ5KGRhdGEucm93cyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzRGVzY3JpYmVRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSB7fTtcbiAgICAgIGNvbnN0IHRhYmxlID0gT2JqZWN0LmtleXModGhpcy5zZXF1ZWxpemUubW9kZWxzKTtcbiAgICAgIGNvbnN0IG1vZGVsQXR0cmlidXRlcyA9IHt9O1xuICAgICAgaWYgKHRoaXMuc2VxdWVsaXplLm1vZGVscyAmJiB0YWJsZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX2dldEF0dHJpYnV0ZU1hcChtb2RlbEF0dHJpYnV0ZXMsIHRoaXMuc2VxdWVsaXplLm1vZGVsc1t0YWJsZVswXV0ucmF3QXR0cmlidXRlcyk7XG4gICAgICB9XG4gICAgICBkYXRhLnJvd3MuZm9yRWFjaCgoX3Jlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoX3Jlc3VsdC5EZWZhdWx0KSB7XG4gICAgICAgICAgX3Jlc3VsdC5EZWZhdWx0ID0gX3Jlc3VsdC5EZWZhdWx0LnJlcGxhY2UoXCIoJ1wiLCBcIlwiKS5yZXBsYWNlKFwiJylcIiwgXCJcIikucmVwbGFjZSgvJy9nLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShtb2RlbEF0dHJpYnV0ZXNbX3Jlc3VsdC5DT0xVTU5fTkFNRV0gaW4gcmVzdWx0KSkge1xuICAgICAgICAgIGxldCBrZXkgPSBtb2RlbEF0dHJpYnV0ZXNbX3Jlc3VsdC5DT0xVTU5fTkFNRV07XG4gICAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIGtleSA9IF9yZXN1bHQuQ09MVU1OX05BTUU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdFtrZXldID0ge1xuICAgICAgICAgICAgdHlwZTogX3Jlc3VsdC5EQVRBX1RZUEUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgIGFsbG93TnVsbDogX3Jlc3VsdC5OVUxMQUJMRSA9PT0gXCJOXCIgPyBmYWxzZSA6IHRydWUsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHZvaWQgMCxcbiAgICAgICAgICAgIHByaW1hcnlLZXk6IF9yZXN1bHQuQ09OU1RSQUlOVF9UWVBFID09PSBcIlBcIlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1Nob3dJbmRleGVzUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5oYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KGRhdGEucm93cyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzU2VsZWN0UXVlcnkoKSkge1xuICAgICAgY29uc3Qgcm93cyA9IGRhdGEucm93cztcbiAgICAgIGNvbnN0IHJlc3VsdDIgPSB0aGlzLl9wcm9jZXNzUm93cyhyb3dzKTtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbGVjdFF1ZXJ5KHJlc3VsdDIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NhbGxRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSBkYXRhLnJvd3NbMF07XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVXBkYXRlUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gW3Jlc3VsdCwgZGF0YS5yb3dzQWZmZWN0ZWRdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0J1bGtVcGRhdGVRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSBkYXRhLnJvd3NBZmZlY3RlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNCdWxrRGVsZXRlUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gZGF0YS5yb3dzQWZmZWN0ZWQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVmVyc2lvblF1ZXJ5KCkpIHtcbiAgICAgIGNvbnN0IHZlcnNpb24gPSBkYXRhLnJvd3NbMF0uVkVSU0lPTl9GVUxMO1xuICAgICAgaWYgKHZlcnNpb24pIHtcbiAgICAgICAgY29uc3QgdmVyc2lvbnMgPSB2ZXJzaW9uLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgcmVzdWx0ID0gYCR7dmVyc2lvbnNbMF19LiR7dmVyc2lvbnNbMV19LiR7dmVyc2lvbnNbMl19YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IFwiMC4wLjBcIjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNGb3JlaWduS2V5c1F1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IGRhdGEucm93cztcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNVcHNlcnRRdWVyeSgpKSB7XG4gICAgICBkYXRhID0gZGF0YS5vdXRCaW5kcztcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMub3V0QmluZEF0dHJpYnV0ZXMpO1xuICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICBmb3IgKGNvbnN0IGsgaW4ga2V5cykge1xuICAgICAgICBvYmpba2V5c1trXV0gPSBkYXRhW2tdO1xuICAgICAgfVxuICAgICAgb2JqLmlzVXBkYXRlID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdO1xuICAgICAgZGF0YSA9IG9iajtcbiAgICAgIHJlc3VsdCA9IFt7IGlzTmV3UmVjb3JkOiBkYXRhLmlzVXBkYXRlLCB2YWx1ZTogZGF0YSB9LCBkYXRhLmlzVXBkYXRlID09IDBdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1Nob3dDb25zdHJhaW50c1F1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuaGFuZGxlU2hvd0NvbnN0cmFpbnRzUXVlcnkoZGF0YSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzUmF3UXVlcnkoKSkge1xuICAgICAgaWYgKGRhdGEgJiYgZGF0YS5yb3dzKSB7XG4gICAgICAgIHJldHVybiBbZGF0YS5yb3dzLCBkYXRhLm1ldGFEYXRhXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbZGF0YSwgZGF0YV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaGFuZGxlU2hvd0NvbnN0cmFpbnRzUXVlcnkoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLnJvd3MubWFwKChyZXN1bHQpID0+IHtcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnQgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdCkge1xuICAgICAgICBjb25zdHJhaW50W18uY2FtZWxDYXNlKGtleSldID0gcmVzdWx0W2tleV0udG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25zdHJhaW50O1xuICAgIH0pO1xuICB9XG4gIGhhbmRsZVNob3dUYWJsZXNRdWVyeShyZXN1bHRzKSB7XG4gICAgcmV0dXJuIHJlc3VsdHMubWFwKChyZXN1bHRTZXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhYmxlTmFtZTogcmVzdWx0U2V0LlRBQkxFX05BTUUsXG4gICAgICAgIHNjaGVtYTogcmVzdWx0U2V0LlRBQkxFX1NDSEVNQVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBmb3JtYXRFcnJvcihlcnIpIHtcbiAgICBsZXQgbWF0Y2g7XG4gICAgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvdW5pcXVlIGNvbnN0cmFpbnQgKFtcXHNcXFNdKikgdmlvbGF0ZWQvKTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgbWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKFwiKFwiLCBcIlwiKS5yZXBsYWNlKFwiKVwiLCBcIlwiKS5zcGxpdChcIi5cIilbMV07XG4gICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgIGxldCBmaWVsZHMgPSBbXSwgbWVzc2FnZSA9IFwiVmFsaWRhdGlvbiBlcnJvclwiLCB1bmlxdWVLZXkgPSBudWxsO1xuICAgICAgaWYgKHRoaXMubW9kZWwpIHtcbiAgICAgICAgY29uc3QgdW5pcXVlS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubW9kZWwudW5pcXVlS2V5cyk7XG4gICAgICAgIGNvbnN0IGN1cnJLZXkgPSB1bmlxdWVLZXlzLmZpbmQoKGtleSkgPT4ge1xuICAgICAgICAgIHJldHVybiBrZXkudG9VcHBlckNhc2UoKSA9PT0gbWF0Y2hbMV0udG9VcHBlckNhc2UoKSB8fCBrZXkudG9VcHBlckNhc2UoKSA9PT0gYFwiJHttYXRjaFsxXS50b1VwcGVyQ2FzZSgpfVwiYDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjdXJyS2V5KSB7XG4gICAgICAgICAgdW5pcXVlS2V5ID0gdGhpcy5tb2RlbC51bmlxdWVLZXlzW2N1cnJLZXldO1xuICAgICAgICAgIGZpZWxkcyA9IHVuaXF1ZUtleS5maWVsZHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXF1ZUtleSAmJiAhIXVuaXF1ZUtleS5tc2cpIHtcbiAgICAgICAgICBtZXNzYWdlID0gdW5pcXVlS2V5Lm1zZztcbiAgICAgICAgfVxuICAgICAgICBmaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICBlcnJvcnMucHVzaChuZXcgU2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvckl0ZW0odGhpcy5nZXRVbmlxdWVDb25zdHJhaW50RXJyb3JNZXNzYWdlKGZpZWxkKSwgXCJ1bmlxdWUgdmlvbGF0aW9uXCIsIGZpZWxkLCBudWxsKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBTZXF1ZWxpemVFcnJvcnMuVW5pcXVlQ29uc3RyYWludEVycm9yKHtcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBlcnIsXG4gICAgICAgIGZpZWxkc1xuICAgICAgfSk7XG4gICAgfVxuICAgIG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL09SQS0wMjI5MS8pIHx8IGVyci5tZXNzYWdlLm1hdGNoKC9PUkEtMDIyOTIvKTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIG5ldyBTZXF1ZWxpemVFcnJvcnMuRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgIGZpZWxkczogbnVsbCxcbiAgICAgICAgaW5kZXg6IG1hdGNoWzFdLFxuICAgICAgICBwYXJlbnQ6IGVyclxuICAgICAgfSk7XG4gICAgfVxuICAgIG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL09SQS0wMjQ0My8pO1xuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gbmV3IFNlcXVlbGl6ZUVycm9ycy5Vbmtub3duQ29uc3RyYWludEVycm9yKG1hdGNoWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTZXF1ZWxpemVFcnJvcnMuRGF0YWJhc2VFcnJvcihlcnIpO1xuICB9XG4gIGlzU2hvd0luZGV4ZXNRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5zcWwuaW5kZXhPZihcIlNFTEVDVCBpLmluZGV4X25hbWUsaS50YWJsZV9uYW1lLCBpLmNvbHVtbl9uYW1lLCB1LnVuaXF1ZW5lc3NcIikgPiAtMTtcbiAgfVxuICBpc1NlbGVjdENvdW50UXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3FsLnRvVXBwZXJDYXNlKCkuaW5kZXhPZihcIlNFTEVDVCBDT1VOVChcIikgPiAtMTtcbiAgfVxuICBoYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KGRhdGEpIHtcbiAgICBjb25zdCBhY2MgPSBbXTtcbiAgICBkYXRhLmZvckVhY2goKGluZGV4UmVjb3JkKSA9PiB7XG4gICAgICBpZiAoIWFjY1tpbmRleFJlY29yZC5JTkRFWF9OQU1FXSkge1xuICAgICAgICBhY2NbaW5kZXhSZWNvcmQuSU5ERVhfTkFNRV0gPSB7XG4gICAgICAgICAgdW5pcXVlOiBpbmRleFJlY29yZC5VTklRVUVORVNTID09PSBcIlVOSVFVRVwiID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgIHByaW1hcnk6IGluZGV4UmVjb3JkLkNPTlNUUkFJTlRfVFlQRSA9PT0gXCJQXCIsXG4gICAgICAgICAgbmFtZTogaW5kZXhSZWNvcmQuSU5ERVhfTkFNRS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgIHRhYmxlTmFtZTogaW5kZXhSZWNvcmQuVEFCTEVfTkFNRS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgIHR5cGU6IHZvaWQgMFxuICAgICAgICB9O1xuICAgICAgICBhY2NbaW5kZXhSZWNvcmQuSU5ERVhfTkFNRV0uZmllbGRzID0gW107XG4gICAgICB9XG4gICAgICBhY2NbaW5kZXhSZWNvcmQuSU5ERVhfTkFNRV0uZmllbGRzLnB1c2goe1xuICAgICAgICBhdHRyaWJ1dGU6IGluZGV4UmVjb3JkLkNPTFVNTl9OQU1FLFxuICAgICAgICBsZW5ndGg6IHZvaWQgMCxcbiAgICAgICAgb3JkZXI6IGluZGV4UmVjb3JkLkRFU0NFTkQsXG4gICAgICAgIGNvbGxhdGU6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgcmV0dXJuSW5kZXhlcyA9IFtdO1xuICAgIGNvbnN0IGFjY0tleXMgPSBPYmplY3Qua2V5cyhhY2MpO1xuICAgIGZvciAoY29uc3QgYWNjS2V5IG9mIGFjY0tleXMpIHtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSB7fTtcbiAgICAgIGNvbHVtbnMuZmllbGRzID0gYWNjW2FjY0tleV0uZmllbGRzO1xuICAgICAgaWYgKGFjY1thY2NLZXldLm5hbWUubWF0Y2goL3N5c19jWzAtOV0qLykpIHtcbiAgICAgICAgYWNjW2FjY0tleV0ubmFtZSA9IFV0aWxzLm5hbWVJbmRleChjb2x1bW5zLCBhY2NbYWNjS2V5XS50YWJsZU5hbWUpLm5hbWU7XG4gICAgICB9XG4gICAgICByZXR1cm5JbmRleGVzLnB1c2goYWNjW2FjY0tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuSW5kZXhlcztcbiAgfVxuICBoYW5kbGVJbnNlcnRRdWVyeShyZXN1bHRzLCBtZXRhRGF0YSkge1xuICAgIGlmICh0aGlzLmluc3RhbmNlICYmIHJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKFwicGtSZXR1cm5WYWxcIiBpbiByZXN1bHRzWzBdKSB7XG4gICAgICAgIHJlc3VsdHNbMF1bdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlXSA9IHJlc3VsdHNbMF0ucGtSZXR1cm5WYWw7XG4gICAgICAgIGRlbGV0ZSByZXN1bHRzWzBdLnBrUmV0dXJuVmFsO1xuICAgICAgfVxuICAgICAgY29uc3QgYXV0b0luY3JlbWVudEZpZWxkID0gdGhpcy5tb2RlbC5hdXRvSW5jcmVtZW50QXR0cmlidXRlO1xuICAgICAgbGV0IGF1dG9JbmNyZW1lbnRGaWVsZEFsaWFzID0gbnVsbCwgaWQgPSBudWxsO1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXMsIGF1dG9JbmNyZW1lbnRGaWVsZCkgJiYgdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2F1dG9JbmNyZW1lbnRGaWVsZF0uZmllbGQgIT09IHZvaWQgMClcbiAgICAgICAgYXV0b0luY3JlbWVudEZpZWxkQWxpYXMgPSB0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbYXV0b0luY3JlbWVudEZpZWxkXS5maWVsZDtcbiAgICAgIGlkID0gaWQgfHwgcmVzdWx0cyAmJiByZXN1bHRzWzBdW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcbiAgICAgIGlkID0gaWQgfHwgbWV0YURhdGEgJiYgbWV0YURhdGFbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuICAgICAgaWQgPSBpZCB8fCByZXN1bHRzICYmIHJlc3VsdHNbMF1bYXV0b0luY3JlbWVudEZpZWxkXTtcbiAgICAgIGlkID0gaWQgfHwgYXV0b0luY3JlbWVudEZpZWxkQWxpYXMgJiYgcmVzdWx0cyAmJiByZXN1bHRzWzBdW2F1dG9JbmNyZW1lbnRGaWVsZEFsaWFzXTtcbiAgICAgIHRoaXMuaW5zdGFuY2VbYXV0b0luY3JlbWVudEZpZWxkXSA9IGlkO1xuICAgIH1cbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnkuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/oracle/query.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/parserStore.js":
/*!*************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/parserStore.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("\nconst stores = /* @__PURE__ */ new Map();\nmodule.exports = (dialect) => {\n  if (!stores.has(dialect)) {\n    stores.set(dialect, /* @__PURE__ */ new Map());\n  }\n  return {\n    clear() {\n      stores.get(dialect).clear();\n    },\n    refresh(dataType) {\n      for (const type of dataType.types[dialect]) {\n        stores.get(dialect).set(type, dataType.parse);\n      }\n    },\n    get(type) {\n      return stores.get(dialect).get(type);\n    }\n  };\n};\n//# sourceMappingURL=parserStore.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wYXJzZXJTdG9yZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3BhcnNlclN0b3JlLmpzPzI0NzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBzdG9yZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xubW9kdWxlLmV4cG9ydHMgPSAoZGlhbGVjdCkgPT4ge1xuICBpZiAoIXN0b3Jlcy5oYXMoZGlhbGVjdCkpIHtcbiAgICBzdG9yZXMuc2V0KGRpYWxlY3QsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgY2xlYXIoKSB7XG4gICAgICBzdG9yZXMuZ2V0KGRpYWxlY3QpLmNsZWFyKCk7XG4gICAgfSxcbiAgICByZWZyZXNoKGRhdGFUeXBlKSB7XG4gICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgZGF0YVR5cGUudHlwZXNbZGlhbGVjdF0pIHtcbiAgICAgICAgc3RvcmVzLmdldChkaWFsZWN0KS5zZXQodHlwZSwgZGF0YVR5cGUucGFyc2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0KHR5cGUpIHtcbiAgICAgIHJldHVybiBzdG9yZXMuZ2V0KGRpYWxlY3QpLmdldCh0eXBlKTtcbiAgICB9XG4gIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VyU3RvcmUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/parserStore.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/postgres/connection-manager.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/postgres/connection-manager.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(action-browser)/../node_modules/sequelize/lib/utils/logger.js\");\nconst debug = logger.debugContext(\"connection:pg\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst semver = __webpack_require__(/*! semver */ \"(action-browser)/../node_modules/semver/index.js\");\nconst dataTypes = __webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\");\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(action-browser)/../node_modules/moment-timezone/index.js\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 5432;\n    super(dialect, sequelize);\n    const pgLib = this._loadDialectModule(\"pg\");\n    this.lib = this.sequelize.config.native ? pgLib.native : pgLib;\n    this._clearDynamicOIDs();\n    this._clearTypeParser();\n    this.refreshTypeParser(dataTypes.postgres);\n  }\n  _refreshTypeParser(dataType) {\n    const arrayParserBuilder = (parser2) => {\n      return (value) => this.lib.types.arrayParser.create(value, parser2).parse();\n    };\n    const rangeParserBuilder = (parser2) => {\n      return (value) => dataType.parse(value, { parser: parser2 });\n    };\n    if (dataType.key.toLowerCase() === \"range\") {\n      for (const name in this.nameOidMap) {\n        const entry = this.nameOidMap[name];\n        if (!entry.rangeOid)\n          continue;\n        const rangeParser = rangeParserBuilder(this.getTypeParser(entry.oid));\n        const arrayRangeParser = arrayParserBuilder(rangeParser);\n        this.oidParserMap.set(entry.rangeOid, rangeParser);\n        if (!entry.arrayRangeOid)\n          continue;\n        this.oidParserMap.set(entry.arrayRangeOid, arrayRangeParser);\n      }\n      return;\n    }\n    const parser = (value) => dataType.parse(value);\n    const arrayParser = arrayParserBuilder(parser);\n    if (dataType.key.toLowerCase() === \"enum\") {\n      this.enumOids.oids.forEach((oid) => {\n        this.oidParserMap.set(oid, parser);\n      });\n      this.enumOids.arrayOids.forEach((arrayOid) => {\n        this.oidParserMap.set(arrayOid, arrayParser);\n      });\n      return;\n    }\n    dataType.types.postgres.forEach((name) => {\n      if (!this.nameOidMap[name])\n        return;\n      this.oidParserMap.set(this.nameOidMap[name].oid, parser);\n      if (!this.nameOidMap[name].arrayOid)\n        return;\n      this.oidParserMap.set(this.nameOidMap[name].arrayOid, arrayParser);\n    });\n  }\n  _clearTypeParser() {\n    this.oidParserMap = /* @__PURE__ */ new Map();\n  }\n  getTypeParser(oid, ...args) {\n    if (this.oidParserMap.get(oid))\n      return this.oidParserMap.get(oid);\n    return this.lib.types.getTypeParser(oid, ...args);\n  }\n  async connect(config) {\n    config.user = config.username;\n    const connectionConfig = _.pick(config, [\n      \"user\",\n      \"password\",\n      \"host\",\n      \"database\",\n      \"port\"\n    ]);\n    connectionConfig.types = {\n      getTypeParser: ConnectionManager.prototype.getTypeParser.bind(this)\n    };\n    if (config.dialectOptions) {\n      _.merge(connectionConfig, _.pick(config.dialectOptions, [\n        \"application_name\",\n        \"ssl\",\n        \"client_encoding\",\n        \"binary\",\n        \"keepAlive\",\n        \"statement_timeout\",\n        \"query_timeout\",\n        \"connectionTimeoutMillis\",\n        \"idle_in_transaction_session_timeout\",\n        \"lock_timeout\",\n        \"options\",\n        \"stream\"\n      ]));\n    }\n    const connection = await new Promise((resolve, reject) => {\n      let responded = false;\n      const connection2 = new this.lib.Client(connectionConfig);\n      const parameterHandler = (message) => {\n        switch (message.parameterName) {\n          case \"server_version\":\n            if (this.sequelize.options.databaseVersion === 0) {\n              const version = semver.coerce(message.parameterValue).version;\n              this.sequelize.options.databaseVersion = semver.valid(version) ? version : this.dialect.defaultVersion;\n            }\n            break;\n          case \"standard_conforming_strings\":\n            connection2[\"standard_conforming_strings\"] = message.parameterValue;\n            break;\n        }\n      };\n      const endHandler = () => {\n        debug(\"connection timeout\");\n        if (!responded) {\n          reject(new sequelizeErrors.ConnectionTimedOutError(new Error(\"Connection timed out\")));\n        }\n      };\n      connection2.once(\"end\", endHandler);\n      if (!this.sequelize.config.native) {\n        connection2.connection.on(\"parameterStatus\", parameterHandler);\n      }\n      connection2.connect((err) => {\n        responded = true;\n        if (!this.sequelize.config.native) {\n          connection2.connection.removeListener(\"parameterStatus\", parameterHandler);\n        }\n        if (err) {\n          if (err.code) {\n            switch (err.code) {\n              case \"ECONNREFUSED\":\n                reject(new sequelizeErrors.ConnectionRefusedError(err));\n                break;\n              case \"ENOTFOUND\":\n                reject(new sequelizeErrors.HostNotFoundError(err));\n                break;\n              case \"EHOSTUNREACH\":\n                reject(new sequelizeErrors.HostNotReachableError(err));\n                break;\n              case \"EINVAL\":\n                reject(new sequelizeErrors.InvalidConnectionError(err));\n                break;\n              default:\n                reject(new sequelizeErrors.ConnectionError(err));\n                break;\n            }\n          } else {\n            reject(new sequelizeErrors.ConnectionError(err));\n          }\n        } else {\n          debug(\"connection acquired\");\n          connection2.removeListener(\"end\", endHandler);\n          resolve(connection2);\n        }\n      });\n    });\n    connection.on(\"error\", (error) => {\n      connection._invalid = true;\n      debug(`connection error ${error.code || error.message}`);\n      this.pool.destroy(connection);\n    });\n    let query = \"\";\n    if (this.sequelize.options.standardConformingStrings !== false && connection[\"standard_conforming_strings\"] !== \"on\") {\n      query += \"SET standard_conforming_strings=on;\";\n    }\n    if (this.sequelize.options.clientMinMessages !== void 0) {\n      console.warn('Usage of \"options.clientMinMessages\" is deprecated and will be removed in v7.');\n      console.warn('Please use the sequelize option \"dialectOptions.clientMinMessages\" instead.');\n    }\n    if (!(config.dialectOptions && config.dialectOptions.clientMinMessages && config.dialectOptions.clientMinMessages.toLowerCase() === \"ignore\" || this.sequelize.options.clientMinMessages === false)) {\n      const clientMinMessages = config.dialectOptions && config.dialectOptions.clientMinMessages || this.sequelize.options.clientMinMessages || \"warning\";\n      query += `SET client_min_messages TO ${clientMinMessages};`;\n    }\n    if (!this.sequelize.config.keepDefaultTimezone) {\n      const isZone = !!momentTz.tz.zone(this.sequelize.options.timezone);\n      if (isZone) {\n        query += `SET TIME ZONE '${this.sequelize.options.timezone}';`;\n      } else {\n        query += `SET TIME ZONE INTERVAL '${this.sequelize.options.timezone}' HOUR TO MINUTE;`;\n      }\n    }\n    if (query) {\n      await connection.query(query);\n    }\n    if (Object.keys(this.nameOidMap).length === 0 && this.enumOids.oids.length === 0 && this.enumOids.arrayOids.length === 0) {\n      await this._refreshDynamicOIDs(connection);\n    }\n    return connection;\n  }\n  async disconnect(connection) {\n    if (connection._ending) {\n      debug(\"connection tried to disconnect but was already at ENDING state\");\n      return;\n    }\n    return await promisify((callback) => connection.end(callback))();\n  }\n  validate(connection) {\n    return !connection._invalid && !connection._ending;\n  }\n  async _refreshDynamicOIDs(connection) {\n    const databaseVersion = this.sequelize.options.databaseVersion;\n    const supportedVersion = \"8.3.0\";\n    if ((databaseVersion && semver.gte(databaseVersion, supportedVersion)) === false) {\n      return;\n    }\n    const results = await (connection || this.sequelize).query(\"WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));\");\n    let result = Array.isArray(results) ? results.pop() : results;\n    if (Array.isArray(result)) {\n      if (result[0].command === \"SET\") {\n        result = result.pop();\n      }\n    }\n    const newNameOidMap = {};\n    const newEnumOids = { oids: [], arrayOids: [] };\n    for (const row of result.rows) {\n      if (row.typtype === \"e\") {\n        newEnumOids.oids.push(row.oid);\n        if (row.typarray)\n          newEnumOids.arrayOids.push(row.typarray);\n        continue;\n      }\n      newNameOidMap[row.typname] = { oid: row.oid };\n      if (row.typarray)\n        newNameOidMap[row.typname].arrayOid = row.typarray;\n      if (row.rngtypid) {\n        newNameOidMap[row.typname].rangeOid = row.rngtypid;\n        if (row.rngtyparray)\n          newNameOidMap[row.typname].arrayRangeOid = row.rngtyparray;\n      }\n    }\n    this.nameOidMap = newNameOidMap;\n    this.enumOids = newEnumOids;\n    this.refreshTypeParser(dataTypes.postgres);\n  }\n  _clearDynamicOIDs() {\n    this.nameOidMap = {};\n    this.enumOids = { oids: [], arrayOids: [] };\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9jb25uZWN0aW9uLW1hbmFnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixVQUFVLG1CQUFPLENBQUMsaUVBQVE7QUFDMUIsa0NBQWtDLG1CQUFPLENBQUMsOEhBQWdDO0FBQzFFLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsMEZBQW9CO0FBQy9DO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsb0ZBQWM7QUFDOUMsZUFBZSxtQkFBTyxDQUFDLGdFQUFRO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLHNGQUFrQjtBQUM1QyxpQkFBaUIsbUJBQU8sQ0FBQyxrRkFBaUI7QUFDMUMsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsbUJBQW1CO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdDQUFnQyxFQUFFO0FBQ3JFLFFBQVE7QUFDUiw0Q0FBNEMsZ0NBQWdDLGlCQUFpQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc2dCQUFzZ0I7QUFDdGdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9jb25uZWN0aW9uLW1hbmFnZXIuanM/YjA1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9jb25uZWN0aW9uLW1hbmFnZXJcIik7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2xvZ2dlclwiKTtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dChcImNvbm5lY3Rpb246cGdcIik7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzXCIpO1xuY29uc3Qgc2VtdmVyID0gcmVxdWlyZShcInNlbXZlclwiKTtcbmNvbnN0IGRhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpO1xuY29uc3QgbW9tZW50VHogPSByZXF1aXJlKFwibW9tZW50LXRpbWV6b25lXCIpO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY2xhc3MgQ29ubmVjdGlvbk1hbmFnZXIgZXh0ZW5kcyBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZGlhbGVjdCwgc2VxdWVsaXplKSB7XG4gICAgc2VxdWVsaXplLmNvbmZpZy5wb3J0ID0gc2VxdWVsaXplLmNvbmZpZy5wb3J0IHx8IDU0MzI7XG4gICAgc3VwZXIoZGlhbGVjdCwgc2VxdWVsaXplKTtcbiAgICBjb25zdCBwZ0xpYiA9IHRoaXMuX2xvYWREaWFsZWN0TW9kdWxlKFwicGdcIik7XG4gICAgdGhpcy5saWIgPSB0aGlzLnNlcXVlbGl6ZS5jb25maWcubmF0aXZlID8gcGdMaWIubmF0aXZlIDogcGdMaWI7XG4gICAgdGhpcy5fY2xlYXJEeW5hbWljT0lEcygpO1xuICAgIHRoaXMuX2NsZWFyVHlwZVBhcnNlcigpO1xuICAgIHRoaXMucmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGVzLnBvc3RncmVzKTtcbiAgfVxuICBfcmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGUpIHtcbiAgICBjb25zdCBhcnJheVBhcnNlckJ1aWxkZXIgPSAocGFyc2VyMikgPT4ge1xuICAgICAgcmV0dXJuICh2YWx1ZSkgPT4gdGhpcy5saWIudHlwZXMuYXJyYXlQYXJzZXIuY3JlYXRlKHZhbHVlLCBwYXJzZXIyKS5wYXJzZSgpO1xuICAgIH07XG4gICAgY29uc3QgcmFuZ2VQYXJzZXJCdWlsZGVyID0gKHBhcnNlcjIpID0+IHtcbiAgICAgIHJldHVybiAodmFsdWUpID0+IGRhdGFUeXBlLnBhcnNlKHZhbHVlLCB7IHBhcnNlcjogcGFyc2VyMiB9KTtcbiAgICB9O1xuICAgIGlmIChkYXRhVHlwZS5rZXkudG9Mb3dlckNhc2UoKSA9PT0gXCJyYW5nZVwiKSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5uYW1lT2lkTWFwKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5uYW1lT2lkTWFwW25hbWVdO1xuICAgICAgICBpZiAoIWVudHJ5LnJhbmdlT2lkKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCByYW5nZVBhcnNlciA9IHJhbmdlUGFyc2VyQnVpbGRlcih0aGlzLmdldFR5cGVQYXJzZXIoZW50cnkub2lkKSk7XG4gICAgICAgIGNvbnN0IGFycmF5UmFuZ2VQYXJzZXIgPSBhcnJheVBhcnNlckJ1aWxkZXIocmFuZ2VQYXJzZXIpO1xuICAgICAgICB0aGlzLm9pZFBhcnNlck1hcC5zZXQoZW50cnkucmFuZ2VPaWQsIHJhbmdlUGFyc2VyKTtcbiAgICAgICAgaWYgKCFlbnRyeS5hcnJheVJhbmdlT2lkKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB0aGlzLm9pZFBhcnNlck1hcC5zZXQoZW50cnkuYXJyYXlSYW5nZU9pZCwgYXJyYXlSYW5nZVBhcnNlcik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlciA9ICh2YWx1ZSkgPT4gZGF0YVR5cGUucGFyc2UodmFsdWUpO1xuICAgIGNvbnN0IGFycmF5UGFyc2VyID0gYXJyYXlQYXJzZXJCdWlsZGVyKHBhcnNlcik7XG4gICAgaWYgKGRhdGFUeXBlLmtleS50b0xvd2VyQ2FzZSgpID09PSBcImVudW1cIikge1xuICAgICAgdGhpcy5lbnVtT2lkcy5vaWRzLmZvckVhY2goKG9pZCkgPT4ge1xuICAgICAgICB0aGlzLm9pZFBhcnNlck1hcC5zZXQob2lkLCBwYXJzZXIpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmVudW1PaWRzLmFycmF5T2lkcy5mb3JFYWNoKChhcnJheU9pZCkgPT4ge1xuICAgICAgICB0aGlzLm9pZFBhcnNlck1hcC5zZXQoYXJyYXlPaWQsIGFycmF5UGFyc2VyKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRhVHlwZS50eXBlcy5wb3N0Z3Jlcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICBpZiAoIXRoaXMubmFtZU9pZE1hcFtuYW1lXSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5vaWRQYXJzZXJNYXAuc2V0KHRoaXMubmFtZU9pZE1hcFtuYW1lXS5vaWQsIHBhcnNlcik7XG4gICAgICBpZiAoIXRoaXMubmFtZU9pZE1hcFtuYW1lXS5hcnJheU9pZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5vaWRQYXJzZXJNYXAuc2V0KHRoaXMubmFtZU9pZE1hcFtuYW1lXS5hcnJheU9pZCwgYXJyYXlQYXJzZXIpO1xuICAgIH0pO1xuICB9XG4gIF9jbGVhclR5cGVQYXJzZXIoKSB7XG4gICAgdGhpcy5vaWRQYXJzZXJNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGdldFR5cGVQYXJzZXIob2lkLCAuLi5hcmdzKSB7XG4gICAgaWYgKHRoaXMub2lkUGFyc2VyTWFwLmdldChvaWQpKVxuICAgICAgcmV0dXJuIHRoaXMub2lkUGFyc2VyTWFwLmdldChvaWQpO1xuICAgIHJldHVybiB0aGlzLmxpYi50eXBlcy5nZXRUeXBlUGFyc2VyKG9pZCwgLi4uYXJncyk7XG4gIH1cbiAgYXN5bmMgY29ubmVjdChjb25maWcpIHtcbiAgICBjb25maWcudXNlciA9IGNvbmZpZy51c2VybmFtZTtcbiAgICBjb25zdCBjb25uZWN0aW9uQ29uZmlnID0gXy5waWNrKGNvbmZpZywgW1xuICAgICAgXCJ1c2VyXCIsXG4gICAgICBcInBhc3N3b3JkXCIsXG4gICAgICBcImhvc3RcIixcbiAgICAgIFwiZGF0YWJhc2VcIixcbiAgICAgIFwicG9ydFwiXG4gICAgXSk7XG4gICAgY29ubmVjdGlvbkNvbmZpZy50eXBlcyA9IHtcbiAgICAgIGdldFR5cGVQYXJzZXI6IENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRUeXBlUGFyc2VyLmJpbmQodGhpcylcbiAgICB9O1xuICAgIGlmIChjb25maWcuZGlhbGVjdE9wdGlvbnMpIHtcbiAgICAgIF8ubWVyZ2UoY29ubmVjdGlvbkNvbmZpZywgXy5waWNrKGNvbmZpZy5kaWFsZWN0T3B0aW9ucywgW1xuICAgICAgICBcImFwcGxpY2F0aW9uX25hbWVcIixcbiAgICAgICAgXCJzc2xcIixcbiAgICAgICAgXCJjbGllbnRfZW5jb2RpbmdcIixcbiAgICAgICAgXCJiaW5hcnlcIixcbiAgICAgICAgXCJrZWVwQWxpdmVcIixcbiAgICAgICAgXCJzdGF0ZW1lbnRfdGltZW91dFwiLFxuICAgICAgICBcInF1ZXJ5X3RpbWVvdXRcIixcbiAgICAgICAgXCJjb25uZWN0aW9uVGltZW91dE1pbGxpc1wiLFxuICAgICAgICBcImlkbGVfaW5fdHJhbnNhY3Rpb25fc2Vzc2lvbl90aW1lb3V0XCIsXG4gICAgICAgIFwibG9ja190aW1lb3V0XCIsXG4gICAgICAgIFwib3B0aW9uc1wiLFxuICAgICAgICBcInN0cmVhbVwiXG4gICAgICBdKSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgcmVzcG9uZGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBjb25uZWN0aW9uMiA9IG5ldyB0aGlzLmxpYi5DbGllbnQoY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICBjb25zdCBwYXJhbWV0ZXJIYW5kbGVyID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLnBhcmFtZXRlck5hbWUpIHtcbiAgICAgICAgICBjYXNlIFwic2VydmVyX3ZlcnNpb25cIjpcbiAgICAgICAgICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gc2VtdmVyLmNvZXJjZShtZXNzYWdlLnBhcmFtZXRlclZhbHVlKS52ZXJzaW9uO1xuICAgICAgICAgICAgICB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbiA9IHNlbXZlci52YWxpZCh2ZXJzaW9uKSA/IHZlcnNpb24gOiB0aGlzLmRpYWxlY3QuZGVmYXVsdFZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic3RhbmRhcmRfY29uZm9ybWluZ19zdHJpbmdzXCI6XG4gICAgICAgICAgICBjb25uZWN0aW9uMltcInN0YW5kYXJkX2NvbmZvcm1pbmdfc3RyaW5nc1wiXSA9IG1lc3NhZ2UucGFyYW1ldGVyVmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGVuZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGRlYnVnKFwiY29ubmVjdGlvbiB0aW1lb3V0XCIpO1xuICAgICAgICBpZiAoIXJlc3BvbmRlZCkge1xuICAgICAgICAgIHJlamVjdChuZXcgc2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25UaW1lZE91dEVycm9yKG5ldyBFcnJvcihcIkNvbm5lY3Rpb24gdGltZWQgb3V0XCIpKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25uZWN0aW9uMi5vbmNlKFwiZW5kXCIsIGVuZEhhbmRsZXIpO1xuICAgICAgaWYgKCF0aGlzLnNlcXVlbGl6ZS5jb25maWcubmF0aXZlKSB7XG4gICAgICAgIGNvbm5lY3Rpb24yLmNvbm5lY3Rpb24ub24oXCJwYXJhbWV0ZXJTdGF0dXNcIiwgcGFyYW1ldGVySGFuZGxlcik7XG4gICAgICB9XG4gICAgICBjb25uZWN0aW9uMi5jb25uZWN0KChlcnIpID0+IHtcbiAgICAgICAgcmVzcG9uZGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLnNlcXVlbGl6ZS5jb25maWcubmF0aXZlKSB7XG4gICAgICAgICAgY29ubmVjdGlvbjIuY29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcihcInBhcmFtZXRlclN0YXR1c1wiLCBwYXJhbWV0ZXJIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyci5jb2RlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGVyci5jb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJFQ09OTlJFRlVTRURcIjpcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IHNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uUmVmdXNlZEVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiRU5PVEZPVU5EXCI6XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBzZXF1ZWxpemVFcnJvcnMuSG9zdE5vdEZvdW5kRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJFSE9TVFVOUkVBQ0hcIjpcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IHNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90UmVhY2hhYmxlRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJFSU5WQUxcIjpcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IHNlcXVlbGl6ZUVycm9ycy5JbnZhbGlkQ29ubmVjdGlvbkVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgc2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25FcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBzZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvbkVycm9yKGVycikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gYWNxdWlyZWRcIik7XG4gICAgICAgICAgY29ubmVjdGlvbjIucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIiwgZW5kSGFuZGxlcik7XG4gICAgICAgICAgcmVzb2x2ZShjb25uZWN0aW9uMik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbm5lY3Rpb24ub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHtcbiAgICAgIGNvbm5lY3Rpb24uX2ludmFsaWQgPSB0cnVlO1xuICAgICAgZGVidWcoYGNvbm5lY3Rpb24gZXJyb3IgJHtlcnJvci5jb2RlIHx8IGVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB0aGlzLnBvb2wuZGVzdHJveShjb25uZWN0aW9uKTtcbiAgICB9KTtcbiAgICBsZXQgcXVlcnkgPSBcIlwiO1xuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnN0YW5kYXJkQ29uZm9ybWluZ1N0cmluZ3MgIT09IGZhbHNlICYmIGNvbm5lY3Rpb25bXCJzdGFuZGFyZF9jb25mb3JtaW5nX3N0cmluZ3NcIl0gIT09IFwib25cIikge1xuICAgICAgcXVlcnkgKz0gXCJTRVQgc3RhbmRhcmRfY29uZm9ybWluZ19zdHJpbmdzPW9uO1wiO1xuICAgIH1cbiAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5jbGllbnRNaW5NZXNzYWdlcyAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1VzYWdlIG9mIFwib3B0aW9ucy5jbGllbnRNaW5NZXNzYWdlc1wiIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2Ny4nKTtcbiAgICAgIGNvbnNvbGUud2FybignUGxlYXNlIHVzZSB0aGUgc2VxdWVsaXplIG9wdGlvbiBcImRpYWxlY3RPcHRpb25zLmNsaWVudE1pbk1lc3NhZ2VzXCIgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgaWYgKCEoY29uZmlnLmRpYWxlY3RPcHRpb25zICYmIGNvbmZpZy5kaWFsZWN0T3B0aW9ucy5jbGllbnRNaW5NZXNzYWdlcyAmJiBjb25maWcuZGlhbGVjdE9wdGlvbnMuY2xpZW50TWluTWVzc2FnZXMudG9Mb3dlckNhc2UoKSA9PT0gXCJpZ25vcmVcIiB8fCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmNsaWVudE1pbk1lc3NhZ2VzID09PSBmYWxzZSkpIHtcbiAgICAgIGNvbnN0IGNsaWVudE1pbk1lc3NhZ2VzID0gY29uZmlnLmRpYWxlY3RPcHRpb25zICYmIGNvbmZpZy5kaWFsZWN0T3B0aW9ucy5jbGllbnRNaW5NZXNzYWdlcyB8fCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmNsaWVudE1pbk1lc3NhZ2VzIHx8IFwid2FybmluZ1wiO1xuICAgICAgcXVlcnkgKz0gYFNFVCBjbGllbnRfbWluX21lc3NhZ2VzIFRPICR7Y2xpZW50TWluTWVzc2FnZXN9O2A7XG4gICAgfVxuICAgIGlmICghdGhpcy5zZXF1ZWxpemUuY29uZmlnLmtlZXBEZWZhdWx0VGltZXpvbmUpIHtcbiAgICAgIGNvbnN0IGlzWm9uZSA9ICEhbW9tZW50VHoudHouem9uZSh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnRpbWV6b25lKTtcbiAgICAgIGlmIChpc1pvbmUpIHtcbiAgICAgICAgcXVlcnkgKz0gYFNFVCBUSU1FIFpPTkUgJyR7dGhpcy5zZXF1ZWxpemUub3B0aW9ucy50aW1lem9uZX0nO2A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeSArPSBgU0VUIFRJTUUgWk9ORSBJTlRFUlZBTCAnJHt0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnRpbWV6b25lfScgSE9VUiBUTyBNSU5VVEU7YDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHF1ZXJ5KSB7XG4gICAgICBhd2FpdCBjb25uZWN0aW9uLnF1ZXJ5KHF1ZXJ5KTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMubmFtZU9pZE1hcCkubGVuZ3RoID09PSAwICYmIHRoaXMuZW51bU9pZHMub2lkcy5sZW5ndGggPT09IDAgJiYgdGhpcy5lbnVtT2lkcy5hcnJheU9pZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBhd2FpdCB0aGlzLl9yZWZyZXNoRHluYW1pY09JRHMoY29ubmVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBjb25uZWN0aW9uO1xuICB9XG4gIGFzeW5jIGRpc2Nvbm5lY3QoY29ubmVjdGlvbikge1xuICAgIGlmIChjb25uZWN0aW9uLl9lbmRpbmcpIHtcbiAgICAgIGRlYnVnKFwiY29ubmVjdGlvbiB0cmllZCB0byBkaXNjb25uZWN0IGJ1dCB3YXMgYWxyZWFkeSBhdCBFTkRJTkcgc3RhdGVcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBwcm9taXNpZnkoKGNhbGxiYWNrKSA9PiBjb25uZWN0aW9uLmVuZChjYWxsYmFjaykpKCk7XG4gIH1cbiAgdmFsaWRhdGUoY29ubmVjdGlvbikge1xuICAgIHJldHVybiAhY29ubmVjdGlvbi5faW52YWxpZCAmJiAhY29ubmVjdGlvbi5fZW5kaW5nO1xuICB9XG4gIGFzeW5jIF9yZWZyZXNoRHluYW1pY09JRHMoY29ubmVjdGlvbikge1xuICAgIGNvbnN0IGRhdGFiYXNlVmVyc2lvbiA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uO1xuICAgIGNvbnN0IHN1cHBvcnRlZFZlcnNpb24gPSBcIjguMy4wXCI7XG4gICAgaWYgKChkYXRhYmFzZVZlcnNpb24gJiYgc2VtdmVyLmd0ZShkYXRhYmFzZVZlcnNpb24sIHN1cHBvcnRlZFZlcnNpb24pKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IChjb25uZWN0aW9uIHx8IHRoaXMuc2VxdWVsaXplKS5xdWVyeShcIldJVEggcmFuZ2VzIEFTICggIFNFTEVDVCBwZ19yYW5nZS5ybmd0eXBpZCwgcGdfdHlwZS50eXBuYW1lIEFTIHJuZ3R5cG5hbWUsICAgICAgICAgcGdfdHlwZS50eXBhcnJheSBBUyBybmd0eXBhcnJheSwgcGdfcmFuZ2Uucm5nc3VidHlwZSAgICBGUk9NIHBnX3JhbmdlIExFRlQgT1VURVIgSk9JTiBwZ190eXBlIE9OIHBnX3R5cGUub2lkID0gcGdfcmFuZ2Uucm5ndHlwaWQpU0VMRUNUIHBnX3R5cGUudHlwbmFtZSwgcGdfdHlwZS50eXB0eXBlLCBwZ190eXBlLm9pZCwgcGdfdHlwZS50eXBhcnJheSwgICAgICAgcmFuZ2VzLnJuZ3R5cG5hbWUsIHJhbmdlcy5ybmd0eXBpZCwgcmFuZ2VzLnJuZ3R5cGFycmF5ICBGUk9NIHBnX3R5cGUgTEVGVCBPVVRFUiBKT0lOIHJhbmdlcyBPTiBwZ190eXBlLm9pZCA9IHJhbmdlcy5ybmdzdWJ0eXBlIFdIRVJFIChwZ190eXBlLnR5cHR5cGUgSU4oJ2InLCAnZScpKTtcIik7XG4gICAgbGV0IHJlc3VsdCA9IEFycmF5LmlzQXJyYXkocmVzdWx0cykgPyByZXN1bHRzLnBvcCgpIDogcmVzdWx0cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICBpZiAocmVzdWx0WzBdLmNvbW1hbmQgPT09IFwiU0VUXCIpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXdOYW1lT2lkTWFwID0ge307XG4gICAgY29uc3QgbmV3RW51bU9pZHMgPSB7IG9pZHM6IFtdLCBhcnJheU9pZHM6IFtdIH07XG4gICAgZm9yIChjb25zdCByb3cgb2YgcmVzdWx0LnJvd3MpIHtcbiAgICAgIGlmIChyb3cudHlwdHlwZSA9PT0gXCJlXCIpIHtcbiAgICAgICAgbmV3RW51bU9pZHMub2lkcy5wdXNoKHJvdy5vaWQpO1xuICAgICAgICBpZiAocm93LnR5cGFycmF5KVxuICAgICAgICAgIG5ld0VudW1PaWRzLmFycmF5T2lkcy5wdXNoKHJvdy50eXBhcnJheSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbmV3TmFtZU9pZE1hcFtyb3cudHlwbmFtZV0gPSB7IG9pZDogcm93Lm9pZCB9O1xuICAgICAgaWYgKHJvdy50eXBhcnJheSlcbiAgICAgICAgbmV3TmFtZU9pZE1hcFtyb3cudHlwbmFtZV0uYXJyYXlPaWQgPSByb3cudHlwYXJyYXk7XG4gICAgICBpZiAocm93LnJuZ3R5cGlkKSB7XG4gICAgICAgIG5ld05hbWVPaWRNYXBbcm93LnR5cG5hbWVdLnJhbmdlT2lkID0gcm93LnJuZ3R5cGlkO1xuICAgICAgICBpZiAocm93LnJuZ3R5cGFycmF5KVxuICAgICAgICAgIG5ld05hbWVPaWRNYXBbcm93LnR5cG5hbWVdLmFycmF5UmFuZ2VPaWQgPSByb3cucm5ndHlwYXJyYXk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubmFtZU9pZE1hcCA9IG5ld05hbWVPaWRNYXA7XG4gICAgdGhpcy5lbnVtT2lkcyA9IG5ld0VudW1PaWRzO1xuICAgIHRoaXMucmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGVzLnBvc3RncmVzKTtcbiAgfVxuICBfY2xlYXJEeW5hbWljT0lEcygpIHtcbiAgICB0aGlzLm5hbWVPaWRNYXAgPSB7fTtcbiAgICB0aGlzLmVudW1PaWRzID0geyBvaWRzOiBbXSwgYXJyYXlPaWRzOiBbXSB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbk1hbmFnZXIgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpb24tbWFuYWdlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/postgres/connection-manager.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/postgres/data-types.js":
/*!*********************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/postgres/data-types.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst wkx = __webpack_require__(/*! wkx */ \"(action-browser)/../node_modules/wkx/lib/wkx.js\");\nmodule.exports = (BaseTypes) => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"http://www.postgresql.org/docs/9.4/static/datatype.html\");\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {\n      warn(`PostgresSQL does not support '${dataType.key}' with LENGTH, UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);\n      dataType._length = void 0;\n      dataType.options.length = void 0;\n      dataType._unsigned = void 0;\n      dataType._zerofill = void 0;\n    }\n  }\n  BaseTypes.UUID.types.postgres = [\"uuid\"];\n  BaseTypes.CIDR.types.postgres = [\"cidr\"];\n  BaseTypes.INET.types.postgres = [\"inet\"];\n  BaseTypes.MACADDR.types.postgres = [\"macaddr\"];\n  BaseTypes.TSVECTOR.types.postgres = [\"tsvector\"];\n  BaseTypes.JSON.types.postgres = [\"json\"];\n  BaseTypes.JSONB.types.postgres = [\"jsonb\"];\n  BaseTypes.TIME.types.postgres = [\"time\"];\n  class DATEONLY extends BaseTypes.DATEONLY {\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return \"Infinity\";\n      }\n      if (value === -Infinity) {\n        return \"-Infinity\";\n      }\n      return super._stringify(value, options);\n    }\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && value !== Infinity && value !== -Infinity) {\n        if (typeof value === \"string\") {\n          const lower = value.toLowerCase();\n          if (lower === \"infinity\") {\n            return Infinity;\n          }\n          if (lower === \"-infinity\") {\n            return -Infinity;\n          }\n        }\n        return super._sanitize(value);\n      }\n      return value;\n    }\n    static parse(value) {\n      if (value === \"infinity\") {\n        return Infinity;\n      }\n      if (value === \"-infinity\") {\n        return -Infinity;\n      }\n      return value;\n    }\n  }\n  BaseTypes.DATEONLY.types.postgres = [\"date\"];\n  class DECIMAL extends BaseTypes.DECIMAL {\n    static parse(value) {\n      return value;\n    }\n  }\n  BaseTypes.DECIMAL.types.postgres = [\"numeric\"];\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this._binary) {\n        return \"BYTEA\";\n      }\n      return super.toSql();\n    }\n  }\n  BaseTypes.STRING.types.postgres = [\"varchar\"];\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      if (this._length) {\n        warn(\"PostgreSQL does not support TEXT with options. Plain `TEXT` will be used instead.\");\n        this._length = void 0;\n      }\n      return \"TEXT\";\n    }\n  }\n  BaseTypes.TEXT.types.postgres = [\"text\"];\n  class CITEXT extends BaseTypes.CITEXT {\n    static parse(value) {\n      return value;\n    }\n  }\n  BaseTypes.CITEXT.types.postgres = [\"citext\"];\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        return \"BYTEA\";\n      }\n      return super.toSql();\n    }\n  }\n  BaseTypes.CHAR.types.postgres = [\"char\", \"bpchar\"];\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"BOOLEAN\";\n    }\n    _sanitize(value) {\n      if (value !== null && value !== void 0) {\n        if (Buffer.isBuffer(value) && value.length === 1) {\n          value = value[0];\n        }\n        if (typeof value === \"string\") {\n          return [\"true\", \"t\"].includes(value) ? true : [\"false\", \"f\"].includes(value) ? false : value;\n        }\n        if (typeof value === \"number\") {\n          return value === 1 ? true : value === 0 ? false : value;\n        }\n      }\n      return value;\n    }\n  }\n  BOOLEAN.parse = BOOLEAN.prototype._sanitize;\n  BaseTypes.BOOLEAN.types.postgres = [\"bool\"];\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return \"TIMESTAMP WITH TIME ZONE\";\n    }\n    validate(value) {\n      if (value !== Infinity && value !== -Infinity) {\n        return super.validate(value);\n      }\n      return true;\n    }\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return \"Infinity\";\n      }\n      if (value === -Infinity) {\n        return \"-Infinity\";\n      }\n      return super._stringify(value, options);\n    }\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && !(value instanceof Date) && !!value && value !== Infinity && value !== -Infinity) {\n        if (typeof value === \"string\") {\n          const lower = value.toLowerCase();\n          if (lower === \"infinity\") {\n            return Infinity;\n          }\n          if (lower === \"-infinity\") {\n            return -Infinity;\n          }\n        }\n        return new Date(value);\n      }\n      return value;\n    }\n  }\n  BaseTypes.DATE.types.postgres = [\"timestamptz\"];\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  BaseTypes.TINYINT.types.postgres = [\"int2\"];\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  BaseTypes.SMALLINT.types.postgres = [\"int2\"];\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  INTEGER.parse = function parse(value) {\n    return parseInt(value, 10);\n  };\n  BaseTypes.INTEGER.types.postgres = [\"int4\"];\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  BaseTypes.BIGINT.types.postgres = [\"int8\"];\n  class REAL extends BaseTypes.REAL {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  BaseTypes.REAL.types.postgres = [\"float4\"];\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  BaseTypes.DOUBLE.types.postgres = [\"float8\"];\n  class FLOAT extends BaseTypes.FLOAT {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (this._decimals) {\n        warn(\"PostgreSQL does not support FLOAT with decimals. Plain `FLOAT` will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._decimals = void 0;\n      }\n      if (this._unsigned) {\n        warn(\"PostgreSQL does not support FLOAT unsigned. `UNSIGNED` was removed.\");\n        this._unsigned = void 0;\n      }\n      if (this._zerofill) {\n        warn(\"PostgreSQL does not support FLOAT zerofill. `ZEROFILL` was removed.\");\n        this._zerofill = void 0;\n      }\n    }\n  }\n  delete FLOAT.parse;\n  class BLOB extends BaseTypes.BLOB {\n    toSql() {\n      if (this._length) {\n        warn(\"PostgreSQL does not support BLOB (BYTEA) with options. Plain `BYTEA` will be used instead.\");\n        this._length = void 0;\n      }\n      return \"BYTEA\";\n    }\n    _hexify(hex) {\n      return `E'\\\\\\\\x${hex}'`;\n    }\n  }\n  BaseTypes.BLOB.types.postgres = [\"bytea\"];\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    toSql() {\n      let result = this.key;\n      if (this.type) {\n        result += `(${this.type}`;\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n        result += \")\";\n      }\n      return result;\n    }\n    static parse(value) {\n      const b = Buffer.from(value, \"hex\");\n      return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });\n    }\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n    _bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n  }\n  BaseTypes.GEOMETRY.types.postgres = [\"geometry\"];\n  class GEOGRAPHY extends BaseTypes.GEOGRAPHY {\n    toSql() {\n      let result = \"GEOGRAPHY\";\n      if (this.type) {\n        result += `(${this.type}`;\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n        result += \")\";\n      }\n      return result;\n    }\n    static parse(value) {\n      const b = Buffer.from(value, \"hex\");\n      return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });\n    }\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n    bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n  }\n  BaseTypes.GEOGRAPHY.types.postgres = [\"geography\"];\n  let hstore;\n  class HSTORE extends BaseTypes.HSTORE {\n    constructor() {\n      super();\n      if (!hstore) {\n        hstore = __webpack_require__(/*! ./hstore */ \"(action-browser)/../node_modules/sequelize/lib/dialects/postgres/hstore.js\");\n      }\n    }\n    _value(value) {\n      if (!hstore) {\n        hstore = __webpack_require__(/*! ./hstore */ \"(action-browser)/../node_modules/sequelize/lib/dialects/postgres/hstore.js\");\n      }\n      return hstore.stringify(value);\n    }\n    _stringify(value) {\n      return `'${this._value(value)}'`;\n    }\n    _bindParam(value, options) {\n      return options.bindParam(this._value(value));\n    }\n    static parse(value) {\n      if (!hstore) {\n        hstore = __webpack_require__(/*! ./hstore */ \"(action-browser)/../node_modules/sequelize/lib/dialects/postgres/hstore.js\");\n      }\n      return hstore.parse(value);\n    }\n  }\n  HSTORE.prototype.escape = false;\n  BaseTypes.HSTORE.types.postgres = [\"hstore\"];\n  class RANGE extends BaseTypes.RANGE {\n    _value(values, options) {\n      if (!Array.isArray(values)) {\n        return this.options.subtype.stringify(values, options);\n      }\n      const valueInclusivity = [true, false];\n      const valuesStringified = values.map((value, index) => {\n        if (_.isObject(value) && Object.prototype.hasOwnProperty.call(value, \"value\")) {\n          if (Object.prototype.hasOwnProperty.call(value, \"inclusive\")) {\n            valueInclusivity[index] = value.inclusive;\n          }\n          value = value.value;\n        }\n        if (value === null || value === -Infinity || value === Infinity) {\n          return value;\n        }\n        if (this.options.subtype.stringify) {\n          return this.options.subtype.stringify(value, options);\n        }\n        return options.escape(value);\n      });\n      valuesStringified.inclusive = valueInclusivity;\n      return range.stringify(valuesStringified);\n    }\n    _stringify(values, options) {\n      const value = this._value(values, options);\n      if (!Array.isArray(values)) {\n        return `'${value}'::${this.toCastType()}`;\n      }\n      return `'${value}'`;\n    }\n    _bindParam(values, options) {\n      const value = this._value(values, options);\n      if (!Array.isArray(values)) {\n        return `${options.bindParam(value)}::${this.toCastType()}`;\n      }\n      return options.bindParam(value);\n    }\n    toSql() {\n      return BaseTypes.RANGE.types.postgres.subtypes[this._subtype.toLowerCase()];\n    }\n    toCastType() {\n      return BaseTypes.RANGE.types.postgres.castTypes[this._subtype.toLowerCase()];\n    }\n    static parse(value, options = { parser: (val) => val }) {\n      return range.parse(value, options.parser);\n    }\n  }\n  const range = __webpack_require__(/*! ./range */ \"(action-browser)/../node_modules/sequelize/lib/dialects/postgres/range.js\");\n  RANGE.prototype.escape = false;\n  BaseTypes.RANGE.types.postgres = {\n    subtypes: {\n      integer: \"int4range\",\n      decimal: \"numrange\",\n      date: \"tstzrange\",\n      dateonly: \"daterange\",\n      bigint: \"int8range\"\n    },\n    castTypes: {\n      integer: \"int4\",\n      decimal: \"numeric\",\n      date: \"timestamptz\",\n      dateonly: \"date\",\n      bigint: \"int8\"\n    }\n  };\n  BaseTypes.ARRAY.prototype.escape = false;\n  BaseTypes.ARRAY.prototype._value = function _value(values, options) {\n    return values.map((value) => {\n      if (options && options.bindParam && this.type && this.type._value) {\n        return this.type._value(value, options);\n      }\n      if (this.type && this.type.stringify) {\n        value = this.type.stringify(value, options);\n        if (this.type.escape === false) {\n          return value;\n        }\n      }\n      return options.escape(value);\n    }, this);\n  };\n  BaseTypes.ARRAY.prototype._stringify = function _stringify(values, options) {\n    let str = `ARRAY[${this._value(values, options).join(\",\")}]`;\n    if (this.type) {\n      const Utils = __webpack_require__(/*! ../../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\n      let castKey = this.toSql();\n      if (this.type instanceof BaseTypes.ENUM) {\n        const table = options.field.Model.getTableName();\n        const useSchema = table.schema !== void 0;\n        const schemaWithDelimiter = useSchema ? `${Utils.addTicks(table.schema, '\"')}${table.delimiter}` : \"\";\n        castKey = `${Utils.addTicks(Utils.generateEnumName(useSchema ? table.tableName : table, options.field.field), '\"')}[]`;\n        str += `::${schemaWithDelimiter}${castKey}`;\n      } else {\n        str += `::${castKey}`;\n      }\n    }\n    return str;\n  };\n  BaseTypes.ARRAY.prototype._bindParam = function _bindParam(values, options) {\n    return options.bindParam(this._value(values, options));\n  };\n  class ENUM extends BaseTypes.ENUM {\n    static parse(value) {\n      return value;\n    }\n  }\n  BaseTypes.ENUM.types.postgres = [null];\n  return {\n    DECIMAL,\n    BLOB,\n    STRING,\n    CHAR,\n    TEXT,\n    CITEXT,\n    TINYINT,\n    SMALLINT,\n    INTEGER,\n    BIGINT,\n    BOOLEAN,\n    DATE,\n    DATEONLY,\n    REAL,\n    \"DOUBLE PRECISION\": DOUBLE,\n    FLOAT,\n    GEOMETRY,\n    GEOGRAPHY,\n    HSTORE,\n    RANGE,\n    ENUM\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9kYXRhLXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsVUFBVSxtQkFBTyxDQUFDLGlFQUFRO0FBQzFCLFlBQVksbUJBQU8sQ0FBQyw0REFBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhLDhDQUE4QyxhQUFhO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsSUFBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQSxtQ0FBbUMsc0NBQXNDO0FBQ3pFO0FBQ0E7QUFDQSxtQ0FBbUMseUJBQXlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0I7QUFDL0Q7QUFDQTtBQUNBLG1DQUFtQyxzQ0FBc0M7QUFDekU7QUFDQTtBQUNBLG1DQUFtQyx5QkFBeUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDRGQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsNEZBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDRGQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU0sS0FBSyxrQkFBa0I7QUFDaEQ7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUIsSUFBSSxrQkFBa0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCLHVDQUF1QztBQUM5RDtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLDRFQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtDQUFrQyxFQUFFLGdCQUFnQjtBQUN2RyxxQkFBcUIsc0dBQXNHO0FBQzNILG9CQUFvQixvQkFBb0IsRUFBRSxRQUFRO0FBQ2xELFFBQVE7QUFDUixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL2RhdGEtdHlwZXMuanM/N2ZkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3Qgd2t4ID0gcmVxdWlyZShcIndreFwiKTtcbm1vZHVsZS5leHBvcnRzID0gKEJhc2VUeXBlcykgPT4ge1xuICBjb25zdCB3YXJuID0gQmFzZVR5cGVzLkFCU1RSQUNULndhcm4uYmluZCh2b2lkIDAsIFwiaHR0cDovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzLzkuNC9zdGF0aWMvZGF0YXR5cGUuaHRtbFwiKTtcbiAgZnVuY3Rpb24gcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyhkYXRhVHlwZSkge1xuICAgIGlmIChkYXRhVHlwZS5fbGVuZ3RoIHx8IGRhdGFUeXBlLm9wdGlvbnMubGVuZ3RoIHx8IGRhdGFUeXBlLl91bnNpZ25lZCB8fCBkYXRhVHlwZS5femVyb2ZpbGwpIHtcbiAgICAgIHdhcm4oYFBvc3RncmVzU1FMIGRvZXMgbm90IHN1cHBvcnQgJyR7ZGF0YVR5cGUua2V5fScgd2l0aCBMRU5HVEgsIFVOU0lHTkVEIG9yIFpFUk9GSUxMLiBQbGFpbiAnJHtkYXRhVHlwZS5rZXl9JyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5gKTtcbiAgICAgIGRhdGFUeXBlLl9sZW5ndGggPSB2b2lkIDA7XG4gICAgICBkYXRhVHlwZS5vcHRpb25zLmxlbmd0aCA9IHZvaWQgMDtcbiAgICAgIGRhdGFUeXBlLl91bnNpZ25lZCA9IHZvaWQgMDtcbiAgICAgIGRhdGFUeXBlLl96ZXJvZmlsbCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgQmFzZVR5cGVzLlVVSUQudHlwZXMucG9zdGdyZXMgPSBbXCJ1dWlkXCJdO1xuICBCYXNlVHlwZXMuQ0lEUi50eXBlcy5wb3N0Z3JlcyA9IFtcImNpZHJcIl07XG4gIEJhc2VUeXBlcy5JTkVULnR5cGVzLnBvc3RncmVzID0gW1wiaW5ldFwiXTtcbiAgQmFzZVR5cGVzLk1BQ0FERFIudHlwZXMucG9zdGdyZXMgPSBbXCJtYWNhZGRyXCJdO1xuICBCYXNlVHlwZXMuVFNWRUNUT1IudHlwZXMucG9zdGdyZXMgPSBbXCJ0c3ZlY3RvclwiXTtcbiAgQmFzZVR5cGVzLkpTT04udHlwZXMucG9zdGdyZXMgPSBbXCJqc29uXCJdO1xuICBCYXNlVHlwZXMuSlNPTkIudHlwZXMucG9zdGdyZXMgPSBbXCJqc29uYlwiXTtcbiAgQmFzZVR5cGVzLlRJTUUudHlwZXMucG9zdGdyZXMgPSBbXCJ0aW1lXCJdO1xuICBjbGFzcyBEQVRFT05MWSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFT05MWSB7XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gXCJJbmZpbml0eVwiO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIFwiLUluZmluaXR5XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwZXIuX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIF9zYW5pdGl6ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCghb3B0aW9ucyB8fCBvcHRpb25zICYmICFvcHRpb25zLnJhdykgJiYgdmFsdWUgIT09IEluZmluaXR5ICYmIHZhbHVlICE9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IGxvd2VyID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAobG93ZXIgPT09IFwiaW5maW5pdHlcIikge1xuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobG93ZXIgPT09IFwiLWluZmluaXR5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiAtSW5maW5pdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5fc2FuaXRpemUodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gXCJpbmZpbml0eVwiKSB7XG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gXCItaW5maW5pdHlcIikge1xuICAgICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICBCYXNlVHlwZXMuREFURU9OTFkudHlwZXMucG9zdGdyZXMgPSBbXCJkYXRlXCJdO1xuICBjbGFzcyBERUNJTUFMIGV4dGVuZHMgQmFzZVR5cGVzLkRFQ0lNQUwge1xuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICBCYXNlVHlwZXMuREVDSU1BTC50eXBlcy5wb3N0Z3JlcyA9IFtcIm51bWVyaWNcIl07XG4gIGNsYXNzIFNUUklORyBleHRlbmRzIEJhc2VUeXBlcy5TVFJJTkcge1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2JpbmFyeSkge1xuICAgICAgICByZXR1cm4gXCJCWVRFQVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cGVyLnRvU3FsKCk7XG4gICAgfVxuICB9XG4gIEJhc2VUeXBlcy5TVFJJTkcudHlwZXMucG9zdGdyZXMgPSBbXCJ2YXJjaGFyXCJdO1xuICBjbGFzcyBURVhUIGV4dGVuZHMgQmFzZVR5cGVzLlRFWFQge1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICB3YXJuKFwiUG9zdGdyZVNRTCBkb2VzIG5vdCBzdXBwb3J0IFRFWFQgd2l0aCBvcHRpb25zLiBQbGFpbiBgVEVYVGAgd2lsbCBiZSB1c2VkIGluc3RlYWQuXCIpO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJURVhUXCI7XG4gICAgfVxuICB9XG4gIEJhc2VUeXBlcy5URVhULnR5cGVzLnBvc3RncmVzID0gW1widGV4dFwiXTtcbiAgY2xhc3MgQ0lURVhUIGV4dGVuZHMgQmFzZVR5cGVzLkNJVEVYVCB7XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIEJhc2VUeXBlcy5DSVRFWFQudHlwZXMucG9zdGdyZXMgPSBbXCJjaXRleHRcIl07XG4gIGNsYXNzIENIQVIgZXh0ZW5kcyBCYXNlVHlwZXMuQ0hBUiB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fYmluYXJ5KSB7XG4gICAgICAgIHJldHVybiBcIkJZVEVBXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwZXIudG9TcWwoKTtcbiAgICB9XG4gIH1cbiAgQmFzZVR5cGVzLkNIQVIudHlwZXMucG9zdGdyZXMgPSBbXCJjaGFyXCIsIFwiYnBjaGFyXCJdO1xuICBjbGFzcyBCT09MRUFOIGV4dGVuZHMgQmFzZVR5cGVzLkJPT0xFQU4ge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiQk9PTEVBTlwiO1xuICAgIH1cbiAgICBfc2FuaXRpemUodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiBbXCJ0cnVlXCIsIFwidFwiXS5pbmNsdWRlcyh2YWx1ZSkgPyB0cnVlIDogW1wiZmFsc2VcIiwgXCJmXCJdLmluY2x1ZGVzKHZhbHVlKSA/IGZhbHNlIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMSA/IHRydWUgOiB2YWx1ZSA9PT0gMCA/IGZhbHNlIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgQk9PTEVBTi5wYXJzZSA9IEJPT0xFQU4ucHJvdG90eXBlLl9zYW5pdGl6ZTtcbiAgQmFzZVR5cGVzLkJPT0xFQU4udHlwZXMucG9zdGdyZXMgPSBbXCJib29sXCJdO1xuICBjbGFzcyBEQVRFIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEUge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiVElNRVNUQU1QIFdJVEggVElNRSBaT05FXCI7XG4gICAgfVxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IEluZmluaXR5ICYmIHZhbHVlICE9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnZhbGlkYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAodmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiBcIkluZmluaXR5XCI7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gXCItSW5maW5pdHlcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdXBlci5fc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgX3Nhbml0aXplKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoKCFvcHRpb25zIHx8IG9wdGlvbnMgJiYgIW9wdGlvbnMucmF3KSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgJiYgISF2YWx1ZSAmJiB2YWx1ZSAhPT0gSW5maW5pdHkgJiYgdmFsdWUgIT09IC1JbmZpbml0eSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29uc3QgbG93ZXIgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChsb3dlciA9PT0gXCJpbmZpbml0eVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsb3dlciA9PT0gXCItaW5maW5pdHlcIikge1xuICAgICAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgQmFzZVR5cGVzLkRBVEUudHlwZXMucG9zdGdyZXMgPSBbXCJ0aW1lc3RhbXB0elwiXTtcbiAgY2xhc3MgVElOWUlOVCBleHRlbmRzIEJhc2VUeXBlcy5USU5ZSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBCYXNlVHlwZXMuVElOWUlOVC50eXBlcy5wb3N0Z3JlcyA9IFtcImludDJcIl07XG4gIGNsYXNzIFNNQUxMSU5UIGV4dGVuZHMgQmFzZVR5cGVzLlNNQUxMSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBCYXNlVHlwZXMuU01BTExJTlQudHlwZXMucG9zdGdyZXMgPSBbXCJpbnQyXCJdO1xuICBjbGFzcyBJTlRFR0VSIGV4dGVuZHMgQmFzZVR5cGVzLklOVEVHRVIge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIElOVEVHRVIucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9O1xuICBCYXNlVHlwZXMuSU5URUdFUi50eXBlcy5wb3N0Z3JlcyA9IFtcImludDRcIl07XG4gIGNsYXNzIEJJR0lOVCBleHRlbmRzIEJhc2VUeXBlcy5CSUdJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIEJhc2VUeXBlcy5CSUdJTlQudHlwZXMucG9zdGdyZXMgPSBbXCJpbnQ4XCJdO1xuICBjbGFzcyBSRUFMIGV4dGVuZHMgQmFzZVR5cGVzLlJFQUwge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIEJhc2VUeXBlcy5SRUFMLnR5cGVzLnBvc3RncmVzID0gW1wiZmxvYXQ0XCJdO1xuICBjbGFzcyBET1VCTEUgZXh0ZW5kcyBCYXNlVHlwZXMuRE9VQkxFIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBCYXNlVHlwZXMuRE9VQkxFLnR5cGVzLnBvc3RncmVzID0gW1wiZmxvYXQ4XCJdO1xuICBjbGFzcyBGTE9BVCBleHRlbmRzIEJhc2VUeXBlcy5GTE9BVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBkZWNpbWFscykge1xuICAgICAgc3VwZXIobGVuZ3RoLCBkZWNpbWFscyk7XG4gICAgICBpZiAodGhpcy5fZGVjaW1hbHMpIHtcbiAgICAgICAgd2FybihcIlBvc3RncmVTUUwgZG9lcyBub3Qgc3VwcG9ydCBGTE9BVCB3aXRoIGRlY2ltYWxzLiBQbGFpbiBgRkxPQVRgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm9wdGlvbnMubGVuZ3RoID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl9kZWNpbWFscyA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl91bnNpZ25lZCkge1xuICAgICAgICB3YXJuKFwiUG9zdGdyZVNRTCBkb2VzIG5vdCBzdXBwb3J0IEZMT0FUIHVuc2lnbmVkLiBgVU5TSUdORURgIHdhcyByZW1vdmVkLlwiKTtcbiAgICAgICAgdGhpcy5fdW5zaWduZWQgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5femVyb2ZpbGwpIHtcbiAgICAgICAgd2FybihcIlBvc3RncmVTUUwgZG9lcyBub3Qgc3VwcG9ydCBGTE9BVCB6ZXJvZmlsbC4gYFpFUk9GSUxMYCB3YXMgcmVtb3ZlZC5cIik7XG4gICAgICAgIHRoaXMuX3plcm9maWxsID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZWxldGUgRkxPQVQucGFyc2U7XG4gIGNsYXNzIEJMT0IgZXh0ZW5kcyBCYXNlVHlwZXMuQkxPQiB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oXCJQb3N0Z3JlU1FMIGRvZXMgbm90IHN1cHBvcnQgQkxPQiAoQllURUEpIHdpdGggb3B0aW9ucy4gUGxhaW4gYEJZVEVBYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cIik7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIkJZVEVBXCI7XG4gICAgfVxuICAgIF9oZXhpZnkoaGV4KSB7XG4gICAgICByZXR1cm4gYEUnXFxcXFxcXFx4JHtoZXh9J2A7XG4gICAgfVxuICB9XG4gIEJhc2VUeXBlcy5CTE9CLnR5cGVzLnBvc3RncmVzID0gW1wiYnl0ZWFcIl07XG4gIGNsYXNzIEdFT01FVFJZIGV4dGVuZHMgQmFzZVR5cGVzLkdFT01FVFJZIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGxldCByZXN1bHQgPSB0aGlzLmtleTtcbiAgICAgIGlmICh0aGlzLnR5cGUpIHtcbiAgICAgICAgcmVzdWx0ICs9IGAoJHt0aGlzLnR5cGV9YDtcbiAgICAgICAgaWYgKHRoaXMuc3JpZCkge1xuICAgICAgICAgIHJlc3VsdCArPSBgLCR7dGhpcy5zcmlkfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IFwiKVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICBjb25zdCBiID0gQnVmZmVyLmZyb20odmFsdWUsIFwiaGV4XCIpO1xuICAgICAgcmV0dXJuIHdreC5HZW9tZXRyeS5wYXJzZShiKS50b0dlb0pTT04oeyBzaG9ydENyczogdHJ1ZSB9KTtcbiAgICB9XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGBTVF9HZW9tRnJvbUdlb0pTT04oJHtvcHRpb25zLmVzY2FwZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpfSlgO1xuICAgIH1cbiAgICBfYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gYFNUX0dlb21Gcm9tR2VvSlNPTigke29wdGlvbnMuYmluZFBhcmFtKHZhbHVlKX0pYDtcbiAgICB9XG4gIH1cbiAgQmFzZVR5cGVzLkdFT01FVFJZLnR5cGVzLnBvc3RncmVzID0gW1wiZ2VvbWV0cnlcIl07XG4gIGNsYXNzIEdFT0dSQVBIWSBleHRlbmRzIEJhc2VUeXBlcy5HRU9HUkFQSFkge1xuICAgIHRvU3FsKCkge1xuICAgICAgbGV0IHJlc3VsdCA9IFwiR0VPR1JBUEhZXCI7XG4gICAgICBpZiAodGhpcy50eXBlKSB7XG4gICAgICAgIHJlc3VsdCArPSBgKCR7dGhpcy50eXBlfWA7XG4gICAgICAgIGlmICh0aGlzLnNyaWQpIHtcbiAgICAgICAgICByZXN1bHQgKz0gYCwke3RoaXMuc3JpZH1gO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBcIilcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgY29uc3QgYiA9IEJ1ZmZlci5mcm9tKHZhbHVlLCBcImhleFwiKTtcbiAgICAgIHJldHVybiB3a3guR2VvbWV0cnkucGFyc2UoYikudG9HZW9KU09OKHsgc2hvcnRDcnM6IHRydWUgfSk7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBgU1RfR2VvbUZyb21HZW9KU09OKCR7b3B0aW9ucy5lc2NhcGUoSlNPTi5zdHJpbmdpZnkodmFsdWUpKX0pYDtcbiAgICB9XG4gICAgYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gYFNUX0dlb21Gcm9tR2VvSlNPTigke29wdGlvbnMuYmluZFBhcmFtKHZhbHVlKX0pYDtcbiAgICB9XG4gIH1cbiAgQmFzZVR5cGVzLkdFT0dSQVBIWS50eXBlcy5wb3N0Z3JlcyA9IFtcImdlb2dyYXBoeVwiXTtcbiAgbGV0IGhzdG9yZTtcbiAgY2xhc3MgSFNUT1JFIGV4dGVuZHMgQmFzZVR5cGVzLkhTVE9SRSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgaWYgKCFoc3RvcmUpIHtcbiAgICAgICAgaHN0b3JlID0gcmVxdWlyZShcIi4vaHN0b3JlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBfdmFsdWUodmFsdWUpIHtcbiAgICAgIGlmICghaHN0b3JlKSB7XG4gICAgICAgIGhzdG9yZSA9IHJlcXVpcmUoXCIuL2hzdG9yZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoc3RvcmUuc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGAnJHt0aGlzLl92YWx1ZSh2YWx1ZSl9J2A7XG4gICAgfVxuICAgIF9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmJpbmRQYXJhbSh0aGlzLl92YWx1ZSh2YWx1ZSkpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIGlmICghaHN0b3JlKSB7XG4gICAgICAgIGhzdG9yZSA9IHJlcXVpcmUoXCIuL2hzdG9yZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoc3RvcmUucGFyc2UodmFsdWUpO1xuICAgIH1cbiAgfVxuICBIU1RPUkUucHJvdG90eXBlLmVzY2FwZSA9IGZhbHNlO1xuICBCYXNlVHlwZXMuSFNUT1JFLnR5cGVzLnBvc3RncmVzID0gW1wiaHN0b3JlXCJdO1xuICBjbGFzcyBSQU5HRSBleHRlbmRzIEJhc2VUeXBlcy5SQU5HRSB7XG4gICAgX3ZhbHVlKHZhbHVlcywgb3B0aW9ucykge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zdWJ0eXBlLnN0cmluZ2lmeSh2YWx1ZXMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWVJbmNsdXNpdml0eSA9IFt0cnVlLCBmYWxzZV07XG4gICAgICBjb25zdCB2YWx1ZXNTdHJpbmdpZmllZCA9IHZhbHVlcy5tYXAoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInZhbHVlXCIpKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJpbmNsdXNpdmVcIikpIHtcbiAgICAgICAgICAgIHZhbHVlSW5jbHVzaXZpdHlbaW5kZXhdID0gdmFsdWUuaW5jbHVzaXZlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gLUluZmluaXR5IHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN1YnR5cGUuc3RyaW5naWZ5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zdWJ0eXBlLnN0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZXNjYXBlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgdmFsdWVzU3RyaW5naWZpZWQuaW5jbHVzaXZlID0gdmFsdWVJbmNsdXNpdml0eTtcbiAgICAgIHJldHVybiByYW5nZS5zdHJpbmdpZnkodmFsdWVzU3RyaW5naWZpZWQpO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KHZhbHVlcywgb3B0aW9ucykge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl92YWx1ZSh2YWx1ZXMsIG9wdGlvbnMpO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgcmV0dXJuIGAnJHt2YWx1ZX0nOjoke3RoaXMudG9DYXN0VHlwZSgpfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYCcke3ZhbHVlfSdgO1xuICAgIH1cbiAgICBfYmluZFBhcmFtKHZhbHVlcywgb3B0aW9ucykge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl92YWx1ZSh2YWx1ZXMsIG9wdGlvbnMpO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgcmV0dXJuIGAke29wdGlvbnMuYmluZFBhcmFtKHZhbHVlKX06OiR7dGhpcy50b0Nhc3RUeXBlKCl9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLmJpbmRQYXJhbSh2YWx1ZSk7XG4gICAgfVxuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIEJhc2VUeXBlcy5SQU5HRS50eXBlcy5wb3N0Z3Jlcy5zdWJ0eXBlc1t0aGlzLl9zdWJ0eXBlLnRvTG93ZXJDYXNlKCldO1xuICAgIH1cbiAgICB0b0Nhc3RUeXBlKCkge1xuICAgICAgcmV0dXJuIEJhc2VUeXBlcy5SQU5HRS50eXBlcy5wb3N0Z3Jlcy5jYXN0VHlwZXNbdGhpcy5fc3VidHlwZS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlLCBvcHRpb25zID0geyBwYXJzZXI6ICh2YWwpID0+IHZhbCB9KSB7XG4gICAgICByZXR1cm4gcmFuZ2UucGFyc2UodmFsdWUsIG9wdGlvbnMucGFyc2VyKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmFuZ2UgPSByZXF1aXJlKFwiLi9yYW5nZVwiKTtcbiAgUkFOR0UucHJvdG90eXBlLmVzY2FwZSA9IGZhbHNlO1xuICBCYXNlVHlwZXMuUkFOR0UudHlwZXMucG9zdGdyZXMgPSB7XG4gICAgc3VidHlwZXM6IHtcbiAgICAgIGludGVnZXI6IFwiaW50NHJhbmdlXCIsXG4gICAgICBkZWNpbWFsOiBcIm51bXJhbmdlXCIsXG4gICAgICBkYXRlOiBcInRzdHpyYW5nZVwiLFxuICAgICAgZGF0ZW9ubHk6IFwiZGF0ZXJhbmdlXCIsXG4gICAgICBiaWdpbnQ6IFwiaW50OHJhbmdlXCJcbiAgICB9LFxuICAgIGNhc3RUeXBlczoge1xuICAgICAgaW50ZWdlcjogXCJpbnQ0XCIsXG4gICAgICBkZWNpbWFsOiBcIm51bWVyaWNcIixcbiAgICAgIGRhdGU6IFwidGltZXN0YW1wdHpcIixcbiAgICAgIGRhdGVvbmx5OiBcImRhdGVcIixcbiAgICAgIGJpZ2ludDogXCJpbnQ4XCJcbiAgICB9XG4gIH07XG4gIEJhc2VUeXBlcy5BUlJBWS5wcm90b3R5cGUuZXNjYXBlID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5BUlJBWS5wcm90b3R5cGUuX3ZhbHVlID0gZnVuY3Rpb24gX3ZhbHVlKHZhbHVlcywgb3B0aW9ucykge1xuICAgIHJldHVybiB2YWx1ZXMubWFwKCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5iaW5kUGFyYW0gJiYgdGhpcy50eXBlICYmIHRoaXMudHlwZS5fdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5fdmFsdWUodmFsdWUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudHlwZSAmJiB0aGlzLnR5cGUuc3RyaW5naWZ5KSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy50eXBlLnN0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUuZXNjYXBlID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMuZXNjYXBlKHZhbHVlKTtcbiAgICB9LCB0aGlzKTtcbiAgfTtcbiAgQmFzZVR5cGVzLkFSUkFZLnByb3RvdHlwZS5fc3RyaW5naWZ5ID0gZnVuY3Rpb24gX3N0cmluZ2lmeSh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBsZXQgc3RyID0gYEFSUkFZWyR7dGhpcy5fdmFsdWUodmFsdWVzLCBvcHRpb25zKS5qb2luKFwiLFwiKX1dYDtcbiAgICBpZiAodGhpcy50eXBlKSB7XG4gICAgICBjb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbiAgICAgIGxldCBjYXN0S2V5ID0gdGhpcy50b1NxbCgpO1xuICAgICAgaWYgKHRoaXMudHlwZSBpbnN0YW5jZW9mIEJhc2VUeXBlcy5FTlVNKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlID0gb3B0aW9ucy5maWVsZC5Nb2RlbC5nZXRUYWJsZU5hbWUoKTtcbiAgICAgICAgY29uc3QgdXNlU2NoZW1hID0gdGFibGUuc2NoZW1hICE9PSB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHNjaGVtYVdpdGhEZWxpbWl0ZXIgPSB1c2VTY2hlbWEgPyBgJHtVdGlscy5hZGRUaWNrcyh0YWJsZS5zY2hlbWEsICdcIicpfSR7dGFibGUuZGVsaW1pdGVyfWAgOiBcIlwiO1xuICAgICAgICBjYXN0S2V5ID0gYCR7VXRpbHMuYWRkVGlja3MoVXRpbHMuZ2VuZXJhdGVFbnVtTmFtZSh1c2VTY2hlbWEgPyB0YWJsZS50YWJsZU5hbWUgOiB0YWJsZSwgb3B0aW9ucy5maWVsZC5maWVsZCksICdcIicpfVtdYDtcbiAgICAgICAgc3RyICs9IGA6OiR7c2NoZW1hV2l0aERlbGltaXRlcn0ke2Nhc3RLZXl9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciArPSBgOjoke2Nhc3RLZXl9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbiAgQmFzZVR5cGVzLkFSUkFZLnByb3RvdHlwZS5fYmluZFBhcmFtID0gZnVuY3Rpb24gX2JpbmRQYXJhbSh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5iaW5kUGFyYW0odGhpcy5fdmFsdWUodmFsdWVzLCBvcHRpb25zKSk7XG4gIH07XG4gIGNsYXNzIEVOVU0gZXh0ZW5kcyBCYXNlVHlwZXMuRU5VTSB7XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIEJhc2VUeXBlcy5FTlVNLnR5cGVzLnBvc3RncmVzID0gW251bGxdO1xuICByZXR1cm4ge1xuICAgIERFQ0lNQUwsXG4gICAgQkxPQixcbiAgICBTVFJJTkcsXG4gICAgQ0hBUixcbiAgICBURVhULFxuICAgIENJVEVYVCxcbiAgICBUSU5ZSU5ULFxuICAgIFNNQUxMSU5ULFxuICAgIElOVEVHRVIsXG4gICAgQklHSU5ULFxuICAgIEJPT0xFQU4sXG4gICAgREFURSxcbiAgICBEQVRFT05MWSxcbiAgICBSRUFMLFxuICAgIFwiRE9VQkxFIFBSRUNJU0lPTlwiOiBET1VCTEUsXG4gICAgRkxPQVQsXG4gICAgR0VPTUVUUlksXG4gICAgR0VPR1JBUEhZLFxuICAgIEhTVE9SRSxcbiAgICBSQU5HRSxcbiAgICBFTlVNXG4gIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS10eXBlcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/postgres/data-types.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/postgres/hstore.js":
/*!*****************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/postgres/hstore.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst hstore = __webpack_require__(/*! pg-hstore */ \"?2dfa\")({ sanitize: true });\nfunction stringify(data) {\n  if (data === null)\n    return null;\n  return hstore.stringify(data);\n}\nexports.stringify = stringify;\nfunction parse(value) {\n  if (value === null)\n    return null;\n  return hstore.parse(value);\n}\nexports.parse = parse;\n//# sourceMappingURL=hstore.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9oc3RvcmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLG1CQUFPLENBQUMsd0JBQVcsSUFBSSxnQkFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL2hzdG9yZS5qcz80NGVjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgaHN0b3JlID0gcmVxdWlyZShcInBnLWhzdG9yZVwiKSh7IHNhbml0aXplOiB0cnVlIH0pO1xuZnVuY3Rpb24gc3RyaW5naWZ5KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG4gIHJldHVybiBoc3RvcmUuc3RyaW5naWZ5KGRhdGEpO1xufVxuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5mdW5jdGlvbiBwYXJzZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG4gIHJldHVybiBoc3RvcmUucGFyc2UodmFsdWUpO1xufVxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHN0b3JlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/postgres/hstore.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/postgres/index.js":
/*!****************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/postgres/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst AbstractDialect = __webpack_require__(/*! ../abstract */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst ConnectionManager = __webpack_require__(/*! ./connection-manager */ \"(action-browser)/../node_modules/sequelize/lib/dialects/postgres/connection-manager.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(action-browser)/../node_modules/sequelize/lib/dialects/postgres/query.js\");\nconst QueryGenerator = __webpack_require__(/*! ./query-generator */ \"(action-browser)/../node_modules/sequelize/lib/dialects/postgres/query-generator.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\").postgres);\nconst { PostgresQueryInterface } = __webpack_require__(/*! ./query-interface */ \"(action-browser)/../node_modules/sequelize/lib/dialects/postgres/query-interface.js\");\nclass PostgresDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new PostgresQueryInterface(sequelize, this.queryGenerator);\n  }\n  canBackslashEscape() {\n    return !this.sequelize.options.standardConformingStrings;\n  }\n}\nPostgresDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  \"DEFAULT VALUES\": true,\n  EXCEPTION: true,\n  \"ON DUPLICATE KEY\": false,\n  \"ORDER NULLS\": true,\n  returnValues: {\n    returning: true\n  },\n  bulkDefault: true,\n  schemas: true,\n  lock: true,\n  lockOf: true,\n  lockKey: true,\n  lockOuterJoinFailure: true,\n  skipLocked: true,\n  forShare: \"FOR SHARE\",\n  index: {\n    concurrently: true,\n    using: 2,\n    where: true,\n    functionBased: true,\n    operator: true\n  },\n  inserts: {\n    onConflictDoNothing: \" ON CONFLICT DO NOTHING\",\n    updateOnDuplicate: \" ON CONFLICT DO UPDATE SET\",\n    conflictFields: true,\n    onConflictWhere: true\n  },\n  NUMERIC: true,\n  ARRAY: true,\n  RANGE: true,\n  GEOMETRY: true,\n  REGEXP: true,\n  GEOGRAPHY: true,\n  JSON: true,\n  JSONB: true,\n  HSTORE: true,\n  TSVECTOR: true,\n  deferrableConstraints: true,\n  searchPath: true,\n  escapeStringConstants: true\n});\nPostgresDialect.prototype.defaultVersion = \"9.5.0\";\nPostgresDialect.prototype.Query = Query;\nPostgresDialect.prototype.DataTypes = DataTypes;\nPostgresDialect.prototype.name = \"postgres\";\nPostgresDialect.prototype.TICK_CHAR = '\"';\nPostgresDialect.prototype.TICK_CHAR_LEFT = PostgresDialect.prototype.TICK_CHAR;\nPostgresDialect.prototype.TICK_CHAR_RIGHT = PostgresDialect.prototype.TICK_CHAR;\nmodule.exports = PostgresDialect;\nmodule.exports[\"default\"] = PostgresDialect;\nmodule.exports.PostgresDialect = PostgresDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFVBQVUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMxQix3QkFBd0IsbUJBQU8sQ0FBQyw4RkFBYTtBQUM3QywwQkFBMEIsbUJBQU8sQ0FBQyxvSEFBc0I7QUFDeEQsY0FBYyxtQkFBTyxDQUFDLDBGQUFTO0FBQy9CLHVCQUF1QixtQkFBTyxDQUFDLDhHQUFtQjtBQUNsRCxrQkFBa0Isc0hBQW9DO0FBQ3RELFFBQVEseUJBQXlCLEVBQUUsbUJBQU8sQ0FBQyw4R0FBbUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUFzQjtBQUN0Qiw4QkFBOEI7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvcG9zdGdyZXMvaW5kZXguanM/MDlmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgQWJzdHJhY3REaWFsZWN0ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0XCIpO1xuY29uc3QgQ29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi9jb25uZWN0aW9uLW1hbmFnZXJcIik7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoXCIuL3F1ZXJ5XCIpO1xuY29uc3QgUXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKFwiLi9xdWVyeS1nZW5lcmF0b3JcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKS5wb3N0Z3JlcztcbmNvbnN0IHsgUG9zdGdyZXNRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZShcIi4vcXVlcnktaW50ZXJmYWNlXCIpO1xuY2xhc3MgUG9zdGdyZXNEaWFsZWN0IGV4dGVuZHMgQWJzdHJhY3REaWFsZWN0IHtcbiAgY29uc3RydWN0b3Ioc2VxdWVsaXplKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gbmV3IENvbm5lY3Rpb25NYW5hZ2VyKHRoaXMsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5xdWVyeUdlbmVyYXRvciA9IG5ldyBRdWVyeUdlbmVyYXRvcih7XG4gICAgICBfZGlhbGVjdDogdGhpcyxcbiAgICAgIHNlcXVlbGl6ZVxuICAgIH0pO1xuICAgIHRoaXMucXVlcnlJbnRlcmZhY2UgPSBuZXcgUG9zdGdyZXNRdWVyeUludGVyZmFjZShzZXF1ZWxpemUsIHRoaXMucXVlcnlHZW5lcmF0b3IpO1xuICB9XG4gIGNhbkJhY2tzbGFzaEVzY2FwZSgpIHtcbiAgICByZXR1cm4gIXRoaXMuc2VxdWVsaXplLm9wdGlvbnMuc3RhbmRhcmRDb25mb3JtaW5nU3RyaW5ncztcbiAgfVxufVxuUG9zdGdyZXNEaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyA9IF8ubWVyZ2UoXy5jbG9uZURlZXAoQWJzdHJhY3REaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyksIHtcbiAgXCJERUZBVUxUIFZBTFVFU1wiOiB0cnVlLFxuICBFWENFUFRJT046IHRydWUsXG4gIFwiT04gRFVQTElDQVRFIEtFWVwiOiBmYWxzZSxcbiAgXCJPUkRFUiBOVUxMU1wiOiB0cnVlLFxuICByZXR1cm5WYWx1ZXM6IHtcbiAgICByZXR1cm5pbmc6IHRydWVcbiAgfSxcbiAgYnVsa0RlZmF1bHQ6IHRydWUsXG4gIHNjaGVtYXM6IHRydWUsXG4gIGxvY2s6IHRydWUsXG4gIGxvY2tPZjogdHJ1ZSxcbiAgbG9ja0tleTogdHJ1ZSxcbiAgbG9ja091dGVySm9pbkZhaWx1cmU6IHRydWUsXG4gIHNraXBMb2NrZWQ6IHRydWUsXG4gIGZvclNoYXJlOiBcIkZPUiBTSEFSRVwiLFxuICBpbmRleDoge1xuICAgIGNvbmN1cnJlbnRseTogdHJ1ZSxcbiAgICB1c2luZzogMixcbiAgICB3aGVyZTogdHJ1ZSxcbiAgICBmdW5jdGlvbkJhc2VkOiB0cnVlLFxuICAgIG9wZXJhdG9yOiB0cnVlXG4gIH0sXG4gIGluc2VydHM6IHtcbiAgICBvbkNvbmZsaWN0RG9Ob3RoaW5nOiBcIiBPTiBDT05GTElDVCBETyBOT1RISU5HXCIsXG4gICAgdXBkYXRlT25EdXBsaWNhdGU6IFwiIE9OIENPTkZMSUNUIERPIFVQREFURSBTRVRcIixcbiAgICBjb25mbGljdEZpZWxkczogdHJ1ZSxcbiAgICBvbkNvbmZsaWN0V2hlcmU6IHRydWVcbiAgfSxcbiAgTlVNRVJJQzogdHJ1ZSxcbiAgQVJSQVk6IHRydWUsXG4gIFJBTkdFOiB0cnVlLFxuICBHRU9NRVRSWTogdHJ1ZSxcbiAgUkVHRVhQOiB0cnVlLFxuICBHRU9HUkFQSFk6IHRydWUsXG4gIEpTT046IHRydWUsXG4gIEpTT05COiB0cnVlLFxuICBIU1RPUkU6IHRydWUsXG4gIFRTVkVDVE9SOiB0cnVlLFxuICBkZWZlcnJhYmxlQ29uc3RyYWludHM6IHRydWUsXG4gIHNlYXJjaFBhdGg6IHRydWUsXG4gIGVzY2FwZVN0cmluZ0NvbnN0YW50czogdHJ1ZVxufSk7XG5Qb3N0Z3Jlc0RpYWxlY3QucHJvdG90eXBlLmRlZmF1bHRWZXJzaW9uID0gXCI5LjUuMFwiO1xuUG9zdGdyZXNEaWFsZWN0LnByb3RvdHlwZS5RdWVyeSA9IFF1ZXJ5O1xuUG9zdGdyZXNEaWFsZWN0LnByb3RvdHlwZS5EYXRhVHlwZXMgPSBEYXRhVHlwZXM7XG5Qb3N0Z3Jlc0RpYWxlY3QucHJvdG90eXBlLm5hbWUgPSBcInBvc3RncmVzXCI7XG5Qb3N0Z3Jlc0RpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUiA9ICdcIic7XG5Qb3N0Z3Jlc0RpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9MRUZUID0gUG9zdGdyZXNEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVI7XG5Qb3N0Z3Jlc0RpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9SSUdIVCA9IFBvc3RncmVzRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSO1xubW9kdWxlLmV4cG9ydHMgPSBQb3N0Z3Jlc0RpYWxlY3Q7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gUG9zdGdyZXNEaWFsZWN0O1xubW9kdWxlLmV4cG9ydHMuUG9zdGdyZXNEaWFsZWN0ID0gUG9zdGdyZXNEaWFsZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/postgres/index.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/postgres/query-generator.js":
/*!**************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/postgres/query-generator.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst Utils = __webpack_require__(/*! ../../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\");\nconst AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-generator.js\");\nconst semver = __webpack_require__(/*! semver */ \"(action-browser)/../node_modules/semver/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst POSTGRES_RESERVED_WORDS = \"all,analyse,analyze,and,any,array,as,asc,asymmetric,authorization,binary,both,case,cast,check,collate,collation,column,concurrently,constraint,create,cross,current_catalog,current_date,current_role,current_schema,current_time,current_timestamp,current_user,default,deferrable,desc,distinct,do,else,end,except,false,fetch,for,foreign,freeze,from,full,grant,group,having,ilike,in,initially,inner,intersect,into,is,isnull,join,lateral,leading,left,like,limit,localtime,localtimestamp,natural,not,notnull,null,offset,on,only,or,order,outer,overlaps,placing,primary,references,returning,right,select,session_user,similar,some,symmetric,table,tablesample,then,to,trailing,true,union,unique,user,using,variadic,verbose,when,where,window,with\".split(\",\");\nclass PostgresQueryGenerator extends AbstractQueryGenerator {\n  setSearchPath(searchPath) {\n    return `SET search_path to ${searchPath};`;\n  }\n  createDatabaseQuery(databaseName, options) {\n    options = __spreadValues({\n      encoding: null,\n      collate: null\n    }, options);\n    const values = {\n      database: this.quoteTable(databaseName),\n      encoding: options.encoding ? ` ENCODING = ${this.escape(options.encoding)}` : \"\",\n      collation: options.collate ? ` LC_COLLATE = ${this.escape(options.collate)}` : \"\",\n      ctype: options.ctype ? ` LC_CTYPE = ${this.escape(options.ctype)}` : \"\",\n      template: options.template ? ` TEMPLATE = ${this.escape(options.template)}` : \"\"\n    };\n    return `CREATE DATABASE ${values.database}${values.encoding}${values.collation}${values.ctype}${values.template};`;\n  }\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteTable(databaseName)};`;\n  }\n  createSchema(schema) {\n    const databaseVersion = _.get(this, \"sequelize.options.databaseVersion\", 0);\n    if (databaseVersion && semver.gte(databaseVersion, \"9.2.0\")) {\n      return `CREATE SCHEMA IF NOT EXISTS ${this.quoteIdentifier(schema)};`;\n    }\n    return `CREATE SCHEMA ${this.quoteIdentifier(schema)};`;\n  }\n  dropSchema(schema) {\n    return `DROP SCHEMA IF EXISTS ${this.quoteIdentifier(schema)} CASCADE;`;\n  }\n  showSchemasQuery() {\n    return \"SELECT schema_name FROM information_schema.schemata WHERE schema_name <> 'information_schema' AND schema_name != 'public' AND schema_name !~ E'^pg_';\";\n  }\n  versionQuery() {\n    return \"SHOW SERVER_VERSION\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    options = __spreadValues({}, options);\n    const databaseVersion = _.get(this, \"sequelize.options.databaseVersion\", 0);\n    const attrStr = [];\n    let comments = \"\";\n    let columnComments = \"\";\n    const quotedTable = this.quoteTable(tableName);\n    if (options.comment && typeof options.comment === \"string\") {\n      comments += `; COMMENT ON TABLE ${quotedTable} IS ${this.escape(options.comment)}`;\n    }\n    for (const attr in attributes) {\n      const quotedAttr = this.quoteIdentifier(attr);\n      const i = attributes[attr].indexOf(\"COMMENT \");\n      if (i !== -1) {\n        const escapedCommentText = this.escape(attributes[attr].substring(i + 8));\n        columnComments += `; COMMENT ON COLUMN ${quotedTable}.${quotedAttr} IS ${escapedCommentText}`;\n        attributes[attr] = attributes[attr].substring(0, i);\n      }\n      const dataType = this.dataTypeMapping(tableName, attr, attributes[attr]);\n      attrStr.push(`${quotedAttr} ${dataType}`);\n    }\n    let attributesClause = attrStr.join(\", \");\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns) => {\n        if (columns.customIndex) {\n          attributesClause += `, UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n    const pks = _.reduce(attributes, (acc, attribute, key) => {\n      if (attribute.includes(\"PRIMARY KEY\")) {\n        acc.push(this.quoteIdentifier(key));\n      }\n      return acc;\n    }, []).join(\",\");\n    if (pks.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pks})`;\n    }\n    return `CREATE TABLE ${databaseVersion === 0 || semver.gte(databaseVersion, \"9.1.0\") ? \"IF NOT EXISTS \" : \"\"}${quotedTable} (${attributesClause})${comments}${columnComments};`;\n  }\n  dropTableQuery(tableName, options) {\n    options = options || {};\n    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)}${options.cascade ? \" CASCADE\" : \"\"};`;\n  }\n  showTablesQuery() {\n    const schema = this.options.schema || \"public\";\n    return `SELECT table_name FROM information_schema.tables WHERE table_schema = ${this.escape(schema)} AND table_type LIKE '%TABLE' AND table_name != 'spatial_ref_sys';`;\n  }\n  tableExistsQuery(tableName) {\n    const table = tableName.tableName || tableName;\n    const schema = tableName.schema || \"public\";\n    return `SELECT table_name FROM information_schema.tables WHERE table_schema = ${this.escape(schema)} AND table_name = ${this.escape(table)}`;\n  }\n  describeTableQuery(tableName, schema) {\n    schema = schema || this.options.schema || \"public\";\n    return `SELECT pk.constraint_type as \"Constraint\",c.column_name as \"Field\", c.column_default as \"Default\",c.is_nullable as \"Null\", (CASE WHEN c.udt_name = 'hstore' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN '(' || c.character_maximum_length || ')' ELSE '' END) as \"Type\", (SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS \"special\", (SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS \"Comment\" FROM information_schema.columns c LEFT JOIN (SELECT tc.table_schema, tc.table_name, cu.column_name, tc.constraint_type FROM information_schema.TABLE_CONSTRAINTS tc JOIN information_schema.KEY_COLUMN_USAGE  cu ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name and tc.constraint_name=cu.constraint_name and tc.constraint_type='PRIMARY KEY') pk ON pk.table_schema=c.table_schema AND pk.table_name=c.table_name AND pk.column_name=c.column_name WHERE c.table_name = ${this.escape(tableName)} AND c.table_schema = ${this.escape(schema)}`;\n  }\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n    const jsonFunctionRegex = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const jsonOperatorRegex = /^\\s*(->>?|#>>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n      const operatorMatches = jsonOperatorRegex.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n      break;\n    }\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n    return hasJsonFunction;\n  }\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map((condition) => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(\" AND \");\n      }\n      if (smth.path) {\n        let str;\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n        if (smth.value) {\n          str += util.format(\" = %s\", this.escape(smth.value));\n        }\n        return str;\n      }\n    }\n    return super.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n  addColumnQuery(table, key, attribute) {\n    const dbDataType = this.attributeToSQL(attribute, { context: \"addColumn\", table, key });\n    const dataType = attribute.type || attribute;\n    const definition = this.dataTypeMapping(table, key, dbDataType);\n    const quotedKey = this.quoteIdentifier(key);\n    const quotedTable = this.quoteTable(this.extractTableDetails(table));\n    let query = `ALTER TABLE ${quotedTable} ADD COLUMN ${quotedKey} ${definition};`;\n    if (dataType instanceof DataTypes.ENUM) {\n      query = this.pgEnum(table, key, dataType) + query;\n    } else if (dataType.type && dataType.type instanceof DataTypes.ENUM) {\n      query = this.pgEnum(table, key, dataType.type) + query;\n    }\n    return query;\n  }\n  removeColumnQuery(tableName, attributeName) {\n    const quotedTableName = this.quoteTable(this.extractTableDetails(tableName));\n    const quotedAttributeName = this.quoteIdentifier(attributeName);\n    return `ALTER TABLE ${quotedTableName} DROP COLUMN ${quotedAttributeName};`;\n  }\n  changeColumnQuery(tableName, attributes) {\n    const query = (subQuery) => `ALTER TABLE ${this.quoteTable(tableName)} ALTER COLUMN ${subQuery};`;\n    const sql = [];\n    for (const attributeName in attributes) {\n      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n      let attrSql = \"\";\n      if (definition.includes(\"NOT NULL\")) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} SET NOT NULL`);\n        definition = definition.replace(\"NOT NULL\", \"\").trim();\n      } else if (!definition.includes(\"REFERENCES\")) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP NOT NULL`);\n      }\n      if (definition.includes(\"DEFAULT\")) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} SET DEFAULT ${definition.match(/DEFAULT ([^;]+)/)[1]}`);\n        definition = definition.replace(/(DEFAULT[^;]+)/, \"\").trim();\n      } else if (!definition.includes(\"REFERENCES\")) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP DEFAULT`);\n      }\n      if (attributes[attributeName].startsWith(\"ENUM(\")) {\n        attrSql += this.pgEnum(tableName, attributeName, attributes[attributeName]);\n        definition = definition.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attributeName, { schema: false }));\n        definition += ` USING (${this.quoteIdentifier(attributeName)}::${this.pgEnumName(tableName, attributeName)})`;\n      }\n      if (definition.match(/UNIQUE;*$/)) {\n        definition = definition.replace(/UNIQUE;*$/, \"\");\n        attrSql += query(`ADD UNIQUE (${this.quoteIdentifier(attributeName)})`).replace(\"ALTER COLUMN\", \"\");\n      }\n      if (definition.includes(\"REFERENCES\")) {\n        definition = definition.replace(/.+?(?=REFERENCES)/, \"\");\n        attrSql += query(`ADD FOREIGN KEY (${this.quoteIdentifier(attributeName)}) ${definition}`).replace(\"ALTER COLUMN\", \"\");\n      } else {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} TYPE ${definition}`);\n      }\n      sql.push(attrSql);\n    }\n    return sql.join(\"\");\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n    for (const attributeName in attributes) {\n      attrString.push(`${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(attributeName)}`);\n    }\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${attrString.join(\", \")};`;\n  }\n  fn(fnName, tableName, parameters, body, returns, language) {\n    fnName = fnName || \"testfunc\";\n    language = language || \"plpgsql\";\n    returns = returns ? `RETURNS ${returns}` : \"\";\n    parameters = parameters || \"\";\n    return `CREATE OR REPLACE FUNCTION pg_temp.${fnName}(${parameters}) ${returns} AS $func$ BEGIN ${body} END; $func$ LANGUAGE ${language}; SELECT * FROM pg_temp.${fnName}();`;\n  }\n  truncateTableQuery(tableName, options = {}) {\n    return [\n      `TRUNCATE ${this.quoteTable(tableName)}`,\n      options.restartIdentity ? \" RESTART IDENTITY\" : \"\",\n      options.cascade ? \" CASCADE\" : \"\"\n    ].join(\"\");\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    const limit = options.limit ? ` LIMIT ${this.escape(options.limit)}` : \"\";\n    let primaryKeys = \"\";\n    let primaryKeysSelection = \"\";\n    if (whereClause) {\n      whereClause = ` WHERE ${whereClause}`;\n    }\n    if (options.limit) {\n      if (!model) {\n        throw new Error(\"Cannot LIMIT delete without a model.\");\n      }\n      const pks = Object.values(model.primaryKeys).map((pk) => this.quoteIdentifier(pk.field)).join(\",\");\n      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;\n      primaryKeysSelection = pks;\n      return `DELETE FROM ${table} WHERE ${primaryKeys} IN (SELECT ${primaryKeysSelection} FROM ${table}${whereClause}${limit})`;\n    }\n    return `DELETE FROM ${table}${whereClause}`;\n  }\n  showIndexesQuery(tableName) {\n    let schemaJoin = \"\";\n    let schemaWhere = \"\";\n    if (typeof tableName !== \"string\") {\n      schemaJoin = \", pg_namespace s\";\n      schemaWhere = ` AND s.oid = t.relnamespace AND s.nspname = '${tableName.schema}'`;\n      tableName = tableName.tableName;\n    }\n    return `SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a${schemaJoin} WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = '${tableName}'${schemaWhere} GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;`;\n  }\n  showConstraintsQuery(tableName) {\n    return [\n      'SELECT constraint_catalog AS \"constraintCatalog\",',\n      'constraint_schema AS \"constraintSchema\",',\n      'constraint_name AS \"constraintName\",',\n      'table_catalog AS \"tableCatalog\",',\n      'table_schema AS \"tableSchema\",',\n      'table_name AS \"tableName\",',\n      'constraint_type AS \"constraintType\",',\n      'is_deferrable AS \"isDeferrable\",',\n      'initially_deferred AS \"initiallyDeferred\"',\n      \"from INFORMATION_SCHEMA.table_constraints\",\n      `WHERE table_name='${tableName}';`\n    ].join(\" \");\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes, options) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return [\n      \"DROP INDEX\",\n      options && options.concurrently && \"CONCURRENTLY\",\n      `IF EXISTS ${this.quoteIdentifiers(indexName)}`\n    ].filter(Boolean).join(\" \");\n  }\n  addLimitAndOffset(options) {\n    let fragment = \"\";\n    if (options.limit != null) {\n      fragment += \" LIMIT \" + this.escape(options.limit);\n    }\n    if (options.offset != null) {\n      fragment += \" OFFSET \" + this.escape(options.offset);\n    }\n    return fragment;\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    let type;\n    if (attribute.type instanceof DataTypes.ENUM || attribute.type instanceof DataTypes.ARRAY && attribute.type.type instanceof DataTypes.ENUM) {\n      const enumType = attribute.type.type || attribute.type;\n      let values = attribute.values;\n      if (enumType.values && !attribute.values) {\n        values = enumType.values;\n      }\n      if (Array.isArray(values) && values.length > 0) {\n        type = `ENUM(${values.map((value) => this.escape(value)).join(\", \")})`;\n        if (attribute.type instanceof DataTypes.ARRAY) {\n          type += \"[]\";\n        }\n      } else {\n        throw new Error(\"Values for ENUM haven't been defined.\");\n      }\n    }\n    if (!type) {\n      type = attribute.type;\n    }\n    let sql = type.toString();\n    if (Object.prototype.hasOwnProperty.call(attribute, \"allowNull\") && !attribute.allowNull) {\n      sql += \" NOT NULL\";\n    }\n    if (attribute.autoIncrement) {\n      if (attribute.autoIncrementIdentity) {\n        sql += \" GENERATED BY DEFAULT AS IDENTITY\";\n      } else {\n        sql += \" SERIAL\";\n      }\n    }\n    if (Utils.defaultValueSchemable(attribute.defaultValue)) {\n      sql += ` DEFAULT ${this.escape(attribute.defaultValue, attribute)}`;\n    }\n    if (attribute.unique === true) {\n      sql += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      sql += \" PRIMARY KEY\";\n    }\n    if (attribute.references) {\n      let referencesTable = this.quoteTable(attribute.references.model);\n      let schema;\n      if (options.schema) {\n        schema = options.schema;\n      } else if ((!attribute.references.model || typeof attribute.references.model == \"string\") && options.table && options.table.schema) {\n        schema = options.table.schema;\n      }\n      if (schema) {\n        referencesTable = this.quoteTable(this.addSchema({\n          tableName: referencesTable,\n          _schema: schema\n        }));\n      }\n      let referencesKey;\n      if (!options.withoutForeignKeyConstraints) {\n        if (attribute.references.key) {\n          referencesKey = this.quoteIdentifiers(attribute.references.key);\n        } else {\n          referencesKey = this.quoteIdentifier(\"id\");\n        }\n        sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n        if (attribute.onDelete) {\n          sql += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n        }\n        if (attribute.onUpdate) {\n          sql += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n        }\n        if (attribute.references.deferrable) {\n          sql += ` ${attribute.references.deferrable.toString(this)}`;\n        }\n      }\n    }\n    if (attribute.comment && typeof attribute.comment === \"string\") {\n      if (options && [\"addColumn\", \"changeColumn\"].includes(options.context)) {\n        const quotedAttr = this.quoteIdentifier(options.key);\n        const escapedCommentText = this.escape(attribute.comment);\n        sql += `; COMMENT ON COLUMN ${this.quoteTable(options.table)}.${quotedAttr} IS ${escapedCommentText}`;\n      } else {\n        sql += ` COMMENT ${attribute.comment}`;\n      }\n    }\n    return sql;\n  }\n  deferConstraintsQuery(options) {\n    return options.deferrable.toString(this);\n  }\n  setConstraintQuery(columns, type) {\n    let columnFragment = \"ALL\";\n    if (columns) {\n      columnFragment = columns.map((column) => this.quoteIdentifier(column)).join(\", \");\n    }\n    return `SET CONSTRAINTS ${columnFragment} ${type}`;\n  }\n  setDeferredQuery(columns) {\n    return this.setConstraintQuery(columns, \"DEFERRED\");\n  }\n  setImmediateQuery(columns) {\n    return this.setConstraintQuery(columns, \"IMMEDIATE\");\n  }\n  attributesToSQL(attributes, options) {\n    const result = {};\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, __spreadValues({ key }, options));\n    }\n    return result;\n  }\n  createTrigger(tableName, triggerName, eventType, fireOnSpec, functionName, functionParams, optionsArray) {\n    const decodedEventType = this.decodeTriggerEventType(eventType);\n    const eventSpec = this.expandTriggerEventSpec(fireOnSpec);\n    const expandedOptions = this.expandOptions(optionsArray);\n    const paramList = this._expandFunctionParamList(functionParams);\n    return `CREATE ${this.triggerEventTypeIsConstraint(eventType)}TRIGGER ${this.quoteIdentifier(triggerName)} ${decodedEventType} ${eventSpec} ON ${this.quoteTable(tableName)}${expandedOptions ? ` ${expandedOptions}` : \"\"} EXECUTE PROCEDURE ${functionName}(${paramList});`;\n  }\n  dropTrigger(tableName, triggerName) {\n    return `DROP TRIGGER ${this.quoteIdentifier(triggerName)} ON ${this.quoteTable(tableName)} RESTRICT;`;\n  }\n  renameTrigger(tableName, oldTriggerName, newTriggerName) {\n    return `ALTER TRIGGER ${this.quoteIdentifier(oldTriggerName)} ON ${this.quoteTable(tableName)} RENAME TO ${this.quoteIdentifier(newTriggerName)};`;\n  }\n  createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    if (!functionName || !returnType || !language || !body)\n      throw new Error(\"createFunction missing some parameters. Did you pass functionName, returnType, language and body?\");\n    const paramList = this._expandFunctionParamList(params);\n    const variableList = options && options.variables ? this._expandFunctionVariableList(options.variables) : \"\";\n    const expandedOptionsArray = this.expandOptions(optionsArray);\n    const statement = options && options.force ? \"CREATE OR REPLACE FUNCTION\" : \"CREATE FUNCTION\";\n    return `${statement} ${functionName}(${paramList}) RETURNS ${returnType} AS $func$ ${variableList} BEGIN ${body} END; $func$ language '${language}'${expandedOptionsArray};`;\n  }\n  dropFunction(functionName, params) {\n    if (!functionName)\n      throw new Error(\"requires functionName\");\n    const paramList = this._expandFunctionParamList(params);\n    return `DROP FUNCTION ${functionName}(${paramList}) RESTRICT;`;\n  }\n  renameFunction(oldFunctionName, params, newFunctionName) {\n    const paramList = this._expandFunctionParamList(params);\n    return `ALTER FUNCTION ${oldFunctionName}(${paramList}) RENAME TO ${newFunctionName};`;\n  }\n  pgEscapeAndQuote(val) {\n    return this.quoteIdentifier(Utils.removeTicks(this.escape(val), \"'\"));\n  }\n  _expandFunctionParamList(params) {\n    if (params === void 0 || !Array.isArray(params)) {\n      throw new Error(\"_expandFunctionParamList: function parameters array required, including an empty one for no arguments\");\n    }\n    const paramList = [];\n    params.forEach((curParam) => {\n      const paramDef = [];\n      if (curParam.type) {\n        if (curParam.direction) {\n          paramDef.push(curParam.direction);\n        }\n        if (curParam.name) {\n          paramDef.push(curParam.name);\n        }\n        paramDef.push(curParam.type);\n      } else {\n        throw new Error(\"function or trigger used with a parameter without any type\");\n      }\n      const joined = paramDef.join(\" \");\n      if (joined)\n        paramList.push(joined);\n    });\n    return paramList.join(\", \");\n  }\n  _expandFunctionVariableList(variables) {\n    if (!Array.isArray(variables)) {\n      throw new Error(\"_expandFunctionVariableList: function variables must be an array\");\n    }\n    const variableDefinitions = [];\n    variables.forEach((variable) => {\n      if (!variable.name || !variable.type) {\n        throw new Error(\"function variable must have a name and type\");\n      }\n      let variableDefinition = `DECLARE ${variable.name} ${variable.type}`;\n      if (variable.default) {\n        variableDefinition += ` := ${variable.default}`;\n      }\n      variableDefinition += \";\";\n      variableDefinitions.push(variableDefinition);\n    });\n    return variableDefinitions.join(\" \");\n  }\n  expandOptions(options) {\n    return options === void 0 || _.isEmpty(options) ? \"\" : options.join(\" \");\n  }\n  decodeTriggerEventType(eventSpecifier) {\n    const EVENT_DECODER = {\n      \"after\": \"AFTER\",\n      \"before\": \"BEFORE\",\n      \"instead_of\": \"INSTEAD OF\",\n      \"after_constraint\": \"AFTER\"\n    };\n    if (!EVENT_DECODER[eventSpecifier]) {\n      throw new Error(`Invalid trigger event specified: ${eventSpecifier}`);\n    }\n    return EVENT_DECODER[eventSpecifier];\n  }\n  triggerEventTypeIsConstraint(eventSpecifier) {\n    return eventSpecifier === \"after_constraint\" ? \"CONSTRAINT \" : \"\";\n  }\n  expandTriggerEventSpec(fireOnSpec) {\n    if (_.isEmpty(fireOnSpec)) {\n      throw new Error(\"no table change events specified to trigger on\");\n    }\n    return _.map(fireOnSpec, (fireValue, fireKey) => {\n      const EVENT_MAP = {\n        \"insert\": \"INSERT\",\n        \"update\": \"UPDATE\",\n        \"delete\": \"DELETE\",\n        \"truncate\": \"TRUNCATE\"\n      };\n      if (!EVENT_MAP[fireValue]) {\n        throw new Error(`parseTriggerEventSpec: undefined trigger event ${fireKey}`);\n      }\n      let eventSpec = EVENT_MAP[fireValue];\n      if (eventSpec === \"UPDATE\") {\n        if (Array.isArray(fireValue) && fireValue.length > 0) {\n          eventSpec += ` OF ${fireValue.join(\", \")}`;\n        }\n      }\n      return eventSpec;\n    }).join(\" OR \");\n  }\n  pgEnumName(tableName, attr, options) {\n    options = options || {};\n    const tableDetails = this.extractTableDetails(tableName, options);\n    let enumName = Utils.addTicks(Utils.generateEnumName(tableDetails.tableName, attr), '\"');\n    if (options.schema !== false && tableDetails.schema) {\n      enumName = this.quoteIdentifier(tableDetails.schema) + tableDetails.delimiter + enumName;\n    }\n    return enumName;\n  }\n  pgListEnums(tableName, attrName, options) {\n    let enumName = \"\";\n    const tableDetails = this.extractTableDetails(tableName, options);\n    if (tableDetails.tableName && attrName) {\n      enumName = ` AND t.typname=${this.pgEnumName(tableDetails.tableName, attrName, { schema: false }).replace(/\"/g, \"'\")}`;\n    }\n    return `SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = '${tableDetails.schema}'${enumName} GROUP BY 1`;\n  }\n  pgEnum(tableName, attr, dataType, options) {\n    const enumName = this.pgEnumName(tableName, attr, options);\n    let values;\n    if (dataType.values) {\n      values = `ENUM(${dataType.values.map((value) => this.escape(value)).join(\", \")})`;\n    } else {\n      values = dataType.toString().match(/^ENUM\\(.+\\)/)[0];\n    }\n    let sql = `DO ${this.escape(`BEGIN CREATE TYPE ${enumName} AS ${values}; EXCEPTION WHEN duplicate_object THEN null; END`)};`;\n    if (!!options && options.force === true) {\n      sql = this.pgEnumDrop(tableName, attr) + sql;\n    }\n    return sql;\n  }\n  pgEnumAdd(tableName, attr, value, options) {\n    const enumName = this.pgEnumName(tableName, attr);\n    let sql = `ALTER TYPE ${enumName} ADD VALUE `;\n    if (semver.gte(this.sequelize.options.databaseVersion, \"9.3.0\")) {\n      sql += \"IF NOT EXISTS \";\n    }\n    sql += this.escape(value);\n    if (options.before) {\n      sql += ` BEFORE ${this.escape(options.before)}`;\n    } else if (options.after) {\n      sql += ` AFTER ${this.escape(options.after)}`;\n    }\n    return sql;\n  }\n  pgEnumDrop(tableName, attr, enumName) {\n    enumName = enumName || this.pgEnumName(tableName, attr);\n    return `DROP TYPE IF EXISTS ${enumName}; `;\n  }\n  fromArray(text) {\n    text = text.replace(/^{/, \"\").replace(/}$/, \"\");\n    let matches = text.match(/(\"(?:\\\\.|[^\"\\\\\\\\])*\"|[^,]*)(?:\\s*,\\s*|\\s*$)/ig);\n    if (matches.length < 1) {\n      return [];\n    }\n    matches = matches.map((m) => m.replace(/\",$/, \"\").replace(/,$/, \"\").replace(/(^\"|\"$)/g, \"\"));\n    return matches.slice(0, -1);\n  }\n  dataTypeMapping(tableName, attr, dataType) {\n    if (dataType.includes(\"PRIMARY KEY\")) {\n      dataType = dataType.replace(\"PRIMARY KEY\", \"\");\n    }\n    if (dataType.includes(\"SERIAL\")) {\n      if (dataType.includes(\"BIGINT\")) {\n        dataType = dataType.replace(\"SERIAL\", \"BIGSERIAL\");\n        dataType = dataType.replace(\"BIGINT\", \"\");\n      } else if (dataType.includes(\"SMALLINT\")) {\n        dataType = dataType.replace(\"SERIAL\", \"SMALLSERIAL\");\n        dataType = dataType.replace(\"SMALLINT\", \"\");\n      } else {\n        dataType = dataType.replace(\"INTEGER\", \"\");\n      }\n      dataType = dataType.replace(\"NOT NULL\", \"\");\n    }\n    if (dataType.startsWith(\"ENUM(\")) {\n      dataType = dataType.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attr));\n    }\n    return dataType;\n  }\n  getForeignKeysQuery(tableName) {\n    return `SELECT conname as constraint_name, pg_catalog.pg_get_constraintdef(r.oid, true) as condef FROM pg_catalog.pg_constraint r WHERE r.conrelid = (SELECT oid FROM pg_class WHERE relname = '${tableName}' LIMIT 1) AND r.contype = 'f' ORDER BY 1;`;\n  }\n  _getForeignKeyReferencesQueryPrefix() {\n    return \"SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name \";\n  }\n  getForeignKeyReferencesQuery(tableName, catalogName, schemaName) {\n    return `${this._getForeignKeyReferencesQueryPrefix()}WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = '${tableName}'${catalogName ? ` AND tc.table_catalog = '${catalogName}'` : \"\"}${schemaName ? ` AND tc.table_schema = '${schemaName}'` : \"\"}`;\n  }\n  getForeignKeyReferenceQuery(table, columnName) {\n    const tableName = table.tableName || table;\n    const schema = table.schema;\n    return `${this._getForeignKeyReferencesQueryPrefix()}WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name='${tableName}' AND  kcu.column_name = '${columnName}'${schema ? ` AND tc.table_schema = '${schema}'` : \"\"}`;\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${this.quoteIdentifier(foreignKey)};`;\n  }\n  quoteIdentifier(identifier, force) {\n    const optForceQuote = force || false;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n    if (optForceQuote === true || optQuoteIdentifiers !== false || identifier.includes(\".\") || identifier.includes(\"->\") || POSTGRES_RESERVED_WORDS.includes(rawIdentifier.toLowerCase())) {\n      return Utils.addTicks(rawIdentifier, '\"');\n    }\n    return rawIdentifier;\n  }\n}\nmodule.exports = PostgresQueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9xdWVyeS1nZW5lcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLDRFQUFhO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBa0I7QUFDNUMsK0JBQStCLG1CQUFPLENBQUMsd0hBQTZCO0FBQ3BFLGVBQWUsbUJBQU8sQ0FBQyxnRUFBUTtBQUMvQixVQUFVLG1CQUFPLENBQUMsaUVBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0RBQWtELDhCQUE4QjtBQUNoRixvREFBb0QsNkJBQTZCO0FBQ2pGLDRDQUE0QywyQkFBMkI7QUFDdkUsa0RBQWtELDhCQUE4QjtBQUNoRjtBQUNBLDhCQUE4QixnQkFBZ0IsRUFBRSxnQkFBZ0IsRUFBRSxpQkFBaUIsRUFBRSxhQUFhLEVBQUUsaUJBQWlCO0FBQ3JIO0FBQ0E7QUFDQSxzQ0FBc0MsK0JBQStCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDhCQUE4QjtBQUMxRTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBLG9DQUFvQyw4QkFBOEIsUUFBUTtBQUMxRTtBQUNBO0FBQ0EsaUtBQWlLO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQixhQUFhLEtBQUssNkJBQTZCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQkFBb0IsWUFBWSxHQUFHLFlBQVksS0FBSyxtQkFBbUI7QUFDcEc7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVksRUFBRSxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsc0VBQXNFO0FBQ2pIO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDRDQUE0QyxJQUFJO0FBQ2hEO0FBQ0EsMkJBQTJCLHNGQUFzRixFQUFFLGFBQWEsR0FBRyxpQkFBaUIsR0FBRyxTQUFTLEVBQUUsZ0JBQWdCO0FBQ2xMO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyQkFBMkIsRUFBRSxtQ0FBbUM7QUFDbkc7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLHFCQUFxQixpRUFBaUU7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YscUJBQXFCLG1CQUFtQixtQkFBbUI7QUFDL0k7QUFDQTtBQUNBO0FBQ0EsZ3BDQUFncEMsd0JBQXdCLHVCQUF1QixvQkFBb0I7QUFDbnRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsSUFBSSxrQkFBa0IsSUFBSTtBQUMxRSwrREFBK0QsRUFBRTtBQUNqRSw0REFBNEQsRUFBRSxzQkFBc0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsS0FBSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYseUVBQXlFLEtBQUssZ0JBQWdCO0FBQzFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxrQ0FBa0M7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYSxhQUFhLFdBQVcsRUFBRSxZQUFZO0FBQ2xGO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCLGNBQWMscUJBQXFCO0FBQzlFO0FBQ0E7QUFDQSwrQ0FBK0MsNEJBQTRCLGVBQWUsVUFBVTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFDQUFxQztBQUNqRTtBQUNBLFFBQVE7QUFDUiw0QkFBNEIscUNBQXFDO0FBQ2pFO0FBQ0E7QUFDQSw0QkFBNEIscUNBQXFDLGNBQWMsOEJBQThCLFNBQVM7QUFDdEgsb0RBQW9EO0FBQ3BELFFBQVE7QUFDUiw0QkFBNEIscUNBQXFDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyxlQUFlO0FBQ2xILGlDQUFpQyxvQ0FBb0MsSUFBSSwwQ0FBMEM7QUFDbkg7QUFDQSxtQ0FBbUM7QUFDbkMsZ0RBQWdEO0FBQ2hELHdDQUF3QyxvQ0FBb0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG9DQUFvQyxJQUFJLFdBQVc7QUFDaEcsUUFBUTtBQUNSLDRCQUE0QixxQ0FBcUMsT0FBTyxXQUFXO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0NBQWtDLEtBQUssb0NBQW9DO0FBQ3BHO0FBQ0EsMEJBQTBCLDRCQUE0QixnQkFBZ0IsdUJBQXVCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSxpREFBaUQsT0FBTyxHQUFHLFdBQVcsSUFBSSxTQUFTLGtCQUFrQixNQUFNLEtBQUssa0JBQWtCLFdBQVcsd0JBQXdCLE9BQU8sR0FBRztBQUMvSztBQUNBLDRDQUE0QztBQUM1QztBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLDRDQUE0QywyQkFBMkI7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLElBQUk7QUFDcEU7QUFDQSw0QkFBNEIsT0FBTyxRQUFRLGFBQWEsYUFBYSxzQkFBc0IsT0FBTyxNQUFNLEVBQUUsWUFBWSxFQUFFLE1BQU07QUFDOUg7QUFDQSwwQkFBMEIsTUFBTSxFQUFFLFlBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGlCQUFpQjtBQUNyRjtBQUNBO0FBQ0EscVNBQXFTLFlBQVksa0hBQWtILFVBQVUsR0FBRyxhQUFhLGlHQUFpRztBQUM5aEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVSxFQUFFO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxHQUFHLGdDQUFnQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQ0FBaUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxREFBcUQ7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtDQUErQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDhCQUE4QixpQkFBaUIsR0FBRyxjQUFjO0FBQ2hFO0FBQ0EsK0JBQStCLGlDQUFpQztBQUNoRTtBQUNBO0FBQ0EsK0JBQStCLGlDQUFpQztBQUNoRTtBQUNBO0FBQ0EscUJBQXFCLCtDQUErQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0IsK0JBQStCLEdBQUcsWUFBWSxLQUFLLG1CQUFtQjtBQUM1RyxRQUFRO0FBQ1IsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCLEVBQUUsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLEtBQUs7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2Q0FBNkMsVUFBVSxtQ0FBbUMsRUFBRSxrQkFBa0IsRUFBRSxXQUFXLEtBQUssMkJBQTJCLEVBQUUsc0JBQXNCLGdCQUFnQixRQUFRLG9CQUFvQixhQUFhLEdBQUcsVUFBVSxFQUFFO0FBQ2hSO0FBQ0E7QUFDQSwyQkFBMkIsbUNBQW1DLEtBQUssNEJBQTRCLFNBQVM7QUFDeEc7QUFDQTtBQUNBLDRCQUE0QixzQ0FBc0MsS0FBSyw0QkFBNEIsWUFBWSxzQ0FBc0M7QUFDcko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVyxFQUFFLGFBQWEsR0FBRyxVQUFVLFlBQVksWUFBWSxZQUFZLGNBQWMsUUFBUSxNQUFNLEtBQUssbUJBQW1CLFNBQVMsR0FBRyxzQkFBc0I7QUFDL0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhLEdBQUcsVUFBVSxXQUFXO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0IsR0FBRyxVQUFVLGNBQWMsaUJBQWlCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxlQUFlLEVBQUUsY0FBYztBQUN6RTtBQUNBLHFDQUFxQyxpQkFBaUI7QUFDdEQ7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsZUFBZTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsUUFBUTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixxQkFBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0RBQW9ELGVBQWUscUJBQXFCO0FBQzNIO0FBQ0Esb09BQW9PLG9CQUFvQixHQUFHLFVBQVU7QUFDclE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4REFBOEQ7QUFDckYsTUFBTTtBQUNOO0FBQ0E7QUFDQSxvQkFBb0IsaUNBQWlDLFVBQVUsS0FBSyxTQUFTLDJDQUEyQyxPQUFPO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQsTUFBTTtBQUNOLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxXQUFXO0FBQzdDO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc01BQXNNLFVBQVUsMENBQTBDO0FBQzFQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQyw2REFBNkQsVUFBVSxHQUFHLDBDQUEwQyxZQUFZLFFBQVEsRUFBRSx3Q0FBd0MsV0FBVyxRQUFRO0FBQzlQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkMsMkRBQTJELFVBQVUsNEJBQTRCLFdBQVcsR0FBRyxvQ0FBb0MsT0FBTyxRQUFRO0FBQzNOO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCLGtCQUFrQixrQ0FBa0M7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvcG9zdGdyZXMvcXVlcnktZ2VuZXJhdG9yLmpzPzliMWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpO1xuY29uc3QgQWJzdHJhY3RRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3JcIik7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBQT1NUR1JFU19SRVNFUlZFRF9XT1JEUyA9IFwiYWxsLGFuYWx5c2UsYW5hbHl6ZSxhbmQsYW55LGFycmF5LGFzLGFzYyxhc3ltbWV0cmljLGF1dGhvcml6YXRpb24sYmluYXJ5LGJvdGgsY2FzZSxjYXN0LGNoZWNrLGNvbGxhdGUsY29sbGF0aW9uLGNvbHVtbixjb25jdXJyZW50bHksY29uc3RyYWludCxjcmVhdGUsY3Jvc3MsY3VycmVudF9jYXRhbG9nLGN1cnJlbnRfZGF0ZSxjdXJyZW50X3JvbGUsY3VycmVudF9zY2hlbWEsY3VycmVudF90aW1lLGN1cnJlbnRfdGltZXN0YW1wLGN1cnJlbnRfdXNlcixkZWZhdWx0LGRlZmVycmFibGUsZGVzYyxkaXN0aW5jdCxkbyxlbHNlLGVuZCxleGNlcHQsZmFsc2UsZmV0Y2gsZm9yLGZvcmVpZ24sZnJlZXplLGZyb20sZnVsbCxncmFudCxncm91cCxoYXZpbmcsaWxpa2UsaW4saW5pdGlhbGx5LGlubmVyLGludGVyc2VjdCxpbnRvLGlzLGlzbnVsbCxqb2luLGxhdGVyYWwsbGVhZGluZyxsZWZ0LGxpa2UsbGltaXQsbG9jYWx0aW1lLGxvY2FsdGltZXN0YW1wLG5hdHVyYWwsbm90LG5vdG51bGwsbnVsbCxvZmZzZXQsb24sb25seSxvcixvcmRlcixvdXRlcixvdmVybGFwcyxwbGFjaW5nLHByaW1hcnkscmVmZXJlbmNlcyxyZXR1cm5pbmcscmlnaHQsc2VsZWN0LHNlc3Npb25fdXNlcixzaW1pbGFyLHNvbWUsc3ltbWV0cmljLHRhYmxlLHRhYmxlc2FtcGxlLHRoZW4sdG8sdHJhaWxpbmcsdHJ1ZSx1bmlvbix1bmlxdWUsdXNlcix1c2luZyx2YXJpYWRpYyx2ZXJib3NlLHdoZW4sd2hlcmUsd2luZG93LHdpdGhcIi5zcGxpdChcIixcIik7XG5jbGFzcyBQb3N0Z3Jlc1F1ZXJ5R2VuZXJhdG9yIGV4dGVuZHMgQWJzdHJhY3RRdWVyeUdlbmVyYXRvciB7XG4gIHNldFNlYXJjaFBhdGgoc2VhcmNoUGF0aCkge1xuICAgIHJldHVybiBgU0VUIHNlYXJjaF9wYXRoIHRvICR7c2VhcmNoUGF0aH07YDtcbiAgfVxuICBjcmVhdGVEYXRhYmFzZVF1ZXJ5KGRhdGFiYXNlTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBlbmNvZGluZzogbnVsbCxcbiAgICAgIGNvbGxhdGU6IG51bGxcbiAgICB9LCBvcHRpb25zKTtcbiAgICBjb25zdCB2YWx1ZXMgPSB7XG4gICAgICBkYXRhYmFzZTogdGhpcy5xdW90ZVRhYmxlKGRhdGFiYXNlTmFtZSksXG4gICAgICBlbmNvZGluZzogb3B0aW9ucy5lbmNvZGluZyA/IGAgRU5DT0RJTkcgPSAke3RoaXMuZXNjYXBlKG9wdGlvbnMuZW5jb2RpbmcpfWAgOiBcIlwiLFxuICAgICAgY29sbGF0aW9uOiBvcHRpb25zLmNvbGxhdGUgPyBgIExDX0NPTExBVEUgPSAke3RoaXMuZXNjYXBlKG9wdGlvbnMuY29sbGF0ZSl9YCA6IFwiXCIsXG4gICAgICBjdHlwZTogb3B0aW9ucy5jdHlwZSA/IGAgTENfQ1RZUEUgPSAke3RoaXMuZXNjYXBlKG9wdGlvbnMuY3R5cGUpfWAgOiBcIlwiLFxuICAgICAgdGVtcGxhdGU6IG9wdGlvbnMudGVtcGxhdGUgPyBgIFRFTVBMQVRFID0gJHt0aGlzLmVzY2FwZShvcHRpb25zLnRlbXBsYXRlKX1gIDogXCJcIlxuICAgIH07XG4gICAgcmV0dXJuIGBDUkVBVEUgREFUQUJBU0UgJHt2YWx1ZXMuZGF0YWJhc2V9JHt2YWx1ZXMuZW5jb2Rpbmd9JHt2YWx1ZXMuY29sbGF0aW9ufSR7dmFsdWVzLmN0eXBlfSR7dmFsdWVzLnRlbXBsYXRlfTtgO1xuICB9XG4gIGRyb3BEYXRhYmFzZVF1ZXJ5KGRhdGFiYXNlTmFtZSkge1xuICAgIHJldHVybiBgRFJPUCBEQVRBQkFTRSBJRiBFWElTVFMgJHt0aGlzLnF1b3RlVGFibGUoZGF0YWJhc2VOYW1lKX07YDtcbiAgfVxuICBjcmVhdGVTY2hlbWEoc2NoZW1hKSB7XG4gICAgY29uc3QgZGF0YWJhc2VWZXJzaW9uID0gXy5nZXQodGhpcywgXCJzZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb25cIiwgMCk7XG4gICAgaWYgKGRhdGFiYXNlVmVyc2lvbiAmJiBzZW12ZXIuZ3RlKGRhdGFiYXNlVmVyc2lvbiwgXCI5LjIuMFwiKSkge1xuICAgICAgcmV0dXJuIGBDUkVBVEUgU0NIRU1BIElGIE5PVCBFWElTVFMgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihzY2hlbWEpfTtgO1xuICAgIH1cbiAgICByZXR1cm4gYENSRUFURSBTQ0hFTUEgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihzY2hlbWEpfTtgO1xuICB9XG4gIGRyb3BTY2hlbWEoc2NoZW1hKSB7XG4gICAgcmV0dXJuIGBEUk9QIFNDSEVNQSBJRiBFWElTVFMgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihzY2hlbWEpfSBDQVNDQURFO2A7XG4gIH1cbiAgc2hvd1NjaGVtYXNRdWVyeSgpIHtcbiAgICByZXR1cm4gXCJTRUxFQ1Qgc2NoZW1hX25hbWUgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEuc2NoZW1hdGEgV0hFUkUgc2NoZW1hX25hbWUgPD4gJ2luZm9ybWF0aW9uX3NjaGVtYScgQU5EIHNjaGVtYV9uYW1lICE9ICdwdWJsaWMnIEFORCBzY2hlbWFfbmFtZSAhfiBFJ15wZ18nO1wiO1xuICB9XG4gIHZlcnNpb25RdWVyeSgpIHtcbiAgICByZXR1cm4gXCJTSE9XIFNFUlZFUl9WRVJTSU9OXCI7XG4gIH1cbiAgY3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRhdGFiYXNlVmVyc2lvbiA9IF8uZ2V0KHRoaXMsIFwic2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uXCIsIDApO1xuICAgIGNvbnN0IGF0dHJTdHIgPSBbXTtcbiAgICBsZXQgY29tbWVudHMgPSBcIlwiO1xuICAgIGxldCBjb2x1bW5Db21tZW50cyA9IFwiXCI7XG4gICAgY29uc3QgcXVvdGVkVGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBpZiAob3B0aW9ucy5jb21tZW50ICYmIHR5cGVvZiBvcHRpb25zLmNvbW1lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbW1lbnRzICs9IGA7IENPTU1FTlQgT04gVEFCTEUgJHtxdW90ZWRUYWJsZX0gSVMgJHt0aGlzLmVzY2FwZShvcHRpb25zLmNvbW1lbnQpfWA7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYXR0ciBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBxdW90ZWRBdHRyID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cik7XG4gICAgICBjb25zdCBpID0gYXR0cmlidXRlc1thdHRyXS5pbmRleE9mKFwiQ09NTUVOVCBcIik7XG4gICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgY29uc3QgZXNjYXBlZENvbW1lbnRUZXh0ID0gdGhpcy5lc2NhcGUoYXR0cmlidXRlc1thdHRyXS5zdWJzdHJpbmcoaSArIDgpKTtcbiAgICAgICAgY29sdW1uQ29tbWVudHMgKz0gYDsgQ09NTUVOVCBPTiBDT0xVTU4gJHtxdW90ZWRUYWJsZX0uJHtxdW90ZWRBdHRyfSBJUyAke2VzY2FwZWRDb21tZW50VGV4dH1gO1xuICAgICAgICBhdHRyaWJ1dGVzW2F0dHJdID0gYXR0cmlidXRlc1thdHRyXS5zdWJzdHJpbmcoMCwgaSk7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IHRoaXMuZGF0YVR5cGVNYXBwaW5nKHRhYmxlTmFtZSwgYXR0ciwgYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICBhdHRyU3RyLnB1c2goYCR7cXVvdGVkQXR0cn0gJHtkYXRhVHlwZX1gKTtcbiAgICB9XG4gICAgbGV0IGF0dHJpYnV0ZXNDbGF1c2UgPSBhdHRyU3RyLmpvaW4oXCIsIFwiKTtcbiAgICBpZiAob3B0aW9ucy51bmlxdWVLZXlzKSB7XG4gICAgICBfLmVhY2gob3B0aW9ucy51bmlxdWVLZXlzLCAoY29sdW1ucykgPT4ge1xuICAgICAgICBpZiAoY29sdW1ucy5jdXN0b21JbmRleCkge1xuICAgICAgICAgIGF0dHJpYnV0ZXNDbGF1c2UgKz0gYCwgVU5JUVVFICgke2NvbHVtbnMuZmllbGRzLm1hcCgoZmllbGQpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKSkuam9pbihcIiwgXCIpfSlgO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcGtzID0gXy5yZWR1Y2UoYXR0cmlidXRlcywgKGFjYywgYXR0cmlidXRlLCBrZXkpID0+IHtcbiAgICAgIGlmIChhdHRyaWJ1dGUuaW5jbHVkZXMoXCJQUklNQVJZIEtFWVwiKSkge1xuICAgICAgICBhY2MucHVzaCh0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pLmpvaW4oXCIsXCIpO1xuICAgIGlmIChwa3MubGVuZ3RoID4gMCkge1xuICAgICAgYXR0cmlidXRlc0NsYXVzZSArPSBgLCBQUklNQVJZIEtFWSAoJHtwa3N9KWA7XG4gICAgfVxuICAgIHJldHVybiBgQ1JFQVRFIFRBQkxFICR7ZGF0YWJhc2VWZXJzaW9uID09PSAwIHx8IHNlbXZlci5ndGUoZGF0YWJhc2VWZXJzaW9uLCBcIjkuMS4wXCIpID8gXCJJRiBOT1QgRVhJU1RTIFwiIDogXCJcIn0ke3F1b3RlZFRhYmxlfSAoJHthdHRyaWJ1dGVzQ2xhdXNlfSkke2NvbW1lbnRzfSR7Y29sdW1uQ29tbWVudHN9O2A7XG4gIH1cbiAgZHJvcFRhYmxlUXVlcnkodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIGBEUk9QIFRBQkxFIElGIEVYSVNUUyAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSR7b3B0aW9ucy5jYXNjYWRlID8gXCIgQ0FTQ0FERVwiIDogXCJcIn07YDtcbiAgfVxuICBzaG93VGFibGVzUXVlcnkoKSB7XG4gICAgY29uc3Qgc2NoZW1hID0gdGhpcy5vcHRpb25zLnNjaGVtYSB8fCBcInB1YmxpY1wiO1xuICAgIHJldHVybiBgU0VMRUNUIHRhYmxlX25hbWUgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVzIFdIRVJFIHRhYmxlX3NjaGVtYSA9ICR7dGhpcy5lc2NhcGUoc2NoZW1hKX0gQU5EIHRhYmxlX3R5cGUgTElLRSAnJVRBQkxFJyBBTkQgdGFibGVfbmFtZSAhPSAnc3BhdGlhbF9yZWZfc3lzJztgO1xuICB9XG4gIHRhYmxlRXhpc3RzUXVlcnkodGFibGVOYW1lKSB7XG4gICAgY29uc3QgdGFibGUgPSB0YWJsZU5hbWUudGFibGVOYW1lIHx8IHRhYmxlTmFtZTtcbiAgICBjb25zdCBzY2hlbWEgPSB0YWJsZU5hbWUuc2NoZW1hIHx8IFwicHVibGljXCI7XG4gICAgcmV0dXJuIGBTRUxFQ1QgdGFibGVfbmFtZSBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZXMgV0hFUkUgdGFibGVfc2NoZW1hID0gJHt0aGlzLmVzY2FwZShzY2hlbWEpfSBBTkQgdGFibGVfbmFtZSA9ICR7dGhpcy5lc2NhcGUodGFibGUpfWA7XG4gIH1cbiAgZGVzY3JpYmVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgc2NoZW1hKSB7XG4gICAgc2NoZW1hID0gc2NoZW1hIHx8IHRoaXMub3B0aW9ucy5zY2hlbWEgfHwgXCJwdWJsaWNcIjtcbiAgICByZXR1cm4gYFNFTEVDVCBway5jb25zdHJhaW50X3R5cGUgYXMgXCJDb25zdHJhaW50XCIsYy5jb2x1bW5fbmFtZSBhcyBcIkZpZWxkXCIsIGMuY29sdW1uX2RlZmF1bHQgYXMgXCJEZWZhdWx0XCIsYy5pc19udWxsYWJsZSBhcyBcIk51bGxcIiwgKENBU0UgV0hFTiBjLnVkdF9uYW1lID0gJ2hzdG9yZScgVEhFTiBjLnVkdF9uYW1lIEVMU0UgYy5kYXRhX3R5cGUgRU5EKSB8fCAoQ0FTRSBXSEVOIGMuY2hhcmFjdGVyX21heGltdW1fbGVuZ3RoIElTIE5PVCBOVUxMIFRIRU4gJygnIHx8IGMuY2hhcmFjdGVyX21heGltdW1fbGVuZ3RoIHx8ICcpJyBFTFNFICcnIEVORCkgYXMgXCJUeXBlXCIsIChTRUxFQ1QgYXJyYXlfYWdnKGUuZW51bWxhYmVsKSBGUk9NIHBnX2NhdGFsb2cucGdfdHlwZSB0IEpPSU4gcGdfY2F0YWxvZy5wZ19lbnVtIGUgT04gdC5vaWQ9ZS5lbnVtdHlwaWQgV0hFUkUgdC50eXBuYW1lPWMudWR0X25hbWUpIEFTIFwic3BlY2lhbFwiLCAoU0VMRUNUIHBnZC5kZXNjcmlwdGlvbiBGUk9NIHBnX2NhdGFsb2cucGdfc3RhdGlvX2FsbF90YWJsZXMgQVMgc3QgSU5ORVIgSk9JTiBwZ19jYXRhbG9nLnBnX2Rlc2NyaXB0aW9uIHBnZCBvbiAocGdkLm9iam9pZD1zdC5yZWxpZCkgV0hFUkUgYy5vcmRpbmFsX3Bvc2l0aW9uPXBnZC5vYmpzdWJpZCBBTkQgYy50YWJsZV9uYW1lPXN0LnJlbG5hbWUpIEFTIFwiQ29tbWVudFwiIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLmNvbHVtbnMgYyBMRUZUIEpPSU4gKFNFTEVDVCB0Yy50YWJsZV9zY2hlbWEsIHRjLnRhYmxlX25hbWUsIGN1LmNvbHVtbl9uYW1lLCB0Yy5jb25zdHJhaW50X3R5cGUgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEuVEFCTEVfQ09OU1RSQUlOVFMgdGMgSk9JTiBpbmZvcm1hdGlvbl9zY2hlbWEuS0VZX0NPTFVNTl9VU0FHRSAgY3UgT04gdGMudGFibGVfc2NoZW1hPWN1LnRhYmxlX3NjaGVtYSBhbmQgdGMudGFibGVfbmFtZT1jdS50YWJsZV9uYW1lIGFuZCB0Yy5jb25zdHJhaW50X25hbWU9Y3UuY29uc3RyYWludF9uYW1lIGFuZCB0Yy5jb25zdHJhaW50X3R5cGU9J1BSSU1BUlkgS0VZJykgcGsgT04gcGsudGFibGVfc2NoZW1hPWMudGFibGVfc2NoZW1hIEFORCBway50YWJsZV9uYW1lPWMudGFibGVfbmFtZSBBTkQgcGsuY29sdW1uX25hbWU9Yy5jb2x1bW5fbmFtZSBXSEVSRSBjLnRhYmxlX25hbWUgPSAke3RoaXMuZXNjYXBlKHRhYmxlTmFtZSl9IEFORCBjLnRhYmxlX3NjaGVtYSA9ICR7dGhpcy5lc2NhcGUoc2NoZW1hKX1gO1xuICB9XG4gIF9jaGVja1ZhbGlkSnNvblN0YXRlbWVudChzdG10KSB7XG4gICAgaWYgKHR5cGVvZiBzdG10ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGpzb25GdW5jdGlvblJlZ2V4ID0gL15cXHMqKCg/OlthLXpdK18pezAsMn1qc29uYj8oPzpfW2Etel0rKXswLDJ9KVxcKFteKV0qXFwpL2k7XG4gICAgY29uc3QganNvbk9wZXJhdG9yUmVnZXggPSAvXlxccyooLT4+P3wjPj4/fEA+fDxAfFxcP1t8Jl0/fFxcfHsyfXwjLSkvaTtcbiAgICBjb25zdCB0b2tlbkNhcHR1cmVSZWdleCA9IC9eXFxzKigoPzooW2BcIiddKSg/Oig/IVxcMikufFxcMnsyfSkqXFwyKXxbXFx3XFxkXFxzXSt8WygpLiw7Ky1dKS9pO1xuICAgIGxldCBjdXJyZW50SW5kZXggPSAwO1xuICAgIGxldCBvcGVuaW5nQnJhY2tldHMgPSAwO1xuICAgIGxldCBjbG9zaW5nQnJhY2tldHMgPSAwO1xuICAgIGxldCBoYXNKc29uRnVuY3Rpb24gPSBmYWxzZTtcbiAgICBsZXQgaGFzSW52YWxpZFRva2VuID0gZmFsc2U7XG4gICAgd2hpbGUgKGN1cnJlbnRJbmRleCA8IHN0bXQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzdHJpbmcgPSBzdG10LnN1YnN0cihjdXJyZW50SW5kZXgpO1xuICAgICAgY29uc3QgZnVuY3Rpb25NYXRjaGVzID0ganNvbkZ1bmN0aW9uUmVnZXguZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKGZ1bmN0aW9uTWF0Y2hlcykge1xuICAgICAgICBjdXJyZW50SW5kZXggKz0gZnVuY3Rpb25NYXRjaGVzWzBdLmluZGV4T2YoXCIoXCIpO1xuICAgICAgICBoYXNKc29uRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wZXJhdG9yTWF0Y2hlcyA9IGpzb25PcGVyYXRvclJlZ2V4LmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmIChvcGVyYXRvck1hdGNoZXMpIHtcbiAgICAgICAgY3VycmVudEluZGV4ICs9IG9wZXJhdG9yTWF0Y2hlc1swXS5sZW5ndGg7XG4gICAgICAgIGhhc0pzb25GdW5jdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9rZW5NYXRjaGVzID0gdG9rZW5DYXB0dXJlUmVnZXguZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKHRva2VuTWF0Y2hlcykge1xuICAgICAgICBjb25zdCBjYXB0dXJlZFRva2VuID0gdG9rZW5NYXRjaGVzWzFdO1xuICAgICAgICBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gXCIoXCIpIHtcbiAgICAgICAgICBvcGVuaW5nQnJhY2tldHMrKztcbiAgICAgICAgfSBlbHNlIGlmIChjYXB0dXJlZFRva2VuID09PSBcIilcIikge1xuICAgICAgICAgIGNsb3NpbmdCcmFja2V0cysrO1xuICAgICAgICB9IGVsc2UgaWYgKGNhcHR1cmVkVG9rZW4gPT09IFwiO1wiKSB7XG4gICAgICAgICAgaGFzSW52YWxpZFRva2VuID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50SW5kZXggKz0gdG9rZW5NYXRjaGVzWzBdLmxlbmd0aDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaGFzSW52YWxpZFRva2VuIHw9IG9wZW5pbmdCcmFja2V0cyAhPT0gY2xvc2luZ0JyYWNrZXRzO1xuICAgIGlmIChoYXNKc29uRnVuY3Rpb24gJiYgaGFzSW52YWxpZFRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQganNvbiBzdGF0ZW1lbnQ6ICR7c3RtdH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0pzb25GdW5jdGlvbjtcbiAgfVxuICBoYW5kbGVTZXF1ZWxpemVNZXRob2Qoc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKSB7XG4gICAgaWYgKHNtdGggaW5zdGFuY2VvZiBVdGlscy5Kc29uKSB7XG4gICAgICBpZiAoc210aC5jb25kaXRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmRpdGlvbnMgPSB0aGlzLnBhcnNlQ29uZGl0aW9uT2JqZWN0KHNtdGguY29uZGl0aW9ucykubWFwKChjb25kaXRpb24pID0+IGAke3RoaXMuanNvblBhdGhFeHRyYWN0aW9uUXVlcnkoY29uZGl0aW9uLnBhdGhbMF0sIF8udGFpbChjb25kaXRpb24ucGF0aCkpfSA9ICcke2NvbmRpdGlvbi52YWx1ZX0nYCk7XG4gICAgICAgIHJldHVybiBjb25kaXRpb25zLmpvaW4oXCIgQU5EIFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzbXRoLnBhdGgpIHtcbiAgICAgICAgbGV0IHN0cjtcbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrVmFsaWRKc29uU3RhdGVtZW50KHNtdGgucGF0aCkpIHtcbiAgICAgICAgICBzdHIgPSBzbXRoLnBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcGF0aHMgPSBfLnRvUGF0aChzbXRoLnBhdGgpO1xuICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IHBhdGhzLnNoaWZ0KCk7XG4gICAgICAgICAgc3RyID0gdGhpcy5qc29uUGF0aEV4dHJhY3Rpb25RdWVyeShjb2x1bW4sIHBhdGhzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc210aC52YWx1ZSkge1xuICAgICAgICAgIHN0ciArPSB1dGlsLmZvcm1hdChcIiA9ICVzXCIsIHRoaXMuZXNjYXBlKHNtdGgudmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuaGFuZGxlU2VxdWVsaXplTWV0aG9kLmNhbGwodGhpcywgc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKTtcbiAgfVxuICBhZGRDb2x1bW5RdWVyeSh0YWJsZSwga2V5LCBhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCBkYkRhdGFUeXBlID0gdGhpcy5hdHRyaWJ1dGVUb1NRTChhdHRyaWJ1dGUsIHsgY29udGV4dDogXCJhZGRDb2x1bW5cIiwgdGFibGUsIGtleSB9KTtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGF0dHJpYnV0ZS50eXBlIHx8IGF0dHJpYnV0ZTtcbiAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5kYXRhVHlwZU1hcHBpbmcodGFibGUsIGtleSwgZGJEYXRhVHlwZSk7XG4gICAgY29uc3QgcXVvdGVkS2V5ID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KTtcbiAgICBjb25zdCBxdW90ZWRUYWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0aGlzLmV4dHJhY3RUYWJsZURldGFpbHModGFibGUpKTtcbiAgICBsZXQgcXVlcnkgPSBgQUxURVIgVEFCTEUgJHtxdW90ZWRUYWJsZX0gQUREIENPTFVNTiAke3F1b3RlZEtleX0gJHtkZWZpbml0aW9ufTtgO1xuICAgIGlmIChkYXRhVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNKSB7XG4gICAgICBxdWVyeSA9IHRoaXMucGdFbnVtKHRhYmxlLCBrZXksIGRhdGFUeXBlKSArIHF1ZXJ5O1xuICAgIH0gZWxzZSBpZiAoZGF0YVR5cGUudHlwZSAmJiBkYXRhVHlwZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0pIHtcbiAgICAgIHF1ZXJ5ID0gdGhpcy5wZ0VudW0odGFibGUsIGtleSwgZGF0YVR5cGUudHlwZSkgKyBxdWVyeTtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG4gIHJlbW92ZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIGNvbnN0IHF1b3RlZFRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZSh0aGlzLmV4dHJhY3RUYWJsZURldGFpbHModGFibGVOYW1lKSk7XG4gICAgY29uc3QgcXVvdGVkQXR0cmlidXRlTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpO1xuICAgIHJldHVybiBgQUxURVIgVEFCTEUgJHtxdW90ZWRUYWJsZU5hbWV9IERST1AgQ09MVU1OICR7cXVvdGVkQXR0cmlidXRlTmFtZX07YDtcbiAgfVxuICBjaGFuZ2VDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBxdWVyeSA9IChzdWJRdWVyeSkgPT4gYEFMVEVSIFRBQkxFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9IEFMVEVSIENPTFVNTiAke3N1YlF1ZXJ5fTtgO1xuICAgIGNvbnN0IHNxbCA9IFtdO1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBsZXQgZGVmaW5pdGlvbiA9IHRoaXMuZGF0YVR5cGVNYXBwaW5nKHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSk7XG4gICAgICBsZXQgYXR0clNxbCA9IFwiXCI7XG4gICAgICBpZiAoZGVmaW5pdGlvbi5pbmNsdWRlcyhcIk5PVCBOVUxMXCIpKSB7XG4gICAgICAgIGF0dHJTcWwgKz0gcXVlcnkoYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSl9IFNFVCBOT1QgTlVMTGApO1xuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbi5yZXBsYWNlKFwiTk9UIE5VTExcIiwgXCJcIikudHJpbSgpO1xuICAgICAgfSBlbHNlIGlmICghZGVmaW5pdGlvbi5pbmNsdWRlcyhcIlJFRkVSRU5DRVNcIikpIHtcbiAgICAgICAgYXR0clNxbCArPSBxdWVyeShgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKX0gRFJPUCBOT1QgTlVMTGApO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmluaXRpb24uaW5jbHVkZXMoXCJERUZBVUxUXCIpKSB7XG4gICAgICAgIGF0dHJTcWwgKz0gcXVlcnkoYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSl9IFNFVCBERUZBVUxUICR7ZGVmaW5pdGlvbi5tYXRjaCgvREVGQVVMVCAoW147XSspLylbMV19YCk7XG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uLnJlcGxhY2UoLyhERUZBVUxUW147XSspLywgXCJcIikudHJpbSgpO1xuICAgICAgfSBlbHNlIGlmICghZGVmaW5pdGlvbi5pbmNsdWRlcyhcIlJFRkVSRU5DRVNcIikpIHtcbiAgICAgICAgYXR0clNxbCArPSBxdWVyeShgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKX0gRFJPUCBERUZBVUxUYCk7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXS5zdGFydHNXaXRoKFwiRU5VTShcIikpIHtcbiAgICAgICAgYXR0clNxbCArPSB0aGlzLnBnRW51bSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0pO1xuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbi5yZXBsYWNlKC9eRU5VTVxcKC4rXFwpLywgdGhpcy5wZ0VudW1OYW1lKHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSwgeyBzY2hlbWE6IGZhbHNlIH0pKTtcbiAgICAgICAgZGVmaW5pdGlvbiArPSBgIFVTSU5HICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpfTo6JHt0aGlzLnBnRW51bU5hbWUodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKX0pYDtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbml0aW9uLm1hdGNoKC9VTklRVUU7KiQvKSkge1xuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbi5yZXBsYWNlKC9VTklRVUU7KiQvLCBcIlwiKTtcbiAgICAgICAgYXR0clNxbCArPSBxdWVyeShgQUREIFVOSVFVRSAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKX0pYCkucmVwbGFjZShcIkFMVEVSIENPTFVNTlwiLCBcIlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbml0aW9uLmluY2x1ZGVzKFwiUkVGRVJFTkNFU1wiKSkge1xuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbi5yZXBsYWNlKC8uKz8oPz1SRUZFUkVOQ0VTKS8sIFwiXCIpO1xuICAgICAgICBhdHRyU3FsICs9IHF1ZXJ5KGBBREQgRk9SRUlHTiBLRVkgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSl9KSAke2RlZmluaXRpb259YCkucmVwbGFjZShcIkFMVEVSIENPTFVNTlwiLCBcIlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJTcWwgKz0gcXVlcnkoYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSl9IFRZUEUgJHtkZWZpbml0aW9ufWApO1xuICAgICAgfVxuICAgICAgc3FsLnB1c2goYXR0clNxbCk7XG4gICAgfVxuICAgIHJldHVybiBzcWwuam9pbihcIlwiKTtcbiAgfVxuICByZW5hbWVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJCZWZvcmUsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBhdHRyU3RyaW5nID0gW107XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGF0dHJTdHJpbmcucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyQmVmb3JlKX0gVE8gJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGBBTFRFUiBUQUJMRSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSBSRU5BTUUgQ09MVU1OICR7YXR0clN0cmluZy5qb2luKFwiLCBcIil9O2A7XG4gIH1cbiAgZm4oZm5OYW1lLCB0YWJsZU5hbWUsIHBhcmFtZXRlcnMsIGJvZHksIHJldHVybnMsIGxhbmd1YWdlKSB7XG4gICAgZm5OYW1lID0gZm5OYW1lIHx8IFwidGVzdGZ1bmNcIjtcbiAgICBsYW5ndWFnZSA9IGxhbmd1YWdlIHx8IFwicGxwZ3NxbFwiO1xuICAgIHJldHVybnMgPSByZXR1cm5zID8gYFJFVFVSTlMgJHtyZXR1cm5zfWAgOiBcIlwiO1xuICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IFwiXCI7XG4gICAgcmV0dXJuIGBDUkVBVEUgT1IgUkVQTEFDRSBGVU5DVElPTiBwZ190ZW1wLiR7Zm5OYW1lfSgke3BhcmFtZXRlcnN9KSAke3JldHVybnN9IEFTICRmdW5jJCBCRUdJTiAke2JvZHl9IEVORDsgJGZ1bmMkIExBTkdVQUdFICR7bGFuZ3VhZ2V9OyBTRUxFQ1QgKiBGUk9NIHBnX3RlbXAuJHtmbk5hbWV9KCk7YDtcbiAgfVxuICB0cnVuY2F0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgYFRSVU5DQVRFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9YCxcbiAgICAgIG9wdGlvbnMucmVzdGFydElkZW50aXR5ID8gXCIgUkVTVEFSVCBJREVOVElUWVwiIDogXCJcIixcbiAgICAgIG9wdGlvbnMuY2FzY2FkZSA/IFwiIENBU0NBREVcIiA6IFwiXCJcbiAgICBdLmpvaW4oXCJcIik7XG4gIH1cbiAgZGVsZXRlUXVlcnkodGFibGVOYW1lLCB3aGVyZSwgb3B0aW9ucyA9IHt9LCBtb2RlbCkge1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgbGV0IHdoZXJlQ2xhdXNlID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnMod2hlcmUsIG51bGwsIG1vZGVsLCBvcHRpb25zKTtcbiAgICBjb25zdCBsaW1pdCA9IG9wdGlvbnMubGltaXQgPyBgIExJTUlUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9YCA6IFwiXCI7XG4gICAgbGV0IHByaW1hcnlLZXlzID0gXCJcIjtcbiAgICBsZXQgcHJpbWFyeUtleXNTZWxlY3Rpb24gPSBcIlwiO1xuICAgIGlmICh3aGVyZUNsYXVzZSkge1xuICAgICAgd2hlcmVDbGF1c2UgPSBgIFdIRVJFICR7d2hlcmVDbGF1c2V9YDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGltaXQpIHtcbiAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IExJTUlUIGRlbGV0ZSB3aXRob3V0IGEgbW9kZWwuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGtzID0gT2JqZWN0LnZhbHVlcyhtb2RlbC5wcmltYXJ5S2V5cykubWFwKChwaykgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIocGsuZmllbGQpKS5qb2luKFwiLFwiKTtcbiAgICAgIHByaW1hcnlLZXlzID0gbW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZXMubGVuZ3RoID4gMSA/IGAoJHtwa3N9KWAgOiBwa3M7XG4gICAgICBwcmltYXJ5S2V5c1NlbGVjdGlvbiA9IHBrcztcbiAgICAgIHJldHVybiBgREVMRVRFIEZST00gJHt0YWJsZX0gV0hFUkUgJHtwcmltYXJ5S2V5c30gSU4gKFNFTEVDVCAke3ByaW1hcnlLZXlzU2VsZWN0aW9ufSBGUk9NICR7dGFibGV9JHt3aGVyZUNsYXVzZX0ke2xpbWl0fSlgO1xuICAgIH1cbiAgICByZXR1cm4gYERFTEVURSBGUk9NICR7dGFibGV9JHt3aGVyZUNsYXVzZX1gO1xuICB9XG4gIHNob3dJbmRleGVzUXVlcnkodGFibGVOYW1lKSB7XG4gICAgbGV0IHNjaGVtYUpvaW4gPSBcIlwiO1xuICAgIGxldCBzY2hlbWFXaGVyZSA9IFwiXCI7XG4gICAgaWYgKHR5cGVvZiB0YWJsZU5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHNjaGVtYUpvaW4gPSBcIiwgcGdfbmFtZXNwYWNlIHNcIjtcbiAgICAgIHNjaGVtYVdoZXJlID0gYCBBTkQgcy5vaWQgPSB0LnJlbG5hbWVzcGFjZSBBTkQgcy5uc3BuYW1lID0gJyR7dGFibGVOYW1lLnNjaGVtYX0nYDtcbiAgICAgIHRhYmxlTmFtZSA9IHRhYmxlTmFtZS50YWJsZU5hbWU7XG4gICAgfVxuICAgIHJldHVybiBgU0VMRUNUIGkucmVsbmFtZSBBUyBuYW1lLCBpeC5pbmRpc3ByaW1hcnkgQVMgcHJpbWFyeSwgaXguaW5kaXN1bmlxdWUgQVMgdW5pcXVlLCBpeC5pbmRrZXkgQVMgaW5ka2V5LCBhcnJheV9hZ2coYS5hdHRudW0pIGFzIGNvbHVtbl9pbmRleGVzLCBhcnJheV9hZ2coYS5hdHRuYW1lKSBBUyBjb2x1bW5fbmFtZXMsIHBnX2dldF9pbmRleGRlZihpeC5pbmRleHJlbGlkKSBBUyBkZWZpbml0aW9uIEZST00gcGdfY2xhc3MgdCwgcGdfY2xhc3MgaSwgcGdfaW5kZXggaXgsIHBnX2F0dHJpYnV0ZSBhJHtzY2hlbWFKb2lufSBXSEVSRSB0Lm9pZCA9IGl4LmluZHJlbGlkIEFORCBpLm9pZCA9IGl4LmluZGV4cmVsaWQgQU5EIGEuYXR0cmVsaWQgPSB0Lm9pZCBBTkQgdC5yZWxraW5kID0gJ3InIGFuZCB0LnJlbG5hbWUgPSAnJHt0YWJsZU5hbWV9JyR7c2NoZW1hV2hlcmV9IEdST1VQIEJZIGkucmVsbmFtZSwgaXguaW5kZXhyZWxpZCwgaXguaW5kaXNwcmltYXJ5LCBpeC5pbmRpc3VuaXF1ZSwgaXguaW5ka2V5IE9SREVSIEJZIGkucmVsbmFtZTtgO1xuICB9XG4gIHNob3dDb25zdHJhaW50c1F1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBbXG4gICAgICAnU0VMRUNUIGNvbnN0cmFpbnRfY2F0YWxvZyBBUyBcImNvbnN0cmFpbnRDYXRhbG9nXCIsJyxcbiAgICAgICdjb25zdHJhaW50X3NjaGVtYSBBUyBcImNvbnN0cmFpbnRTY2hlbWFcIiwnLFxuICAgICAgJ2NvbnN0cmFpbnRfbmFtZSBBUyBcImNvbnN0cmFpbnROYW1lXCIsJyxcbiAgICAgICd0YWJsZV9jYXRhbG9nIEFTIFwidGFibGVDYXRhbG9nXCIsJyxcbiAgICAgICd0YWJsZV9zY2hlbWEgQVMgXCJ0YWJsZVNjaGVtYVwiLCcsXG4gICAgICAndGFibGVfbmFtZSBBUyBcInRhYmxlTmFtZVwiLCcsXG4gICAgICAnY29uc3RyYWludF90eXBlIEFTIFwiY29uc3RyYWludFR5cGVcIiwnLFxuICAgICAgJ2lzX2RlZmVycmFibGUgQVMgXCJpc0RlZmVycmFibGVcIiwnLFxuICAgICAgJ2luaXRpYWxseV9kZWZlcnJlZCBBUyBcImluaXRpYWxseURlZmVycmVkXCInLFxuICAgICAgXCJmcm9tIElORk9STUFUSU9OX1NDSEVNQS50YWJsZV9jb25zdHJhaW50c1wiLFxuICAgICAgYFdIRVJFIHRhYmxlX25hbWU9JyR7dGFibGVOYW1lfSc7YFxuICAgIF0uam9pbihcIiBcIik7XG4gIH1cbiAgcmVtb3ZlSW5kZXhRdWVyeSh0YWJsZU5hbWUsIGluZGV4TmFtZU9yQXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIGxldCBpbmRleE5hbWUgPSBpbmRleE5hbWVPckF0dHJpYnV0ZXM7XG4gICAgaWYgKHR5cGVvZiBpbmRleE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGluZGV4TmFtZSA9IFV0aWxzLnVuZGVyc2NvcmUoYCR7dGFibGVOYW1lfV8ke2luZGV4TmFtZU9yQXR0cmlidXRlcy5qb2luKFwiX1wiKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiRFJPUCBJTkRFWFwiLFxuICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLmNvbmN1cnJlbnRseSAmJiBcIkNPTkNVUlJFTlRMWVwiLFxuICAgICAgYElGIEVYSVNUUyAke3RoaXMucXVvdGVJZGVudGlmaWVycyhpbmRleE5hbWUpfWBcbiAgICBdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbiAgfVxuICBhZGRMaW1pdEFuZE9mZnNldChvcHRpb25zKSB7XG4gICAgbGV0IGZyYWdtZW50ID0gXCJcIjtcbiAgICBpZiAob3B0aW9ucy5saW1pdCAhPSBudWxsKSB7XG4gICAgICBmcmFnbWVudCArPSBcIiBMSU1JVCBcIiArIHRoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5vZmZzZXQgIT0gbnVsbCkge1xuICAgICAgZnJhZ21lbnQgKz0gXCIgT0ZGU0VUIFwiICsgdGhpcy5lc2NhcGUob3B0aW9ucy5vZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cbiAgYXR0cmlidXRlVG9TUUwoYXR0cmlidXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFfLmlzUGxhaW5PYmplY3QoYXR0cmlidXRlKSkge1xuICAgICAgYXR0cmlidXRlID0ge1xuICAgICAgICB0eXBlOiBhdHRyaWJ1dGVcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCB0eXBlO1xuICAgIGlmIChhdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNIHx8IGF0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkFSUkFZICYmIGF0dHJpYnV0ZS50eXBlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSkge1xuICAgICAgY29uc3QgZW51bVR5cGUgPSBhdHRyaWJ1dGUudHlwZS50eXBlIHx8IGF0dHJpYnV0ZS50eXBlO1xuICAgICAgbGV0IHZhbHVlcyA9IGF0dHJpYnV0ZS52YWx1ZXM7XG4gICAgICBpZiAoZW51bVR5cGUudmFsdWVzICYmICFhdHRyaWJ1dGUudmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcyA9IGVudW1UeXBlLnZhbHVlcztcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykgJiYgdmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHlwZSA9IGBFTlVNKCR7dmFsdWVzLm1hcCgodmFsdWUpID0+IHRoaXMuZXNjYXBlKHZhbHVlKSkuam9pbihcIiwgXCIpfSlgO1xuICAgICAgICBpZiAoYXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQVJSQVkpIHtcbiAgICAgICAgICB0eXBlICs9IFwiW11cIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsdWVzIGZvciBFTlVNIGhhdmVuJ3QgYmVlbiBkZWZpbmVkLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0eXBlID0gYXR0cmlidXRlLnR5cGU7XG4gICAgfVxuICAgIGxldCBzcWwgPSB0eXBlLnRvU3RyaW5nKCk7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGUsIFwiYWxsb3dOdWxsXCIpICYmICFhdHRyaWJ1dGUuYWxsb3dOdWxsKSB7XG4gICAgICBzcWwgKz0gXCIgTk9UIE5VTExcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5hdXRvSW5jcmVtZW50KSB7XG4gICAgICBpZiAoYXR0cmlidXRlLmF1dG9JbmNyZW1lbnRJZGVudGl0eSkge1xuICAgICAgICBzcWwgKz0gXCIgR0VORVJBVEVEIEJZIERFRkFVTFQgQVMgSURFTlRJVFlcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNxbCArPSBcIiBTRVJJQUxcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKFV0aWxzLmRlZmF1bHRWYWx1ZVNjaGVtYWJsZShhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlKSkge1xuICAgICAgc3FsICs9IGAgREVGQVVMVCAke3RoaXMuZXNjYXBlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUsIGF0dHJpYnV0ZSl9YDtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS51bmlxdWUgPT09IHRydWUpIHtcbiAgICAgIHNxbCArPSBcIiBVTklRVUVcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5wcmltYXJ5S2V5KSB7XG4gICAgICBzcWwgKz0gXCIgUFJJTUFSWSBLRVlcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzKSB7XG4gICAgICBsZXQgcmVmZXJlbmNlc1RhYmxlID0gdGhpcy5xdW90ZVRhYmxlKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsKTtcbiAgICAgIGxldCBzY2hlbWE7XG4gICAgICBpZiAob3B0aW9ucy5zY2hlbWEpIHtcbiAgICAgICAgc2NoZW1hID0gb3B0aW9ucy5zY2hlbWE7XG4gICAgICB9IGVsc2UgaWYgKCghYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwgfHwgdHlwZW9mIGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsID09IFwic3RyaW5nXCIpICYmIG9wdGlvbnMudGFibGUgJiYgb3B0aW9ucy50YWJsZS5zY2hlbWEpIHtcbiAgICAgICAgc2NoZW1hID0gb3B0aW9ucy50YWJsZS5zY2hlbWE7XG4gICAgICB9XG4gICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgIHJlZmVyZW5jZXNUYWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0aGlzLmFkZFNjaGVtYSh7XG4gICAgICAgICAgdGFibGVOYW1lOiByZWZlcmVuY2VzVGFibGUsXG4gICAgICAgICAgX3NjaGVtYTogc2NoZW1hXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGxldCByZWZlcmVuY2VzS2V5O1xuICAgICAgaWYgKCFvcHRpb25zLndpdGhvdXRGb3JlaWduS2V5Q29uc3RyYWludHMpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLmtleSkge1xuICAgICAgICAgIHJlZmVyZW5jZXNLZXkgPSB0aGlzLnF1b3RlSWRlbnRpZmllcnMoYXR0cmlidXRlLnJlZmVyZW5jZXMua2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZlcmVuY2VzS2V5ID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoXCJpZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBzcWwgKz0gYCBSRUZFUkVOQ0VTICR7cmVmZXJlbmNlc1RhYmxlfSAoJHtyZWZlcmVuY2VzS2V5fSlgO1xuICAgICAgICBpZiAoYXR0cmlidXRlLm9uRGVsZXRlKSB7XG4gICAgICAgICAgc3FsICs9IGAgT04gREVMRVRFICR7YXR0cmlidXRlLm9uRGVsZXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlLm9uVXBkYXRlKSB7XG4gICAgICAgICAgc3FsICs9IGAgT04gVVBEQVRFICR7YXR0cmlidXRlLm9uVXBkYXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMuZGVmZXJyYWJsZSkge1xuICAgICAgICAgIHNxbCArPSBgICR7YXR0cmlidXRlLnJlZmVyZW5jZXMuZGVmZXJyYWJsZS50b1N0cmluZyh0aGlzKX1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUuY29tbWVudCAmJiB0eXBlb2YgYXR0cmlidXRlLmNvbW1lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChvcHRpb25zICYmIFtcImFkZENvbHVtblwiLCBcImNoYW5nZUNvbHVtblwiXS5pbmNsdWRlcyhvcHRpb25zLmNvbnRleHQpKSB7XG4gICAgICAgIGNvbnN0IHF1b3RlZEF0dHIgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLmtleSk7XG4gICAgICAgIGNvbnN0IGVzY2FwZWRDb21tZW50VGV4dCA9IHRoaXMuZXNjYXBlKGF0dHJpYnV0ZS5jb21tZW50KTtcbiAgICAgICAgc3FsICs9IGA7IENPTU1FTlQgT04gQ09MVU1OICR7dGhpcy5xdW90ZVRhYmxlKG9wdGlvbnMudGFibGUpfS4ke3F1b3RlZEF0dHJ9IElTICR7ZXNjYXBlZENvbW1lbnRUZXh0fWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcWwgKz0gYCBDT01NRU5UICR7YXR0cmlidXRlLmNvbW1lbnR9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNxbDtcbiAgfVxuICBkZWZlckNvbnN0cmFpbnRzUXVlcnkob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmRlZmVycmFibGUudG9TdHJpbmcodGhpcyk7XG4gIH1cbiAgc2V0Q29uc3RyYWludFF1ZXJ5KGNvbHVtbnMsIHR5cGUpIHtcbiAgICBsZXQgY29sdW1uRnJhZ21lbnQgPSBcIkFMTFwiO1xuICAgIGlmIChjb2x1bW5zKSB7XG4gICAgICBjb2x1bW5GcmFnbWVudCA9IGNvbHVtbnMubWFwKChjb2x1bW4pID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGNvbHVtbikpLmpvaW4oXCIsIFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGBTRVQgQ09OU1RSQUlOVFMgJHtjb2x1bW5GcmFnbWVudH0gJHt0eXBlfWA7XG4gIH1cbiAgc2V0RGVmZXJyZWRRdWVyeShjb2x1bW5zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0Q29uc3RyYWludFF1ZXJ5KGNvbHVtbnMsIFwiREVGRVJSRURcIik7XG4gIH1cbiAgc2V0SW1tZWRpYXRlUXVlcnkoY29sdW1ucykge1xuICAgIHJldHVybiB0aGlzLnNldENvbnN0cmFpbnRRdWVyeShjb2x1bW5zLCBcIklNTUVESUFURVwiKTtcbiAgfVxuICBhdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgIHJlc3VsdFthdHRyaWJ1dGUuZmllbGQgfHwga2V5XSA9IHRoaXMuYXR0cmlidXRlVG9TUUwoYXR0cmlidXRlLCBfX3NwcmVhZFZhbHVlcyh7IGtleSB9LCBvcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY3JlYXRlVHJpZ2dlcih0YWJsZU5hbWUsIHRyaWdnZXJOYW1lLCBldmVudFR5cGUsIGZpcmVPblNwZWMsIGZ1bmN0aW9uTmFtZSwgZnVuY3Rpb25QYXJhbXMsIG9wdGlvbnNBcnJheSkge1xuICAgIGNvbnN0IGRlY29kZWRFdmVudFR5cGUgPSB0aGlzLmRlY29kZVRyaWdnZXJFdmVudFR5cGUoZXZlbnRUeXBlKTtcbiAgICBjb25zdCBldmVudFNwZWMgPSB0aGlzLmV4cGFuZFRyaWdnZXJFdmVudFNwZWMoZmlyZU9uU3BlYyk7XG4gICAgY29uc3QgZXhwYW5kZWRPcHRpb25zID0gdGhpcy5leHBhbmRPcHRpb25zKG9wdGlvbnNBcnJheSk7XG4gICAgY29uc3QgcGFyYW1MaXN0ID0gdGhpcy5fZXhwYW5kRnVuY3Rpb25QYXJhbUxpc3QoZnVuY3Rpb25QYXJhbXMpO1xuICAgIHJldHVybiBgQ1JFQVRFICR7dGhpcy50cmlnZ2VyRXZlbnRUeXBlSXNDb25zdHJhaW50KGV2ZW50VHlwZSl9VFJJR0dFUiAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRyaWdnZXJOYW1lKX0gJHtkZWNvZGVkRXZlbnRUeXBlfSAke2V2ZW50U3BlY30gT04gJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0ke2V4cGFuZGVkT3B0aW9ucyA/IGAgJHtleHBhbmRlZE9wdGlvbnN9YCA6IFwiXCJ9IEVYRUNVVEUgUFJPQ0VEVVJFICR7ZnVuY3Rpb25OYW1lfSgke3BhcmFtTGlzdH0pO2A7XG4gIH1cbiAgZHJvcFRyaWdnZXIodGFibGVOYW1lLCB0cmlnZ2VyTmFtZSkge1xuICAgIHJldHVybiBgRFJPUCBUUklHR0VSICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodHJpZ2dlck5hbWUpfSBPTiAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSBSRVNUUklDVDtgO1xuICB9XG4gIHJlbmFtZVRyaWdnZXIodGFibGVOYW1lLCBvbGRUcmlnZ2VyTmFtZSwgbmV3VHJpZ2dlck5hbWUpIHtcbiAgICByZXR1cm4gYEFMVEVSIFRSSUdHRVIgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihvbGRUcmlnZ2VyTmFtZSl9IE9OICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9IFJFTkFNRSBUTyAke3RoaXMucXVvdGVJZGVudGlmaWVyKG5ld1RyaWdnZXJOYW1lKX07YDtcbiAgfVxuICBjcmVhdGVGdW5jdGlvbihmdW5jdGlvbk5hbWUsIHBhcmFtcywgcmV0dXJuVHlwZSwgbGFuZ3VhZ2UsIGJvZHksIG9wdGlvbnNBcnJheSwgb3B0aW9ucykge1xuICAgIGlmICghZnVuY3Rpb25OYW1lIHx8ICFyZXR1cm5UeXBlIHx8ICFsYW5ndWFnZSB8fCAhYm9keSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNyZWF0ZUZ1bmN0aW9uIG1pc3Npbmcgc29tZSBwYXJhbWV0ZXJzLiBEaWQgeW91IHBhc3MgZnVuY3Rpb25OYW1lLCByZXR1cm5UeXBlLCBsYW5ndWFnZSBhbmQgYm9keT9cIik7XG4gICAgY29uc3QgcGFyYW1MaXN0ID0gdGhpcy5fZXhwYW5kRnVuY3Rpb25QYXJhbUxpc3QocGFyYW1zKTtcbiAgICBjb25zdCB2YXJpYWJsZUxpc3QgPSBvcHRpb25zICYmIG9wdGlvbnMudmFyaWFibGVzID8gdGhpcy5fZXhwYW5kRnVuY3Rpb25WYXJpYWJsZUxpc3Qob3B0aW9ucy52YXJpYWJsZXMpIDogXCJcIjtcbiAgICBjb25zdCBleHBhbmRlZE9wdGlvbnNBcnJheSA9IHRoaXMuZXhwYW5kT3B0aW9ucyhvcHRpb25zQXJyYXkpO1xuICAgIGNvbnN0IHN0YXRlbWVudCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5mb3JjZSA/IFwiQ1JFQVRFIE9SIFJFUExBQ0UgRlVOQ1RJT05cIiA6IFwiQ1JFQVRFIEZVTkNUSU9OXCI7XG4gICAgcmV0dXJuIGAke3N0YXRlbWVudH0gJHtmdW5jdGlvbk5hbWV9KCR7cGFyYW1MaXN0fSkgUkVUVVJOUyAke3JldHVyblR5cGV9IEFTICRmdW5jJCAke3ZhcmlhYmxlTGlzdH0gQkVHSU4gJHtib2R5fSBFTkQ7ICRmdW5jJCBsYW5ndWFnZSAnJHtsYW5ndWFnZX0nJHtleHBhbmRlZE9wdGlvbnNBcnJheX07YDtcbiAgfVxuICBkcm9wRnVuY3Rpb24oZnVuY3Rpb25OYW1lLCBwYXJhbXMpIHtcbiAgICBpZiAoIWZ1bmN0aW9uTmFtZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInJlcXVpcmVzIGZ1bmN0aW9uTmFtZVwiKTtcbiAgICBjb25zdCBwYXJhbUxpc3QgPSB0aGlzLl9leHBhbmRGdW5jdGlvblBhcmFtTGlzdChwYXJhbXMpO1xuICAgIHJldHVybiBgRFJPUCBGVU5DVElPTiAke2Z1bmN0aW9uTmFtZX0oJHtwYXJhbUxpc3R9KSBSRVNUUklDVDtgO1xuICB9XG4gIHJlbmFtZUZ1bmN0aW9uKG9sZEZ1bmN0aW9uTmFtZSwgcGFyYW1zLCBuZXdGdW5jdGlvbk5hbWUpIHtcbiAgICBjb25zdCBwYXJhbUxpc3QgPSB0aGlzLl9leHBhbmRGdW5jdGlvblBhcmFtTGlzdChwYXJhbXMpO1xuICAgIHJldHVybiBgQUxURVIgRlVOQ1RJT04gJHtvbGRGdW5jdGlvbk5hbWV9KCR7cGFyYW1MaXN0fSkgUkVOQU1FIFRPICR7bmV3RnVuY3Rpb25OYW1lfTtgO1xuICB9XG4gIHBnRXNjYXBlQW5kUXVvdGUodmFsKSB7XG4gICAgcmV0dXJuIHRoaXMucXVvdGVJZGVudGlmaWVyKFV0aWxzLnJlbW92ZVRpY2tzKHRoaXMuZXNjYXBlKHZhbCksIFwiJ1wiKSk7XG4gIH1cbiAgX2V4cGFuZEZ1bmN0aW9uUGFyYW1MaXN0KHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMgPT09IHZvaWQgMCB8fCAhQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfZXhwYW5kRnVuY3Rpb25QYXJhbUxpc3Q6IGZ1bmN0aW9uIHBhcmFtZXRlcnMgYXJyYXkgcmVxdWlyZWQsIGluY2x1ZGluZyBhbiBlbXB0eSBvbmUgZm9yIG5vIGFyZ3VtZW50c1wiKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1MaXN0ID0gW107XG4gICAgcGFyYW1zLmZvckVhY2goKGN1clBhcmFtKSA9PiB7XG4gICAgICBjb25zdCBwYXJhbURlZiA9IFtdO1xuICAgICAgaWYgKGN1clBhcmFtLnR5cGUpIHtcbiAgICAgICAgaWYgKGN1clBhcmFtLmRpcmVjdGlvbikge1xuICAgICAgICAgIHBhcmFtRGVmLnB1c2goY3VyUGFyYW0uZGlyZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyUGFyYW0ubmFtZSkge1xuICAgICAgICAgIHBhcmFtRGVmLnB1c2goY3VyUGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1EZWYucHVzaChjdXJQYXJhbS50eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZ1bmN0aW9uIG9yIHRyaWdnZXIgdXNlZCB3aXRoIGEgcGFyYW1ldGVyIHdpdGhvdXQgYW55IHR5cGVcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBqb2luZWQgPSBwYXJhbURlZi5qb2luKFwiIFwiKTtcbiAgICAgIGlmIChqb2luZWQpXG4gICAgICAgIHBhcmFtTGlzdC5wdXNoKGpvaW5lZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcmFtTGlzdC5qb2luKFwiLCBcIik7XG4gIH1cbiAgX2V4cGFuZEZ1bmN0aW9uVmFyaWFibGVMaXN0KHZhcmlhYmxlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YXJpYWJsZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfZXhwYW5kRnVuY3Rpb25WYXJpYWJsZUxpc3Q6IGZ1bmN0aW9uIHZhcmlhYmxlcyBtdXN0IGJlIGFuIGFycmF5XCIpO1xuICAgIH1cbiAgICBjb25zdCB2YXJpYWJsZURlZmluaXRpb25zID0gW107XG4gICAgdmFyaWFibGVzLmZvckVhY2goKHZhcmlhYmxlKSA9PiB7XG4gICAgICBpZiAoIXZhcmlhYmxlLm5hbWUgfHwgIXZhcmlhYmxlLnR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZnVuY3Rpb24gdmFyaWFibGUgbXVzdCBoYXZlIGEgbmFtZSBhbmQgdHlwZVwiKTtcbiAgICAgIH1cbiAgICAgIGxldCB2YXJpYWJsZURlZmluaXRpb24gPSBgREVDTEFSRSAke3ZhcmlhYmxlLm5hbWV9ICR7dmFyaWFibGUudHlwZX1gO1xuICAgICAgaWYgKHZhcmlhYmxlLmRlZmF1bHQpIHtcbiAgICAgICAgdmFyaWFibGVEZWZpbml0aW9uICs9IGAgOj0gJHt2YXJpYWJsZS5kZWZhdWx0fWA7XG4gICAgICB9XG4gICAgICB2YXJpYWJsZURlZmluaXRpb24gKz0gXCI7XCI7XG4gICAgICB2YXJpYWJsZURlZmluaXRpb25zLnB1c2godmFyaWFibGVEZWZpbml0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdmFyaWFibGVEZWZpbml0aW9ucy5qb2luKFwiIFwiKTtcbiAgfVxuICBleHBhbmRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyA9PT0gdm9pZCAwIHx8IF8uaXNFbXB0eShvcHRpb25zKSA/IFwiXCIgOiBvcHRpb25zLmpvaW4oXCIgXCIpO1xuICB9XG4gIGRlY29kZVRyaWdnZXJFdmVudFR5cGUoZXZlbnRTcGVjaWZpZXIpIHtcbiAgICBjb25zdCBFVkVOVF9ERUNPREVSID0ge1xuICAgICAgXCJhZnRlclwiOiBcIkFGVEVSXCIsXG4gICAgICBcImJlZm9yZVwiOiBcIkJFRk9SRVwiLFxuICAgICAgXCJpbnN0ZWFkX29mXCI6IFwiSU5TVEVBRCBPRlwiLFxuICAgICAgXCJhZnRlcl9jb25zdHJhaW50XCI6IFwiQUZURVJcIlxuICAgIH07XG4gICAgaWYgKCFFVkVOVF9ERUNPREVSW2V2ZW50U3BlY2lmaWVyXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRyaWdnZXIgZXZlbnQgc3BlY2lmaWVkOiAke2V2ZW50U3BlY2lmaWVyfWApO1xuICAgIH1cbiAgICByZXR1cm4gRVZFTlRfREVDT0RFUltldmVudFNwZWNpZmllcl07XG4gIH1cbiAgdHJpZ2dlckV2ZW50VHlwZUlzQ29uc3RyYWludChldmVudFNwZWNpZmllcikge1xuICAgIHJldHVybiBldmVudFNwZWNpZmllciA9PT0gXCJhZnRlcl9jb25zdHJhaW50XCIgPyBcIkNPTlNUUkFJTlQgXCIgOiBcIlwiO1xuICB9XG4gIGV4cGFuZFRyaWdnZXJFdmVudFNwZWMoZmlyZU9uU3BlYykge1xuICAgIGlmIChfLmlzRW1wdHkoZmlyZU9uU3BlYykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIHRhYmxlIGNoYW5nZSBldmVudHMgc3BlY2lmaWVkIHRvIHRyaWdnZXIgb25cIik7XG4gICAgfVxuICAgIHJldHVybiBfLm1hcChmaXJlT25TcGVjLCAoZmlyZVZhbHVlLCBmaXJlS2V5KSA9PiB7XG4gICAgICBjb25zdCBFVkVOVF9NQVAgPSB7XG4gICAgICAgIFwiaW5zZXJ0XCI6IFwiSU5TRVJUXCIsXG4gICAgICAgIFwidXBkYXRlXCI6IFwiVVBEQVRFXCIsXG4gICAgICAgIFwiZGVsZXRlXCI6IFwiREVMRVRFXCIsXG4gICAgICAgIFwidHJ1bmNhdGVcIjogXCJUUlVOQ0FURVwiXG4gICAgICB9O1xuICAgICAgaWYgKCFFVkVOVF9NQVBbZmlyZVZhbHVlXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcnNlVHJpZ2dlckV2ZW50U3BlYzogdW5kZWZpbmVkIHRyaWdnZXIgZXZlbnQgJHtmaXJlS2V5fWApO1xuICAgICAgfVxuICAgICAgbGV0IGV2ZW50U3BlYyA9IEVWRU5UX01BUFtmaXJlVmFsdWVdO1xuICAgICAgaWYgKGV2ZW50U3BlYyA9PT0gXCJVUERBVEVcIikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaXJlVmFsdWUpICYmIGZpcmVWYWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZXZlbnRTcGVjICs9IGAgT0YgJHtmaXJlVmFsdWUuam9pbihcIiwgXCIpfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBldmVudFNwZWM7XG4gICAgfSkuam9pbihcIiBPUiBcIik7XG4gIH1cbiAgcGdFbnVtTmFtZSh0YWJsZU5hbWUsIGF0dHIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCB0YWJsZURldGFpbHMgPSB0aGlzLmV4dHJhY3RUYWJsZURldGFpbHModGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICBsZXQgZW51bU5hbWUgPSBVdGlscy5hZGRUaWNrcyhVdGlscy5nZW5lcmF0ZUVudW1OYW1lKHRhYmxlRGV0YWlscy50YWJsZU5hbWUsIGF0dHIpLCAnXCInKTtcbiAgICBpZiAob3B0aW9ucy5zY2hlbWEgIT09IGZhbHNlICYmIHRhYmxlRGV0YWlscy5zY2hlbWEpIHtcbiAgICAgIGVudW1OYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIodGFibGVEZXRhaWxzLnNjaGVtYSkgKyB0YWJsZURldGFpbHMuZGVsaW1pdGVyICsgZW51bU5hbWU7XG4gICAgfVxuICAgIHJldHVybiBlbnVtTmFtZTtcbiAgfVxuICBwZ0xpc3RFbnVtcyh0YWJsZU5hbWUsIGF0dHJOYW1lLCBvcHRpb25zKSB7XG4gICAgbGV0IGVudW1OYW1lID0gXCJcIjtcbiAgICBjb25zdCB0YWJsZURldGFpbHMgPSB0aGlzLmV4dHJhY3RUYWJsZURldGFpbHModGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICBpZiAodGFibGVEZXRhaWxzLnRhYmxlTmFtZSAmJiBhdHRyTmFtZSkge1xuICAgICAgZW51bU5hbWUgPSBgIEFORCB0LnR5cG5hbWU9JHt0aGlzLnBnRW51bU5hbWUodGFibGVEZXRhaWxzLnRhYmxlTmFtZSwgYXR0ck5hbWUsIHsgc2NoZW1hOiBmYWxzZSB9KS5yZXBsYWNlKC9cIi9nLCBcIidcIil9YDtcbiAgICB9XG4gICAgcmV0dXJuIGBTRUxFQ1QgdC50eXBuYW1lIGVudW1fbmFtZSwgYXJyYXlfYWdnKGUuZW51bWxhYmVsIE9SREVSIEJZIGVudW1zb3J0b3JkZXIpIGVudW1fdmFsdWUgRlJPTSBwZ190eXBlIHQgSk9JTiBwZ19lbnVtIGUgT04gdC5vaWQgPSBlLmVudW10eXBpZCBKT0lOIHBnX2NhdGFsb2cucGdfbmFtZXNwYWNlIG4gT04gbi5vaWQgPSB0LnR5cG5hbWVzcGFjZSBXSEVSRSBuLm5zcG5hbWUgPSAnJHt0YWJsZURldGFpbHMuc2NoZW1hfScke2VudW1OYW1lfSBHUk9VUCBCWSAxYDtcbiAgfVxuICBwZ0VudW0odGFibGVOYW1lLCBhdHRyLCBkYXRhVHlwZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGVudW1OYW1lID0gdGhpcy5wZ0VudW1OYW1lKHRhYmxlTmFtZSwgYXR0ciwgb3B0aW9ucyk7XG4gICAgbGV0IHZhbHVlcztcbiAgICBpZiAoZGF0YVR5cGUudmFsdWVzKSB7XG4gICAgICB2YWx1ZXMgPSBgRU5VTSgke2RhdGFUeXBlLnZhbHVlcy5tYXAoKHZhbHVlKSA9PiB0aGlzLmVzY2FwZSh2YWx1ZSkpLmpvaW4oXCIsIFwiKX0pYDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzID0gZGF0YVR5cGUudG9TdHJpbmcoKS5tYXRjaCgvXkVOVU1cXCguK1xcKS8pWzBdO1xuICAgIH1cbiAgICBsZXQgc3FsID0gYERPICR7dGhpcy5lc2NhcGUoYEJFR0lOIENSRUFURSBUWVBFICR7ZW51bU5hbWV9IEFTICR7dmFsdWVzfTsgRVhDRVBUSU9OIFdIRU4gZHVwbGljYXRlX29iamVjdCBUSEVOIG51bGw7IEVORGApfTtgO1xuICAgIGlmICghIW9wdGlvbnMgJiYgb3B0aW9ucy5mb3JjZSA9PT0gdHJ1ZSkge1xuICAgICAgc3FsID0gdGhpcy5wZ0VudW1Ecm9wKHRhYmxlTmFtZSwgYXR0cikgKyBzcWw7XG4gICAgfVxuICAgIHJldHVybiBzcWw7XG4gIH1cbiAgcGdFbnVtQWRkKHRhYmxlTmFtZSwgYXR0ciwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBlbnVtTmFtZSA9IHRoaXMucGdFbnVtTmFtZSh0YWJsZU5hbWUsIGF0dHIpO1xuICAgIGxldCBzcWwgPSBgQUxURVIgVFlQRSAke2VudW1OYW1lfSBBREQgVkFMVUUgYDtcbiAgICBpZiAoc2VtdmVyLmd0ZSh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbiwgXCI5LjMuMFwiKSkge1xuICAgICAgc3FsICs9IFwiSUYgTk9UIEVYSVNUUyBcIjtcbiAgICB9XG4gICAgc3FsICs9IHRoaXMuZXNjYXBlKHZhbHVlKTtcbiAgICBpZiAob3B0aW9ucy5iZWZvcmUpIHtcbiAgICAgIHNxbCArPSBgIEJFRk9SRSAke3RoaXMuZXNjYXBlKG9wdGlvbnMuYmVmb3JlKX1gO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5hZnRlcikge1xuICAgICAgc3FsICs9IGAgQUZURVIgJHt0aGlzLmVzY2FwZShvcHRpb25zLmFmdGVyKX1gO1xuICAgIH1cbiAgICByZXR1cm4gc3FsO1xuICB9XG4gIHBnRW51bURyb3AodGFibGVOYW1lLCBhdHRyLCBlbnVtTmFtZSkge1xuICAgIGVudW1OYW1lID0gZW51bU5hbWUgfHwgdGhpcy5wZ0VudW1OYW1lKHRhYmxlTmFtZSwgYXR0cik7XG4gICAgcmV0dXJuIGBEUk9QIFRZUEUgSUYgRVhJU1RTICR7ZW51bU5hbWV9OyBgO1xuICB9XG4gIGZyb21BcnJheSh0ZXh0KSB7XG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXnsvLCBcIlwiKS5yZXBsYWNlKC99JC8sIFwiXCIpO1xuICAgIGxldCBtYXRjaGVzID0gdGV4dC5tYXRjaCgvKFwiKD86XFxcXC58W15cIlxcXFxcXFxcXSkqXCJ8W14sXSopKD86XFxzKixcXHMqfFxccyokKS9pZyk7XG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoIDwgMSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBtYXRjaGVzID0gbWF0Y2hlcy5tYXAoKG0pID0+IG0ucmVwbGFjZSgvXCIsJC8sIFwiXCIpLnJlcGxhY2UoLywkLywgXCJcIikucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiXCIpKTtcbiAgICByZXR1cm4gbWF0Y2hlcy5zbGljZSgwLCAtMSk7XG4gIH1cbiAgZGF0YVR5cGVNYXBwaW5nKHRhYmxlTmFtZSwgYXR0ciwgZGF0YVR5cGUpIHtcbiAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJQUklNQVJZIEtFWVwiKSkge1xuICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKFwiUFJJTUFSWSBLRVlcIiwgXCJcIik7XG4gICAgfVxuICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIlNFUklBTFwiKSkge1xuICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiQklHSU5UXCIpKSB7XG4gICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZShcIlNFUklBTFwiLCBcIkJJR1NFUklBTFwiKTtcbiAgICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKFwiQklHSU5UXCIsIFwiXCIpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIlNNQUxMSU5UXCIpKSB7XG4gICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZShcIlNFUklBTFwiLCBcIlNNQUxMU0VSSUFMXCIpO1xuICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoXCJTTUFMTElOVFwiLCBcIlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZShcIklOVEVHRVJcIiwgXCJcIik7XG4gICAgICB9XG4gICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoXCJOT1QgTlVMTFwiLCBcIlwiKTtcbiAgICB9XG4gICAgaWYgKGRhdGFUeXBlLnN0YXJ0c1dpdGgoXCJFTlVNKFwiKSkge1xuICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKC9eRU5VTVxcKC4rXFwpLywgdGhpcy5wZ0VudW1OYW1lKHRhYmxlTmFtZSwgYXR0cikpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YVR5cGU7XG4gIH1cbiAgZ2V0Rm9yZWlnbktleXNRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gYFNFTEVDVCBjb25uYW1lIGFzIGNvbnN0cmFpbnRfbmFtZSwgcGdfY2F0YWxvZy5wZ19nZXRfY29uc3RyYWludGRlZihyLm9pZCwgdHJ1ZSkgYXMgY29uZGVmIEZST00gcGdfY2F0YWxvZy5wZ19jb25zdHJhaW50IHIgV0hFUkUgci5jb25yZWxpZCA9IChTRUxFQ1Qgb2lkIEZST00gcGdfY2xhc3MgV0hFUkUgcmVsbmFtZSA9ICcke3RhYmxlTmFtZX0nIExJTUlUIDEpIEFORCByLmNvbnR5cGUgPSAnZicgT1JERVIgQlkgMTtgO1xuICB9XG4gIF9nZXRGb3JlaWduS2V5UmVmZXJlbmNlc1F1ZXJ5UHJlZml4KCkge1xuICAgIHJldHVybiBcIlNFTEVDVCBESVNUSU5DVCB0Yy5jb25zdHJhaW50X25hbWUgYXMgY29uc3RyYWludF9uYW1lLCB0Yy5jb25zdHJhaW50X3NjaGVtYSBhcyBjb25zdHJhaW50X3NjaGVtYSwgdGMuY29uc3RyYWludF9jYXRhbG9nIGFzIGNvbnN0cmFpbnRfY2F0YWxvZywgdGMudGFibGVfbmFtZSBhcyB0YWJsZV9uYW1lLHRjLnRhYmxlX3NjaGVtYSBhcyB0YWJsZV9zY2hlbWEsdGMudGFibGVfY2F0YWxvZyBhcyB0YWJsZV9jYXRhbG9nLHRjLmluaXRpYWxseV9kZWZlcnJlZCBhcyBpbml0aWFsbHlfZGVmZXJyZWQsdGMuaXNfZGVmZXJyYWJsZSBhcyBpc19kZWZlcnJhYmxlLGtjdS5jb2x1bW5fbmFtZSBhcyBjb2x1bW5fbmFtZSxjY3UudGFibGVfc2NoZW1hICBBUyByZWZlcmVuY2VkX3RhYmxlX3NjaGVtYSxjY3UudGFibGVfY2F0YWxvZyAgQVMgcmVmZXJlbmNlZF90YWJsZV9jYXRhbG9nLGNjdS50YWJsZV9uYW1lICBBUyByZWZlcmVuY2VkX3RhYmxlX25hbWUsY2N1LmNvbHVtbl9uYW1lIEFTIHJlZmVyZW5jZWRfY29sdW1uX25hbWUgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVfY29uc3RyYWludHMgQVMgdGMgSk9JTiBpbmZvcm1hdGlvbl9zY2hlbWEua2V5X2NvbHVtbl91c2FnZSBBUyBrY3UgT04gdGMuY29uc3RyYWludF9uYW1lID0ga2N1LmNvbnN0cmFpbnRfbmFtZSBKT0lOIGluZm9ybWF0aW9uX3NjaGVtYS5jb25zdHJhaW50X2NvbHVtbl91c2FnZSBBUyBjY3UgT04gY2N1LmNvbnN0cmFpbnRfbmFtZSA9IHRjLmNvbnN0cmFpbnRfbmFtZSBcIjtcbiAgfVxuICBnZXRGb3JlaWduS2V5UmVmZXJlbmNlc1F1ZXJ5KHRhYmxlTmFtZSwgY2F0YWxvZ05hbWUsIHNjaGVtYU5hbWUpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5fZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNRdWVyeVByZWZpeCgpfVdIRVJFIGNvbnN0cmFpbnRfdHlwZSA9ICdGT1JFSUdOIEtFWScgQU5EIHRjLnRhYmxlX25hbWUgPSAnJHt0YWJsZU5hbWV9JyR7Y2F0YWxvZ05hbWUgPyBgIEFORCB0Yy50YWJsZV9jYXRhbG9nID0gJyR7Y2F0YWxvZ05hbWV9J2AgOiBcIlwifSR7c2NoZW1hTmFtZSA/IGAgQU5EIHRjLnRhYmxlX3NjaGVtYSA9ICcke3NjaGVtYU5hbWV9J2AgOiBcIlwifWA7XG4gIH1cbiAgZ2V0Rm9yZWlnbktleVJlZmVyZW5jZVF1ZXJ5KHRhYmxlLCBjb2x1bW5OYW1lKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGFibGUudGFibGVOYW1lIHx8IHRhYmxlO1xuICAgIGNvbnN0IHNjaGVtYSA9IHRhYmxlLnNjaGVtYTtcbiAgICByZXR1cm4gYCR7dGhpcy5fZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNRdWVyeVByZWZpeCgpfVdIRVJFIGNvbnN0cmFpbnRfdHlwZSA9ICdGT1JFSUdOIEtFWScgQU5EIHRjLnRhYmxlX25hbWU9JyR7dGFibGVOYW1lfScgQU5EICBrY3UuY29sdW1uX25hbWUgPSAnJHtjb2x1bW5OYW1lfScke3NjaGVtYSA/IGAgQU5EIHRjLnRhYmxlX3NjaGVtYSA9ICcke3NjaGVtYX0nYCA6IFwiXCJ9YDtcbiAgfVxuICBkcm9wRm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZSwgZm9yZWlnbktleSkge1xuICAgIHJldHVybiBgQUxURVIgVEFCTEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gRFJPUCBDT05TVFJBSU5UICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoZm9yZWlnbktleSl9O2A7XG4gIH1cbiAgcXVvdGVJZGVudGlmaWVyKGlkZW50aWZpZXIsIGZvcmNlKSB7XG4gICAgY29uc3Qgb3B0Rm9yY2VRdW90ZSA9IGZvcmNlIHx8IGZhbHNlO1xuICAgIGNvbnN0IG9wdFF1b3RlSWRlbnRpZmllcnMgPSB0aGlzLm9wdGlvbnMucXVvdGVJZGVudGlmaWVycyAhPT0gZmFsc2U7XG4gICAgY29uc3QgcmF3SWRlbnRpZmllciA9IFV0aWxzLnJlbW92ZVRpY2tzKGlkZW50aWZpZXIsICdcIicpO1xuICAgIGlmIChvcHRGb3JjZVF1b3RlID09PSB0cnVlIHx8IG9wdFF1b3RlSWRlbnRpZmllcnMgIT09IGZhbHNlIHx8IGlkZW50aWZpZXIuaW5jbHVkZXMoXCIuXCIpIHx8IGlkZW50aWZpZXIuaW5jbHVkZXMoXCItPlwiKSB8fCBQT1NUR1JFU19SRVNFUlZFRF9XT1JEUy5pbmNsdWRlcyhyYXdJZGVudGlmaWVyLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICByZXR1cm4gVXRpbHMuYWRkVGlja3MocmF3SWRlbnRpZmllciwgJ1wiJyk7XG4gICAgfVxuICAgIHJldHVybiByYXdJZGVudGlmaWVyO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFBvc3RncmVzUXVlcnlHZW5lcmF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS1nZW5lcmF0b3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/postgres/query-generator.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/postgres/query-interface.js":
/*!**************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/postgres/query-interface.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(action-browser)/../node_modules/sequelize/lib/query-types.js\");\nconst { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst Deferrable = __webpack_require__(/*! ../../deferrable */ \"(action-browser)/../node_modules/sequelize/lib/deferrable.js\");\nclass PostgresQueryInterface extends QueryInterface {\n  async ensureEnums(tableName, attributes, options, model) {\n    const keys = Object.keys(attributes);\n    const keyLen = keys.length;\n    let sql = \"\";\n    let promises = [];\n    let i = 0;\n    for (i = 0; i < keyLen; i++) {\n      const attribute = attributes[keys[i]];\n      const type = attribute.type;\n      if (type instanceof DataTypes.ENUM || type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM) {\n        sql = this.queryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);\n        promises.push(this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { plain: true, raw: true, type: QueryTypes.SELECT })));\n      }\n    }\n    const results = await Promise.all(promises);\n    promises = [];\n    let enumIdx = 0;\n    const addEnumValue = (field, value, relativeValue, position = \"before\", spliceStart = promises.length) => {\n      const valueOptions = __spreadValues({}, options);\n      valueOptions.before = null;\n      valueOptions.after = null;\n      switch (position) {\n        case \"after\":\n          valueOptions.after = relativeValue;\n          break;\n        case \"before\":\n        default:\n          valueOptions.before = relativeValue;\n          break;\n      }\n      promises.splice(spliceStart, 0, () => {\n        return this.sequelize.query(this.queryGenerator.pgEnumAdd(tableName, field, value, valueOptions), valueOptions);\n      });\n    };\n    for (i = 0; i < keyLen; i++) {\n      const attribute = attributes[keys[i]];\n      const type = attribute.type;\n      const enumType = type.type || type;\n      const field = attribute.field || keys[i];\n      if (type instanceof DataTypes.ENUM || type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM) {\n        if (!results[enumIdx]) {\n          promises.push(() => {\n            return this.sequelize.query(this.queryGenerator.pgEnum(tableName, field, enumType, options), __spreadProps(__spreadValues({}, options), { raw: true }));\n          });\n        } else if (!!results[enumIdx] && !!model) {\n          const enumVals = this.queryGenerator.fromArray(results[enumIdx].enum_value);\n          const vals = enumType.values;\n          let lastOldEnumValue;\n          let rightestPosition = -1;\n          for (let oldIndex = 0; oldIndex < enumVals.length; oldIndex++) {\n            const enumVal = enumVals[oldIndex];\n            const newIdx = vals.indexOf(enumVal);\n            lastOldEnumValue = enumVal;\n            if (newIdx === -1) {\n              continue;\n            }\n            const newValuesBefore = vals.slice(0, newIdx);\n            const promisesLength = promises.length;\n            for (let reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--) {\n              if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {\n                break;\n              }\n              addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, \"before\", promisesLength);\n            }\n            if (newIdx > rightestPosition) {\n              rightestPosition = newIdx;\n            }\n          }\n          if (lastOldEnumValue && rightestPosition < vals.length - 1) {\n            const remainingEnumValues = vals.slice(rightestPosition + 1);\n            for (let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--) {\n              addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, \"after\");\n            }\n          }\n          enumIdx++;\n        }\n      }\n    }\n    const result = await promises.reduce(async (promise, asyncFunction) => await asyncFunction(await promise), Promise.resolve());\n    if (promises.length) {\n      await this.sequelize.dialect.connectionManager._refreshDynamicOIDs();\n    }\n    return result;\n  }\n  async getForeignKeyReferencesForTable(table, options) {\n    const queryOptions = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n    const query = this.queryGenerator.getForeignKeyReferencesQuery(table.tableName || table, this.sequelize.config.database, table.schema);\n    const result = await this.sequelize.query(query, queryOptions);\n    return result.map((fkMeta) => {\n      const _a = Utils.camelizeObjectKeys(fkMeta), { initiallyDeferred, isDeferrable } = _a, remaining = __objRest(_a, [\"initiallyDeferred\", \"isDeferrable\"]);\n      return __spreadProps(__spreadValues({}, remaining), {\n        deferrable: isDeferrable === \"NO\" ? Deferrable.NOT : initiallyDeferred === \"NO\" ? Deferrable.INITIALLY_IMMEDIATE : Deferrable.INITIALLY_DEFERRED\n      });\n    });\n  }\n  async dropEnum(enumName, options) {\n    options = options || {};\n    return this.sequelize.query(this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(enumName)), __spreadProps(__spreadValues({}, options), { raw: true }));\n  }\n  async dropAllEnums(options) {\n    options = options || {};\n    const enums = await this.pgListEnums(null, options);\n    return await Promise.all(enums.map((result) => this.sequelize.query(this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(result.enum_name)), __spreadProps(__spreadValues({}, options), { raw: true }))));\n  }\n  async pgListEnums(tableName, options) {\n    options = options || {};\n    const sql = this.queryGenerator.pgListEnums(tableName);\n    return this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { plain: false, raw: true, type: QueryTypes.SELECT }));\n  }\n  async dropTable(tableName, options) {\n    await super.dropTable(tableName, options);\n    const promises = [];\n    const instanceTable = this.sequelize.modelManager.getModel(tableName, { attribute: \"tableName\" });\n    if (!instanceTable) {\n      return;\n    }\n    const getTableName = (!options || !options.schema || options.schema === \"public\" ? \"\" : `${options.schema}_`) + tableName;\n    const keys = Object.keys(instanceTable.rawAttributes);\n    const keyLen = keys.length;\n    for (let i = 0; i < keyLen; i++) {\n      if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {\n        const sql = this.queryGenerator.pgEnumDrop(getTableName, keys[i]);\n        options.supportsSearchPath = false;\n        promises.push(this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { raw: true })));\n      }\n    }\n    await Promise.all(promises);\n  }\n}\nexports.PostgresQueryInterface = PostgresQueryInterface;\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9xdWVyeS1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsc0ZBQWtCO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLHdGQUFtQjtBQUM5QyxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsd0hBQTZCO0FBQ2hFLGNBQWMsbUJBQU8sQ0FBQyw0RUFBYTtBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxjQUFjLGlEQUFpRDtBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdJQUF3SSxjQUFjLFdBQVc7QUFDakssV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0QkFBNEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxpQkFBaUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxpQkFBaUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0NBQWtDO0FBQ3ZGLDRDQUE0QztBQUM1QztBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkpBQTJKLGNBQWMsV0FBVztBQUNwTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJNQUEyTSxjQUFjLFdBQVc7QUFDcE87QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsY0FBYyxrREFBa0Q7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsd0JBQXdCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixlQUFlO0FBQzlHO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsY0FBYyxXQUFXO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvcG9zdGdyZXMvcXVlcnktaW50ZXJmYWNlLmpzPzYzNzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbnZhciBfX29ialJlc3QgPSAoc291cmNlLCBleGNsdWRlKSA9PiB7XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkgJiYgZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMClcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgaWYgKHNvdXJjZSAhPSBudWxsICYmIF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKHNvdXJjZSkpIHtcbiAgICAgIGlmIChleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwICYmIF9fcHJvcElzRW51bS5jYWxsKHNvdXJjZSwgcHJvcCkpXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIik7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL3F1ZXJ5LXR5cGVzXCIpO1xuY29uc3QgeyBRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5LWludGVyZmFjZVwiKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuY29uc3QgRGVmZXJyYWJsZSA9IHJlcXVpcmUoXCIuLi8uLi9kZWZlcnJhYmxlXCIpO1xuY2xhc3MgUG9zdGdyZXNRdWVyeUludGVyZmFjZSBleHRlbmRzIFF1ZXJ5SW50ZXJmYWNlIHtcbiAgYXN5bmMgZW5zdXJlRW51bXModGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zLCBtb2RlbCkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKTtcbiAgICBjb25zdCBrZXlMZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQgc3FsID0gXCJcIjtcbiAgICBsZXQgcHJvbWlzZXMgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGtleUxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2tleXNbaV1dO1xuICAgICAgY29uc3QgdHlwZSA9IGF0dHJpYnV0ZS50eXBlO1xuICAgICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSB8fCB0eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkFSUkFZICYmIHR5cGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNKSB7XG4gICAgICAgIHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucGdMaXN0RW51bXModGFibGVOYW1lLCBhdHRyaWJ1dGUuZmllbGQgfHwga2V5c1tpXSwgb3B0aW9ucyk7XG4gICAgICAgIHByb21pc2VzLnB1c2godGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyBwbGFpbjogdHJ1ZSwgcmF3OiB0cnVlLCB0eXBlOiBRdWVyeVR5cGVzLlNFTEVDVCB9KSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIHByb21pc2VzID0gW107XG4gICAgbGV0IGVudW1JZHggPSAwO1xuICAgIGNvbnN0IGFkZEVudW1WYWx1ZSA9IChmaWVsZCwgdmFsdWUsIHJlbGF0aXZlVmFsdWUsIHBvc2l0aW9uID0gXCJiZWZvcmVcIiwgc3BsaWNlU3RhcnQgPSBwcm9taXNlcy5sZW5ndGgpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlT3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKTtcbiAgICAgIHZhbHVlT3B0aW9ucy5iZWZvcmUgPSBudWxsO1xuICAgICAgdmFsdWVPcHRpb25zLmFmdGVyID0gbnVsbDtcbiAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBcImFmdGVyXCI6XG4gICAgICAgICAgdmFsdWVPcHRpb25zLmFmdGVyID0gcmVsYXRpdmVWYWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJlZm9yZVwiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZhbHVlT3B0aW9ucy5iZWZvcmUgPSByZWxhdGl2ZVZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcHJvbWlzZXMuc3BsaWNlKHNwbGljZVN0YXJ0LCAwLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLnBnRW51bUFkZCh0YWJsZU5hbWUsIGZpZWxkLCB2YWx1ZSwgdmFsdWVPcHRpb25zKSwgdmFsdWVPcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZm9yIChpID0gMDsgaSA8IGtleUxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2tleXNbaV1dO1xuICAgICAgY29uc3QgdHlwZSA9IGF0dHJpYnV0ZS50eXBlO1xuICAgICAgY29uc3QgZW51bVR5cGUgPSB0eXBlLnR5cGUgfHwgdHlwZTtcbiAgICAgIGNvbnN0IGZpZWxkID0gYXR0cmlidXRlLmZpZWxkIHx8IGtleXNbaV07XG4gICAgICBpZiAodHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNIHx8IHR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQVJSQVkgJiYgZW51bVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSkge1xuICAgICAgICBpZiAoIXJlc3VsdHNbZW51bUlkeF0pIHtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLnBnRW51bSh0YWJsZU5hbWUsIGZpZWxkLCBlbnVtVHlwZSwgb3B0aW9ucyksIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHJhdzogdHJ1ZSB9KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoISFyZXN1bHRzW2VudW1JZHhdICYmICEhbW9kZWwpIHtcbiAgICAgICAgICBjb25zdCBlbnVtVmFscyA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZnJvbUFycmF5KHJlc3VsdHNbZW51bUlkeF0uZW51bV92YWx1ZSk7XG4gICAgICAgICAgY29uc3QgdmFscyA9IGVudW1UeXBlLnZhbHVlcztcbiAgICAgICAgICBsZXQgbGFzdE9sZEVudW1WYWx1ZTtcbiAgICAgICAgICBsZXQgcmlnaHRlc3RQb3NpdGlvbiA9IC0xO1xuICAgICAgICAgIGZvciAobGV0IG9sZEluZGV4ID0gMDsgb2xkSW5kZXggPCBlbnVtVmFscy5sZW5ndGg7IG9sZEluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVudW1WYWwgPSBlbnVtVmFsc1tvbGRJbmRleF07XG4gICAgICAgICAgICBjb25zdCBuZXdJZHggPSB2YWxzLmluZGV4T2YoZW51bVZhbCk7XG4gICAgICAgICAgICBsYXN0T2xkRW51bVZhbHVlID0gZW51bVZhbDtcbiAgICAgICAgICAgIGlmIChuZXdJZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWVzQmVmb3JlID0gdmFscy5zbGljZSgwLCBuZXdJZHgpO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXNMZW5ndGggPSBwcm9taXNlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCByZXZlcnNlSWR4ID0gbmV3VmFsdWVzQmVmb3JlLmxlbmd0aCAtIDE7IHJldmVyc2VJZHggPj0gMDsgcmV2ZXJzZUlkeC0tKSB7XG4gICAgICAgICAgICAgIGlmICh+ZW51bVZhbHMuaW5kZXhPZihuZXdWYWx1ZXNCZWZvcmVbcmV2ZXJzZUlkeF0pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYWRkRW51bVZhbHVlKGZpZWxkLCBuZXdWYWx1ZXNCZWZvcmVbcmV2ZXJzZUlkeF0sIGxhc3RPbGRFbnVtVmFsdWUsIFwiYmVmb3JlXCIsIHByb21pc2VzTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdJZHggPiByaWdodGVzdFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIHJpZ2h0ZXN0UG9zaXRpb24gPSBuZXdJZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsYXN0T2xkRW51bVZhbHVlICYmIHJpZ2h0ZXN0UG9zaXRpb24gPCB2YWxzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0VudW1WYWx1ZXMgPSB2YWxzLnNsaWNlKHJpZ2h0ZXN0UG9zaXRpb24gKyAxKTtcbiAgICAgICAgICAgIGZvciAobGV0IHJldmVyc2VJZHggPSByZW1haW5pbmdFbnVtVmFsdWVzLmxlbmd0aCAtIDE7IHJldmVyc2VJZHggPj0gMDsgcmV2ZXJzZUlkeC0tKSB7XG4gICAgICAgICAgICAgIGFkZEVudW1WYWx1ZShmaWVsZCwgcmVtYWluaW5nRW51bVZhbHVlc1tyZXZlcnNlSWR4XSwgbGFzdE9sZEVudW1WYWx1ZSwgXCJhZnRlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZW51bUlkeCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb21pc2VzLnJlZHVjZShhc3luYyAocHJvbWlzZSwgYXN5bmNGdW5jdGlvbikgPT4gYXdhaXQgYXN5bmNGdW5jdGlvbihhd2FpdCBwcm9taXNlKSwgUHJvbWlzZS5yZXNvbHZlKCkpO1xuICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLmRpYWxlY3QuY29ubmVjdGlvbk1hbmFnZXIuX3JlZnJlc2hEeW5hbWljT0lEcygpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIGdldEZvcmVpZ25LZXlSZWZlcmVuY2VzRm9yVGFibGUodGFibGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBxdWVyeU9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwge1xuICAgICAgdHlwZTogUXVlcnlUeXBlcy5GT1JFSUdOS0VZU1xuICAgIH0pO1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeUdlbmVyYXRvci5nZXRGb3JlaWduS2V5UmVmZXJlbmNlc1F1ZXJ5KHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZSwgdGhpcy5zZXF1ZWxpemUuY29uZmlnLmRhdGFiYXNlLCB0YWJsZS5zY2hlbWEpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHF1ZXJ5LCBxdWVyeU9wdGlvbnMpO1xuICAgIHJldHVybiByZXN1bHQubWFwKChma01ldGEpID0+IHtcbiAgICAgIGNvbnN0IF9hID0gVXRpbHMuY2FtZWxpemVPYmplY3RLZXlzKGZrTWV0YSksIHsgaW5pdGlhbGx5RGVmZXJyZWQsIGlzRGVmZXJyYWJsZSB9ID0gX2EsIHJlbWFpbmluZyA9IF9fb2JqUmVzdChfYSwgW1wiaW5pdGlhbGx5RGVmZXJyZWRcIiwgXCJpc0RlZmVycmFibGVcIl0pO1xuICAgICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHJlbWFpbmluZyksIHtcbiAgICAgICAgZGVmZXJyYWJsZTogaXNEZWZlcnJhYmxlID09PSBcIk5PXCIgPyBEZWZlcnJhYmxlLk5PVCA6IGluaXRpYWxseURlZmVycmVkID09PSBcIk5PXCIgPyBEZWZlcnJhYmxlLklOSVRJQUxMWV9JTU1FRElBVEUgOiBEZWZlcnJhYmxlLklOSVRJQUxMWV9ERUZFUlJFRFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZHJvcEVudW0oZW51bU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5wZ0VudW1Ecm9wKG51bGwsIG51bGwsIHRoaXMucXVlcnlHZW5lcmF0b3IucGdFc2NhcGVBbmRRdW90ZShlbnVtTmFtZSkpLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyByYXc6IHRydWUgfSkpO1xuICB9XG4gIGFzeW5jIGRyb3BBbGxFbnVtcyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgZW51bXMgPSBhd2FpdCB0aGlzLnBnTGlzdEVudW1zKG51bGwsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChlbnVtcy5tYXAoKHJlc3VsdCkgPT4gdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5wZ0VudW1Ecm9wKG51bGwsIG51bGwsIHRoaXMucXVlcnlHZW5lcmF0b3IucGdFc2NhcGVBbmRRdW90ZShyZXN1bHQuZW51bV9uYW1lKSksIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHJhdzogdHJ1ZSB9KSkpKTtcbiAgfVxuICBhc3luYyBwZ0xpc3RFbnVtcyh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnBnTGlzdEVudW1zKHRhYmxlTmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgcGxhaW46IGZhbHNlLCByYXc6IHRydWUsIHR5cGU6IFF1ZXJ5VHlwZXMuU0VMRUNUIH0pKTtcbiAgfVxuICBhc3luYyBkcm9wVGFibGUodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgYXdhaXQgc3VwZXIuZHJvcFRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICBjb25zdCBpbnN0YW5jZVRhYmxlID0gdGhpcy5zZXF1ZWxpemUubW9kZWxNYW5hZ2VyLmdldE1vZGVsKHRhYmxlTmFtZSwgeyBhdHRyaWJ1dGU6IFwidGFibGVOYW1lXCIgfSk7XG4gICAgaWYgKCFpbnN0YW5jZVRhYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGdldFRhYmxlTmFtZSA9ICghb3B0aW9ucyB8fCAhb3B0aW9ucy5zY2hlbWEgfHwgb3B0aW9ucy5zY2hlbWEgPT09IFwicHVibGljXCIgPyBcIlwiIDogYCR7b3B0aW9ucy5zY2hlbWF9X2ApICsgdGFibGVOYW1lO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpbnN0YW5jZVRhYmxlLnJhd0F0dHJpYnV0ZXMpO1xuICAgIGNvbnN0IGtleUxlbiA9IGtleXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5TGVuOyBpKyspIHtcbiAgICAgIGlmIChpbnN0YW5jZVRhYmxlLnJhd0F0dHJpYnV0ZXNba2V5c1tpXV0udHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNKSB7XG4gICAgICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucGdFbnVtRHJvcChnZXRUYWJsZU5hbWUsIGtleXNbaV0pO1xuICAgICAgICBvcHRpb25zLnN1cHBvcnRzU2VhcmNoUGF0aCA9IGZhbHNlO1xuICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgcmF3OiB0cnVlIH0pKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfVxufVxuZXhwb3J0cy5Qb3N0Z3Jlc1F1ZXJ5SW50ZXJmYWNlID0gUG9zdGdyZXNRdWVyeUludGVyZmFjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWludGVyZmFjZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/postgres/query-interface.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/postgres/query.js":
/*!****************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/postgres/query.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(action-browser)/../node_modules/sequelize/lib/query-types.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(action-browser)/../node_modules/sequelize/lib/utils/logger.js\");\nconst debug = logger.debugContext(\"sql:pg\");\nclass Query extends AbstractQuery {\n  static formatBindParameters(sql, values, dialect) {\n    const stringReplaceFunc = (value) => typeof value === \"string\" ? value.replace(/\\0/g, \"\\\\0\") : value;\n    let bindParam;\n    if (Array.isArray(values)) {\n      bindParam = values.map(stringReplaceFunc);\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    } else {\n      bindParam = [];\n      let i = 0;\n      const seen = {};\n      const replacementFunc = (match, key, values2) => {\n        if (seen[key] !== void 0) {\n          return seen[key];\n        }\n        if (values2[key] !== void 0) {\n          i = i + 1;\n          bindParam.push(stringReplaceFunc(values2[key]));\n          seen[key] = `$${i}`;\n          return `$${i}`;\n        }\n        return void 0;\n      };\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    }\n    return [sql, bindParam];\n  }\n  async run(sql, parameters) {\n    const { connection } = this;\n    if (!_.isEmpty(this.options.searchPath)) {\n      sql = this.sequelize.getQueryInterface().queryGenerator.setSearchPath(this.options.searchPath) + sql;\n    }\n    if (this.sequelize.options.minifyAliases && this.options.includeAliases) {\n      _.toPairs(this.options.includeAliases).sort((a, b) => b[1].length - a[1].length).forEach(([alias, original]) => {\n        const reg = new RegExp(_.escapeRegExp(original), \"g\");\n        sql = sql.replace(reg, alias);\n      });\n    }\n    this.sql = sql;\n    const query = parameters && parameters.length ? new Promise((resolve, reject) => connection.query(sql, parameters, (error, result) => error ? reject(error) : resolve(result))) : new Promise((resolve, reject) => connection.query(sql, (error, result) => error ? reject(error) : resolve(result)));\n    const complete = this._logQuery(sql, debug, parameters);\n    let queryResult;\n    const errForStack = new Error();\n    try {\n      queryResult = await query;\n    } catch (error) {\n      if (error.code === \"ECONNRESET\" || /Unable to set non-blocking to true/i.test(error) || /SSL SYSCALL error: EOF detected/i.test(error) || /Local: Authentication failure/i.test(error) || error.message === \"Query read timeout\") {\n        connection._invalid = true;\n      }\n      error.sql = sql;\n      error.parameters = parameters;\n      throw this.formatError(error, errForStack.stack);\n    }\n    complete();\n    let rows = Array.isArray(queryResult) ? queryResult.reduce((allRows, r) => allRows.concat(r.rows || []), []) : queryResult.rows;\n    const rowCount = Array.isArray(queryResult) ? queryResult.reduce((count, r) => Number.isFinite(r.rowCount) ? count + r.rowCount : count, 0) : queryResult.rowCount || 0;\n    if (this.sequelize.options.minifyAliases && this.options.aliasesMapping) {\n      rows = rows.map((row) => _.toPairs(row).reduce((acc, [key, value]) => {\n        const mapping = this.options.aliasesMapping.get(key);\n        acc[mapping || key] = value;\n        return acc;\n      }, {}));\n    }\n    const isTableNameQuery = sql.startsWith(\"SELECT table_name FROM information_schema.tables\");\n    const isRelNameQuery = sql.startsWith(\"SELECT relname FROM pg_class WHERE oid IN\");\n    if (isRelNameQuery) {\n      return rows.map((row) => ({\n        name: row.relname,\n        tableName: row.relname.split(\"_\")[0]\n      }));\n    }\n    if (isTableNameQuery) {\n      return rows.map((row) => Object.values(row));\n    }\n    if (rows[0] && rows[0].sequelize_caught_exception !== void 0) {\n      if (rows[0].sequelize_caught_exception !== null) {\n        throw this.formatError({\n          sql,\n          parameters,\n          code: \"23505\",\n          detail: rows[0].sequelize_caught_exception\n        });\n      }\n      for (const row of rows) {\n        delete row.sequelize_caught_exception;\n      }\n    }\n    if (this.isShowIndexesQuery()) {\n      for (const row of rows) {\n        const attributes = /ON .*? (?:USING .*?\\s)?\\(([^]*)\\)/gi.exec(row.definition)[1].split(\",\");\n        const columns = _.zipObject(row.column_indexes, this.sequelize.getQueryInterface().queryGenerator.fromArray(row.column_names));\n        delete row.column_indexes;\n        delete row.column_names;\n        let field;\n        let attribute;\n        row.fields = row.indkey.split(\" \").map((indKey, index) => {\n          field = columns[indKey];\n          if (!field) {\n            return null;\n          }\n          attribute = attributes[index];\n          return {\n            attribute: field,\n            collate: attribute.match(/COLLATE \"(.*?)\"/) ? /COLLATE \"(.*?)\"/.exec(attribute)[1] : void 0,\n            order: attribute.includes(\"DESC\") ? \"DESC\" : attribute.includes(\"ASC\") ? \"ASC\" : void 0,\n            length: void 0\n          };\n        }).filter((n) => n !== null);\n        delete row.columns;\n      }\n      return rows;\n    }\n    if (this.isForeignKeysQuery()) {\n      const result = [];\n      for (const row of rows) {\n        let defParts;\n        if (row.condef !== void 0 && (defParts = row.condef.match(/FOREIGN KEY \\((.+)\\) REFERENCES (.+)\\((.+)\\)( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?/))) {\n          row.id = row.constraint_name;\n          row.table = defParts[2];\n          row.from = defParts[1];\n          row.to = defParts[3];\n          let i;\n          for (i = 5; i <= 8; i += 3) {\n            if (/(UPDATE|DELETE)/.test(defParts[i])) {\n              row[`on_${defParts[i].toLowerCase()}`] = defParts[i + 1];\n            }\n          }\n        }\n        result.push(row);\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      let result = rows;\n      if (this.options.raw === false && this.sequelize.options.quoteIdentifiers === false) {\n        const attrsMap = _.reduce(this.model.rawAttributes, (m, v, k) => {\n          m[k.toLowerCase()] = k;\n          return m;\n        }, {});\n        result = rows.map((row) => {\n          return _.mapKeys(row, (value, key) => {\n            const targetAttr = attrsMap[key];\n            if (typeof targetAttr === \"string\" && targetAttr !== key) {\n              return targetAttr;\n            }\n            return key;\n          });\n        });\n      }\n      return this.handleSelectQuery(result);\n    }\n    if (QueryTypes.DESCRIBE === this.options.type) {\n      const result = {};\n      for (const row of rows) {\n        result[row.Field] = {\n          type: row.Type.toUpperCase(),\n          allowNull: row.Null === \"YES\",\n          defaultValue: row.Default,\n          comment: row.Comment,\n          special: row.special ? this.sequelize.getQueryInterface().queryGenerator.fromArray(row.special) : [],\n          primaryKey: row.Constraint === \"PRIMARY KEY\"\n        };\n        if (result[row.Field].type === \"BOOLEAN\") {\n          result[row.Field].defaultValue = { \"false\": false, \"true\": true }[result[row.Field].defaultValue];\n          if (result[row.Field].defaultValue === void 0) {\n            result[row.Field].defaultValue = null;\n          }\n        }\n        if (typeof result[row.Field].defaultValue === \"string\") {\n          result[row.Field].defaultValue = result[row.Field].defaultValue.replace(/'/g, \"\");\n          if (result[row.Field].defaultValue.includes(\"::\")) {\n            const split = result[row.Field].defaultValue.split(\"::\");\n            if (split[1].toLowerCase() !== \"regclass)\") {\n              result[row.Field].defaultValue = split[0];\n            }\n          }\n        }\n      }\n      return result;\n    }\n    if (this.isVersionQuery()) {\n      return rows[0].server_version;\n    }\n    if (this.isShowOrDescribeQuery()) {\n      return rows;\n    }\n    if (QueryTypes.BULKUPDATE === this.options.type) {\n      if (!this.options.returning) {\n        return parseInt(rowCount, 10);\n      }\n      return this.handleSelectQuery(rows);\n    }\n    if (QueryTypes.BULKDELETE === this.options.type) {\n      return parseInt(rowCount, 10);\n    }\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery()) {\n      if (this.instance && this.instance.dataValues) {\n        if (this.isInsertQuery() && !this.isUpsertQuery() && rowCount === 0) {\n          throw new sequelizeErrors.EmptyResultError();\n        }\n        for (const key in rows[0]) {\n          if (Object.prototype.hasOwnProperty.call(rows[0], key)) {\n            const record = rows[0][key];\n            const attr = _.find(this.model.rawAttributes, (attribute) => attribute.fieldName === key || attribute.field === key);\n            this.instance.dataValues[attr && attr.fieldName || key] = record;\n          }\n        }\n      }\n      if (this.isUpsertQuery()) {\n        return [\n          this.instance,\n          null\n        ];\n      }\n      return [\n        this.instance || rows && (this.options.plain && rows[0] || rows) || void 0,\n        rowCount\n      ];\n    }\n    if (this.isRawQuery()) {\n      return [rows, queryResult];\n    }\n    return rows;\n  }\n  formatError(err, errStack) {\n    let match;\n    let table;\n    let index;\n    let fields;\n    let errors;\n    let message;\n    const code = err.code || err.sqlState;\n    const errMessage = err.message || err.messagePrimary;\n    const errDetail = err.detail || err.messageDetail;\n    switch (code) {\n      case \"23503\":\n        index = errMessage.match(/violates foreign key constraint \"(.+?)\"/);\n        index = index ? index[1] : void 0;\n        table = errMessage.match(/on table \"(.+?)\"/);\n        table = table ? table[1] : void 0;\n        return new sequelizeErrors.ForeignKeyConstraintError({\n          message: errMessage,\n          fields: null,\n          index,\n          table,\n          parent: err,\n          stack: errStack\n        });\n      case \"23505\":\n        if (errDetail && (match = errDetail.replace(/\"/g, \"\").match(/Key \\((.*?)\\)=\\((.*?)\\)/))) {\n          fields = _.zipObject(match[1].split(\", \"), match[2].split(\", \"));\n          errors = [];\n          message = \"Validation error\";\n          _.forOwn(fields, (value, field) => {\n            errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, value, this.instance, \"not_unique\"));\n          });\n          if (this.model && this.model.uniqueKeys) {\n            _.forOwn(this.model.uniqueKeys, (constraint) => {\n              if (_.isEqual(constraint.fields, Object.keys(fields)) && !!constraint.msg) {\n                message = constraint.msg;\n                return false;\n              }\n            });\n          }\n          return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n        }\n        return new sequelizeErrors.UniqueConstraintError({\n          message: errMessage,\n          parent: err,\n          stack: errStack\n        });\n      case \"23P01\":\n        match = errDetail.match(/Key \\((.*?)\\)=\\((.*?)\\)/);\n        if (match) {\n          fields = _.zipObject(match[1].split(\", \"), match[2].split(\", \"));\n        }\n        message = \"Exclusion constraint error\";\n        return new sequelizeErrors.ExclusionConstraintError({\n          message,\n          constraint: err.constraint,\n          fields,\n          table: err.table,\n          parent: err,\n          stack: errStack\n        });\n      case \"42704\":\n        if (err.sql && /(CONSTRAINT|INDEX)/gi.test(err.sql)) {\n          message = \"Unknown constraint error\";\n          index = errMessage.match(/(?:constraint|index) \"(.+?)\"/i);\n          index = index ? index[1] : void 0;\n          table = errMessage.match(/relation \"(.+?)\"/i);\n          table = table ? table[1] : void 0;\n          throw new sequelizeErrors.UnknownConstraintError({\n            message,\n            constraint: index,\n            fields,\n            table,\n            parent: err,\n            stack: errStack\n          });\n        }\n      default:\n        return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n    }\n  }\n  isForeignKeysQuery() {\n    return /SELECT conname as constraint_name, pg_catalog\\.pg_get_constraintdef\\(r\\.oid, true\\) as condef FROM pg_catalog\\.pg_constraint r WHERE r\\.conrelid = \\(SELECT oid FROM pg_class WHERE relname = '.*' LIMIT 1\\) AND r\\.contype = 'f' ORDER BY 1;/.test(this.sql);\n  }\n  getInsertIdField() {\n    return \"id\";\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports[\"default\"] = Query;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9xdWVyeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHNCQUFzQixtQkFBTyxDQUFDLG9HQUFtQjtBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDOUMsd0JBQXdCLG1CQUFPLENBQUMsb0ZBQWM7QUFDOUMsVUFBVSxtQkFBTyxDQUFDLGlFQUFRO0FBQzFCLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsMEZBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHdCQUF3QjtBQUMvRixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsRUFBRTtBQUM1QixxQkFBcUIsRUFBRTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw4QkFBOEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw2REFBNkQsdURBQXVEO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Esd0RBQXdELGlCQUFpQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSx5UEFBeVA7QUFDelA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9xdWVyeS5qcz83MWJiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgQWJzdHJhY3RRdWVyeSA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9xdWVyeVwiKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vcXVlcnktdHlwZXNcIik7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzXCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2xvZ2dlclwiKTtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dChcInNxbDpwZ1wiKTtcbmNsYXNzIFF1ZXJ5IGV4dGVuZHMgQWJzdHJhY3RRdWVyeSB7XG4gIHN0YXRpYyBmb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCkge1xuICAgIGNvbnN0IHN0cmluZ1JlcGxhY2VGdW5jID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5yZXBsYWNlKC9cXDAvZywgXCJcXFxcMFwiKSA6IHZhbHVlO1xuICAgIGxldCBiaW5kUGFyYW07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgYmluZFBhcmFtID0gdmFsdWVzLm1hcChzdHJpbmdSZXBsYWNlRnVuYyk7XG4gICAgICBzcWwgPSBBYnN0cmFjdFF1ZXJ5LmZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0LCB7IHNraXBWYWx1ZVJlcGxhY2U6IHRydWUgfSlbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGJpbmRQYXJhbSA9IFtdO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgY29uc3Qgc2VlbiA9IHt9O1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnRGdW5jID0gKG1hdGNoLCBrZXksIHZhbHVlczIpID0+IHtcbiAgICAgICAgaWYgKHNlZW5ba2V5XSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHNlZW5ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVzMltrZXldICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBpID0gaSArIDE7XG4gICAgICAgICAgYmluZFBhcmFtLnB1c2goc3RyaW5nUmVwbGFjZUZ1bmModmFsdWVzMltrZXldKSk7XG4gICAgICAgICAgc2VlbltrZXldID0gYCQke2l9YDtcbiAgICAgICAgICByZXR1cm4gYCQke2l9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfTtcbiAgICAgIHNxbCA9IEFic3RyYWN0UXVlcnkuZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QsIHJlcGxhY2VtZW50RnVuYylbMF07XG4gICAgfVxuICAgIHJldHVybiBbc3FsLCBiaW5kUGFyYW1dO1xuICB9XG4gIGFzeW5jIHJ1bihzcWwsIHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb24gfSA9IHRoaXM7XG4gICAgaWYgKCFfLmlzRW1wdHkodGhpcy5vcHRpb25zLnNlYXJjaFBhdGgpKSB7XG4gICAgICBzcWwgPSB0aGlzLnNlcXVlbGl6ZS5nZXRRdWVyeUludGVyZmFjZSgpLnF1ZXJ5R2VuZXJhdG9yLnNldFNlYXJjaFBhdGgodGhpcy5vcHRpb25zLnNlYXJjaFBhdGgpICsgc3FsO1xuICAgIH1cbiAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5taW5pZnlBbGlhc2VzICYmIHRoaXMub3B0aW9ucy5pbmNsdWRlQWxpYXNlcykge1xuICAgICAgXy50b1BhaXJzKHRoaXMub3B0aW9ucy5pbmNsdWRlQWxpYXNlcykuc29ydCgoYSwgYikgPT4gYlsxXS5sZW5ndGggLSBhWzFdLmxlbmd0aCkuZm9yRWFjaCgoW2FsaWFzLCBvcmlnaW5hbF0pID0+IHtcbiAgICAgICAgY29uc3QgcmVnID0gbmV3IFJlZ0V4cChfLmVzY2FwZVJlZ0V4cChvcmlnaW5hbCksIFwiZ1wiKTtcbiAgICAgICAgc3FsID0gc3FsLnJlcGxhY2UocmVnLCBhbGlhcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5zcWwgPSBzcWw7XG4gICAgY29uc3QgcXVlcnkgPSBwYXJhbWV0ZXJzICYmIHBhcmFtZXRlcnMubGVuZ3RoID8gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gY29ubmVjdGlvbi5xdWVyeShzcWwsIHBhcmFtZXRlcnMsIChlcnJvciwgcmVzdWx0KSA9PiBlcnJvciA/IHJlamVjdChlcnJvcikgOiByZXNvbHZlKHJlc3VsdCkpKSA6IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IGNvbm5lY3Rpb24ucXVlcnkoc3FsLCAoZXJyb3IsIHJlc3VsdCkgPT4gZXJyb3IgPyByZWplY3QoZXJyb3IpIDogcmVzb2x2ZShyZXN1bHQpKSk7XG4gICAgY29uc3QgY29tcGxldGUgPSB0aGlzLl9sb2dRdWVyeShzcWwsIGRlYnVnLCBwYXJhbWV0ZXJzKTtcbiAgICBsZXQgcXVlcnlSZXN1bHQ7XG4gICAgY29uc3QgZXJyRm9yU3RhY2sgPSBuZXcgRXJyb3IoKTtcbiAgICB0cnkge1xuICAgICAgcXVlcnlSZXN1bHQgPSBhd2FpdCBxdWVyeTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFwiRUNPTk5SRVNFVFwiIHx8IC9VbmFibGUgdG8gc2V0IG5vbi1ibG9ja2luZyB0byB0cnVlL2kudGVzdChlcnJvcikgfHwgL1NTTCBTWVNDQUxMIGVycm9yOiBFT0YgZGV0ZWN0ZWQvaS50ZXN0KGVycm9yKSB8fCAvTG9jYWw6IEF1dGhlbnRpY2F0aW9uIGZhaWx1cmUvaS50ZXN0KGVycm9yKSB8fCBlcnJvci5tZXNzYWdlID09PSBcIlF1ZXJ5IHJlYWQgdGltZW91dFwiKSB7XG4gICAgICAgIGNvbm5lY3Rpb24uX2ludmFsaWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZXJyb3Iuc3FsID0gc3FsO1xuICAgICAgZXJyb3IucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICB0aHJvdyB0aGlzLmZvcm1hdEVycm9yKGVycm9yLCBlcnJGb3JTdGFjay5zdGFjayk7XG4gICAgfVxuICAgIGNvbXBsZXRlKCk7XG4gICAgbGV0IHJvd3MgPSBBcnJheS5pc0FycmF5KHF1ZXJ5UmVzdWx0KSA/IHF1ZXJ5UmVzdWx0LnJlZHVjZSgoYWxsUm93cywgcikgPT4gYWxsUm93cy5jb25jYXQoci5yb3dzIHx8IFtdKSwgW10pIDogcXVlcnlSZXN1bHQucm93cztcbiAgICBjb25zdCByb3dDb3VudCA9IEFycmF5LmlzQXJyYXkocXVlcnlSZXN1bHQpID8gcXVlcnlSZXN1bHQucmVkdWNlKChjb3VudCwgcikgPT4gTnVtYmVyLmlzRmluaXRlKHIucm93Q291bnQpID8gY291bnQgKyByLnJvd0NvdW50IDogY291bnQsIDApIDogcXVlcnlSZXN1bHQucm93Q291bnQgfHwgMDtcbiAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5taW5pZnlBbGlhc2VzICYmIHRoaXMub3B0aW9ucy5hbGlhc2VzTWFwcGluZykge1xuICAgICAgcm93cyA9IHJvd3MubWFwKChyb3cpID0+IF8udG9QYWlycyhyb3cpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgY29uc3QgbWFwcGluZyA9IHRoaXMub3B0aW9ucy5hbGlhc2VzTWFwcGluZy5nZXQoa2V5KTtcbiAgICAgICAgYWNjW21hcHBpbmcgfHwga2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pKTtcbiAgICB9XG4gICAgY29uc3QgaXNUYWJsZU5hbWVRdWVyeSA9IHNxbC5zdGFydHNXaXRoKFwiU0VMRUNUIHRhYmxlX25hbWUgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVzXCIpO1xuICAgIGNvbnN0IGlzUmVsTmFtZVF1ZXJ5ID0gc3FsLnN0YXJ0c1dpdGgoXCJTRUxFQ1QgcmVsbmFtZSBGUk9NIHBnX2NsYXNzIFdIRVJFIG9pZCBJTlwiKTtcbiAgICBpZiAoaXNSZWxOYW1lUXVlcnkpIHtcbiAgICAgIHJldHVybiByb3dzLm1hcCgocm93KSA9PiAoe1xuICAgICAgICBuYW1lOiByb3cucmVsbmFtZSxcbiAgICAgICAgdGFibGVOYW1lOiByb3cucmVsbmFtZS5zcGxpdChcIl9cIilbMF1cbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKGlzVGFibGVOYW1lUXVlcnkpIHtcbiAgICAgIHJldHVybiByb3dzLm1hcCgocm93KSA9PiBPYmplY3QudmFsdWVzKHJvdykpO1xuICAgIH1cbiAgICBpZiAocm93c1swXSAmJiByb3dzWzBdLnNlcXVlbGl6ZV9jYXVnaHRfZXhjZXB0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChyb3dzWzBdLnNlcXVlbGl6ZV9jYXVnaHRfZXhjZXB0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IHRoaXMuZm9ybWF0RXJyb3Ioe1xuICAgICAgICAgIHNxbCxcbiAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgIGNvZGU6IFwiMjM1MDVcIixcbiAgICAgICAgICBkZXRhaWw6IHJvd3NbMF0uc2VxdWVsaXplX2NhdWdodF9leGNlcHRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgIGRlbGV0ZSByb3cuc2VxdWVsaXplX2NhdWdodF9leGNlcHRpb247XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd0luZGV4ZXNRdWVyeSgpKSB7XG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSAvT04gLio/ICg/OlVTSU5HIC4qP1xccyk/XFwoKFteXSopXFwpL2dpLmV4ZWMocm93LmRlZmluaXRpb24pWzFdLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgY29uc3QgY29sdW1ucyA9IF8uemlwT2JqZWN0KHJvdy5jb2x1bW5faW5kZXhlcywgdGhpcy5zZXF1ZWxpemUuZ2V0UXVlcnlJbnRlcmZhY2UoKS5xdWVyeUdlbmVyYXRvci5mcm9tQXJyYXkocm93LmNvbHVtbl9uYW1lcykpO1xuICAgICAgICBkZWxldGUgcm93LmNvbHVtbl9pbmRleGVzO1xuICAgICAgICBkZWxldGUgcm93LmNvbHVtbl9uYW1lcztcbiAgICAgICAgbGV0IGZpZWxkO1xuICAgICAgICBsZXQgYXR0cmlidXRlO1xuICAgICAgICByb3cuZmllbGRzID0gcm93LmluZGtleS5zcGxpdChcIiBcIikubWFwKChpbmRLZXksIGluZGV4KSA9PiB7XG4gICAgICAgICAgZmllbGQgPSBjb2x1bW5zW2luZEtleV07XG4gICAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaW5kZXhdO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdHRyaWJ1dGU6IGZpZWxkLFxuICAgICAgICAgICAgY29sbGF0ZTogYXR0cmlidXRlLm1hdGNoKC9DT0xMQVRFIFwiKC4qPylcIi8pID8gL0NPTExBVEUgXCIoLio/KVwiLy5leGVjKGF0dHJpYnV0ZSlbMV0gOiB2b2lkIDAsXG4gICAgICAgICAgICBvcmRlcjogYXR0cmlidXRlLmluY2x1ZGVzKFwiREVTQ1wiKSA/IFwiREVTQ1wiIDogYXR0cmlidXRlLmluY2x1ZGVzKFwiQVNDXCIpID8gXCJBU0NcIiA6IHZvaWQgMCxcbiAgICAgICAgICAgIGxlbmd0aDogdm9pZCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfSkuZmlsdGVyKChuKSA9PiBuICE9PSBudWxsKTtcbiAgICAgICAgZGVsZXRlIHJvdy5jb2x1bW5zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRm9yZWlnbktleXNRdWVyeSgpKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgbGV0IGRlZlBhcnRzO1xuICAgICAgICBpZiAocm93LmNvbmRlZiAhPT0gdm9pZCAwICYmIChkZWZQYXJ0cyA9IHJvdy5jb25kZWYubWF0Y2goL0ZPUkVJR04gS0VZIFxcKCguKylcXCkgUkVGRVJFTkNFUyAoLispXFwoKC4rKVxcKSggT04gKFVQREFURXxERUxFVEUpIChDQVNDQURFfFJFU1RSSUNUKSk/KCBPTiAoVVBEQVRFfERFTEVURSkgKENBU0NBREV8UkVTVFJJQ1QpKT8vKSkpIHtcbiAgICAgICAgICByb3cuaWQgPSByb3cuY29uc3RyYWludF9uYW1lO1xuICAgICAgICAgIHJvdy50YWJsZSA9IGRlZlBhcnRzWzJdO1xuICAgICAgICAgIHJvdy5mcm9tID0gZGVmUGFydHNbMV07XG4gICAgICAgICAgcm93LnRvID0gZGVmUGFydHNbM107XG4gICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgZm9yIChpID0gNTsgaSA8PSA4OyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICgvKFVQREFURXxERUxFVEUpLy50ZXN0KGRlZlBhcnRzW2ldKSkge1xuICAgICAgICAgICAgICByb3dbYG9uXyR7ZGVmUGFydHNbaV0udG9Mb3dlckNhc2UoKX1gXSA9IGRlZlBhcnRzW2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2gocm93KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2VsZWN0UXVlcnkoKSkge1xuICAgICAgbGV0IHJlc3VsdCA9IHJvd3M7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJhdyA9PT0gZmFsc2UgJiYgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5xdW90ZUlkZW50aWZpZXJzID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBhdHRyc01hcCA9IF8ucmVkdWNlKHRoaXMubW9kZWwucmF3QXR0cmlidXRlcywgKG0sIHYsIGspID0+IHtcbiAgICAgICAgICBtW2sudG9Mb3dlckNhc2UoKV0gPSBrO1xuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJlc3VsdCA9IHJvd3MubWFwKChyb3cpID0+IHtcbiAgICAgICAgICByZXR1cm4gXy5tYXBLZXlzKHJvdywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEF0dHIgPSBhdHRyc01hcFtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRBdHRyID09PSBcInN0cmluZ1wiICYmIHRhcmdldEF0dHIgIT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0QXR0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VsZWN0UXVlcnkocmVzdWx0KTtcbiAgICB9XG4gICAgaWYgKFF1ZXJ5VHlwZXMuREVTQ1JJQkUgPT09IHRoaXMub3B0aW9ucy50eXBlKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgcmVzdWx0W3Jvdy5GaWVsZF0gPSB7XG4gICAgICAgICAgdHlwZTogcm93LlR5cGUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICBhbGxvd051bGw6IHJvdy5OdWxsID09PSBcIllFU1wiLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogcm93LkRlZmF1bHQsXG4gICAgICAgICAgY29tbWVudDogcm93LkNvbW1lbnQsXG4gICAgICAgICAgc3BlY2lhbDogcm93LnNwZWNpYWwgPyB0aGlzLnNlcXVlbGl6ZS5nZXRRdWVyeUludGVyZmFjZSgpLnF1ZXJ5R2VuZXJhdG9yLmZyb21BcnJheShyb3cuc3BlY2lhbCkgOiBbXSxcbiAgICAgICAgICBwcmltYXJ5S2V5OiByb3cuQ29uc3RyYWludCA9PT0gXCJQUklNQVJZIEtFWVwiXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZXN1bHRbcm93LkZpZWxkXS50eXBlID09PSBcIkJPT0xFQU5cIikge1xuICAgICAgICAgIHJlc3VsdFtyb3cuRmllbGRdLmRlZmF1bHRWYWx1ZSA9IHsgXCJmYWxzZVwiOiBmYWxzZSwgXCJ0cnVlXCI6IHRydWUgfVtyZXN1bHRbcm93LkZpZWxkXS5kZWZhdWx0VmFsdWVdO1xuICAgICAgICAgIGlmIChyZXN1bHRbcm93LkZpZWxkXS5kZWZhdWx0VmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmVzdWx0W3Jvdy5GaWVsZF0uZGVmYXVsdFZhbHVlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRbcm93LkZpZWxkXS5kZWZhdWx0VmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXN1bHRbcm93LkZpZWxkXS5kZWZhdWx0VmFsdWUgPSByZXN1bHRbcm93LkZpZWxkXS5kZWZhdWx0VmFsdWUucmVwbGFjZSgvJy9nLCBcIlwiKTtcbiAgICAgICAgICBpZiAocmVzdWx0W3Jvdy5GaWVsZF0uZGVmYXVsdFZhbHVlLmluY2x1ZGVzKFwiOjpcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwbGl0ID0gcmVzdWx0W3Jvdy5GaWVsZF0uZGVmYXVsdFZhbHVlLnNwbGl0KFwiOjpcIik7XG4gICAgICAgICAgICBpZiAoc3BsaXRbMV0udG9Mb3dlckNhc2UoKSAhPT0gXCJyZWdjbGFzcylcIikge1xuICAgICAgICAgICAgICByZXN1bHRbcm93LkZpZWxkXS5kZWZhdWx0VmFsdWUgPSBzcGxpdFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVmVyc2lvblF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiByb3dzWzBdLnNlcnZlcl92ZXJzaW9uO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dPckRlc2NyaWJlUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfVxuICAgIGlmIChRdWVyeVR5cGVzLkJVTEtVUERBVEUgPT09IHRoaXMub3B0aW9ucy50eXBlKSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHJvd0NvdW50LCAxMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZWxlY3RRdWVyeShyb3dzKTtcbiAgICB9XG4gICAgaWYgKFF1ZXJ5VHlwZXMuQlVMS0RFTEVURSA9PT0gdGhpcy5vcHRpb25zLnR5cGUpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChyb3dDb3VudCwgMTApO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KCkgfHwgdGhpcy5pc1VwZGF0ZVF1ZXJ5KCkgfHwgdGhpcy5pc1Vwc2VydFF1ZXJ5KCkpIHtcbiAgICAgIGlmICh0aGlzLmluc3RhbmNlICYmIHRoaXMuaW5zdGFuY2UuZGF0YVZhbHVlcykge1xuICAgICAgICBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KCkgJiYgIXRoaXMuaXNVcHNlcnRRdWVyeSgpICYmIHJvd0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5FbXB0eVJlc3VsdEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcm93c1swXSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocm93c1swXSwga2V5KSkge1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkID0gcm93c1swXVtrZXldO1xuICAgICAgICAgICAgY29uc3QgYXR0ciA9IF8uZmluZCh0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXMsIChhdHRyaWJ1dGUpID0+IGF0dHJpYnV0ZS5maWVsZE5hbWUgPT09IGtleSB8fCBhdHRyaWJ1dGUuZmllbGQgPT09IGtleSk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLmRhdGFWYWx1ZXNbYXR0ciAmJiBhdHRyLmZpZWxkTmFtZSB8fCBrZXldID0gcmVjb3JkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNVcHNlcnRRdWVyeSgpKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgdGhpcy5pbnN0YW5jZSxcbiAgICAgICAgICBudWxsXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICByZXR1cm4gW1xuICAgICAgICB0aGlzLmluc3RhbmNlIHx8IHJvd3MgJiYgKHRoaXMub3B0aW9ucy5wbGFpbiAmJiByb3dzWzBdIHx8IHJvd3MpIHx8IHZvaWQgMCxcbiAgICAgICAgcm93Q291bnRcbiAgICAgIF07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzUmF3UXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFtyb3dzLCBxdWVyeVJlc3VsdF07XG4gICAgfVxuICAgIHJldHVybiByb3dzO1xuICB9XG4gIGZvcm1hdEVycm9yKGVyciwgZXJyU3RhY2spIHtcbiAgICBsZXQgbWF0Y2g7XG4gICAgbGV0IHRhYmxlO1xuICAgIGxldCBpbmRleDtcbiAgICBsZXQgZmllbGRzO1xuICAgIGxldCBlcnJvcnM7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgY29uc3QgY29kZSA9IGVyci5jb2RlIHx8IGVyci5zcWxTdGF0ZTtcbiAgICBjb25zdCBlcnJNZXNzYWdlID0gZXJyLm1lc3NhZ2UgfHwgZXJyLm1lc3NhZ2VQcmltYXJ5O1xuICAgIGNvbnN0IGVyckRldGFpbCA9IGVyci5kZXRhaWwgfHwgZXJyLm1lc3NhZ2VEZXRhaWw7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICBjYXNlIFwiMjM1MDNcIjpcbiAgICAgICAgaW5kZXggPSBlcnJNZXNzYWdlLm1hdGNoKC92aW9sYXRlcyBmb3JlaWduIGtleSBjb25zdHJhaW50IFwiKC4rPylcIi8pO1xuICAgICAgICBpbmRleCA9IGluZGV4ID8gaW5kZXhbMV0gOiB2b2lkIDA7XG4gICAgICAgIHRhYmxlID0gZXJyTWVzc2FnZS5tYXRjaCgvb24gdGFibGUgXCIoLis/KVwiLyk7XG4gICAgICAgIHRhYmxlID0gdGFibGUgPyB0YWJsZVsxXSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogZXJyTWVzc2FnZSxcbiAgICAgICAgICBmaWVsZHM6IG51bGwsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgdGFibGUsXG4gICAgICAgICAgcGFyZW50OiBlcnIsXG4gICAgICAgICAgc3RhY2s6IGVyclN0YWNrXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBcIjIzNTA1XCI6XG4gICAgICAgIGlmIChlcnJEZXRhaWwgJiYgKG1hdGNoID0gZXJyRGV0YWlsLnJlcGxhY2UoL1wiL2csIFwiXCIpLm1hdGNoKC9LZXkgXFwoKC4qPylcXCk9XFwoKC4qPylcXCkvKSkpIHtcbiAgICAgICAgICBmaWVsZHMgPSBfLnppcE9iamVjdChtYXRjaFsxXS5zcGxpdChcIiwgXCIpLCBtYXRjaFsyXS5zcGxpdChcIiwgXCIpKTtcbiAgICAgICAgICBlcnJvcnMgPSBbXTtcbiAgICAgICAgICBtZXNzYWdlID0gXCJWYWxpZGF0aW9uIGVycm9yXCI7XG4gICAgICAgICAgXy5mb3JPd24oZmllbGRzLCAodmFsdWUsIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvckl0ZW0odGhpcy5nZXRVbmlxdWVDb25zdHJhaW50RXJyb3JNZXNzYWdlKGZpZWxkKSwgXCJ1bmlxdWUgdmlvbGF0aW9uXCIsIGZpZWxkLCB2YWx1ZSwgdGhpcy5pbnN0YW5jZSwgXCJub3RfdW5pcXVlXCIpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodGhpcy5tb2RlbCAmJiB0aGlzLm1vZGVsLnVuaXF1ZUtleXMpIHtcbiAgICAgICAgICAgIF8uZm9yT3duKHRoaXMubW9kZWwudW5pcXVlS2V5cywgKGNvbnN0cmFpbnQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKF8uaXNFcXVhbChjb25zdHJhaW50LmZpZWxkcywgT2JqZWN0LmtleXMoZmllbGRzKSkgJiYgISFjb25zdHJhaW50Lm1zZykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBjb25zdHJhaW50Lm1zZztcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5VbmlxdWVDb25zdHJhaW50RXJyb3IoeyBtZXNzYWdlLCBlcnJvcnMsIHBhcmVudDogZXJyLCBmaWVsZHMsIHN0YWNrOiBlcnJTdGFjayB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5VbmlxdWVDb25zdHJhaW50RXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IGVyck1lc3NhZ2UsXG4gICAgICAgICAgcGFyZW50OiBlcnIsXG4gICAgICAgICAgc3RhY2s6IGVyclN0YWNrXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBcIjIzUDAxXCI6XG4gICAgICAgIG1hdGNoID0gZXJyRGV0YWlsLm1hdGNoKC9LZXkgXFwoKC4qPylcXCk9XFwoKC4qPylcXCkvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgZmllbGRzID0gXy56aXBPYmplY3QobWF0Y2hbMV0uc3BsaXQoXCIsIFwiKSwgbWF0Y2hbMl0uc3BsaXQoXCIsIFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZSA9IFwiRXhjbHVzaW9uIGNvbnN0cmFpbnQgZXJyb3JcIjtcbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRXhjbHVzaW9uQ29uc3RyYWludEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgIGNvbnN0cmFpbnQ6IGVyci5jb25zdHJhaW50LFxuICAgICAgICAgIGZpZWxkcyxcbiAgICAgICAgICB0YWJsZTogZXJyLnRhYmxlLFxuICAgICAgICAgIHBhcmVudDogZXJyLFxuICAgICAgICAgIHN0YWNrOiBlcnJTdGFja1xuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCI0MjcwNFwiOlxuICAgICAgICBpZiAoZXJyLnNxbCAmJiAvKENPTlNUUkFJTlR8SU5ERVgpL2dpLnRlc3QoZXJyLnNxbCkpIHtcbiAgICAgICAgICBtZXNzYWdlID0gXCJVbmtub3duIGNvbnN0cmFpbnQgZXJyb3JcIjtcbiAgICAgICAgICBpbmRleCA9IGVyck1lc3NhZ2UubWF0Y2goLyg/OmNvbnN0cmFpbnR8aW5kZXgpIFwiKC4rPylcIi9pKTtcbiAgICAgICAgICBpbmRleCA9IGluZGV4ID8gaW5kZXhbMV0gOiB2b2lkIDA7XG4gICAgICAgICAgdGFibGUgPSBlcnJNZXNzYWdlLm1hdGNoKC9yZWxhdGlvbiBcIiguKz8pXCIvaSk7XG4gICAgICAgICAgdGFibGUgPSB0YWJsZSA/IHRhYmxlWzFdIDogdm9pZCAwO1xuICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5rbm93bkNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgY29uc3RyYWludDogaW5kZXgsXG4gICAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgICAgIHBhcmVudDogZXJyLFxuICAgICAgICAgICAgc3RhY2s6IGVyclN0YWNrXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkRhdGFiYXNlRXJyb3IoZXJyLCB7IHN0YWNrOiBlcnJTdGFjayB9KTtcbiAgICB9XG4gIH1cbiAgaXNGb3JlaWduS2V5c1F1ZXJ5KCkge1xuICAgIHJldHVybiAvU0VMRUNUIGNvbm5hbWUgYXMgY29uc3RyYWludF9uYW1lLCBwZ19jYXRhbG9nXFwucGdfZ2V0X2NvbnN0cmFpbnRkZWZcXChyXFwub2lkLCB0cnVlXFwpIGFzIGNvbmRlZiBGUk9NIHBnX2NhdGFsb2dcXC5wZ19jb25zdHJhaW50IHIgV0hFUkUgclxcLmNvbnJlbGlkID0gXFwoU0VMRUNUIG9pZCBGUk9NIHBnX2NsYXNzIFdIRVJFIHJlbG5hbWUgPSAnLionIExJTUlUIDFcXCkgQU5EIHJcXC5jb250eXBlID0gJ2YnIE9SREVSIEJZIDE7Ly50ZXN0KHRoaXMuc3FsKTtcbiAgfVxuICBnZXRJbnNlcnRJZEZpZWxkKCkge1xuICAgIHJldHVybiBcImlkXCI7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5RdWVyeSA9IFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IFF1ZXJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnkuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/postgres/query.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/postgres/range.js":
/*!****************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/postgres/range.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nfunction stringifyRangeBound(bound) {\n  if (bound === null) {\n    return \"\";\n  }\n  if (bound === Infinity || bound === -Infinity) {\n    return bound.toString().toLowerCase();\n  }\n  return JSON.stringify(bound);\n}\nfunction parseRangeBound(bound, parseType) {\n  if (!bound) {\n    return null;\n  }\n  if (bound === \"infinity\") {\n    return Infinity;\n  }\n  if (bound === \"-infinity\") {\n    return -Infinity;\n  }\n  return parseType(bound);\n}\nfunction stringify(data) {\n  if (data === null)\n    return null;\n  if (!Array.isArray(data))\n    throw new Error(\"range must be an array\");\n  if (!data.length)\n    return \"empty\";\n  if (data.length !== 2)\n    throw new Error(\"range array length must be 0 (empty) or 2 (lower and upper bounds)\");\n  if (Object.prototype.hasOwnProperty.call(data, \"inclusive\")) {\n    if (data.inclusive === false)\n      data.inclusive = [false, false];\n    else if (!data.inclusive)\n      data.inclusive = [true, false];\n    else if (data.inclusive === true)\n      data.inclusive = [true, true];\n  } else {\n    data.inclusive = [true, false];\n  }\n  _.each(data, (value, index) => {\n    if (_.isObject(value)) {\n      if (Object.prototype.hasOwnProperty.call(value, \"inclusive\"))\n        data.inclusive[index] = !!value.inclusive;\n      if (Object.prototype.hasOwnProperty.call(value, \"value\"))\n        data[index] = value.value;\n    }\n  });\n  const lowerBound = stringifyRangeBound(data[0]);\n  const upperBound = stringifyRangeBound(data[1]);\n  return `${(data.inclusive[0] ? \"[\" : \"(\") + lowerBound},${upperBound}${data.inclusive[1] ? \"]\" : \")\"}`;\n}\nexports.stringify = stringify;\nfunction parse(value, parser) {\n  if (value === null)\n    return null;\n  if (value === \"empty\") {\n    return [];\n  }\n  let result = value.substring(1, value.length - 1).split(\",\", 2);\n  if (result.length !== 2)\n    return value;\n  result = result.map((item, index) => {\n    return {\n      value: parseRangeBound(item, parser),\n      inclusive: index === 0 ? value[0] === \"[\" : value[value.length - 1] === \"]\"\n    };\n  });\n  return result;\n}\nexports.parse = parse;\n//# sourceMappingURL=range.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9yYW5nZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFVBQVUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVksNkNBQTZDLEdBQUcsV0FBVyxFQUFFLDhCQUE4QjtBQUN2RztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvcG9zdGdyZXMvcmFuZ2UuanM/MmFiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuZnVuY3Rpb24gc3RyaW5naWZ5UmFuZ2VCb3VuZChib3VuZCkge1xuICBpZiAoYm91bmQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBpZiAoYm91bmQgPT09IEluZmluaXR5IHx8IGJvdW5kID09PSAtSW5maW5pdHkpIHtcbiAgICByZXR1cm4gYm91bmQudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShib3VuZCk7XG59XG5mdW5jdGlvbiBwYXJzZVJhbmdlQm91bmQoYm91bmQsIHBhcnNlVHlwZSkge1xuICBpZiAoIWJvdW5kKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGJvdW5kID09PSBcImluZmluaXR5XCIpIHtcbiAgICByZXR1cm4gSW5maW5pdHk7XG4gIH1cbiAgaWYgKGJvdW5kID09PSBcIi1pbmZpbml0eVwiKSB7XG4gICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgfVxuICByZXR1cm4gcGFyc2VUeXBlKGJvdW5kKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeShkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmFuZ2UgbXVzdCBiZSBhbiBhcnJheVwiKTtcbiAgaWYgKCFkYXRhLmxlbmd0aClcbiAgICByZXR1cm4gXCJlbXB0eVwiO1xuICBpZiAoZGF0YS5sZW5ndGggIT09IDIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmFuZ2UgYXJyYXkgbGVuZ3RoIG11c3QgYmUgMCAoZW1wdHkpIG9yIDIgKGxvd2VyIGFuZCB1cHBlciBib3VuZHMpXCIpO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIFwiaW5jbHVzaXZlXCIpKSB7XG4gICAgaWYgKGRhdGEuaW5jbHVzaXZlID09PSBmYWxzZSlcbiAgICAgIGRhdGEuaW5jbHVzaXZlID0gW2ZhbHNlLCBmYWxzZV07XG4gICAgZWxzZSBpZiAoIWRhdGEuaW5jbHVzaXZlKVxuICAgICAgZGF0YS5pbmNsdXNpdmUgPSBbdHJ1ZSwgZmFsc2VdO1xuICAgIGVsc2UgaWYgKGRhdGEuaW5jbHVzaXZlID09PSB0cnVlKVxuICAgICAgZGF0YS5pbmNsdXNpdmUgPSBbdHJ1ZSwgdHJ1ZV07XG4gIH0gZWxzZSB7XG4gICAgZGF0YS5pbmNsdXNpdmUgPSBbdHJ1ZSwgZmFsc2VdO1xuICB9XG4gIF8uZWFjaChkYXRhLCAodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgaWYgKF8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBcImluY2x1c2l2ZVwiKSlcbiAgICAgICAgZGF0YS5pbmNsdXNpdmVbaW5kZXhdID0gISF2YWx1ZS5pbmNsdXNpdmU7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInZhbHVlXCIpKVxuICAgICAgICBkYXRhW2luZGV4XSA9IHZhbHVlLnZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGxvd2VyQm91bmQgPSBzdHJpbmdpZnlSYW5nZUJvdW5kKGRhdGFbMF0pO1xuICBjb25zdCB1cHBlckJvdW5kID0gc3RyaW5naWZ5UmFuZ2VCb3VuZChkYXRhWzFdKTtcbiAgcmV0dXJuIGAkeyhkYXRhLmluY2x1c2l2ZVswXSA/IFwiW1wiIDogXCIoXCIpICsgbG93ZXJCb3VuZH0sJHt1cHBlckJvdW5kfSR7ZGF0YS5pbmNsdXNpdmVbMV0gPyBcIl1cIiA6IFwiKVwifWA7XG59XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbmZ1bmN0aW9uIHBhcnNlKHZhbHVlLCBwYXJzZXIpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuICBpZiAodmFsdWUgPT09IFwiZW1wdHlcIikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBsZXQgcmVzdWx0ID0gdmFsdWUuc3Vic3RyaW5nKDEsIHZhbHVlLmxlbmd0aCAtIDEpLnNwbGl0KFwiLFwiLCAyKTtcbiAgaWYgKHJlc3VsdC5sZW5ndGggIT09IDIpXG4gICAgcmV0dXJuIHZhbHVlO1xuICByZXN1bHQgPSByZXN1bHQubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogcGFyc2VSYW5nZUJvdW5kKGl0ZW0sIHBhcnNlciksXG4gICAgICBpbmNsdXNpdmU6IGluZGV4ID09PSAwID8gdmFsdWVbMF0gPT09IFwiW1wiIDogdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09IFwiXVwiXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5nZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/postgres/range.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/snowflake/connection-manager.js":
/*!******************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/snowflake/connection-manager.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst SequelizeErrors = __webpack_require__(/*! ../../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(action-browser)/../node_modules/sequelize/lib/utils/logger.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\").snowflake);\nconst debug = logger.debugContext(\"connection:snowflake\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(action-browser)/../node_modules/sequelize/lib/dialects/parserStore.js\")(\"snowflake\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"snowflake-sdk\");\n    this.refreshTypeParser(DataTypes);\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n  async connect(config) {\n    const connectionConfig = __spreadValues({\n      account: config.host,\n      username: config.username,\n      password: config.password,\n      database: config.database,\n      warehouse: config.warehouse,\n      role: config.role\n    }, config.dialectOptions);\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        this.lib.createConnection(connectionConfig).connect((err, conn) => {\n          if (err) {\n            console.log(err);\n            reject(err);\n          } else {\n            resolve(conn);\n          }\n        });\n      });\n      debug(\"connection acquired\");\n      if (!this.sequelize.config.keepDefaultTimezone) {\n        const tzOffset = this.sequelize.options.timezone === \"+00:00\" ? \"Etc/UTC\" : this.sequelize.options.timezone;\n        const isNamedTzOffset = /\\//.test(tzOffset);\n        if (isNamedTzOffset) {\n          await new Promise((resolve, reject) => {\n            connection.execute({\n              sqlText: `ALTER SESSION SET timezone = '${tzOffset}'`,\n              complete(err) {\n                if (err) {\n                  console.log(err);\n                  reject(err);\n                } else {\n                  resolve();\n                }\n              }\n            });\n          });\n        } else {\n          throw Error(\"only support time zone name for snowflake!\");\n        }\n      }\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case \"ECONNREFUSED\":\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case \"ER_ACCESS_DENIED_ERROR\":\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case \"ENOTFOUND\":\n          throw new SequelizeErrors.HostNotFoundError(err);\n        case \"EHOSTUNREACH\":\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case \"EINVAL\":\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n  async disconnect(connection) {\n    if (!connection.isUp()) {\n      debug(\"connection tried to disconnect but was already at CLOSED state\");\n      return;\n    }\n    return new Promise((resolve, reject) => {\n      connection.destroy((err) => {\n        if (err) {\n          console.error(`Unable to disconnect: ${err.message}`);\n          reject(err);\n        } else {\n          console.log(`Disconnected connection with id: ${connection.getId()}`);\n          resolve(connection.getId());\n        }\n      });\n    });\n  }\n  validate(connection) {\n    return connection.isUp();\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvY29ubmVjdGlvbi1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLDhIQUFnQztBQUMxRSx3QkFBd0IsbUJBQU8sQ0FBQyxvRkFBYztBQUM5QyxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDBGQUFvQjtBQUMvQyxrQkFBa0IsdUhBQXFDO0FBQ3ZEO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsOEZBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsU0FBUztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsWUFBWTtBQUM3RDtBQUNBLFVBQVU7QUFDViwwREFBMEQsbUJBQW1CO0FBQzdFO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyx5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvc25vd2ZsYWtlL2Nvbm5lY3Rpb24tbWFuYWdlci5qcz84MmEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xuY29uc3QgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9jb25uZWN0aW9uLW1hbmFnZXJcIik7XG5jb25zdCBTZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzXCIpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9sb2dnZXJcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKS5zbm93Zmxha2U7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoXCJjb25uZWN0aW9uOnNub3dmbGFrZVwiKTtcbmNvbnN0IHBhcnNlclN0b3JlID0gcmVxdWlyZShcIi4uL3BhcnNlclN0b3JlXCIpKFwic25vd2ZsYWtlXCIpO1xuY2xhc3MgQ29ubmVjdGlvbk1hbmFnZXIgZXh0ZW5kcyBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZGlhbGVjdCwgc2VxdWVsaXplKSB7XG4gICAgc2VxdWVsaXplLmNvbmZpZy5wb3J0ID0gc2VxdWVsaXplLmNvbmZpZy5wb3J0IHx8IDMzMDY7XG4gICAgc3VwZXIoZGlhbGVjdCwgc2VxdWVsaXplKTtcbiAgICB0aGlzLmxpYiA9IHRoaXMuX2xvYWREaWFsZWN0TW9kdWxlKFwic25vd2ZsYWtlLXNka1wiKTtcbiAgICB0aGlzLnJlZnJlc2hUeXBlUGFyc2VyKERhdGFUeXBlcyk7XG4gIH1cbiAgX3JlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlKSB7XG4gICAgcGFyc2VyU3RvcmUucmVmcmVzaChkYXRhVHlwZSk7XG4gIH1cbiAgX2NsZWFyVHlwZVBhcnNlcigpIHtcbiAgICBwYXJzZXJTdG9yZS5jbGVhcigpO1xuICB9XG4gIHN0YXRpYyBfdHlwZWNhc3QoZmllbGQsIG5leHQpIHtcbiAgICBpZiAocGFyc2VyU3RvcmUuZ2V0KGZpZWxkLnR5cGUpKSB7XG4gICAgICByZXR1cm4gcGFyc2VyU3RvcmUuZ2V0KGZpZWxkLnR5cGUpKGZpZWxkLCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLCBuZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQoKTtcbiAgfVxuICBhc3luYyBjb25uZWN0KGNvbmZpZykge1xuICAgIGNvbnN0IGNvbm5lY3Rpb25Db25maWcgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBhY2NvdW50OiBjb25maWcuaG9zdCxcbiAgICAgIHVzZXJuYW1lOiBjb25maWcudXNlcm5hbWUsXG4gICAgICBwYXNzd29yZDogY29uZmlnLnBhc3N3b3JkLFxuICAgICAgZGF0YWJhc2U6IGNvbmZpZy5kYXRhYmFzZSxcbiAgICAgIHdhcmVob3VzZTogY29uZmlnLndhcmVob3VzZSxcbiAgICAgIHJvbGU6IGNvbmZpZy5yb2xlXG4gICAgfSwgY29uZmlnLmRpYWxlY3RPcHRpb25zKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5saWIuY3JlYXRlQ29ubmVjdGlvbihjb25uZWN0aW9uQ29uZmlnKS5jb25uZWN0KChlcnIsIGNvbm4pID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoY29ubik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZGVidWcoXCJjb25uZWN0aW9uIGFjcXVpcmVkXCIpO1xuICAgICAgaWYgKCF0aGlzLnNlcXVlbGl6ZS5jb25maWcua2VlcERlZmF1bHRUaW1lem9uZSkge1xuICAgICAgICBjb25zdCB0ek9mZnNldCA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMudGltZXpvbmUgPT09IFwiKzAwOjAwXCIgPyBcIkV0Yy9VVENcIiA6IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMudGltZXpvbmU7XG4gICAgICAgIGNvbnN0IGlzTmFtZWRUek9mZnNldCA9IC9cXC8vLnRlc3QodHpPZmZzZXQpO1xuICAgICAgICBpZiAoaXNOYW1lZFR6T2Zmc2V0KSB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29ubmVjdGlvbi5leGVjdXRlKHtcbiAgICAgICAgICAgICAgc3FsVGV4dDogYEFMVEVSIFNFU1NJT04gU0VUIHRpbWV6b25lID0gJyR7dHpPZmZzZXR9J2AsXG4gICAgICAgICAgICAgIGNvbXBsZXRlKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJvbmx5IHN1cHBvcnQgdGltZSB6b25lIG5hbWUgZm9yIHNub3dmbGFrZSFcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc3dpdGNoIChlcnIuY29kZSkge1xuICAgICAgICBjYXNlIFwiRUNPTk5SRUZVU0VEXCI6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uUmVmdXNlZEVycm9yKGVycik7XG4gICAgICAgIGNhc2UgXCJFUl9BQ0NFU1NfREVOSUVEX0VSUk9SXCI6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5BY2Nlc3NEZW5pZWRFcnJvcihlcnIpO1xuICAgICAgICBjYXNlIFwiRU5PVEZPVU5EXCI6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90Rm91bmRFcnJvcihlcnIpO1xuICAgICAgICBjYXNlIFwiRUhPU1RVTlJFQUNIXCI6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90UmVhY2hhYmxlRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSBcIkVJTlZBTFwiOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuSW52YWxpZENvbm5lY3Rpb25FcnJvcihlcnIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvbkVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGRpc2Nvbm5lY3QoY29ubmVjdGlvbikge1xuICAgIGlmICghY29ubmVjdGlvbi5pc1VwKCkpIHtcbiAgICAgIGRlYnVnKFwiY29ubmVjdGlvbiB0cmllZCB0byBkaXNjb25uZWN0IGJ1dCB3YXMgYWxyZWFkeSBhdCBDTE9TRUQgc3RhdGVcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25uZWN0aW9uLmRlc3Ryb3koKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgVW5hYmxlIHRvIGRpc2Nvbm5lY3Q6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYERpc2Nvbm5lY3RlZCBjb25uZWN0aW9uIHdpdGggaWQ6ICR7Y29ubmVjdGlvbi5nZXRJZCgpfWApO1xuICAgICAgICAgIHJlc29sdmUoY29ubmVjdGlvbi5nZXRJZCgpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgdmFsaWRhdGUoY29ubmVjdGlvbikge1xuICAgIHJldHVybiBjb25uZWN0aW9uLmlzVXAoKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25NYW5hZ2VyID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdGlvbk1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aW9uLW1hbmFnZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/snowflake/connection-manager.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/snowflake/data-types.js":
/*!**********************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/snowflake/data-types.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(action-browser)/../node_modules/moment-timezone/index.js\");\nconst moment = __webpack_require__(/*! moment */ \"(action-browser)/../node_modules/moment/moment.js\");\nmodule.exports = (BaseTypes) => {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = \"https://dev.snowflake.com/doc/refman/5.7/en/data-types.html\";\n  BaseTypes.DATE.types.snowflake = [\"DATETIME\"];\n  BaseTypes.STRING.types.snowflake = [\"VAR_STRING\"];\n  BaseTypes.CHAR.types.snowflake = [\"STRING\"];\n  BaseTypes.TEXT.types.snowflake = [\"BLOB\"];\n  BaseTypes.TINYINT.types.snowflake = [\"TINY\"];\n  BaseTypes.SMALLINT.types.snowflake = [\"SHORT\"];\n  BaseTypes.MEDIUMINT.types.snowflake = [\"INT24\"];\n  BaseTypes.INTEGER.types.snowflake = [\"LONG\"];\n  BaseTypes.BIGINT.types.snowflake = [\"LONGLONG\"];\n  BaseTypes.FLOAT.types.snowflake = [\"FLOAT\"];\n  BaseTypes.TIME.types.snowflake = [\"TIME\"];\n  BaseTypes.DATEONLY.types.snowflake = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.snowflake = [\"TINY\"];\n  BaseTypes.BLOB.types.snowflake = [\"TINYBLOB\", \"BLOB\", \"LONGBLOB\"];\n  BaseTypes.DECIMAL.types.snowflake = [\"NEWDECIMAL\"];\n  BaseTypes.UUID.types.snowflake = false;\n  BaseTypes.ENUM.types.snowflake = false;\n  BaseTypes.REAL.types.snowflake = [\"DOUBLE\"];\n  BaseTypes.DOUBLE.types.snowflake = [\"DOUBLE\"];\n  BaseTypes.GEOMETRY.types.snowflake = [\"GEOMETRY\"];\n  BaseTypes.JSON.types.snowflake = [\"JSON\"];\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return \"TIMESTAMP\";\n    }\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n      if (this._length) {\n        return date.format(\"YYYY-MM-DD HH:mm:ss.SSS\");\n      }\n      return date.format(\"YYYY-MM-DD HH:mm:ss\");\n    }\n    static parse(value, options) {\n      value = value.string();\n      if (value === null) {\n        return value;\n      }\n      if (momentTz.tz.zone(options.timezone)) {\n        value = momentTz.tz(value, options.timezone).toDate();\n      } else {\n        value = new Date(`${value} ${options.timezone}`);\n      }\n      return value;\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return value.string();\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"VARCHAR(36)\";\n    }\n  }\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      return \"TEXT\";\n    }\n  }\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"BOOLEAN\";\n    }\n  }\n  class JSONTYPE extends BaseTypes.JSON {\n    _stringify(value, options) {\n      return options.operation === \"where\" && typeof value === \"string\" ? value : JSON.stringify(value);\n    }\n  }\n  return {\n    TEXT,\n    DATE,\n    BOOLEAN,\n    DATEONLY,\n    UUID,\n    JSON: JSONTYPE\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvZGF0YS10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGlCQUFpQixtQkFBTyxDQUFDLGtGQUFpQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMsaUVBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNEJBQTRCLE9BQU8sRUFBRSxpQkFBaUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Nub3dmbGFrZS9kYXRhLXR5cGVzLmpzP2U3N2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBtb21lbnRUeiA9IHJlcXVpcmUoXCJtb21lbnQtdGltZXpvbmVcIik7XG5jb25zdCBtb21lbnQgPSByZXF1aXJlKFwibW9tZW50XCIpO1xubW9kdWxlLmV4cG9ydHMgPSAoQmFzZVR5cGVzKSA9PiB7XG4gIEJhc2VUeXBlcy5BQlNUUkFDVC5wcm90b3R5cGUuZGlhbGVjdFR5cGVzID0gXCJodHRwczovL2Rldi5zbm93Zmxha2UuY29tL2RvYy9yZWZtYW4vNS43L2VuL2RhdGEtdHlwZXMuaHRtbFwiO1xuICBCYXNlVHlwZXMuREFURS50eXBlcy5zbm93Zmxha2UgPSBbXCJEQVRFVElNRVwiXTtcbiAgQmFzZVR5cGVzLlNUUklORy50eXBlcy5zbm93Zmxha2UgPSBbXCJWQVJfU1RSSU5HXCJdO1xuICBCYXNlVHlwZXMuQ0hBUi50eXBlcy5zbm93Zmxha2UgPSBbXCJTVFJJTkdcIl07XG4gIEJhc2VUeXBlcy5URVhULnR5cGVzLnNub3dmbGFrZSA9IFtcIkJMT0JcIl07XG4gIEJhc2VUeXBlcy5USU5ZSU5ULnR5cGVzLnNub3dmbGFrZSA9IFtcIlRJTllcIl07XG4gIEJhc2VUeXBlcy5TTUFMTElOVC50eXBlcy5zbm93Zmxha2UgPSBbXCJTSE9SVFwiXTtcbiAgQmFzZVR5cGVzLk1FRElVTUlOVC50eXBlcy5zbm93Zmxha2UgPSBbXCJJTlQyNFwiXTtcbiAgQmFzZVR5cGVzLklOVEVHRVIudHlwZXMuc25vd2ZsYWtlID0gW1wiTE9OR1wiXTtcbiAgQmFzZVR5cGVzLkJJR0lOVC50eXBlcy5zbm93Zmxha2UgPSBbXCJMT05HTE9OR1wiXTtcbiAgQmFzZVR5cGVzLkZMT0FULnR5cGVzLnNub3dmbGFrZSA9IFtcIkZMT0FUXCJdO1xuICBCYXNlVHlwZXMuVElNRS50eXBlcy5zbm93Zmxha2UgPSBbXCJUSU1FXCJdO1xuICBCYXNlVHlwZXMuREFURU9OTFkudHlwZXMuc25vd2ZsYWtlID0gW1wiREFURVwiXTtcbiAgQmFzZVR5cGVzLkJPT0xFQU4udHlwZXMuc25vd2ZsYWtlID0gW1wiVElOWVwiXTtcbiAgQmFzZVR5cGVzLkJMT0IudHlwZXMuc25vd2ZsYWtlID0gW1wiVElOWUJMT0JcIiwgXCJCTE9CXCIsIFwiTE9OR0JMT0JcIl07XG4gIEJhc2VUeXBlcy5ERUNJTUFMLnR5cGVzLnNub3dmbGFrZSA9IFtcIk5FV0RFQ0lNQUxcIl07XG4gIEJhc2VUeXBlcy5VVUlELnR5cGVzLnNub3dmbGFrZSA9IGZhbHNlO1xuICBCYXNlVHlwZXMuRU5VTS50eXBlcy5zbm93Zmxha2UgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLlJFQUwudHlwZXMuc25vd2ZsYWtlID0gW1wiRE9VQkxFXCJdO1xuICBCYXNlVHlwZXMuRE9VQkxFLnR5cGVzLnNub3dmbGFrZSA9IFtcIkRPVUJMRVwiXTtcbiAgQmFzZVR5cGVzLkdFT01FVFJZLnR5cGVzLnNub3dmbGFrZSA9IFtcIkdFT01FVFJZXCJdO1xuICBCYXNlVHlwZXMuSlNPTi50eXBlcy5zbm93Zmxha2UgPSBbXCJKU09OXCJdO1xuICBjbGFzcyBEQVRFIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEUge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiVElNRVNUQU1QXCI7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkoZGF0ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFtb21lbnQuaXNNb21lbnQoZGF0ZSkpIHtcbiAgICAgICAgZGF0ZSA9IHRoaXMuX2FwcGx5VGltZXpvbmUoZGF0ZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBkYXRlLmZvcm1hdChcIllZWVktTU0tREQgSEg6bW06c3MuU1NTXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGUuZm9ybWF0KFwiWVlZWS1NTS1ERCBISDptbTpzc1wiKTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnN0cmluZygpO1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChtb21lbnRUei50ei56b25lKG9wdGlvbnMudGltZXpvbmUpKSB7XG4gICAgICAgIHZhbHVlID0gbW9tZW50VHoudHoodmFsdWUsIG9wdGlvbnMudGltZXpvbmUpLnRvRGF0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZShgJHt2YWx1ZX0gJHtvcHRpb25zLnRpbWV6b25lfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICBjbGFzcyBEQVRFT05MWSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFT05MWSB7XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUuc3RyaW5nKCk7XG4gICAgfVxuICB9XG4gIGNsYXNzIFVVSUQgZXh0ZW5kcyBCYXNlVHlwZXMuVVVJRCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJWQVJDSEFSKDM2KVwiO1xuICAgIH1cbiAgfVxuICBjbGFzcyBURVhUIGV4dGVuZHMgQmFzZVR5cGVzLlRFWFQge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiVEVYVFwiO1xuICAgIH1cbiAgfVxuICBjbGFzcyBCT09MRUFOIGV4dGVuZHMgQmFzZVR5cGVzLkJPT0xFQU4ge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiQk9PTEVBTlwiO1xuICAgIH1cbiAgfVxuICBjbGFzcyBKU09OVFlQRSBleHRlbmRzIEJhc2VUeXBlcy5KU09OIHtcbiAgICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5vcGVyYXRpb24gPT09IFwid2hlcmVcIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBURVhULFxuICAgIERBVEUsXG4gICAgQk9PTEVBTixcbiAgICBEQVRFT05MWSxcbiAgICBVVUlELFxuICAgIEpTT046IEpTT05UWVBFXG4gIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS10eXBlcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/snowflake/data-types.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/snowflake/index.js":
/*!*****************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/snowflake/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst AbstractDialect = __webpack_require__(/*! ../abstract */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst ConnectionManager = __webpack_require__(/*! ./connection-manager */ \"(action-browser)/../node_modules/sequelize/lib/dialects/snowflake/connection-manager.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(action-browser)/../node_modules/sequelize/lib/dialects/snowflake/query.js\");\nconst QueryGenerator = __webpack_require__(/*! ./query-generator */ \"(action-browser)/../node_modules/sequelize/lib/dialects/snowflake/query-generator.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\").snowflake);\nconst { SnowflakeQueryInterface } = __webpack_require__(/*! ./query-interface */ \"(action-browser)/../node_modules/sequelize/lib/dialects/snowflake/query-interface.js\");\nclass SnowflakeDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new SnowflakeQueryInterface(sequelize, this.queryGenerator);\n  }\n}\nSnowflakeDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  \"VALUES ()\": true,\n  \"LIMIT ON UPDATE\": true,\n  lock: true,\n  forShare: \"LOCK IN SHARE MODE\",\n  settingIsolationLevelDuringTransaction: false,\n  inserts: {\n    ignoreDuplicates: \" IGNORE\",\n    updateOnDuplicate: false\n  },\n  index: {\n    collate: false,\n    length: true,\n    parser: true,\n    type: true,\n    using: 1\n  },\n  constraints: {\n    dropConstraint: false,\n    check: false\n  },\n  indexViaAlter: true,\n  indexHints: true,\n  NUMERIC: true,\n  GEOMETRY: false,\n  JSON: false,\n  REGEXP: true,\n  schemas: true\n});\nSnowflakeDialect.prototype.defaultVersion = \"5.7.0\";\nSnowflakeDialect.prototype.Query = Query;\nSnowflakeDialect.prototype.QueryGenerator = QueryGenerator;\nSnowflakeDialect.prototype.DataTypes = DataTypes;\nSnowflakeDialect.prototype.name = \"snowflake\";\nSnowflakeDialect.prototype.TICK_CHAR = '\"';\nSnowflakeDialect.prototype.TICK_CHAR_LEFT = SnowflakeDialect.prototype.TICK_CHAR;\nSnowflakeDialect.prototype.TICK_CHAR_RIGHT = SnowflakeDialect.prototype.TICK_CHAR;\nmodule.exports = SnowflakeDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixVQUFVLG1CQUFPLENBQUMsaUVBQVE7QUFDMUIsd0JBQXdCLG1CQUFPLENBQUMsOEZBQWE7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMscUhBQXNCO0FBQ3hELGNBQWMsbUJBQU8sQ0FBQywyRkFBUztBQUMvQix1QkFBdUIsbUJBQU8sQ0FBQywrR0FBbUI7QUFDbEQsa0JBQWtCLHVIQUFxQztBQUN2RCxRQUFRLDBCQUEwQixFQUFFLG1CQUFPLENBQUMsK0dBQW1CO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvc25vd2ZsYWtlL2luZGV4LmpzPzA2NzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IEFic3RyYWN0RGlhbGVjdCA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdFwiKTtcbmNvbnN0IENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4vY29ubmVjdGlvbi1tYW5hZ2VyXCIpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKFwiLi9xdWVyeVwiKTtcbmNvbnN0IFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZShcIi4vcXVlcnktZ2VuZXJhdG9yXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIikuc25vd2ZsYWtlO1xuY29uc3QgeyBTbm93Zmxha2VRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZShcIi4vcXVlcnktaW50ZXJmYWNlXCIpO1xuY2xhc3MgU25vd2ZsYWtlRGlhbGVjdCBleHRlbmRzIEFic3RyYWN0RGlhbGVjdCB7XG4gIGNvbnN0cnVjdG9yKHNlcXVlbGl6ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBDb25uZWN0aW9uTWFuYWdlcih0aGlzLCBzZXF1ZWxpemUpO1xuICAgIHRoaXMucXVlcnlHZW5lcmF0b3IgPSBuZXcgUXVlcnlHZW5lcmF0b3Ioe1xuICAgICAgX2RpYWxlY3Q6IHRoaXMsXG4gICAgICBzZXF1ZWxpemVcbiAgICB9KTtcbiAgICB0aGlzLnF1ZXJ5SW50ZXJmYWNlID0gbmV3IFNub3dmbGFrZVF1ZXJ5SW50ZXJmYWNlKHNlcXVlbGl6ZSwgdGhpcy5xdWVyeUdlbmVyYXRvcik7XG4gIH1cbn1cblNub3dmbGFrZURpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzID0gXy5tZXJnZShfLmNsb25lRGVlcChBYnN0cmFjdERpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzKSwge1xuICBcIlZBTFVFUyAoKVwiOiB0cnVlLFxuICBcIkxJTUlUIE9OIFVQREFURVwiOiB0cnVlLFxuICBsb2NrOiB0cnVlLFxuICBmb3JTaGFyZTogXCJMT0NLIElOIFNIQVJFIE1PREVcIixcbiAgc2V0dGluZ0lzb2xhdGlvbkxldmVsRHVyaW5nVHJhbnNhY3Rpb246IGZhbHNlLFxuICBpbnNlcnRzOiB7XG4gICAgaWdub3JlRHVwbGljYXRlczogXCIgSUdOT1JFXCIsXG4gICAgdXBkYXRlT25EdXBsaWNhdGU6IGZhbHNlXG4gIH0sXG4gIGluZGV4OiB7XG4gICAgY29sbGF0ZTogZmFsc2UsXG4gICAgbGVuZ3RoOiB0cnVlLFxuICAgIHBhcnNlcjogdHJ1ZSxcbiAgICB0eXBlOiB0cnVlLFxuICAgIHVzaW5nOiAxXG4gIH0sXG4gIGNvbnN0cmFpbnRzOiB7XG4gICAgZHJvcENvbnN0cmFpbnQ6IGZhbHNlLFxuICAgIGNoZWNrOiBmYWxzZVxuICB9LFxuICBpbmRleFZpYUFsdGVyOiB0cnVlLFxuICBpbmRleEhpbnRzOiB0cnVlLFxuICBOVU1FUklDOiB0cnVlLFxuICBHRU9NRVRSWTogZmFsc2UsXG4gIEpTT046IGZhbHNlLFxuICBSRUdFWFA6IHRydWUsXG4gIHNjaGVtYXM6IHRydWVcbn0pO1xuU25vd2ZsYWtlRGlhbGVjdC5wcm90b3R5cGUuZGVmYXVsdFZlcnNpb24gPSBcIjUuNy4wXCI7XG5Tbm93Zmxha2VEaWFsZWN0LnByb3RvdHlwZS5RdWVyeSA9IFF1ZXJ5O1xuU25vd2ZsYWtlRGlhbGVjdC5wcm90b3R5cGUuUXVlcnlHZW5lcmF0b3IgPSBRdWVyeUdlbmVyYXRvcjtcblNub3dmbGFrZURpYWxlY3QucHJvdG90eXBlLkRhdGFUeXBlcyA9IERhdGFUeXBlcztcblNub3dmbGFrZURpYWxlY3QucHJvdG90eXBlLm5hbWUgPSBcInNub3dmbGFrZVwiO1xuU25vd2ZsYWtlRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSID0gJ1wiJztcblNub3dmbGFrZURpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9MRUZUID0gU25vd2ZsYWtlRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSO1xuU25vd2ZsYWtlRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX1JJR0hUID0gU25vd2ZsYWtlRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSO1xubW9kdWxlLmV4cG9ydHMgPSBTbm93Zmxha2VEaWFsZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/snowflake/index.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/snowflake/query-generator.js":
/*!***************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/snowflake/query-generator.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-generator.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst Op = __webpack_require__(/*! ../../operators */ \"(action-browser)/../node_modules/sequelize/lib/operators.js\");\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst FOREIGN_KEY_FIELDS = [\n  \"CONSTRAINT_NAME as constraint_name\",\n  \"CONSTRAINT_NAME as constraintName\",\n  \"CONSTRAINT_SCHEMA as constraintSchema\",\n  \"CONSTRAINT_SCHEMA as constraintCatalog\",\n  \"TABLE_NAME as tableName\",\n  \"TABLE_SCHEMA as tableSchema\",\n  \"TABLE_SCHEMA as tableCatalog\",\n  \"COLUMN_NAME as columnName\",\n  \"REFERENCED_TABLE_SCHEMA as referencedTableSchema\",\n  \"REFERENCED_TABLE_SCHEMA as referencedTableCatalog\",\n  \"REFERENCED_TABLE_NAME as referencedTableName\",\n  \"REFERENCED_COLUMN_NAME as referencedColumnName\"\n].join(\",\");\nconst SNOWFLAKE_RESERVED_WORDS = \"account,all,alter,and,any,as,between,by,case,cast,check,column,connect,connections,constraint,create,cross,current,current_date,current_time,current_timestamp,current_user,database,delete,distinct,drop,else,exists,false,following,for,from,full,grant,group,gscluster,having,ilike,in,increment,inner,insert,intersect,into,is,issue,join,lateral,left,like,localtime,localtimestamp,minus,natural,not,null,of,on,or,order,organization,qualify,regexp,revoke,right,rlike,row,rows,sample,schema,select,set,some,start,table,tablesample,then,to,trigger,true,try_cast,union,unique,update,using,values,view,when,whenever,where,with\".split(\",\");\nconst typeWithoutDefault = /* @__PURE__ */ new Set([\"BLOB\", \"TEXT\", \"GEOMETRY\", \"JSON\"]);\nclass SnowflakeQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n    this.OperatorMap = __spreadProps(__spreadValues({}, this.OperatorMap), {\n      [Op.regexp]: \"REGEXP\",\n      [Op.notRegexp]: \"NOT REGEXP\"\n    });\n  }\n  createDatabaseQuery(databaseName, options) {\n    options = __spreadValues({\n      charset: null,\n      collate: null\n    }, options);\n    return Utils.joinSQLFragments([\n      \"CREATE DATABASE IF NOT EXISTS\",\n      this.quoteIdentifier(databaseName),\n      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,\n      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,\n      \";\"\n    ]);\n  }\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;\n  }\n  createSchema() {\n    return \"SHOW TABLES\";\n  }\n  showSchemasQuery() {\n    return \"SHOW TABLES\";\n  }\n  versionQuery() {\n    return \"SELECT CURRENT_VERSION()\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    options = __spreadValues({\n      charset: null,\n      rowFormat: null\n    }, options);\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr))\n        continue;\n      const dataType = attributes[attr];\n      let match;\n      if (dataType.includes(\"PRIMARY KEY\")) {\n        primaryKeys.push(attr);\n        if (dataType.includes(\"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace(\"PRIMARY KEY\", \"\")}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace(\"PRIMARY KEY\", \"\")}`);\n        }\n      } else if (dataType.includes(\"REFERENCES\")) {\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(\", \");\n    const pkString = primaryKeys.map((pk) => this.quoteIdentifier(pk)).join(\", \");\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== \"string\") {\n            indexName = `uniq_${tableName}_${columns.fields.join(\"_\")}`;\n          }\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n    return Utils.joinSQLFragments([\n      \"CREATE TABLE IF NOT EXISTS\",\n      table,\n      `(${attributesClause})`,\n      options.comment && typeof options.comment === \"string\" && `COMMENT ${this.escape(options.comment)}`,\n      options.charset && `DEFAULT CHARSET=${options.charset}`,\n      options.collate && `COLLATE ${options.collate}`,\n      options.rowFormat && `ROW_FORMAT=${options.rowFormat}`,\n      \";\"\n    ]);\n  }\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(this.addSchema({\n      tableName,\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter\n    }));\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n  showTablesQuery(database) {\n    return Utils.joinSQLFragments([\n      \"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'\",\n      database ? `AND TABLE_SCHEMA = ${this.escape(database)}` : \"AND TABLE_SCHEMA NOT IN ( 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA', 'SYS')\",\n      \";\"\n    ]);\n  }\n  tableExistsQuery(table) {\n    const tableName = table.tableName || table;\n    const schema = table.schema;\n    return Utils.joinSQLFragments([\n      \"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'\",\n      `AND TABLE_SCHEMA = ${schema !== void 0 ? this.escape(schema) : \"CURRENT_SCHEMA()\"}`,\n      `AND TABLE_NAME = ${this.escape(tableName)}`,\n      \";\"\n    ]);\n  }\n  addColumnQuery(table, key, dataType) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(table),\n      \"ADD\",\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, {\n        context: \"addColumn\",\n        tableName: table,\n        foreignKey: key\n      }),\n      \";\"\n    ]);\n  }\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP\",\n      this.quoteIdentifier(attributeName),\n      \";\"\n    ]);\n  }\n  changeColumnQuery(tableName, attributes) {\n    const query = (...subQuerys) => Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"ALTER COLUMN\",\n      ...subQuerys,\n      \";\"\n    ]);\n    const sql = [];\n    for (const attributeName in attributes) {\n      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n      const attrSql = [];\n      if (definition.includes(\"NOT NULL\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"SET NOT NULL\"));\n        definition = definition.replace(\"NOT NULL\", \"\").trim();\n      } else if (!definition.includes(\"REFERENCES\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"DROP NOT NULL\"));\n      }\n      if (definition.includes(\"DEFAULT\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"SET DEFAULT\", definition.match(/DEFAULT ([^;]+)/)[1]));\n        definition = definition.replace(/(DEFAULT[^;]+)/, \"\").trim();\n      } else if (!definition.includes(\"REFERENCES\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"DROP DEFAULT\"));\n      }\n      if (definition.match(/UNIQUE;*$/)) {\n        definition = definition.replace(/UNIQUE;*$/, \"\");\n        attrSql.push(query(\"ADD UNIQUE (\", this.quoteIdentifier(attributeName), \")\").replace(\"ALTER COLUMN\", \"\"));\n      }\n      if (definition.includes(\"REFERENCES\")) {\n        definition = definition.replace(/.+?(?=REFERENCES)/, \"\");\n        attrSql.push(query(\"ADD FOREIGN KEY (\", this.quoteIdentifier(attributeName), \")\", definition).replace(\"ALTER COLUMN\", \"\"));\n      } else {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"TYPE\", definition));\n      }\n      sql.push(attrSql.join(\"\"));\n    }\n    return sql.join(\"\");\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`'${attrBefore}' '${attrName}' ${definition}`);\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"RENAME COLUMN\",\n      attrString.join(\" to \"),\n      \";\"\n    ]);\n  }\n  handleSequelizeMethod(attr, tableName, factory, options, prepend) {\n    if (attr instanceof Utils.Json) {\n      if (attr.conditions) {\n        const conditions = this.parseConditionObject(attr.conditions).map((condition) => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(\" AND \");\n      }\n      if (attr.path) {\n        let str;\n        if (this._checkValidJsonStatement(attr.path)) {\n          str = attr.path;\n        } else {\n          const paths = _.toPath(attr.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n        if (attr.value) {\n          str += util.format(\" = %s\", this.escape(attr.value));\n        }\n        return str;\n      }\n    } else if (attr instanceof Utils.Cast) {\n      if (/timestamp/i.test(attr.type)) {\n        attr.type = \"datetime\";\n      } else if (attr.json && /boolean/i.test(attr.type)) {\n        attr.type = \"char\";\n      } else if (/double precision/i.test(attr.type) || /boolean/i.test(attr.type) || /integer/i.test(attr.type)) {\n        attr.type = \"decimal\";\n      } else if (/text/i.test(attr.type)) {\n        attr.type = \"char\";\n      }\n    }\n    return super.handleSequelizeMethod(attr, tableName, factory, options, prepend);\n  }\n  truncateTableQuery(tableName) {\n    return Utils.joinSQLFragments([\n      \"TRUNCATE\",\n      this.quoteTable(tableName)\n    ]);\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    const limit = options.limit && ` LIMIT ${this.escape(options.limit)}`;\n    let primaryKeys = \"\";\n    let primaryKeysSelection = \"\";\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n    if (limit) {\n      if (!model) {\n        throw new Error(\"Cannot LIMIT delete without a model.\");\n      }\n      const pks = Object.values(model.primaryKeys).map((pk) => this.quoteIdentifier(pk.field)).join(\",\");\n      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;\n      primaryKeysSelection = pks;\n      return Utils.joinSQLFragments([\n        \"DELETE FROM\",\n        table,\n        \"WHERE\",\n        primaryKeys,\n        \"IN (SELECT\",\n        primaryKeysSelection,\n        \"FROM\",\n        table,\n        whereClause,\n        limit,\n        \")\",\n        \";\"\n      ]);\n    }\n    return Utils.joinSQLFragments([\n      \"DELETE FROM\",\n      table,\n      whereClause,\n      \";\"\n    ]);\n  }\n  showIndexesQuery() {\n    return \"SELECT '' FROM DUAL\";\n  }\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    return Utils.joinSQLFragments([\n      \"SELECT CONSTRAINT_CATALOG AS constraintCatalog,\",\n      \"CONSTRAINT_NAME AS constraintName,\",\n      \"CONSTRAINT_SCHEMA AS constraintSchema,\",\n      \"CONSTRAINT_TYPE AS constraintType,\",\n      \"TABLE_NAME AS tableName,\",\n      \"TABLE_SCHEMA AS tableSchema\",\n      \"from INFORMATION_SCHEMA.TABLE_CONSTRAINTS\",\n      `WHERE table_name='${tableName}'`,\n      constraintName && `AND constraint_name = '${constraintName}'`,\n      schemaName && `AND TABLE_SCHEMA = '${schemaName}'`,\n      \";\"\n    ]);\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return Utils.joinSQLFragments([\n      \"DROP INDEX\",\n      this.quoteIdentifier(indexName),\n      \"ON\",\n      this.quoteTable(tableName),\n      \";\"\n    ]);\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });\n    let template = attributeString;\n    if (attribute.allowNull === false) {\n      template += \" NOT NULL\";\n    }\n    if (attribute.autoIncrement) {\n      template += \" AUTOINCREMENT\";\n    }\n    if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.unique === true) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n    if (attribute.first) {\n      template += \" FIRST\";\n    }\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n    if (attribute.references) {\n      if (options && options.context === \"addColumn\" && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {};\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n    return result;\n  }\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n      break;\n    }\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n    return hasJsonFunction;\n  }\n  dataTypeMapping(tableName, attr, dataType) {\n    if (dataType.includes(\"PRIMARY KEY\")) {\n      dataType = dataType.replace(\"PRIMARY KEY\", \"\");\n    }\n    if (dataType.includes(\"SERIAL\")) {\n      if (dataType.includes(\"BIGINT\")) {\n        dataType = dataType.replace(\"SERIAL\", \"BIGSERIAL\");\n        dataType = dataType.replace(\"BIGINT\", \"\");\n      } else if (dataType.includes(\"SMALLINT\")) {\n        dataType = dataType.replace(\"SERIAL\", \"SMALLSERIAL\");\n        dataType = dataType.replace(\"SMALLINT\", \"\");\n      } else {\n        dataType = dataType.replace(\"INTEGER\", \"\");\n      }\n      dataType = dataType.replace(\"NOT NULL\", \"\");\n    }\n    return dataType;\n  }\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\n      \"SELECT\",\n      FOREIGN_KEY_FIELDS,\n      `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`,\n      `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`,\n      \"AND REFERENCED_TABLE_NAME IS NOT NULL\",\n      \";\"\n    ]);\n  }\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : \"\";\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n    return Utils.joinSQLFragments([\n      \"SELECT\",\n      FOREIGN_KEY_FIELDS,\n      \"FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE\",\n      \"WHERE (\",\n      [\n        `REFERENCED_TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`\n      ],\n      \") OR (\",\n      [\n        `TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND COLUMN_NAME = ${quotedColumnName}`,\n        \"AND REFERENCED_TABLE_NAME IS NOT NULL\"\n      ],\n      \")\"\n    ]);\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP FOREIGN KEY\",\n      this.quoteIdentifier(foreignKey),\n      \";\"\n    ]);\n  }\n  addLimitAndOffset(options) {\n    let fragment = [];\n    if (options.offset !== null && options.offset !== void 0 && options.offset !== 0) {\n      fragment = fragment.concat([\" LIMIT \", this.escape(options.limit), \" OFFSET \", this.escape(options.offset)]);\n    } else if (options.limit !== null && options.limit !== void 0) {\n      fragment = [\" LIMIT \", this.escape(options.limit)];\n    }\n    return fragment.join(\"\");\n  }\n  quoteIdentifier(identifier, force) {\n    const optForceQuote = force || false;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n    if (optForceQuote === true || optQuoteIdentifiers !== false || identifier.includes(\".\") || identifier.includes(\"->\") || SNOWFLAKE_RESERVED_WORDS.includes(rawIdentifier.toLowerCase())) {\n      return Utils.addTicks(rawIdentifier, '\"');\n    }\n    return rawIdentifier;\n  }\n}\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, \"'\");\n}\nmodule.exports = SnowflakeQueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvcXVlcnktZ2VuZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMxQixjQUFjLG1CQUFPLENBQUMsNEVBQWE7QUFDbkMsK0JBQStCLG1CQUFPLENBQUMsd0hBQTZCO0FBQ3BFLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixXQUFXLG1CQUFPLENBQUMsb0ZBQWlCO0FBQ3BDLDhDQUE4QyxJQUFJLGtCQUFrQixJQUFJO0FBQ3hFLHdEQUF3RCxFQUFFO0FBQzFELDBEQUEwRCxFQUFFLHNCQUFzQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDZCQUE2QjtBQUMvRSw0Q0FBNEMsNkJBQTZCO0FBQ3pFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0NBQW9DO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRCQUE0QixFQUFFLG9DQUFvQztBQUM1RjtBQUNBLFVBQVU7QUFDViwwQkFBMEIsNEJBQTRCLEVBQUUsb0NBQW9DO0FBQzVGO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esd0JBQXdCLDRCQUE0QixFQUFFLFNBQVM7QUFDL0Q7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCLDRCQUE0QixFQUFFLFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsR0FBRyx5QkFBeUI7QUFDdEU7QUFDQSwwQ0FBMEMsaUNBQWlDLEdBQUcsc0VBQXNFO0FBQ3BKO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMkJBQTJCLElBQUksa0JBQWtCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQiwyRUFBMkUsNkJBQTZCO0FBQ3hHLDRDQUE0QyxnQkFBZ0I7QUFDNUQsb0NBQW9DLGdCQUFnQjtBQUNwRCx5Q0FBeUMsa0JBQWtCO0FBQzNELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzQkFBc0I7QUFDN0QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZEQUE2RDtBQUN6RiwwQkFBMEIsdUJBQXVCO0FBQ2pELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RztBQUM3RyxvREFBb0Q7QUFDcEQsUUFBUTtBQUNSO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVyxLQUFLLFNBQVMsSUFBSSxXQUFXO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLHlFQUF5RSxLQUFLLGdCQUFnQjtBQUMxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsNkNBQTZDLDJCQUEyQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsSUFBSTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQyxrREFBa0QsZUFBZTtBQUNqRSwyQ0FBMkMsV0FBVztBQUN0RCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLEdBQUcsZ0NBQWdDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGdDQUFnQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9DQUFvQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtCQUErQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNDQUFzQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxrQkFBa0IsR0FBRyxTQUFTO0FBQzdFLHdDQUF3QyxRQUFRLGVBQWUsU0FBUztBQUN4RTtBQUNBLGlDQUFpQyw0Q0FBNEM7QUFDN0U7QUFDQSx5QkFBeUIsK0NBQStDO0FBQ3hFLFFBQVE7QUFDUix5QkFBeUIsMkJBQTJCO0FBQ3BEO0FBQ0E7QUFDQSxrQ0FBa0MsaUNBQWlDO0FBQ25FO0FBQ0E7QUFDQSxrQ0FBa0MsaUNBQWlDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsVUFBVTtBQUNoRiwrREFBK0QsV0FBVztBQUMxRTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25ELHlEQUF5RCxpQkFBaUI7QUFDMUUsd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDLDhDQUE4QyxpQkFBaUI7QUFDL0QsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvcXVlcnktZ2VuZXJhdG9yLmpzP2ZmYmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5jb25zdCBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5LWdlbmVyYXRvclwiKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IE9wID0gcmVxdWlyZShcIi4uLy4uL29wZXJhdG9yc1wiKTtcbmNvbnN0IEpTT05fRlVOQ1RJT05fUkVHRVggPSAvXlxccyooKD86W2Etel0rXyl7MCwyfWpzb25iPyg/Ol9bYS16XSspezAsMn0pXFwoW14pXSpcXCkvaTtcbmNvbnN0IEpTT05fT1BFUkFUT1JfUkVHRVggPSAvXlxccyooLT4+P3xAPnw8QHxcXD9bfCZdP3xcXHx7Mn18Iy0pL2k7XG5jb25zdCBUT0tFTl9DQVBUVVJFX1JFR0VYID0gL15cXHMqKCg/OihbYFwiJ10pKD86KD8hXFwyKS58XFwyezJ9KSpcXDIpfFtcXHdcXGRcXHNdK3xbKCkuLDsrLV0pL2k7XG5jb25zdCBGT1JFSUdOX0tFWV9GSUVMRFMgPSBbXG4gIFwiQ09OU1RSQUlOVF9OQU1FIGFzIGNvbnN0cmFpbnRfbmFtZVwiLFxuICBcIkNPTlNUUkFJTlRfTkFNRSBhcyBjb25zdHJhaW50TmFtZVwiLFxuICBcIkNPTlNUUkFJTlRfU0NIRU1BIGFzIGNvbnN0cmFpbnRTY2hlbWFcIixcbiAgXCJDT05TVFJBSU5UX1NDSEVNQSBhcyBjb25zdHJhaW50Q2F0YWxvZ1wiLFxuICBcIlRBQkxFX05BTUUgYXMgdGFibGVOYW1lXCIsXG4gIFwiVEFCTEVfU0NIRU1BIGFzIHRhYmxlU2NoZW1hXCIsXG4gIFwiVEFCTEVfU0NIRU1BIGFzIHRhYmxlQ2F0YWxvZ1wiLFxuICBcIkNPTFVNTl9OQU1FIGFzIGNvbHVtbk5hbWVcIixcbiAgXCJSRUZFUkVOQ0VEX1RBQkxFX1NDSEVNQSBhcyByZWZlcmVuY2VkVGFibGVTY2hlbWFcIixcbiAgXCJSRUZFUkVOQ0VEX1RBQkxFX1NDSEVNQSBhcyByZWZlcmVuY2VkVGFibGVDYXRhbG9nXCIsXG4gIFwiUkVGRVJFTkNFRF9UQUJMRV9OQU1FIGFzIHJlZmVyZW5jZWRUYWJsZU5hbWVcIixcbiAgXCJSRUZFUkVOQ0VEX0NPTFVNTl9OQU1FIGFzIHJlZmVyZW5jZWRDb2x1bW5OYW1lXCJcbl0uam9pbihcIixcIik7XG5jb25zdCBTTk9XRkxBS0VfUkVTRVJWRURfV09SRFMgPSBcImFjY291bnQsYWxsLGFsdGVyLGFuZCxhbnksYXMsYmV0d2VlbixieSxjYXNlLGNhc3QsY2hlY2ssY29sdW1uLGNvbm5lY3QsY29ubmVjdGlvbnMsY29uc3RyYWludCxjcmVhdGUsY3Jvc3MsY3VycmVudCxjdXJyZW50X2RhdGUsY3VycmVudF90aW1lLGN1cnJlbnRfdGltZXN0YW1wLGN1cnJlbnRfdXNlcixkYXRhYmFzZSxkZWxldGUsZGlzdGluY3QsZHJvcCxlbHNlLGV4aXN0cyxmYWxzZSxmb2xsb3dpbmcsZm9yLGZyb20sZnVsbCxncmFudCxncm91cCxnc2NsdXN0ZXIsaGF2aW5nLGlsaWtlLGluLGluY3JlbWVudCxpbm5lcixpbnNlcnQsaW50ZXJzZWN0LGludG8saXMsaXNzdWUsam9pbixsYXRlcmFsLGxlZnQsbGlrZSxsb2NhbHRpbWUsbG9jYWx0aW1lc3RhbXAsbWludXMsbmF0dXJhbCxub3QsbnVsbCxvZixvbixvcixvcmRlcixvcmdhbml6YXRpb24scXVhbGlmeSxyZWdleHAscmV2b2tlLHJpZ2h0LHJsaWtlLHJvdyxyb3dzLHNhbXBsZSxzY2hlbWEsc2VsZWN0LHNldCxzb21lLHN0YXJ0LHRhYmxlLHRhYmxlc2FtcGxlLHRoZW4sdG8sdHJpZ2dlcix0cnVlLHRyeV9jYXN0LHVuaW9uLHVuaXF1ZSx1cGRhdGUsdXNpbmcsdmFsdWVzLHZpZXcsd2hlbix3aGVuZXZlcix3aGVyZSx3aXRoXCIuc3BsaXQoXCIsXCIpO1xuY29uc3QgdHlwZVdpdGhvdXREZWZhdWx0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiQkxPQlwiLCBcIlRFWFRcIiwgXCJHRU9NRVRSWVwiLCBcIkpTT05cIl0pO1xuY2xhc3MgU25vd2ZsYWtlUXVlcnlHZW5lcmF0b3IgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMuT3BlcmF0b3JNYXAgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLk9wZXJhdG9yTWFwKSwge1xuICAgICAgW09wLnJlZ2V4cF06IFwiUkVHRVhQXCIsXG4gICAgICBbT3Aubm90UmVnZXhwXTogXCJOT1QgUkVHRVhQXCJcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVEYXRhYmFzZVF1ZXJ5KGRhdGFiYXNlTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBjaGFyc2V0OiBudWxsLFxuICAgICAgY29sbGF0ZTogbnVsbFxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQ1JFQVRFIERBVEFCQVNFIElGIE5PVCBFWElTVFNcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGRhdGFiYXNlTmFtZSksXG4gICAgICBvcHRpb25zLmNoYXJzZXQgJiYgYERFRkFVTFQgQ0hBUkFDVEVSIFNFVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMuY2hhcnNldCl9YCxcbiAgICAgIG9wdGlvbnMuY29sbGF0ZSAmJiBgREVGQVVMVCBDT0xMQVRFICR7dGhpcy5lc2NhcGUob3B0aW9ucy5jb2xsYXRlKX1gLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBkcm9wRGF0YWJhc2VRdWVyeShkYXRhYmFzZU5hbWUpIHtcbiAgICByZXR1cm4gYERST1AgREFUQUJBU0UgSUYgRVhJU1RTICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoZGF0YWJhc2VOYW1lKX07YDtcbiAgfVxuICBjcmVhdGVTY2hlbWEoKSB7XG4gICAgcmV0dXJuIFwiU0hPVyBUQUJMRVNcIjtcbiAgfVxuICBzaG93U2NoZW1hc1F1ZXJ5KCkge1xuICAgIHJldHVybiBcIlNIT1cgVEFCTEVTXCI7XG4gIH1cbiAgdmVyc2lvblF1ZXJ5KCkge1xuICAgIHJldHVybiBcIlNFTEVDVCBDVVJSRU5UX1ZFUlNJT04oKVwiO1xuICB9XG4gIGNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGNoYXJzZXQ6IG51bGwsXG4gICAgICByb3dGb3JtYXQ6IG51bGxcbiAgICB9LCBvcHRpb25zKTtcbiAgICBjb25zdCBwcmltYXJ5S2V5cyA9IFtdO1xuICAgIGNvbnN0IGZvcmVpZ25LZXlzID0ge307XG4gICAgY29uc3QgYXR0clN0ciA9IFtdO1xuICAgIGZvciAoY29uc3QgYXR0ciBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGVzLCBhdHRyKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IGF0dHJpYnV0ZXNbYXR0cl07XG4gICAgICBsZXQgbWF0Y2g7XG4gICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJQUklNQVJZIEtFWVwiKSkge1xuICAgICAgICBwcmltYXJ5S2V5cy5wdXNoKGF0dHIpO1xuICAgICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJSRUZFUkVOQ0VTXCIpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBkYXRhVHlwZS5tYXRjaCgvXiguKykgKFJFRkVSRU5DRVMuKikkLyk7XG4gICAgICAgICAgYXR0clN0ci5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke21hdGNoWzFdLnJlcGxhY2UoXCJQUklNQVJZIEtFWVwiLCBcIlwiKX1gKTtcbiAgICAgICAgICBmb3JlaWduS2V5c1thdHRyXSA9IG1hdGNoWzJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0dHJTdHIucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHtkYXRhVHlwZS5yZXBsYWNlKFwiUFJJTUFSWSBLRVlcIiwgXCJcIil9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJSRUZFUkVOQ0VTXCIpKSB7XG4gICAgICAgIG1hdGNoID0gZGF0YVR5cGUubWF0Y2goL14oLispIChSRUZFUkVOQ0VTLiopJC8pO1xuICAgICAgICBhdHRyU3RyLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7bWF0Y2hbMV19YCk7XG4gICAgICAgIGZvcmVpZ25LZXlzW2F0dHJdID0gbWF0Y2hbMl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyU3RyLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7ZGF0YVR5cGV9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgbGV0IGF0dHJpYnV0ZXNDbGF1c2UgPSBhdHRyU3RyLmpvaW4oXCIsIFwiKTtcbiAgICBjb25zdCBwa1N0cmluZyA9IHByaW1hcnlLZXlzLm1hcCgocGspID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKHBrKSkuam9pbihcIiwgXCIpO1xuICAgIGlmIChvcHRpb25zLnVuaXF1ZUtleXMpIHtcbiAgICAgIF8uZWFjaChvcHRpb25zLnVuaXF1ZUtleXMsIChjb2x1bW5zLCBpbmRleE5hbWUpID0+IHtcbiAgICAgICAgaWYgKGNvbHVtbnMuY3VzdG9tSW5kZXgpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGluZGV4TmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaW5kZXhOYW1lID0gYHVuaXFfJHt0YWJsZU5hbWV9XyR7Y29sdW1ucy5maWVsZHMuam9pbihcIl9cIil9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0cmlidXRlc0NsYXVzZSArPSBgLCBVTklRVUUgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihpbmRleE5hbWUpfSAoJHtjb2x1bW5zLmZpZWxkcy5tYXAoKGZpZWxkKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZCkpLmpvaW4oXCIsIFwiKX0pYDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwa1N0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICBhdHRyaWJ1dGVzQ2xhdXNlICs9IGAsIFBSSU1BUlkgS0VZICgke3BrU3RyaW5nfSlgO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZrZXkgaW4gZm9yZWlnbktleXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZm9yZWlnbktleXMsIGZrZXkpKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNDbGF1c2UgKz0gYCwgRk9SRUlHTiBLRVkgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoZmtleSl9KSAke2ZvcmVpZ25LZXlzW2ZrZXldfWA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFNcIixcbiAgICAgIHRhYmxlLFxuICAgICAgYCgke2F0dHJpYnV0ZXNDbGF1c2V9KWAsXG4gICAgICBvcHRpb25zLmNvbW1lbnQgJiYgdHlwZW9mIG9wdGlvbnMuY29tbWVudCA9PT0gXCJzdHJpbmdcIiAmJiBgQ09NTUVOVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMuY29tbWVudCl9YCxcbiAgICAgIG9wdGlvbnMuY2hhcnNldCAmJiBgREVGQVVMVCBDSEFSU0VUPSR7b3B0aW9ucy5jaGFyc2V0fWAsXG4gICAgICBvcHRpb25zLmNvbGxhdGUgJiYgYENPTExBVEUgJHtvcHRpb25zLmNvbGxhdGV9YCxcbiAgICAgIG9wdGlvbnMucm93Rm9ybWF0ICYmIGBST1dfRk9STUFUPSR7b3B0aW9ucy5yb3dGb3JtYXR9YCxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgZGVzY3JpYmVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgc2NoZW1hLCBzY2hlbWFEZWxpbWl0ZXIpIHtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0aGlzLmFkZFNjaGVtYSh7XG4gICAgICB0YWJsZU5hbWUsXG4gICAgICBfc2NoZW1hOiBzY2hlbWEsXG4gICAgICBfc2NoZW1hRGVsaW1pdGVyOiBzY2hlbWFEZWxpbWl0ZXJcbiAgICB9KSk7XG4gICAgcmV0dXJuIGBTSE9XIEZVTEwgQ09MVU1OUyBGUk9NICR7dGFibGV9O2A7XG4gIH1cbiAgc2hvd1RhYmxlc1F1ZXJ5KGRhdGFiYXNlKSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJTRUxFQ1QgVEFCTEVfTkFNRSBGUk9NIElORk9STUFUSU9OX1NDSEVNQS5UQUJMRVMgV0hFUkUgVEFCTEVfVFlQRSA9ICdCQVNFIFRBQkxFJ1wiLFxuICAgICAgZGF0YWJhc2UgPyBgQU5EIFRBQkxFX1NDSEVNQSA9ICR7dGhpcy5lc2NhcGUoZGF0YWJhc2UpfWAgOiBcIkFORCBUQUJMRV9TQ0hFTUEgTk9UIElOICggJ0lORk9STUFUSU9OX1NDSEVNQScsICdQRVJGT1JNQU5DRV9TQ0hFTUEnLCAnU1lTJylcIixcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgdGFibGVFeGlzdHNRdWVyeSh0YWJsZSkge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZTtcbiAgICBjb25zdCBzY2hlbWEgPSB0YWJsZS5zY2hlbWE7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJTRUxFQ1QgVEFCTEVfTkFNRSBGUk9NIElORk9STUFUSU9OX1NDSEVNQS5UQUJMRVMgV0hFUkUgVEFCTEVfVFlQRSA9ICdCQVNFIFRBQkxFJ1wiLFxuICAgICAgYEFORCBUQUJMRV9TQ0hFTUEgPSAke3NjaGVtYSAhPT0gdm9pZCAwID8gdGhpcy5lc2NhcGUoc2NoZW1hKSA6IFwiQ1VSUkVOVF9TQ0hFTUEoKVwifWAsXG4gICAgICBgQU5EIFRBQkxFX05BTUUgPSAke3RoaXMuZXNjYXBlKHRhYmxlTmFtZSl9YCxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgYWRkQ29sdW1uUXVlcnkodGFibGUsIGtleSwgZGF0YVR5cGUpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGUpLFxuICAgICAgXCJBRERcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSksXG4gICAgICB0aGlzLmF0dHJpYnV0ZVRvU1FMKGRhdGFUeXBlLCB7XG4gICAgICAgIGNvbnRleHQ6IFwiYWRkQ29sdW1uXCIsXG4gICAgICAgIHRhYmxlTmFtZTogdGFibGUsXG4gICAgICAgIGZvcmVpZ25LZXk6IGtleVxuICAgICAgfSksXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIHJlbW92ZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQUxURVIgVEFCTEVcIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgXCJEUk9QXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKSxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgY2hhbmdlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgcXVlcnkgPSAoLi4uc3ViUXVlcnlzKSA9PiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQUxURVIgVEFCTEVcIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgXCJBTFRFUiBDT0xVTU5cIixcbiAgICAgIC4uLnN1YlF1ZXJ5cyxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gICAgY29uc3Qgc3FsID0gW107XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGxldCBkZWZpbml0aW9uID0gdGhpcy5kYXRhVHlwZU1hcHBpbmcodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdKTtcbiAgICAgIGNvbnN0IGF0dHJTcWwgPSBbXTtcbiAgICAgIGlmIChkZWZpbml0aW9uLmluY2x1ZGVzKFwiTk9UIE5VTExcIikpIHtcbiAgICAgICAgYXR0clNxbC5wdXNoKHF1ZXJ5KHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpLCBcIlNFVCBOT1QgTlVMTFwiKSk7XG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uLnJlcGxhY2UoXCJOT1QgTlVMTFwiLCBcIlwiKS50cmltKCk7XG4gICAgICB9IGVsc2UgaWYgKCFkZWZpbml0aW9uLmluY2x1ZGVzKFwiUkVGRVJFTkNFU1wiKSkge1xuICAgICAgICBhdHRyU3FsLnB1c2gocXVlcnkodGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSksIFwiRFJPUCBOT1QgTlVMTFwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5pdGlvbi5pbmNsdWRlcyhcIkRFRkFVTFRcIikpIHtcbiAgICAgICAgYXR0clNxbC5wdXNoKHF1ZXJ5KHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpLCBcIlNFVCBERUZBVUxUXCIsIGRlZmluaXRpb24ubWF0Y2goL0RFRkFVTFQgKFteO10rKS8pWzFdKSk7XG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uLnJlcGxhY2UoLyhERUZBVUxUW147XSspLywgXCJcIikudHJpbSgpO1xuICAgICAgfSBlbHNlIGlmICghZGVmaW5pdGlvbi5pbmNsdWRlcyhcIlJFRkVSRU5DRVNcIikpIHtcbiAgICAgICAgYXR0clNxbC5wdXNoKHF1ZXJ5KHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpLCBcIkRST1AgREVGQVVMVFwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5pdGlvbi5tYXRjaCgvVU5JUVVFOyokLykpIHtcbiAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24ucmVwbGFjZSgvVU5JUVVFOyokLywgXCJcIik7XG4gICAgICAgIGF0dHJTcWwucHVzaChxdWVyeShcIkFERCBVTklRVUUgKFwiLCB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKSwgXCIpXCIpLnJlcGxhY2UoXCJBTFRFUiBDT0xVTU5cIiwgXCJcIikpO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmluaXRpb24uaW5jbHVkZXMoXCJSRUZFUkVOQ0VTXCIpKSB7XG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uLnJlcGxhY2UoLy4rPyg/PVJFRkVSRU5DRVMpLywgXCJcIik7XG4gICAgICAgIGF0dHJTcWwucHVzaChxdWVyeShcIkFERCBGT1JFSUdOIEtFWSAoXCIsIHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpLCBcIilcIiwgZGVmaW5pdGlvbikucmVwbGFjZShcIkFMVEVSIENPTFVNTlwiLCBcIlwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyU3FsLnB1c2gocXVlcnkodGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSksIFwiVFlQRVwiLCBkZWZpbml0aW9uKSk7XG4gICAgICB9XG4gICAgICBzcWwucHVzaChhdHRyU3FsLmpvaW4oXCJcIikpO1xuICAgIH1cbiAgICByZXR1cm4gc3FsLmpvaW4oXCJcIik7XG4gIH1cbiAgcmVuYW1lQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyQmVmb3JlLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgYXR0clN0cmluZyA9IFtdO1xuICAgIGZvciAoY29uc3QgYXR0ck5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IGF0dHJpYnV0ZXNbYXR0ck5hbWVdO1xuICAgICAgYXR0clN0cmluZy5wdXNoKGAnJHthdHRyQmVmb3JlfScgJyR7YXR0ck5hbWV9JyAke2RlZmluaXRpb259YCk7XG4gICAgfVxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQUxURVIgVEFCTEVcIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgXCJSRU5BTUUgQ09MVU1OXCIsXG4gICAgICBhdHRyU3RyaW5nLmpvaW4oXCIgdG8gXCIpLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBoYW5kbGVTZXF1ZWxpemVNZXRob2QoYXR0ciwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKSB7XG4gICAgaWYgKGF0dHIgaW5zdGFuY2VvZiBVdGlscy5Kc29uKSB7XG4gICAgICBpZiAoYXR0ci5jb25kaXRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmRpdGlvbnMgPSB0aGlzLnBhcnNlQ29uZGl0aW9uT2JqZWN0KGF0dHIuY29uZGl0aW9ucykubWFwKChjb25kaXRpb24pID0+IGAke3RoaXMuanNvblBhdGhFeHRyYWN0aW9uUXVlcnkoY29uZGl0aW9uLnBhdGhbMF0sIF8udGFpbChjb25kaXRpb24ucGF0aCkpfSA9ICcke2NvbmRpdGlvbi52YWx1ZX0nYCk7XG4gICAgICAgIHJldHVybiBjb25kaXRpb25zLmpvaW4oXCIgQU5EIFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyLnBhdGgpIHtcbiAgICAgICAgbGV0IHN0cjtcbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrVmFsaWRKc29uU3RhdGVtZW50KGF0dHIucGF0aCkpIHtcbiAgICAgICAgICBzdHIgPSBhdHRyLnBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcGF0aHMgPSBfLnRvUGF0aChhdHRyLnBhdGgpO1xuICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IHBhdGhzLnNoaWZ0KCk7XG4gICAgICAgICAgc3RyID0gdGhpcy5qc29uUGF0aEV4dHJhY3Rpb25RdWVyeShjb2x1bW4sIHBhdGhzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0ci52YWx1ZSkge1xuICAgICAgICAgIHN0ciArPSB1dGlsLmZvcm1hdChcIiA9ICVzXCIsIHRoaXMuZXNjYXBlKGF0dHIudmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXR0ciBpbnN0YW5jZW9mIFV0aWxzLkNhc3QpIHtcbiAgICAgIGlmICgvdGltZXN0YW1wL2kudGVzdChhdHRyLnR5cGUpKSB7XG4gICAgICAgIGF0dHIudHlwZSA9IFwiZGF0ZXRpbWVcIjtcbiAgICAgIH0gZWxzZSBpZiAoYXR0ci5qc29uICYmIC9ib29sZWFuL2kudGVzdChhdHRyLnR5cGUpKSB7XG4gICAgICAgIGF0dHIudHlwZSA9IFwiY2hhclwiO1xuICAgICAgfSBlbHNlIGlmICgvZG91YmxlIHByZWNpc2lvbi9pLnRlc3QoYXR0ci50eXBlKSB8fCAvYm9vbGVhbi9pLnRlc3QoYXR0ci50eXBlKSB8fCAvaW50ZWdlci9pLnRlc3QoYXR0ci50eXBlKSkge1xuICAgICAgICBhdHRyLnR5cGUgPSBcImRlY2ltYWxcIjtcbiAgICAgIH0gZWxzZSBpZiAoL3RleHQvaS50ZXN0KGF0dHIudHlwZSkpIHtcbiAgICAgICAgYXR0ci50eXBlID0gXCJjaGFyXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5oYW5kbGVTZXF1ZWxpemVNZXRob2QoYXR0ciwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKTtcbiAgfVxuICB0cnVuY2F0ZVRhYmxlUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJUUlVOQ0FURVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSlcbiAgICBdKTtcbiAgfVxuICBkZWxldGVRdWVyeSh0YWJsZU5hbWUsIHdoZXJlLCBvcHRpb25zID0ge30sIG1vZGVsKSB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBsZXQgd2hlcmVDbGF1c2UgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyh3aGVyZSwgbnVsbCwgbW9kZWwsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGxpbWl0ID0gb3B0aW9ucy5saW1pdCAmJiBgIExJTUlUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9YDtcbiAgICBsZXQgcHJpbWFyeUtleXMgPSBcIlwiO1xuICAgIGxldCBwcmltYXJ5S2V5c1NlbGVjdGlvbiA9IFwiXCI7XG4gICAgaWYgKHdoZXJlQ2xhdXNlKSB7XG4gICAgICB3aGVyZUNsYXVzZSA9IGBXSEVSRSAke3doZXJlQ2xhdXNlfWA7XG4gICAgfVxuICAgIGlmIChsaW1pdCkge1xuICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgTElNSVQgZGVsZXRlIHdpdGhvdXQgYSBtb2RlbC5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBwa3MgPSBPYmplY3QudmFsdWVzKG1vZGVsLnByaW1hcnlLZXlzKS5tYXAoKHBrKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihway5maWVsZCkpLmpvaW4oXCIsXCIpO1xuICAgICAgcHJpbWFyeUtleXMgPSBtb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlcy5sZW5ndGggPiAxID8gYCgke3Brc30pYCA6IHBrcztcbiAgICAgIHByaW1hcnlLZXlzU2VsZWN0aW9uID0gcGtzO1xuICAgICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgICBcIkRFTEVURSBGUk9NXCIsXG4gICAgICAgIHRhYmxlLFxuICAgICAgICBcIldIRVJFXCIsXG4gICAgICAgIHByaW1hcnlLZXlzLFxuICAgICAgICBcIklOIChTRUxFQ1RcIixcbiAgICAgICAgcHJpbWFyeUtleXNTZWxlY3Rpb24sXG4gICAgICAgIFwiRlJPTVwiLFxuICAgICAgICB0YWJsZSxcbiAgICAgICAgd2hlcmVDbGF1c2UsXG4gICAgICAgIGxpbWl0LFxuICAgICAgICBcIilcIixcbiAgICAgICAgXCI7XCJcbiAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkRFTEVURSBGUk9NXCIsXG4gICAgICB0YWJsZSxcbiAgICAgIHdoZXJlQ2xhdXNlLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBzaG93SW5kZXhlc1F1ZXJ5KCkge1xuICAgIHJldHVybiBcIlNFTEVDVCAnJyBGUk9NIERVQUxcIjtcbiAgfVxuICBzaG93Q29uc3RyYWludHNRdWVyeSh0YWJsZSwgY29uc3RyYWludE5hbWUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZS50YWJsZU5hbWUgfHwgdGFibGU7XG4gICAgY29uc3Qgc2NoZW1hTmFtZSA9IHRhYmxlLnNjaGVtYTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIlNFTEVDVCBDT05TVFJBSU5UX0NBVEFMT0cgQVMgY29uc3RyYWludENhdGFsb2csXCIsXG4gICAgICBcIkNPTlNUUkFJTlRfTkFNRSBBUyBjb25zdHJhaW50TmFtZSxcIixcbiAgICAgIFwiQ09OU1RSQUlOVF9TQ0hFTUEgQVMgY29uc3RyYWludFNjaGVtYSxcIixcbiAgICAgIFwiQ09OU1RSQUlOVF9UWVBFIEFTIGNvbnN0cmFpbnRUeXBlLFwiLFxuICAgICAgXCJUQUJMRV9OQU1FIEFTIHRhYmxlTmFtZSxcIixcbiAgICAgIFwiVEFCTEVfU0NIRU1BIEFTIHRhYmxlU2NoZW1hXCIsXG4gICAgICBcImZyb20gSU5GT1JNQVRJT05fU0NIRU1BLlRBQkxFX0NPTlNUUkFJTlRTXCIsXG4gICAgICBgV0hFUkUgdGFibGVfbmFtZT0nJHt0YWJsZU5hbWV9J2AsXG4gICAgICBjb25zdHJhaW50TmFtZSAmJiBgQU5EIGNvbnN0cmFpbnRfbmFtZSA9ICcke2NvbnN0cmFpbnROYW1lfSdgLFxuICAgICAgc2NoZW1hTmFtZSAmJiBgQU5EIFRBQkxFX1NDSEVNQSA9ICcke3NjaGVtYU5hbWV9J2AsXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIHJlbW92ZUluZGV4UXVlcnkodGFibGVOYW1lLCBpbmRleE5hbWVPckF0dHJpYnV0ZXMpIHtcbiAgICBsZXQgaW5kZXhOYW1lID0gaW5kZXhOYW1lT3JBdHRyaWJ1dGVzO1xuICAgIGlmICh0eXBlb2YgaW5kZXhOYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBpbmRleE5hbWUgPSBVdGlscy51bmRlcnNjb3JlKGAke3RhYmxlTmFtZX1fJHtpbmRleE5hbWVPckF0dHJpYnV0ZXMuam9pbihcIl9cIil9YCk7XG4gICAgfVxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiRFJPUCBJTkRFWFwiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoaW5kZXhOYW1lKSxcbiAgICAgIFwiT05cIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBhdHRyaWJ1dGVUb1NRTChhdHRyaWJ1dGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIV8uaXNQbGFpbk9iamVjdChhdHRyaWJ1dGUpKSB7XG4gICAgICBhdHRyaWJ1dGUgPSB7XG4gICAgICAgIHR5cGU6IGF0dHJpYnV0ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgYXR0cmlidXRlU3RyaW5nID0gYXR0cmlidXRlLnR5cGUudG9TdHJpbmcoeyBlc2NhcGU6IHRoaXMuZXNjYXBlLmJpbmQodGhpcykgfSk7XG4gICAgbGV0IHRlbXBsYXRlID0gYXR0cmlidXRlU3RyaW5nO1xuICAgIGlmIChhdHRyaWJ1dGUuYWxsb3dOdWxsID09PSBmYWxzZSkge1xuICAgICAgdGVtcGxhdGUgKz0gXCIgTk9UIE5VTExcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5hdXRvSW5jcmVtZW50KSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBBVVRPSU5DUkVNRU5UXCI7XG4gICAgfVxuICAgIGlmICghdHlwZVdpdGhvdXREZWZhdWx0LmhhcyhhdHRyaWJ1dGVTdHJpbmcpICYmIGF0dHJpYnV0ZS50eXBlLl9iaW5hcnkgIT09IHRydWUgJiYgVXRpbHMuZGVmYXVsdFZhbHVlU2NoZW1hYmxlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBgIERFRkFVTFQgJHt0aGlzLmVzY2FwZShhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlKX1gO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLnVuaXF1ZSA9PT0gdHJ1ZSkge1xuICAgICAgdGVtcGxhdGUgKz0gXCIgVU5JUVVFXCI7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUucHJpbWFyeUtleSkge1xuICAgICAgdGVtcGxhdGUgKz0gXCIgUFJJTUFSWSBLRVlcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5jb21tZW50KSB7XG4gICAgICB0ZW1wbGF0ZSArPSBgIENPTU1FTlQgJHt0aGlzLmVzY2FwZShhdHRyaWJ1dGUuY29tbWVudCl9YDtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5maXJzdCkge1xuICAgICAgdGVtcGxhdGUgKz0gXCIgRklSU1RcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5hZnRlcikge1xuICAgICAgdGVtcGxhdGUgKz0gYCBBRlRFUiAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZS5hZnRlcil9YDtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzKSB7XG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbnRleHQgPT09IFwiYWRkQ29sdW1uXCIgJiYgb3B0aW9ucy5mb3JlaWduS2V5KSB7XG4gICAgICAgIGNvbnN0IGF0dHJOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIob3B0aW9ucy5mb3JlaWduS2V5KTtcbiAgICAgICAgY29uc3QgZmtOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoYCR7b3B0aW9ucy50YWJsZU5hbWV9XyR7YXR0ck5hbWV9X2ZvcmVpZ25faWR4YCk7XG4gICAgICAgIHRlbXBsYXRlICs9IGAsIEFERCBDT05TVFJBSU5UICR7ZmtOYW1lfSBGT1JFSUdOIEtFWSAoJHthdHRyTmFtZX0pYDtcbiAgICAgIH1cbiAgICAgIHRlbXBsYXRlICs9IGAgUkVGRVJFTkNFUyAke3RoaXMucXVvdGVUYWJsZShhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbCl9YDtcbiAgICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcy5rZXkpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGUucmVmZXJlbmNlcy5rZXkpfSlgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihcImlkXCIpfSlgO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZS5vbkRlbGV0ZSkge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgIE9OIERFTEVURSAke2F0dHJpYnV0ZS5vbkRlbGV0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlLm9uVXBkYXRlKSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgT04gVVBEQVRFICR7YXR0cmlidXRlLm9uVXBkYXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9XG4gIGF0dHJpYnV0ZXNUb1NRTChhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgcmVzdWx0W2F0dHJpYnV0ZS5maWVsZCB8fCBrZXldID0gdGhpcy5hdHRyaWJ1dGVUb1NRTChhdHRyaWJ1dGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIF9jaGVja1ZhbGlkSnNvblN0YXRlbWVudChzdG10KSB7XG4gICAgaWYgKHR5cGVvZiBzdG10ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBjdXJyZW50SW5kZXggPSAwO1xuICAgIGxldCBvcGVuaW5nQnJhY2tldHMgPSAwO1xuICAgIGxldCBjbG9zaW5nQnJhY2tldHMgPSAwO1xuICAgIGxldCBoYXNKc29uRnVuY3Rpb24gPSBmYWxzZTtcbiAgICBsZXQgaGFzSW52YWxpZFRva2VuID0gZmFsc2U7XG4gICAgd2hpbGUgKGN1cnJlbnRJbmRleCA8IHN0bXQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzdHJpbmcgPSBzdG10LnN1YnN0cihjdXJyZW50SW5kZXgpO1xuICAgICAgY29uc3QgZnVuY3Rpb25NYXRjaGVzID0gSlNPTl9GVU5DVElPTl9SRUdFWC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAoZnVuY3Rpb25NYXRjaGVzKSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSBmdW5jdGlvbk1hdGNoZXNbMF0uaW5kZXhPZihcIihcIik7XG4gICAgICAgIGhhc0pzb25GdW5jdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3BlcmF0b3JNYXRjaGVzID0gSlNPTl9PUEVSQVRPUl9SRUdFWC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAob3BlcmF0b3JNYXRjaGVzKSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSBvcGVyYXRvck1hdGNoZXNbMF0ubGVuZ3RoO1xuICAgICAgICBoYXNKc29uRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRva2VuTWF0Y2hlcyA9IFRPS0VOX0NBUFRVUkVfUkVHRVguZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKHRva2VuTWF0Y2hlcykge1xuICAgICAgICBjb25zdCBjYXB0dXJlZFRva2VuID0gdG9rZW5NYXRjaGVzWzFdO1xuICAgICAgICBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gXCIoXCIpIHtcbiAgICAgICAgICBvcGVuaW5nQnJhY2tldHMrKztcbiAgICAgICAgfSBlbHNlIGlmIChjYXB0dXJlZFRva2VuID09PSBcIilcIikge1xuICAgICAgICAgIGNsb3NpbmdCcmFja2V0cysrO1xuICAgICAgICB9IGVsc2UgaWYgKGNhcHR1cmVkVG9rZW4gPT09IFwiO1wiKSB7XG4gICAgICAgICAgaGFzSW52YWxpZFRva2VuID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50SW5kZXggKz0gdG9rZW5NYXRjaGVzWzBdLmxlbmd0aDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGhhc0pzb25GdW5jdGlvbiAmJiAoaGFzSW52YWxpZFRva2VuIHx8IG9wZW5pbmdCcmFja2V0cyAhPT0gY2xvc2luZ0JyYWNrZXRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGpzb24gc3RhdGVtZW50OiAke3N0bXR9YCk7XG4gICAgfVxuICAgIHJldHVybiBoYXNKc29uRnVuY3Rpb247XG4gIH1cbiAgZGF0YVR5cGVNYXBwaW5nKHRhYmxlTmFtZSwgYXR0ciwgZGF0YVR5cGUpIHtcbiAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJQUklNQVJZIEtFWVwiKSkge1xuICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKFwiUFJJTUFSWSBLRVlcIiwgXCJcIik7XG4gICAgfVxuICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIlNFUklBTFwiKSkge1xuICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiQklHSU5UXCIpKSB7XG4gICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZShcIlNFUklBTFwiLCBcIkJJR1NFUklBTFwiKTtcbiAgICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKFwiQklHSU5UXCIsIFwiXCIpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIlNNQUxMSU5UXCIpKSB7XG4gICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZShcIlNFUklBTFwiLCBcIlNNQUxMU0VSSUFMXCIpO1xuICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoXCJTTUFMTElOVFwiLCBcIlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZShcIklOVEVHRVJcIiwgXCJcIik7XG4gICAgICB9XG4gICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoXCJOT1QgTlVMTFwiLCBcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFUeXBlO1xuICB9XG4gIGdldEZvcmVpZ25LZXlzUXVlcnkodGFibGUsIHNjaGVtYU5hbWUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZS50YWJsZU5hbWUgfHwgdGFibGU7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJTRUxFQ1RcIixcbiAgICAgIEZPUkVJR05fS0VZX0ZJRUxEUyxcbiAgICAgIGBGUk9NIElORk9STUFUSU9OX1NDSEVNQS5LRVlfQ09MVU1OX1VTQUdFIHdoZXJlIFRBQkxFX05BTUUgPSAnJHt0YWJsZU5hbWV9J2AsXG4gICAgICBgQU5EIENPTlNUUkFJTlRfTkFNRSE9J1BSSU1BUlknIEFORCBDT05TVFJBSU5UX1NDSEVNQT0nJHtzY2hlbWFOYW1lfSdgLFxuICAgICAgXCJBTkQgUkVGRVJFTkNFRF9UQUJMRV9OQU1FIElTIE5PVCBOVUxMXCIsXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIGdldEZvcmVpZ25LZXlRdWVyeSh0YWJsZSwgY29sdW1uTmFtZSkge1xuICAgIGNvbnN0IHF1b3RlZFNjaGVtYU5hbWUgPSB0YWJsZS5zY2hlbWEgPyB3cmFwU2luZ2xlUXVvdGUodGFibGUuc2NoZW1hKSA6IFwiXCI7XG4gICAgY29uc3QgcXVvdGVkVGFibGVOYW1lID0gd3JhcFNpbmdsZVF1b3RlKHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZSk7XG4gICAgY29uc3QgcXVvdGVkQ29sdW1uTmFtZSA9IHdyYXBTaW5nbGVRdW90ZShjb2x1bW5OYW1lKTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIlNFTEVDVFwiLFxuICAgICAgRk9SRUlHTl9LRVlfRklFTERTLFxuICAgICAgXCJGUk9NIElORk9STUFUSU9OX1NDSEVNQS5LRVlfQ09MVU1OX1VTQUdFXCIsXG4gICAgICBcIldIRVJFIChcIixcbiAgICAgIFtcbiAgICAgICAgYFJFRkVSRU5DRURfVEFCTEVfTkFNRSA9ICR7cXVvdGVkVGFibGVOYW1lfWAsXG4gICAgICAgIHRhYmxlLnNjaGVtYSAmJiBgQU5EIFJFRkVSRU5DRURfVEFCTEVfU0NIRU1BID0gJHtxdW90ZWRTY2hlbWFOYW1lfWAsXG4gICAgICAgIGBBTkQgUkVGRVJFTkNFRF9DT0xVTU5fTkFNRSA9ICR7cXVvdGVkQ29sdW1uTmFtZX1gXG4gICAgICBdLFxuICAgICAgXCIpIE9SIChcIixcbiAgICAgIFtcbiAgICAgICAgYFRBQkxFX05BTUUgPSAke3F1b3RlZFRhYmxlTmFtZX1gLFxuICAgICAgICB0YWJsZS5zY2hlbWEgJiYgYEFORCBUQUJMRV9TQ0hFTUEgPSAke3F1b3RlZFNjaGVtYU5hbWV9YCxcbiAgICAgICAgYEFORCBDT0xVTU5fTkFNRSA9ICR7cXVvdGVkQ29sdW1uTmFtZX1gLFxuICAgICAgICBcIkFORCBSRUZFUkVOQ0VEX1RBQkxFX05BTUUgSVMgTk9UIE5VTExcIlxuICAgICAgXSxcbiAgICAgIFwiKVwiXG4gICAgXSk7XG4gIH1cbiAgZHJvcEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIGZvcmVpZ25LZXkpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIFwiRFJPUCBGT1JFSUdOIEtFWVwiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoZm9yZWlnbktleSksXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIGFkZExpbWl0QW5kT2Zmc2V0KG9wdGlvbnMpIHtcbiAgICBsZXQgZnJhZ21lbnQgPSBbXTtcbiAgICBpZiAob3B0aW9ucy5vZmZzZXQgIT09IG51bGwgJiYgb3B0aW9ucy5vZmZzZXQgIT09IHZvaWQgMCAmJiBvcHRpb25zLm9mZnNldCAhPT0gMCkge1xuICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5jb25jYXQoW1wiIExJTUlUIFwiLCB0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KSwgXCIgT0ZGU0VUIFwiLCB0aGlzLmVzY2FwZShvcHRpb25zLm9mZnNldCldKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMubGltaXQgIT09IG51bGwgJiYgb3B0aW9ucy5saW1pdCAhPT0gdm9pZCAwKSB7XG4gICAgICBmcmFnbWVudCA9IFtcIiBMSU1JVCBcIiwgdGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCldO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQuam9pbihcIlwiKTtcbiAgfVxuICBxdW90ZUlkZW50aWZpZXIoaWRlbnRpZmllciwgZm9yY2UpIHtcbiAgICBjb25zdCBvcHRGb3JjZVF1b3RlID0gZm9yY2UgfHwgZmFsc2U7XG4gICAgY29uc3Qgb3B0UXVvdGVJZGVudGlmaWVycyA9IHRoaXMub3B0aW9ucy5xdW90ZUlkZW50aWZpZXJzICE9PSBmYWxzZTtcbiAgICBjb25zdCByYXdJZGVudGlmaWVyID0gVXRpbHMucmVtb3ZlVGlja3MoaWRlbnRpZmllciwgJ1wiJyk7XG4gICAgaWYgKG9wdEZvcmNlUXVvdGUgPT09IHRydWUgfHwgb3B0UXVvdGVJZGVudGlmaWVycyAhPT0gZmFsc2UgfHwgaWRlbnRpZmllci5pbmNsdWRlcyhcIi5cIikgfHwgaWRlbnRpZmllci5pbmNsdWRlcyhcIi0+XCIpIHx8IFNOT1dGTEFLRV9SRVNFUlZFRF9XT1JEUy5pbmNsdWRlcyhyYXdJZGVudGlmaWVyLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICByZXR1cm4gVXRpbHMuYWRkVGlja3MocmF3SWRlbnRpZmllciwgJ1wiJyk7XG4gICAgfVxuICAgIHJldHVybiByYXdJZGVudGlmaWVyO1xuICB9XG59XG5mdW5jdGlvbiB3cmFwU2luZ2xlUXVvdGUoaWRlbnRpZmllcikge1xuICByZXR1cm4gVXRpbHMuYWRkVGlja3MoaWRlbnRpZmllciwgXCInXCIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBTbm93Zmxha2VRdWVyeUdlbmVyYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWdlbmVyYXRvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/snowflake/query-generator.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/snowflake/query-interface.js":
/*!***************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/snowflake/query-interface.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(action-browser)/../node_modules/sequelize/lib/query-types.js\");\nclass SnowflakeQueryInterface extends QueryInterface {\n  async removeColumn(tableName, columnName, options) {\n    options = options || {};\n    const [results] = await this.sequelize.query(this.queryGenerator.getForeignKeyQuery(tableName.tableName ? tableName : {\n      tableName,\n      schema: this.sequelize.config.database\n    }, columnName), __spreadValues({ raw: true }, options));\n    if (results.length && results[0].constraint_name !== \"PRIMARY\") {\n      await Promise.all(results.map((constraint) => this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, constraint.constraint_name), __spreadValues({ raw: true }, options))));\n    }\n    return await this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, columnName), __spreadValues({ raw: true }, options));\n  }\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    const model = options.model;\n    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async removeConstraint(tableName, constraintName, options) {\n    const sql = this.queryGenerator.showConstraintsQuery(tableName.tableName ? tableName : {\n      tableName,\n      schema: this.sequelize.config.database\n    }, constraintName);\n    const constraints = await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      type: this.sequelize.QueryTypes.SHOWCONSTRAINTS\n    }));\n    const constraint = constraints[0];\n    let query;\n    if (!constraint || !constraint.constraintType) {\n      throw new sequelizeErrors.UnknownConstraintError({\n        message: `Constraint ${constraintName} on table ${tableName} does not exist`,\n        constraint: constraintName,\n        table: tableName\n      });\n    }\n    if (constraint.constraintType === \"FOREIGN KEY\") {\n      query = this.queryGenerator.dropForeignKeyQuery(tableName, constraintName);\n    } else {\n      query = this.queryGenerator.removeIndexQuery(constraint.tableName, constraint.constraintName);\n    }\n    return await this.sequelize.query(query, options);\n  }\n}\nexports.SnowflakeQueryInterface = SnowflakeQueryInterface;\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvcXVlcnktaW50ZXJmYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLG9GQUFjO0FBQzlDLFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyx3SEFBNkI7QUFDaEUsbUJBQW1CLG1CQUFPLENBQUMsd0ZBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0NBQWdDLFdBQVc7QUFDaEQ7QUFDQSwwS0FBMEssV0FBVztBQUNyTDtBQUNBLHFIQUFxSCxXQUFXO0FBQ2hJO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUZBQXVGO0FBQ3ZGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQixXQUFXLFdBQVc7QUFDckU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvcXVlcnktaW50ZXJmYWNlLmpzP2QzMWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCB7IFF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnktaW50ZXJmYWNlXCIpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9xdWVyeS10eXBlc1wiKTtcbmNsYXNzIFNub3dmbGFrZVF1ZXJ5SW50ZXJmYWNlIGV4dGVuZHMgUXVlcnlJbnRlcmZhY2Uge1xuICBhc3luYyByZW1vdmVDb2x1bW4odGFibGVOYW1lLCBjb2x1bW5OYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgW3Jlc3VsdHNdID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5nZXRGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLnRhYmxlTmFtZSA/IHRhYmxlTmFtZSA6IHtcbiAgICAgIHRhYmxlTmFtZSxcbiAgICAgIHNjaGVtYTogdGhpcy5zZXF1ZWxpemUuY29uZmlnLmRhdGFiYXNlXG4gICAgfSwgY29sdW1uTmFtZSksIF9fc3ByZWFkVmFsdWVzKHsgcmF3OiB0cnVlIH0sIG9wdGlvbnMpKTtcbiAgICBpZiAocmVzdWx0cy5sZW5ndGggJiYgcmVzdWx0c1swXS5jb25zdHJhaW50X25hbWUgIT09IFwiUFJJTUFSWVwiKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChyZXN1bHRzLm1hcCgoY29uc3RyYWludCkgPT4gdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wRm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZSwgY29uc3RyYWludC5jb25zdHJhaW50X25hbWUpLCBfX3NwcmVhZFZhbHVlcyh7IHJhdzogdHJ1ZSB9LCBvcHRpb25zKSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IucmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBjb2x1bW5OYW1lKSwgX19zcHJlYWRWYWx1ZXMoeyByYXc6IHRydWUgfSwgb3B0aW9ucykpO1xuICB9XG4gIGFzeW5jIHVwc2VydCh0YWJsZU5hbWUsIGluc2VydFZhbHVlcywgdXBkYXRlVmFsdWVzLCB3aGVyZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyk7XG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5VUFNFUlQ7XG4gICAgb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSA9IE9iamVjdC5rZXlzKHVwZGF0ZVZhbHVlcyk7XG4gICAgY29uc3QgbW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuaW5zZXJ0UXVlcnkodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIG1vZGVsLnJhd0F0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIHJlbW92ZUNvbnN0cmFpbnQodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3Iuc2hvd0NvbnN0cmFpbnRzUXVlcnkodGFibGVOYW1lLnRhYmxlTmFtZSA/IHRhYmxlTmFtZSA6IHtcbiAgICAgIHRhYmxlTmFtZSxcbiAgICAgIHNjaGVtYTogdGhpcy5zZXF1ZWxpemUuY29uZmlnLmRhdGFiYXNlXG4gICAgfSwgY29uc3RyYWludE5hbWUpO1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwge1xuICAgICAgdHlwZTogdGhpcy5zZXF1ZWxpemUuUXVlcnlUeXBlcy5TSE9XQ09OU1RSQUlOVFNcbiAgICB9KSk7XG4gICAgY29uc3QgY29uc3RyYWludCA9IGNvbnN0cmFpbnRzWzBdO1xuICAgIGxldCBxdWVyeTtcbiAgICBpZiAoIWNvbnN0cmFpbnQgfHwgIWNvbnN0cmFpbnQuY29uc3RyYWludFR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5rbm93bkNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBDb25zdHJhaW50ICR7Y29uc3RyYWludE5hbWV9IG9uIHRhYmxlICR7dGFibGVOYW1lfSBkb2VzIG5vdCBleGlzdGAsXG4gICAgICAgIGNvbnN0cmFpbnQ6IGNvbnN0cmFpbnROYW1lLFxuICAgICAgICB0YWJsZTogdGFibGVOYW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGNvbnN0cmFpbnQuY29uc3RyYWludFR5cGUgPT09IFwiRk9SRUlHTiBLRVlcIikge1xuICAgICAgcXVlcnkgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5ID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yZW1vdmVJbmRleFF1ZXJ5KGNvbnN0cmFpbnQudGFibGVOYW1lLCBjb25zdHJhaW50LmNvbnN0cmFpbnROYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHF1ZXJ5LCBvcHRpb25zKTtcbiAgfVxufVxuZXhwb3J0cy5Tbm93Zmxha2VRdWVyeUludGVyZmFjZSA9IFNub3dmbGFrZVF1ZXJ5SW50ZXJmYWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnktaW50ZXJmYWNlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/snowflake/query-interface.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/snowflake/query.js":
/*!*****************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/snowflake/query.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(action-browser)/../node_modules/sequelize/lib/utils/logger.js\");\nconst ER_DUP_ENTRY = 1062;\nconst ER_DEADLOCK = 1213;\nconst ER_ROW_IS_REFERENCED = 1451;\nconst ER_NO_REFERENCED_ROW = 1452;\nconst debug = logger.debugContext(\"sql:snowflake\");\nclass Query extends AbstractQuery {\n  static formatBindParameters(sql, values, dialect) {\n    const bindParam = [];\n    const replacementFunc = (_match, key, values_) => {\n      if (values_[key] !== void 0) {\n        bindParam.push(values_[key]);\n        return \"?\";\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, bindParam.length > 0 ? bindParam : void 0];\n  }\n  async run(sql, parameters) {\n    this.sql = sql;\n    const { connection, options } = this;\n    const showWarnings = this.sequelize.options.showWarnings || options.showWarnings;\n    const complete = this._logQuery(sql, debug, parameters);\n    if (parameters) {\n      debug(\"parameters(%j)\", parameters);\n    }\n    let results;\n    try {\n      results = await new Promise((resolve, reject) => {\n        connection.execute({\n          sqlText: sql,\n          binds: parameters,\n          complete(err, _stmt, rows) {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(rows);\n            }\n          }\n        });\n      });\n    } catch (error) {\n      if (options.transaction && error.errno === ER_DEADLOCK) {\n        try {\n          await options.transaction.rollback();\n        } catch (error_) {\n        }\n        options.transaction.finished = \"rollback\";\n      }\n      error.sql = sql;\n      error.parameters = parameters;\n      throw this.formatError(error);\n    } finally {\n      complete();\n    }\n    if (showWarnings && results && results.warningStatus > 0) {\n      await this.logWarnings(results);\n    }\n    return this.formatResults(results);\n  }\n  formatResults(data) {\n    let result = this.instance;\n    if (this.isInsertQuery(data)) {\n      this.handleInsertQuery(data);\n      if (!this.instance) {\n        if (data.constructor.name === \"ResultSetHeader\" && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n          const startId = data[this.getInsertIdField()];\n          result = [];\n          for (let i = startId; i < startId + data.affectedRows; i++) {\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\n          }\n        } else {\n          result = data[this.getInsertIdField()];\n        }\n      }\n    }\n    if (this.isSelectQuery()) {\n      if (this.options.raw === false && this.sequelize.options.quoteIdentifiers === false) {\n        const sfAttrMap = _.reduce(this.model.rawAttributes, (m, v, k) => {\n          m[k.toUpperCase()] = k;\n          return m;\n        }, {});\n        data = data.map((data2) => _.reduce(data2, (prev, value, key) => {\n          if (value !== void 0 && sfAttrMap[key]) {\n            prev[sfAttrMap[key]] = value;\n            delete prev[key];\n          }\n          return prev;\n        }, data2));\n      }\n      this.options.fieldMap = _.mapKeys(this.options.fieldMap, (v, k) => {\n        return k.toUpperCase();\n      });\n      return this.handleSelectQuery(data);\n    }\n    if (this.isShowTablesQuery()) {\n      return this.handleShowTablesQuery(data);\n    }\n    if (this.isDescribeQuery()) {\n      result = {};\n      for (const _result of data) {\n        result[_result.Field] = {\n          type: _result.Type.toUpperCase(),\n          allowNull: _result.Null === \"YES\",\n          defaultValue: _result.Default,\n          primaryKey: _result.Key === \"PRI\",\n          autoIncrement: Object.prototype.hasOwnProperty.call(_result, \"Extra\") && _result.Extra.toLowerCase() === \"auto_increment\",\n          comment: _result.Comment ? _result.Comment : null\n        };\n      }\n      return result;\n    }\n    if (this.isShowIndexesQuery()) {\n      return this.handleShowIndexesQuery(data);\n    }\n    if (this.isCallQuery()) {\n      return data[0];\n    }\n    if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery()) {\n      return data[0][\"number of rows updated\"];\n    }\n    if (this.isVersionQuery()) {\n      return data[0].version;\n    }\n    if (this.isForeignKeysQuery()) {\n      return data;\n    }\n    if (this.isUpsertQuery()) {\n      return [result, data.affectedRows === 1];\n    }\n    if (this.isInsertQuery() || this.isUpdateQuery()) {\n      return [result, data.affectedRows];\n    }\n    if (this.isShowConstraintsQuery()) {\n      return data;\n    }\n    if (this.isRawQuery()) {\n      return [data, data];\n    }\n    return result;\n  }\n  async logWarnings(results) {\n    const warningResults = await this.run(\"SHOW WARNINGS\");\n    const warningMessage = `Snowflake Warnings (${this.connection.uuid || \"default\"}): `;\n    const messages = [];\n    for (const _warningRow of warningResults) {\n      if (_warningRow === void 0 || typeof _warningRow[Symbol.iterator] !== \"function\") {\n        continue;\n      }\n      for (const _warningResult of _warningRow) {\n        if (Object.prototype.hasOwnProperty.call(_warningResult, \"Message\")) {\n          messages.push(_warningResult.Message);\n        } else {\n          for (const _objectKey of _warningResult.keys()) {\n            messages.push([_objectKey, _warningResult[_objectKey]].join(\": \"));\n          }\n        }\n      }\n    }\n    this.sequelize.log(warningMessage + messages.join(\"; \"), this.options);\n    return results;\n  }\n  formatError(err) {\n    const errCode = err.errno || err.code;\n    switch (errCode) {\n      case ER_DUP_ENTRY: {\n        const match = err.message.match(/Duplicate entry '([\\s\\S]*)' for key '?((.|\\s)*?)'?$/);\n        let fields = {};\n        let message = \"Validation error\";\n        const values = match ? match[1].split(\"-\") : void 0;\n        const fieldKey = match ? match[2] : void 0;\n        const fieldVal = match ? match[1] : void 0;\n        const uniqueKey = this.model && this.model.uniqueKeys[fieldKey];\n        if (uniqueKey) {\n          if (uniqueKey.msg)\n            message = uniqueKey.msg;\n          fields = _.zipObject(uniqueKey.fields, values);\n        } else {\n          fields[fieldKey] = fieldVal;\n        }\n        const errors = [];\n        _.forOwn(fields, (value, field) => {\n          errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, value, this.instance, \"not_unique\"));\n        });\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });\n      }\n      case ER_ROW_IS_REFERENCED:\n      case ER_NO_REFERENCED_ROW: {\n        const match = err.message.match(/CONSTRAINT ([`\"])(.*)\\1 FOREIGN KEY \\(\\1(.*)\\1\\) REFERENCES \\1(.*)\\1 \\(\\1(.*)\\1\\)/);\n        const quoteChar = match ? match[1] : \"`\";\n        const fields = match ? match[3].split(new RegExp(`${quoteChar}, *${quoteChar}`)) : void 0;\n        return new sequelizeErrors.ForeignKeyConstraintError({\n          reltype: String(errCode) === String(ER_ROW_IS_REFERENCED) ? \"parent\" : \"child\",\n          table: match ? match[4] : void 0,\n          fields,\n          value: fields && fields.length && this.instance && this.instance[fields[0]] || void 0,\n          index: match ? match[2] : void 0,\n          parent: err\n        });\n      }\n      default:\n        return new sequelizeErrors.DatabaseError(err);\n    }\n  }\n  handleShowIndexesQuery(data) {\n    data = data.reduce((acc, item) => {\n      if (!(item.Key_name in acc)) {\n        acc[item.Key_name] = item;\n        item.fields = [];\n      }\n      acc[item.Key_name].fields[item.Seq_in_index - 1] = {\n        attribute: item.Column_name,\n        length: item.Sub_part || void 0,\n        order: item.Collation === \"A\" ? \"ASC\" : void 0\n      };\n      delete item.column_name;\n      return acc;\n    }, {});\n    return _.map(data, (item) => ({\n      primary: item.Key_name === \"PRIMARY\",\n      fields: item.fields,\n      name: item.Key_name,\n      tableName: item.Table,\n      unique: item.Non_unique !== 1,\n      type: item.Index_type\n    }));\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports[\"default\"] = Query;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixzQkFBc0IsbUJBQU8sQ0FBQyxvR0FBbUI7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMsb0ZBQWM7QUFDOUMsVUFBVSxtQkFBTyxDQUFDLGlFQUFRO0FBQzFCLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsMEZBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlDQUFpQztBQUNqRSwwQkFBMEIscUVBQXFFO0FBQy9GO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxrQ0FBa0M7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDJEQUEyRCxzQ0FBc0M7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxVQUFVLEtBQUssVUFBVTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIseUJBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Nub3dmbGFrZS9xdWVyeS5qcz9lNGRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgQWJzdHJhY3RRdWVyeSA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9xdWVyeVwiKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvbG9nZ2VyXCIpO1xuY29uc3QgRVJfRFVQX0VOVFJZID0gMTA2MjtcbmNvbnN0IEVSX0RFQURMT0NLID0gMTIxMztcbmNvbnN0IEVSX1JPV19JU19SRUZFUkVOQ0VEID0gMTQ1MTtcbmNvbnN0IEVSX05PX1JFRkVSRU5DRURfUk9XID0gMTQ1MjtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dChcInNxbDpzbm93Zmxha2VcIik7XG5jbGFzcyBRdWVyeSBleHRlbmRzIEFic3RyYWN0UXVlcnkge1xuICBzdGF0aWMgZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QpIHtcbiAgICBjb25zdCBiaW5kUGFyYW0gPSBbXTtcbiAgICBjb25zdCByZXBsYWNlbWVudEZ1bmMgPSAoX21hdGNoLCBrZXksIHZhbHVlc18pID0+IHtcbiAgICAgIGlmICh2YWx1ZXNfW2tleV0gIT09IHZvaWQgMCkge1xuICAgICAgICBiaW5kUGFyYW0ucHVzaCh2YWx1ZXNfW2tleV0pO1xuICAgICAgICByZXR1cm4gXCI/XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG4gICAgc3FsID0gQWJzdHJhY3RRdWVyeS5mb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCwgcmVwbGFjZW1lbnRGdW5jKVswXTtcbiAgICByZXR1cm4gW3NxbCwgYmluZFBhcmFtLmxlbmd0aCA+IDAgPyBiaW5kUGFyYW0gOiB2b2lkIDBdO1xuICB9XG4gIGFzeW5jIHJ1bihzcWwsIHBhcmFtZXRlcnMpIHtcbiAgICB0aGlzLnNxbCA9IHNxbDtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb24sIG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2hvd1dhcm5pbmdzID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5zaG93V2FybmluZ3MgfHwgb3B0aW9ucy5zaG93V2FybmluZ3M7XG4gICAgY29uc3QgY29tcGxldGUgPSB0aGlzLl9sb2dRdWVyeShzcWwsIGRlYnVnLCBwYXJhbWV0ZXJzKTtcbiAgICBpZiAocGFyYW1ldGVycykge1xuICAgICAgZGVidWcoXCJwYXJhbWV0ZXJzKCVqKVwiLCBwYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdHM7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdHMgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbm5lY3Rpb24uZXhlY3V0ZSh7XG4gICAgICAgICAgc3FsVGV4dDogc3FsLFxuICAgICAgICAgIGJpbmRzOiBwYXJhbWV0ZXJzLFxuICAgICAgICAgIGNvbXBsZXRlKGVyciwgX3N0bXQsIHJvd3MpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKHJvd3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gJiYgZXJyb3IuZXJybm8gPT09IEVSX0RFQURMT0NLKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgb3B0aW9ucy50cmFuc2FjdGlvbi5yb2xsYmFjaygpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcl8pIHtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnRyYW5zYWN0aW9uLmZpbmlzaGVkID0gXCJyb2xsYmFja1wiO1xuICAgICAgfVxuICAgICAgZXJyb3Iuc3FsID0gc3FsO1xuICAgICAgZXJyb3IucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICB0aHJvdyB0aGlzLmZvcm1hdEVycm9yKGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY29tcGxldGUoKTtcbiAgICB9XG4gICAgaWYgKHNob3dXYXJuaW5ncyAmJiByZXN1bHRzICYmIHJlc3VsdHMud2FybmluZ1N0YXR1cyA+IDApIHtcbiAgICAgIGF3YWl0IHRoaXMubG9nV2FybmluZ3MocmVzdWx0cyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZvcm1hdFJlc3VsdHMocmVzdWx0cyk7XG4gIH1cbiAgZm9ybWF0UmVzdWx0cyhkYXRhKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuaW5zdGFuY2U7XG4gICAgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeShkYXRhKSkge1xuICAgICAgdGhpcy5oYW5kbGVJbnNlcnRRdWVyeShkYXRhKTtcbiAgICAgIGlmICghdGhpcy5pbnN0YW5jZSkge1xuICAgICAgICBpZiAoZGF0YS5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIlJlc3VsdFNldEhlYWRlclwiICYmIHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC5hdXRvSW5jcmVtZW50QXR0cmlidXRlICYmIHRoaXMubW9kZWwuYXV0b0luY3JlbWVudEF0dHJpYnV0ZSA9PT0gdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlICYmIHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVdKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRJZCA9IGRhdGFbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydElkOyBpIDwgc3RhcnRJZCArIGRhdGEuYWZmZWN0ZWRSb3dzOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgW3RoaXMubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVdLmZpZWxkXTogaSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gZGF0YVt0aGlzLmdldEluc2VydElkRmllbGQoKV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTZWxlY3RRdWVyeSgpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJhdyA9PT0gZmFsc2UgJiYgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5xdW90ZUlkZW50aWZpZXJzID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBzZkF0dHJNYXAgPSBfLnJlZHVjZSh0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXMsIChtLCB2LCBrKSA9PiB7XG4gICAgICAgICAgbVtrLnRvVXBwZXJDYXNlKCldID0gaztcbiAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICBkYXRhID0gZGF0YS5tYXAoKGRhdGEyKSA9PiBfLnJlZHVjZShkYXRhMiwgKHByZXYsIHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCAmJiBzZkF0dHJNYXBba2V5XSkge1xuICAgICAgICAgICAgcHJldltzZkF0dHJNYXBba2V5XV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGRlbGV0ZSBwcmV2W2tleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9LCBkYXRhMikpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zLmZpZWxkTWFwID0gXy5tYXBLZXlzKHRoaXMub3B0aW9ucy5maWVsZE1hcCwgKHYsIGspID0+IHtcbiAgICAgICAgcmV0dXJuIGsudG9VcHBlckNhc2UoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VsZWN0UXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd1RhYmxlc1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNob3dUYWJsZXNRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNEZXNjcmliZVF1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBfcmVzdWx0IG9mIGRhdGEpIHtcbiAgICAgICAgcmVzdWx0W19yZXN1bHQuRmllbGRdID0ge1xuICAgICAgICAgIHR5cGU6IF9yZXN1bHQuVHlwZS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgIGFsbG93TnVsbDogX3Jlc3VsdC5OdWxsID09PSBcIllFU1wiLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogX3Jlc3VsdC5EZWZhdWx0LFxuICAgICAgICAgIHByaW1hcnlLZXk6IF9yZXN1bHQuS2V5ID09PSBcIlBSSVwiLFxuICAgICAgICAgIGF1dG9JbmNyZW1lbnQ6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfcmVzdWx0LCBcIkV4dHJhXCIpICYmIF9yZXN1bHQuRXh0cmEudG9Mb3dlckNhc2UoKSA9PT0gXCJhdXRvX2luY3JlbWVudFwiLFxuICAgICAgICAgIGNvbW1lbnQ6IF9yZXN1bHQuQ29tbWVudCA/IF9yZXN1bHQuQ29tbWVudCA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd0luZGV4ZXNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0NhbGxRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YVswXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNCdWxrVXBkYXRlUXVlcnkoKSB8fCB0aGlzLmlzQnVsa0RlbGV0ZVF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhWzBdW1wibnVtYmVyIG9mIHJvd3MgdXBkYXRlZFwiXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNWZXJzaW9uUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGFbMF0udmVyc2lvbjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNGb3JlaWduS2V5c1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Vwc2VydFF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbcmVzdWx0LCBkYXRhLmFmZmVjdGVkUm93cyA9PT0gMV07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkoKSB8fCB0aGlzLmlzVXBkYXRlUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFtyZXN1bHQsIGRhdGEuYWZmZWN0ZWRSb3dzXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93Q29uc3RyYWludHNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNSYXdRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW2RhdGEsIGRhdGFdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIGxvZ1dhcm5pbmdzKHJlc3VsdHMpIHtcbiAgICBjb25zdCB3YXJuaW5nUmVzdWx0cyA9IGF3YWl0IHRoaXMucnVuKFwiU0hPVyBXQVJOSU5HU1wiKTtcbiAgICBjb25zdCB3YXJuaW5nTWVzc2FnZSA9IGBTbm93Zmxha2UgV2FybmluZ3MgKCR7dGhpcy5jb25uZWN0aW9uLnV1aWQgfHwgXCJkZWZhdWx0XCJ9KTogYDtcbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgX3dhcm5pbmdSb3cgb2Ygd2FybmluZ1Jlc3VsdHMpIHtcbiAgICAgIGlmIChfd2FybmluZ1JvdyA9PT0gdm9pZCAwIHx8IHR5cGVvZiBfd2FybmluZ1Jvd1tTeW1ib2wuaXRlcmF0b3JdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IF93YXJuaW5nUmVzdWx0IG9mIF93YXJuaW5nUm93KSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX3dhcm5pbmdSZXN1bHQsIFwiTWVzc2FnZVwiKSkge1xuICAgICAgICAgIG1lc3NhZ2VzLnB1c2goX3dhcm5pbmdSZXN1bHQuTWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBfb2JqZWN0S2V5IG9mIF93YXJuaW5nUmVzdWx0LmtleXMoKSkge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaChbX29iamVjdEtleSwgX3dhcm5pbmdSZXN1bHRbX29iamVjdEtleV1dLmpvaW4oXCI6IFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2VxdWVsaXplLmxvZyh3YXJuaW5nTWVzc2FnZSArIG1lc3NhZ2VzLmpvaW4oXCI7IFwiKSwgdGhpcy5vcHRpb25zKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICBmb3JtYXRFcnJvcihlcnIpIHtcbiAgICBjb25zdCBlcnJDb2RlID0gZXJyLmVycm5vIHx8IGVyci5jb2RlO1xuICAgIHN3aXRjaCAoZXJyQ29kZSkge1xuICAgICAgY2FzZSBFUl9EVVBfRU5UUlk6IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvRHVwbGljYXRlIGVudHJ5ICcoW1xcc1xcU10qKScgZm9yIGtleSAnPygoLnxcXHMpKj8pJz8kLyk7XG4gICAgICAgIGxldCBmaWVsZHMgPSB7fTtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBcIlZhbGlkYXRpb24gZXJyb3JcIjtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gbWF0Y2ggPyBtYXRjaFsxXS5zcGxpdChcIi1cIikgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IGZpZWxkS2V5ID0gbWF0Y2ggPyBtYXRjaFsyXSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgZmllbGRWYWwgPSBtYXRjaCA/IG1hdGNoWzFdIDogdm9pZCAwO1xuICAgICAgICBjb25zdCB1bmlxdWVLZXkgPSB0aGlzLm1vZGVsICYmIHRoaXMubW9kZWwudW5pcXVlS2V5c1tmaWVsZEtleV07XG4gICAgICAgIGlmICh1bmlxdWVLZXkpIHtcbiAgICAgICAgICBpZiAodW5pcXVlS2V5Lm1zZylcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB1bmlxdWVLZXkubXNnO1xuICAgICAgICAgIGZpZWxkcyA9IF8uemlwT2JqZWN0KHVuaXF1ZUtleS5maWVsZHMsIHZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmllbGRzW2ZpZWxkS2V5XSA9IGZpZWxkVmFsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBfLmZvck93bihmaWVsZHMsICh2YWx1ZSwgZmllbGQpID0+IHtcbiAgICAgICAgICBlcnJvcnMucHVzaChuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvckl0ZW0odGhpcy5nZXRVbmlxdWVDb25zdHJhaW50RXJyb3JNZXNzYWdlKGZpZWxkKSwgXCJ1bmlxdWUgdmlvbGF0aW9uXCIsIGZpZWxkLCB2YWx1ZSwgdGhpcy5pbnN0YW5jZSwgXCJub3RfdW5pcXVlXCIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvcih7IG1lc3NhZ2UsIGVycm9ycywgcGFyZW50OiBlcnIsIGZpZWxkcyB9KTtcbiAgICAgIH1cbiAgICAgIGNhc2UgRVJfUk9XX0lTX1JFRkVSRU5DRUQ6XG4gICAgICBjYXNlIEVSX05PX1JFRkVSRU5DRURfUk9XOiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL0NPTlNUUkFJTlQgKFtgXCJdKSguKilcXDEgRk9SRUlHTiBLRVkgXFwoXFwxKC4qKVxcMVxcKSBSRUZFUkVOQ0VTIFxcMSguKilcXDEgXFwoXFwxKC4qKVxcMVxcKS8pO1xuICAgICAgICBjb25zdCBxdW90ZUNoYXIgPSBtYXRjaCA/IG1hdGNoWzFdIDogXCJgXCI7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IG1hdGNoID8gbWF0Y2hbM10uc3BsaXQobmV3IFJlZ0V4cChgJHtxdW90ZUNoYXJ9LCAqJHtxdW90ZUNoYXJ9YCkpIDogdm9pZCAwO1xuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5Gb3JlaWduS2V5Q29uc3RyYWludEVycm9yKHtcbiAgICAgICAgICByZWx0eXBlOiBTdHJpbmcoZXJyQ29kZSkgPT09IFN0cmluZyhFUl9ST1dfSVNfUkVGRVJFTkNFRCkgPyBcInBhcmVudFwiIDogXCJjaGlsZFwiLFxuICAgICAgICAgIHRhYmxlOiBtYXRjaCA/IG1hdGNoWzRdIDogdm9pZCAwLFxuICAgICAgICAgIGZpZWxkcyxcbiAgICAgICAgICB2YWx1ZTogZmllbGRzICYmIGZpZWxkcy5sZW5ndGggJiYgdGhpcy5pbnN0YW5jZSAmJiB0aGlzLmluc3RhbmNlW2ZpZWxkc1swXV0gfHwgdm9pZCAwLFxuICAgICAgICAgIGluZGV4OiBtYXRjaCA/IG1hdGNoWzJdIDogdm9pZCAwLFxuICAgICAgICAgIHBhcmVudDogZXJyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRGF0YWJhc2VFcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KGRhdGEpIHtcbiAgICBkYXRhID0gZGF0YS5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgICAgaWYgKCEoaXRlbS5LZXlfbmFtZSBpbiBhY2MpKSB7XG4gICAgICAgIGFjY1tpdGVtLktleV9uYW1lXSA9IGl0ZW07XG4gICAgICAgIGl0ZW0uZmllbGRzID0gW107XG4gICAgICB9XG4gICAgICBhY2NbaXRlbS5LZXlfbmFtZV0uZmllbGRzW2l0ZW0uU2VxX2luX2luZGV4IC0gMV0gPSB7XG4gICAgICAgIGF0dHJpYnV0ZTogaXRlbS5Db2x1bW5fbmFtZSxcbiAgICAgICAgbGVuZ3RoOiBpdGVtLlN1Yl9wYXJ0IHx8IHZvaWQgMCxcbiAgICAgICAgb3JkZXI6IGl0ZW0uQ29sbGF0aW9uID09PSBcIkFcIiA/IFwiQVNDXCIgOiB2b2lkIDBcbiAgICAgIH07XG4gICAgICBkZWxldGUgaXRlbS5jb2x1bW5fbmFtZTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBfLm1hcChkYXRhLCAoaXRlbSkgPT4gKHtcbiAgICAgIHByaW1hcnk6IGl0ZW0uS2V5X25hbWUgPT09IFwiUFJJTUFSWVwiLFxuICAgICAgZmllbGRzOiBpdGVtLmZpZWxkcyxcbiAgICAgIG5hbWU6IGl0ZW0uS2V5X25hbWUsXG4gICAgICB0YWJsZU5hbWU6IGl0ZW0uVGFibGUsXG4gICAgICB1bmlxdWU6IGl0ZW0uTm9uX3VuaXF1ZSAhPT0gMSxcbiAgICAgIHR5cGU6IGl0ZW0uSW5kZXhfdHlwZVxuICAgIH0pKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeTtcbm1vZHVsZS5leHBvcnRzLlF1ZXJ5ID0gUXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gUXVlcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/snowflake/query.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/sqlite/connection-manager.js":
/*!***************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/sqlite/connection-manager.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(action-browser)/../node_modules/sequelize/lib/utils/logger.js\");\nconst debug = logger.debugContext(\"connection:sqlite\");\nconst dataTypes = (__webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\").sqlite);\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(action-browser)/../node_modules/sequelize/lib/dialects/parserStore.js\")(\"sqlite\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n    if (this.sequelize.options.host === \"localhost\") {\n      delete this.sequelize.options.host;\n    }\n    this.connections = {};\n    this.lib = this._loadDialectModule(\"sqlite3\");\n    this.refreshTypeParser(dataTypes);\n  }\n  async _onProcessExit() {\n    await Promise.all(Object.getOwnPropertyNames(this.connections).map((connection) => promisify((callback) => this.connections[connection].close(callback))()));\n    return super._onProcessExit.call(this);\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  async getConnection(options) {\n    options = options || {};\n    options.uuid = options.uuid || \"default\";\n    if (!!this.sequelize.options.storage !== null && this.sequelize.options.storage !== void 0) {\n      options.storage = this.sequelize.options.storage;\n    } else {\n      options.storage = this.sequelize.options.host || \":memory:\";\n    }\n    options.inMemory = options.storage === \":memory:\" ? 1 : 0;\n    const dialectOptions = this.sequelize.options.dialectOptions;\n    const defaultReadWriteMode = this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE;\n    options.readWriteMode = dialectOptions && dialectOptions.mode || defaultReadWriteMode;\n    if (this.connections[options.inMemory || options.uuid]) {\n      return this.connections[options.inMemory || options.uuid];\n    }\n    if (!options.inMemory && (options.readWriteMode & this.lib.OPEN_CREATE) !== 0) {\n      fs.mkdirSync(path.dirname(options.storage), { recursive: true });\n    }\n    const connection = await new Promise((resolve, reject) => {\n      this.connections[options.inMemory || options.uuid] = new this.lib.Database(options.storage, options.readWriteMode, (err) => {\n        if (err)\n          return reject(new sequelizeErrors.ConnectionError(err));\n        debug(`connection acquired ${options.uuid}`);\n        resolve(this.connections[options.inMemory || options.uuid]);\n      });\n    });\n    if (this.sequelize.config.password) {\n      connection.run(`PRAGMA KEY=${this.sequelize.escape(this.sequelize.config.password)}`);\n    }\n    if (this.sequelize.options.foreignKeys !== false) {\n      connection.run(\"PRAGMA FOREIGN_KEYS=ON\");\n    }\n    return connection;\n  }\n  releaseConnection(connection, force) {\n    if (connection.filename === \":memory:\" && force !== true)\n      return;\n    if (connection.uuid) {\n      connection.close();\n      debug(`connection released ${connection.uuid}`);\n      delete this.connections[connection.uuid];\n    }\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvY29ubmVjdGlvbi1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGtDQUFrQyxtQkFBTyxDQUFDLDhIQUFnQztBQUMxRSxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDBGQUFvQjtBQUMvQztBQUNBLGtCQUFrQixvSEFBa0M7QUFDcEQsd0JBQXdCLG1CQUFPLENBQUMsb0ZBQWM7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsOEZBQWdCO0FBQzVDLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsa0JBQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUJBQWlCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsYUFBYTtBQUNsRDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxtQ0FBbUMsc0RBQXNEO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMseUJBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3NxbGl0ZS9jb25uZWN0aW9uLW1hbmFnZXIuanM/MmYyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9jb25uZWN0aW9uLW1hbmFnZXJcIik7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2xvZ2dlclwiKTtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dChcImNvbm5lY3Rpb246c3FsaXRlXCIpO1xuY29uc3QgZGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIikuc3FsaXRlO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc1wiKTtcbmNvbnN0IHBhcnNlclN0b3JlID0gcmVxdWlyZShcIi4uL3BhcnNlclN0b3JlXCIpKFwic3FsaXRlXCIpO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY2xhc3MgQ29ubmVjdGlvbk1hbmFnZXIgZXh0ZW5kcyBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZGlhbGVjdCwgc2VxdWVsaXplKSB7XG4gICAgc3VwZXIoZGlhbGVjdCwgc2VxdWVsaXplKTtcbiAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5ob3N0ID09PSBcImxvY2FsaG9zdFwiKSB7XG4gICAgICBkZWxldGUgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5ob3N0O1xuICAgIH1cbiAgICB0aGlzLmNvbm5lY3Rpb25zID0ge307XG4gICAgdGhpcy5saWIgPSB0aGlzLl9sb2FkRGlhbGVjdE1vZHVsZShcInNxbGl0ZTNcIik7XG4gICAgdGhpcy5yZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZXMpO1xuICB9XG4gIGFzeW5jIF9vblByb2Nlc3NFeGl0KCkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuY29ubmVjdGlvbnMpLm1hcCgoY29ubmVjdGlvbikgPT4gcHJvbWlzaWZ5KChjYWxsYmFjaykgPT4gdGhpcy5jb25uZWN0aW9uc1tjb25uZWN0aW9uXS5jbG9zZShjYWxsYmFjaykpKCkpKTtcbiAgICByZXR1cm4gc3VwZXIuX29uUHJvY2Vzc0V4aXQuY2FsbCh0aGlzKTtcbiAgfVxuICBfcmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGUpIHtcbiAgICBwYXJzZXJTdG9yZS5yZWZyZXNoKGRhdGFUeXBlKTtcbiAgfVxuICBfY2xlYXJUeXBlUGFyc2VyKCkge1xuICAgIHBhcnNlclN0b3JlLmNsZWFyKCk7XG4gIH1cbiAgYXN5bmMgZ2V0Q29ubmVjdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51dWlkID0gb3B0aW9ucy51dWlkIHx8IFwiZGVmYXVsdFwiO1xuICAgIGlmICghIXRoaXMuc2VxdWVsaXplLm9wdGlvbnMuc3RvcmFnZSAhPT0gbnVsbCAmJiB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnN0b3JhZ2UgIT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucy5zdG9yYWdlID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5zdG9yYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLnN0b3JhZ2UgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmhvc3QgfHwgXCI6bWVtb3J5OlwiO1xuICAgIH1cbiAgICBvcHRpb25zLmluTWVtb3J5ID0gb3B0aW9ucy5zdG9yYWdlID09PSBcIjptZW1vcnk6XCIgPyAxIDogMDtcbiAgICBjb25zdCBkaWFsZWN0T3B0aW9ucyA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdE9wdGlvbnM7XG4gICAgY29uc3QgZGVmYXVsdFJlYWRXcml0ZU1vZGUgPSB0aGlzLmxpYi5PUEVOX1JFQURXUklURSB8IHRoaXMubGliLk9QRU5fQ1JFQVRFO1xuICAgIG9wdGlvbnMucmVhZFdyaXRlTW9kZSA9IGRpYWxlY3RPcHRpb25zICYmIGRpYWxlY3RPcHRpb25zLm1vZGUgfHwgZGVmYXVsdFJlYWRXcml0ZU1vZGU7XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbnNbb3B0aW9ucy5pbk1lbW9yeSB8fCBvcHRpb25zLnV1aWRdKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uc1tvcHRpb25zLmluTWVtb3J5IHx8IG9wdGlvbnMudXVpZF07XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5pbk1lbW9yeSAmJiAob3B0aW9ucy5yZWFkV3JpdGVNb2RlICYgdGhpcy5saWIuT1BFTl9DUkVBVEUpICE9PSAwKSB7XG4gICAgICBmcy5ta2RpclN5bmMocGF0aC5kaXJuYW1lKG9wdGlvbnMuc3RvcmFnZSksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIH1cbiAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5jb25uZWN0aW9uc1tvcHRpb25zLmluTWVtb3J5IHx8IG9wdGlvbnMudXVpZF0gPSBuZXcgdGhpcy5saWIuRGF0YWJhc2Uob3B0aW9ucy5zdG9yYWdlLCBvcHRpb25zLnJlYWRXcml0ZU1vZGUsIChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycilcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBzZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvbkVycm9yKGVycikpO1xuICAgICAgICBkZWJ1ZyhgY29ubmVjdGlvbiBhY3F1aXJlZCAke29wdGlvbnMudXVpZH1gKTtcbiAgICAgICAgcmVzb2x2ZSh0aGlzLmNvbm5lY3Rpb25zW29wdGlvbnMuaW5NZW1vcnkgfHwgb3B0aW9ucy51dWlkXSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5zZXF1ZWxpemUuY29uZmlnLnBhc3N3b3JkKSB7XG4gICAgICBjb25uZWN0aW9uLnJ1bihgUFJBR01BIEtFWT0ke3RoaXMuc2VxdWVsaXplLmVzY2FwZSh0aGlzLnNlcXVlbGl6ZS5jb25maWcucGFzc3dvcmQpfWApO1xuICAgIH1cbiAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5mb3JlaWduS2V5cyAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbm5lY3Rpb24ucnVuKFwiUFJBR01BIEZPUkVJR05fS0VZUz1PTlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gIH1cbiAgcmVsZWFzZUNvbm5lY3Rpb24oY29ubmVjdGlvbiwgZm9yY2UpIHtcbiAgICBpZiAoY29ubmVjdGlvbi5maWxlbmFtZSA9PT0gXCI6bWVtb3J5OlwiICYmIGZvcmNlICE9PSB0cnVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChjb25uZWN0aW9uLnV1aWQpIHtcbiAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgIGRlYnVnKGBjb25uZWN0aW9uIHJlbGVhc2VkICR7Y29ubmVjdGlvbi51dWlkfWApO1xuICAgICAgZGVsZXRlIHRoaXMuY29ubmVjdGlvbnNbY29ubmVjdGlvbi51dWlkXTtcbiAgICB9XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uTWFuYWdlciA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb25NYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbi1tYW5hZ2VyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/sqlite/connection-manager.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/sqlite/data-types.js":
/*!*******************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/sqlite/data-types.js ***!
  \*******************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = (BaseTypes) => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"https://www.sqlite.org/datatype3.html\");\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._zerofill || dataType._unsigned) {\n      warn(`SQLite does not support '${dataType.key}' with UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);\n      dataType._unsigned = void 0;\n      dataType._zerofill = void 0;\n    }\n  }\n  BaseTypes.DATE.types.sqlite = [\"DATETIME\"];\n  BaseTypes.STRING.types.sqlite = [\"VARCHAR\", \"VARCHAR BINARY\"];\n  BaseTypes.CHAR.types.sqlite = [\"CHAR\", \"CHAR BINARY\"];\n  BaseTypes.TEXT.types.sqlite = [\"TEXT\"];\n  BaseTypes.TINYINT.types.sqlite = [\"TINYINT\"];\n  BaseTypes.SMALLINT.types.sqlite = [\"SMALLINT\"];\n  BaseTypes.MEDIUMINT.types.sqlite = [\"MEDIUMINT\"];\n  BaseTypes.INTEGER.types.sqlite = [\"INTEGER\"];\n  BaseTypes.BIGINT.types.sqlite = [\"BIGINT\"];\n  BaseTypes.FLOAT.types.sqlite = [\"FLOAT\"];\n  BaseTypes.TIME.types.sqlite = [\"TIME\"];\n  BaseTypes.DATEONLY.types.sqlite = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.sqlite = [\"TINYINT\"];\n  BaseTypes.BLOB.types.sqlite = [\"TINYBLOB\", \"BLOB\", \"LONGBLOB\"];\n  BaseTypes.DECIMAL.types.sqlite = [\"DECIMAL\"];\n  BaseTypes.UUID.types.sqlite = [\"UUID\"];\n  BaseTypes.ENUM.types.sqlite = false;\n  BaseTypes.REAL.types.sqlite = [\"REAL\"];\n  BaseTypes.DOUBLE.types.sqlite = [\"DOUBLE PRECISION\"];\n  BaseTypes.GEOMETRY.types.sqlite = false;\n  BaseTypes.JSON.types.sqlite = [\"JSON\", \"JSONB\"];\n  class JSONTYPE extends BaseTypes.JSON {\n    static parse(data) {\n      return JSON.parse(data);\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    static parse(date, options) {\n      if (!date.includes(\"+\")) {\n        return new Date(date + options.timezone);\n      }\n      return new Date(date);\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(date) {\n      return date;\n    }\n  }\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this._binary) {\n        return `VARCHAR BINARY(${this._length})`;\n      }\n      return super.toSql(this);\n    }\n  }\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      if (this._length) {\n        warn(\"SQLite does not support TEXT with options. Plain `TEXT` will be used instead.\");\n        this._length = void 0;\n      }\n      return \"TEXT\";\n    }\n  }\n  class CITEXT extends BaseTypes.CITEXT {\n    toSql() {\n      return \"TEXT COLLATE NOCASE\";\n    }\n  }\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        return `CHAR BINARY(${this._length})`;\n      }\n      return super.toSql();\n    }\n  }\n  class NUMBER extends BaseTypes.NUMBER {\n    toSql() {\n      let result = this.key;\n      if (this._unsigned) {\n        result += \" UNSIGNED\";\n      }\n      if (this._zerofill) {\n        result += \" ZEROFILL\";\n      }\n      if (this._length) {\n        result += `(${this._length}`;\n        if (typeof this._decimals === \"number\") {\n          result += `,${this._decimals}`;\n        }\n        result += \")\";\n      }\n      return result;\n    }\n  }\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class MEDIUMINT extends BaseTypes.MEDIUMINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class FLOAT extends BaseTypes.FLOAT {\n  }\n  class DOUBLE extends BaseTypes.DOUBLE {\n  }\n  class REAL extends BaseTypes.REAL {\n  }\n  function parseFloating(value) {\n    if (typeof value !== \"string\") {\n      return value;\n    }\n    if (value === \"NaN\") {\n      return NaN;\n    }\n    if (value === \"Infinity\") {\n      return Infinity;\n    }\n    if (value === \"-Infinity\") {\n      return -Infinity;\n    }\n  }\n  for (const floating of [FLOAT, DOUBLE, REAL]) {\n    floating.parse = parseFloating;\n  }\n  for (const num of [FLOAT, DOUBLE, REAL, TINYINT, SMALLINT, MEDIUMINT, INTEGER, BIGINT]) {\n    num.prototype.toSql = NUMBER.prototype.toSql;\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return \"TEXT\";\n    }\n  }\n  return {\n    DATE,\n    DATEONLY,\n    STRING,\n    CHAR,\n    NUMBER,\n    FLOAT,\n    REAL,\n    \"DOUBLE PRECISION\": DOUBLE,\n    TINYINT,\n    SMALLINT,\n    MEDIUMINT,\n    INTEGER,\n    BIGINT,\n    TEXT,\n    ENUM,\n    JSON: JSONTYPE,\n    CITEXT\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvZGF0YS10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGFBQWEsc0NBQXNDLGFBQWE7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvZGF0YS10eXBlcy5qcz83NDY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSAoQmFzZVR5cGVzKSA9PiB7XG4gIGNvbnN0IHdhcm4gPSBCYXNlVHlwZXMuQUJTVFJBQ1Qud2Fybi5iaW5kKHZvaWQgMCwgXCJodHRwczovL3d3dy5zcWxpdGUub3JnL2RhdGF0eXBlMy5odG1sXCIpO1xuICBmdW5jdGlvbiByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKGRhdGFUeXBlKSB7XG4gICAgaWYgKGRhdGFUeXBlLl96ZXJvZmlsbCB8fCBkYXRhVHlwZS5fdW5zaWduZWQpIHtcbiAgICAgIHdhcm4oYFNRTGl0ZSBkb2VzIG5vdCBzdXBwb3J0ICcke2RhdGFUeXBlLmtleX0nIHdpdGggVU5TSUdORUQgb3IgWkVST0ZJTEwuIFBsYWluICcke2RhdGFUeXBlLmtleX0nIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLmApO1xuICAgICAgZGF0YVR5cGUuX3Vuc2lnbmVkID0gdm9pZCAwO1xuICAgICAgZGF0YVR5cGUuX3plcm9maWxsID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBCYXNlVHlwZXMuREFURS50eXBlcy5zcWxpdGUgPSBbXCJEQVRFVElNRVwiXTtcbiAgQmFzZVR5cGVzLlNUUklORy50eXBlcy5zcWxpdGUgPSBbXCJWQVJDSEFSXCIsIFwiVkFSQ0hBUiBCSU5BUllcIl07XG4gIEJhc2VUeXBlcy5DSEFSLnR5cGVzLnNxbGl0ZSA9IFtcIkNIQVJcIiwgXCJDSEFSIEJJTkFSWVwiXTtcbiAgQmFzZVR5cGVzLlRFWFQudHlwZXMuc3FsaXRlID0gW1wiVEVYVFwiXTtcbiAgQmFzZVR5cGVzLlRJTllJTlQudHlwZXMuc3FsaXRlID0gW1wiVElOWUlOVFwiXTtcbiAgQmFzZVR5cGVzLlNNQUxMSU5ULnR5cGVzLnNxbGl0ZSA9IFtcIlNNQUxMSU5UXCJdO1xuICBCYXNlVHlwZXMuTUVESVVNSU5ULnR5cGVzLnNxbGl0ZSA9IFtcIk1FRElVTUlOVFwiXTtcbiAgQmFzZVR5cGVzLklOVEVHRVIudHlwZXMuc3FsaXRlID0gW1wiSU5URUdFUlwiXTtcbiAgQmFzZVR5cGVzLkJJR0lOVC50eXBlcy5zcWxpdGUgPSBbXCJCSUdJTlRcIl07XG4gIEJhc2VUeXBlcy5GTE9BVC50eXBlcy5zcWxpdGUgPSBbXCJGTE9BVFwiXTtcbiAgQmFzZVR5cGVzLlRJTUUudHlwZXMuc3FsaXRlID0gW1wiVElNRVwiXTtcbiAgQmFzZVR5cGVzLkRBVEVPTkxZLnR5cGVzLnNxbGl0ZSA9IFtcIkRBVEVcIl07XG4gIEJhc2VUeXBlcy5CT09MRUFOLnR5cGVzLnNxbGl0ZSA9IFtcIlRJTllJTlRcIl07XG4gIEJhc2VUeXBlcy5CTE9CLnR5cGVzLnNxbGl0ZSA9IFtcIlRJTllCTE9CXCIsIFwiQkxPQlwiLCBcIkxPTkdCTE9CXCJdO1xuICBCYXNlVHlwZXMuREVDSU1BTC50eXBlcy5zcWxpdGUgPSBbXCJERUNJTUFMXCJdO1xuICBCYXNlVHlwZXMuVVVJRC50eXBlcy5zcWxpdGUgPSBbXCJVVUlEXCJdO1xuICBCYXNlVHlwZXMuRU5VTS50eXBlcy5zcWxpdGUgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLlJFQUwudHlwZXMuc3FsaXRlID0gW1wiUkVBTFwiXTtcbiAgQmFzZVR5cGVzLkRPVUJMRS50eXBlcy5zcWxpdGUgPSBbXCJET1VCTEUgUFJFQ0lTSU9OXCJdO1xuICBCYXNlVHlwZXMuR0VPTUVUUlkudHlwZXMuc3FsaXRlID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5KU09OLnR5cGVzLnNxbGl0ZSA9IFtcIkpTT05cIiwgXCJKU09OQlwiXTtcbiAgY2xhc3MgSlNPTlRZUEUgZXh0ZW5kcyBCYXNlVHlwZXMuSlNPTiB7XG4gICAgc3RhdGljIHBhcnNlKGRhdGEpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBEQVRFIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEUge1xuICAgIHN0YXRpYyBwYXJzZShkYXRlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIWRhdGUuaW5jbHVkZXMoXCIrXCIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlICsgb3B0aW9ucy50aW1lem9uZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSk7XG4gICAgfVxuICB9XG4gIGNsYXNzIERBVEVPTkxZIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEVPTkxZIHtcbiAgICBzdGF0aWMgcGFyc2UoZGF0ZSkge1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICB9XG4gIGNsYXNzIFNUUklORyBleHRlbmRzIEJhc2VUeXBlcy5TVFJJTkcge1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2JpbmFyeSkge1xuICAgICAgICByZXR1cm4gYFZBUkNIQVIgQklOQVJZKCR7dGhpcy5fbGVuZ3RofSlgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cGVyLnRvU3FsKHRoaXMpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBURVhUIGV4dGVuZHMgQmFzZVR5cGVzLlRFWFQge1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICB3YXJuKFwiU1FMaXRlIGRvZXMgbm90IHN1cHBvcnQgVEVYVCB3aXRoIG9wdGlvbnMuIFBsYWluIGBURVhUYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cIik7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIlRFWFRcIjtcbiAgICB9XG4gIH1cbiAgY2xhc3MgQ0lURVhUIGV4dGVuZHMgQmFzZVR5cGVzLkNJVEVYVCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJURVhUIENPTExBVEUgTk9DQVNFXCI7XG4gICAgfVxuICB9XG4gIGNsYXNzIENIQVIgZXh0ZW5kcyBCYXNlVHlwZXMuQ0hBUiB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fYmluYXJ5KSB7XG4gICAgICAgIHJldHVybiBgQ0hBUiBCSU5BUlkoJHt0aGlzLl9sZW5ndGh9KWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwZXIudG9TcWwoKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgTlVNQkVSIGV4dGVuZHMgQmFzZVR5cGVzLk5VTUJFUiB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gdGhpcy5rZXk7XG4gICAgICBpZiAodGhpcy5fdW5zaWduZWQpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiIFVOU0lHTkVEXCI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5femVyb2ZpbGwpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiIFpFUk9GSUxMXCI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCArPSBgKCR7dGhpcy5fbGVuZ3RofWA7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fZGVjaW1hbHMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICByZXN1bHQgKz0gYCwke3RoaXMuX2RlY2ltYWxzfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IFwiKVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgY2xhc3MgVElOWUlOVCBleHRlbmRzIEJhc2VUeXBlcy5USU5ZSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBTTUFMTElOVCBleHRlbmRzIEJhc2VUeXBlcy5TTUFMTElOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgTUVESVVNSU5UIGV4dGVuZHMgQmFzZVR5cGVzLk1FRElVTUlOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgSU5URUdFUiBleHRlbmRzIEJhc2VUeXBlcy5JTlRFR0VSIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBCSUdJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuQklHSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBGTE9BVCBleHRlbmRzIEJhc2VUeXBlcy5GTE9BVCB7XG4gIH1cbiAgY2xhc3MgRE9VQkxFIGV4dGVuZHMgQmFzZVR5cGVzLkRPVUJMRSB7XG4gIH1cbiAgY2xhc3MgUkVBTCBleHRlbmRzIEJhc2VUeXBlcy5SRUFMIHtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZUZsb2F0aW5nKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IFwiTmFOXCIpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gXCJJbmZpbml0eVwiKSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gXCItSW5maW5pdHlcIikge1xuICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBmbG9hdGluZyBvZiBbRkxPQVQsIERPVUJMRSwgUkVBTF0pIHtcbiAgICBmbG9hdGluZy5wYXJzZSA9IHBhcnNlRmxvYXRpbmc7XG4gIH1cbiAgZm9yIChjb25zdCBudW0gb2YgW0ZMT0FULCBET1VCTEUsIFJFQUwsIFRJTllJTlQsIFNNQUxMSU5ULCBNRURJVU1JTlQsIElOVEVHRVIsIEJJR0lOVF0pIHtcbiAgICBudW0ucHJvdG90eXBlLnRvU3FsID0gTlVNQkVSLnByb3RvdHlwZS50b1NxbDtcbiAgfVxuICBjbGFzcyBFTlVNIGV4dGVuZHMgQmFzZVR5cGVzLkVOVU0ge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiVEVYVFwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIERBVEUsXG4gICAgREFURU9OTFksXG4gICAgU1RSSU5HLFxuICAgIENIQVIsXG4gICAgTlVNQkVSLFxuICAgIEZMT0FULFxuICAgIFJFQUwsXG4gICAgXCJET1VCTEUgUFJFQ0lTSU9OXCI6IERPVUJMRSxcbiAgICBUSU5ZSU5ULFxuICAgIFNNQUxMSU5ULFxuICAgIE1FRElVTUlOVCxcbiAgICBJTlRFR0VSLFxuICAgIEJJR0lOVCxcbiAgICBURVhULFxuICAgIEVOVU0sXG4gICAgSlNPTjogSlNPTlRZUEUsXG4gICAgQ0lURVhUXG4gIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS10eXBlcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/sqlite/data-types.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/sqlite/index.js":
/*!**************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/sqlite/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst AbstractDialect = __webpack_require__(/*! ../abstract */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst ConnectionManager = __webpack_require__(/*! ./connection-manager */ \"(action-browser)/../node_modules/sequelize/lib/dialects/sqlite/connection-manager.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(action-browser)/../node_modules/sequelize/lib/dialects/sqlite/query.js\");\nconst QueryGenerator = __webpack_require__(/*! ./query-generator */ \"(action-browser)/../node_modules/sequelize/lib/dialects/sqlite/query-generator.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\").sqlite);\nconst { SQLiteQueryInterface } = __webpack_require__(/*! ./query-interface */ \"(action-browser)/../node_modules/sequelize/lib/dialects/sqlite/query-interface.js\");\nclass SqliteDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new SQLiteQueryInterface(sequelize, this.queryGenerator);\n  }\n}\nSqliteDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  DEFAULT: false,\n  \"DEFAULT VALUES\": true,\n  \"UNION ALL\": false,\n  \"RIGHT JOIN\": false,\n  inserts: {\n    ignoreDuplicates: \" OR IGNORE\",\n    updateOnDuplicate: \" ON CONFLICT DO UPDATE SET\",\n    conflictFields: true,\n    onConflictWhere: true\n  },\n  index: {\n    using: false,\n    where: true,\n    functionBased: true\n  },\n  transactionOptions: {\n    type: true\n  },\n  constraints: {\n    addConstraint: false,\n    dropConstraint: false\n  },\n  groupedLimit: false,\n  JSON: true\n});\nSqliteDialect.prototype.defaultVersion = \"3.8.0\";\nSqliteDialect.prototype.Query = Query;\nSqliteDialect.prototype.DataTypes = DataTypes;\nSqliteDialect.prototype.name = \"sqlite\";\nSqliteDialect.prototype.TICK_CHAR = \"`\";\nSqliteDialect.prototype.TICK_CHAR_LEFT = SqliteDialect.prototype.TICK_CHAR;\nSqliteDialect.prototype.TICK_CHAR_RIGHT = SqliteDialect.prototype.TICK_CHAR;\nmodule.exports = SqliteDialect;\nmodule.exports.SqliteDialect = SqliteDialect;\nmodule.exports[\"default\"] = SqliteDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixVQUFVLG1CQUFPLENBQUMsaUVBQVE7QUFDMUIsd0JBQXdCLG1CQUFPLENBQUMsOEZBQWE7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMsa0hBQXNCO0FBQ3hELGNBQWMsbUJBQU8sQ0FBQyx3RkFBUztBQUMvQix1QkFBdUIsbUJBQU8sQ0FBQyw0R0FBbUI7QUFDbEQsa0JBQWtCLG9IQUFrQztBQUNwRCxRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsNEdBQW1CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvaW5kZXguanM/NDM0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgQWJzdHJhY3REaWFsZWN0ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0XCIpO1xuY29uc3QgQ29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi9jb25uZWN0aW9uLW1hbmFnZXJcIik7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoXCIuL3F1ZXJ5XCIpO1xuY29uc3QgUXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKFwiLi9xdWVyeS1nZW5lcmF0b3JcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKS5zcWxpdGU7XG5jb25zdCB7IFNRTGl0ZVF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKFwiLi9xdWVyeS1pbnRlcmZhY2VcIik7XG5jbGFzcyBTcWxpdGVEaWFsZWN0IGV4dGVuZHMgQWJzdHJhY3REaWFsZWN0IHtcbiAgY29uc3RydWN0b3Ioc2VxdWVsaXplKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gbmV3IENvbm5lY3Rpb25NYW5hZ2VyKHRoaXMsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5xdWVyeUdlbmVyYXRvciA9IG5ldyBRdWVyeUdlbmVyYXRvcih7XG4gICAgICBfZGlhbGVjdDogdGhpcyxcbiAgICAgIHNlcXVlbGl6ZVxuICAgIH0pO1xuICAgIHRoaXMucXVlcnlJbnRlcmZhY2UgPSBuZXcgU1FMaXRlUXVlcnlJbnRlcmZhY2Uoc2VxdWVsaXplLCB0aGlzLnF1ZXJ5R2VuZXJhdG9yKTtcbiAgfVxufVxuU3FsaXRlRGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMgPSBfLm1lcmdlKF8uY2xvbmVEZWVwKEFic3RyYWN0RGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMpLCB7XG4gIERFRkFVTFQ6IGZhbHNlLFxuICBcIkRFRkFVTFQgVkFMVUVTXCI6IHRydWUsXG4gIFwiVU5JT04gQUxMXCI6IGZhbHNlLFxuICBcIlJJR0hUIEpPSU5cIjogZmFsc2UsXG4gIGluc2VydHM6IHtcbiAgICBpZ25vcmVEdXBsaWNhdGVzOiBcIiBPUiBJR05PUkVcIixcbiAgICB1cGRhdGVPbkR1cGxpY2F0ZTogXCIgT04gQ09ORkxJQ1QgRE8gVVBEQVRFIFNFVFwiLFxuICAgIGNvbmZsaWN0RmllbGRzOiB0cnVlLFxuICAgIG9uQ29uZmxpY3RXaGVyZTogdHJ1ZVxuICB9LFxuICBpbmRleDoge1xuICAgIHVzaW5nOiBmYWxzZSxcbiAgICB3aGVyZTogdHJ1ZSxcbiAgICBmdW5jdGlvbkJhc2VkOiB0cnVlXG4gIH0sXG4gIHRyYW5zYWN0aW9uT3B0aW9uczoge1xuICAgIHR5cGU6IHRydWVcbiAgfSxcbiAgY29uc3RyYWludHM6IHtcbiAgICBhZGRDb25zdHJhaW50OiBmYWxzZSxcbiAgICBkcm9wQ29uc3RyYWludDogZmFsc2VcbiAgfSxcbiAgZ3JvdXBlZExpbWl0OiBmYWxzZSxcbiAgSlNPTjogdHJ1ZVxufSk7XG5TcWxpdGVEaWFsZWN0LnByb3RvdHlwZS5kZWZhdWx0VmVyc2lvbiA9IFwiMy44LjBcIjtcblNxbGl0ZURpYWxlY3QucHJvdG90eXBlLlF1ZXJ5ID0gUXVlcnk7XG5TcWxpdGVEaWFsZWN0LnByb3RvdHlwZS5EYXRhVHlwZXMgPSBEYXRhVHlwZXM7XG5TcWxpdGVEaWFsZWN0LnByb3RvdHlwZS5uYW1lID0gXCJzcWxpdGVcIjtcblNxbGl0ZURpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUiA9IFwiYFwiO1xuU3FsaXRlRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX0xFRlQgPSBTcWxpdGVEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVI7XG5TcWxpdGVEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfUklHSFQgPSBTcWxpdGVEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVI7XG5tb2R1bGUuZXhwb3J0cyA9IFNxbGl0ZURpYWxlY3Q7XG5tb2R1bGUuZXhwb3J0cy5TcWxpdGVEaWFsZWN0ID0gU3FsaXRlRGlhbGVjdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBTcWxpdGVEaWFsZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/sqlite/index.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/sqlite/query-generator.js":
/*!************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/sqlite/query-generator.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst Utils = __webpack_require__(/*! ../../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst Transaction = __webpack_require__(/*! ../../transaction */ \"(action-browser)/../node_modules/sequelize/lib/transaction.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst MySqlQueryGenerator = __webpack_require__(/*! ../mysql/query-generator */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mysql/query-generator.js\");\nconst AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-generator.js\");\nclass SQLiteQueryGenerator extends MySqlQueryGenerator {\n  createSchema() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n  showSchemasQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n  versionQuery() {\n    return \"SELECT sqlite_version() as `version`\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    options = options || {};\n    const primaryKeys = [];\n    const needsMultiplePrimaryKeys = Object.values(attributes).filter((definition) => definition.includes(\"PRIMARY KEY\")).length > 1;\n    const attrArray = [];\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        const dataType = attributes[attr];\n        const containsAutoIncrement = dataType.includes(\"AUTOINCREMENT\");\n        let dataTypeString = dataType;\n        if (dataType.includes(\"PRIMARY KEY\")) {\n          if (dataType.includes(\"INT\")) {\n            dataTypeString = containsAutoIncrement ? \"INTEGER PRIMARY KEY AUTOINCREMENT\" : \"INTEGER PRIMARY KEY\";\n            if (dataType.includes(\" REFERENCES\")) {\n              dataTypeString += dataType.substr(dataType.indexOf(\" REFERENCES\"));\n            }\n          }\n          if (needsMultiplePrimaryKeys) {\n            primaryKeys.push(attr);\n            if (dataType.includes(\"NOT NULL\")) {\n              dataTypeString = dataType.replace(\" PRIMARY KEY\", \"\");\n            } else {\n              dataTypeString = dataType.replace(\"PRIMARY KEY\", \"NOT NULL\");\n            }\n          }\n        }\n        attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);\n      }\n    }\n    const table = this.quoteTable(tableName);\n    let attrStr = attrArray.join(\", \");\n    const pkString = primaryKeys.map((pk) => this.quoteIdentifier(pk)).join(\", \");\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns) => {\n        if (columns.customIndex) {\n          attrStr += `, UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n    if (pkString.length > 0) {\n      attrStr += `, PRIMARY KEY (${pkString})`;\n    }\n    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;\n    return this.replaceBooleanDefaults(sql);\n  }\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n    const jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n      break;\n    }\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n    return hasJsonFunction;\n  }\n  _toJSONValue(value) {\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n    if (Array.isArray(value) && value[0] instanceof Date) {\n      return value.map((val) => val.toISOString());\n    }\n    return value;\n  }\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n    if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = \"datetime\";\n      }\n    }\n    return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n  addColumnQuery(table, key, dataType) {\n    const attributes = {};\n    attributes[key] = dataType;\n    const fields = this.attributesToSQL(attributes, { context: \"addColumn\" });\n    const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;\n    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;\n    return this.replaceBooleanDefaults(sql);\n  }\n  showTablesQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"UPDATE\" })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"UPDATE\" }, bindParam)}`);\n      }\n    }\n    let query;\n    const whereOptions = __spreadProps(__spreadValues({}, options), { bindParam });\n    if (options.limit) {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(\",\")} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit)})`;\n    } else {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(\",\")} ${this.whereQuery(where, whereOptions)}`;\n    }\n    return { query, bind };\n  }\n  truncateTableQuery(tableName, options = {}) {\n    return [\n      `DELETE FROM ${this.quoteTable(tableName)}`,\n      options.restartIdentity ? `; DELETE FROM ${this.quoteTable(\"sqlite_sequence\")} WHERE ${this.quoteIdentifier(\"name\")} = ${Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), \"`\"), \"'\")};` : \"\"\n    ].join(\"\");\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    _.defaults(options, this.options);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n    if (options.limit) {\n      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit)})`;\n    }\n    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`;\n  }\n  attributesToSQL(attributes) {\n    const result = {};\n    for (const name in attributes) {\n      const dataType = attributes[name];\n      const fieldName = dataType.field || name;\n      if (_.isObject(dataType)) {\n        let sql = dataType.type.toString();\n        if (Object.prototype.hasOwnProperty.call(dataType, \"allowNull\") && !dataType.allowNull) {\n          sql += \" NOT NULL\";\n        }\n        if (Utils.defaultValueSchemable(dataType.defaultValue)) {\n          sql += ` DEFAULT ${this.escape(dataType.defaultValue, dataType)}`;\n        }\n        if (dataType.unique === true) {\n          sql += \" UNIQUE\";\n        }\n        if (dataType.primaryKey) {\n          sql += \" PRIMARY KEY\";\n          if (dataType.autoIncrement) {\n            sql += \" AUTOINCREMENT\";\n          }\n        }\n        if (dataType.references) {\n          const referencesTable = this.quoteTable(dataType.references.model);\n          let referencesKey;\n          if (dataType.references.key) {\n            referencesKey = this.quoteIdentifier(dataType.references.key);\n          } else {\n            referencesKey = this.quoteIdentifier(\"id\");\n          }\n          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n          if (dataType.onDelete) {\n            sql += ` ON DELETE ${dataType.onDelete.toUpperCase()}`;\n          }\n          if (dataType.onUpdate) {\n            sql += ` ON UPDATE ${dataType.onUpdate.toUpperCase()}`;\n          }\n        }\n        result[fieldName] = sql;\n      } else {\n        result[fieldName] = dataType;\n      }\n    }\n    return result;\n  }\n  showIndexesQuery(tableName) {\n    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;\n  }\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;\n    if (constraintName) {\n      sql += ` AND sql LIKE '%${constraintName}%'`;\n    }\n    return `${sql};`;\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;\n  }\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = {\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter,\n      tableName\n    };\n    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;\n  }\n  describeCreateTableQuery(tableName) {\n    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;\n  }\n  removeColumnQuery(tableName, attributes) {\n    attributes = this.attributesToSQL(attributes);\n    let backupTableName;\n    if (typeof tableName === \"object\") {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map((attr) => this.quoteIdentifier(attr)).join(\", \");\n    return `${this.createTableQuery(backupTableName, attributes)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};DROP TABLE ${quotedTableName};${this.createTableQuery(tableName, attributes)}INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};DROP TABLE ${quotedBackupTableName};`;\n  }\n  _alterConstraintQuery(tableName, attributes, createTableSql) {\n    let backupTableName;\n    attributes = this.attributesToSQL(attributes);\n    if (typeof tableName === \"object\") {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map((attr) => this.quoteIdentifier(attr)).join(\", \");\n    return `${createTableSql.replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`).replace(`CREATE TABLE ${quotedTableName.replace(/`/g, '\"')}`, `CREATE TABLE ${quotedBackupTableName}`)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};DROP TABLE ${quotedTableName};ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;\n  }\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n    let backupTableName;\n    attributes = this.attributesToSQL(attributes);\n    if (typeof tableName === \"object\") {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNamesImport = Object.keys(attributes).map((attr) => attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr)).join(\", \");\n    const attributeNamesExport = Object.keys(attributes).map((attr) => this.quoteIdentifier(attr)).join(\", \");\n    return `${this.createTableQuery(backupTableName, attributes)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};DROP TABLE ${quotedTableName};${this.createTableQuery(tableName, attributes)}INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};DROP TABLE ${quotedBackupTableName};`;\n  }\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return `BEGIN ${transaction.options.type} TRANSACTION;`;\n  }\n  setIsolationLevelQuery(value) {\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return \"-- SQLite is not able to choose the isolation level REPEATABLE READ.\";\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        return \"PRAGMA read_uncommitted = ON;\";\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return \"PRAGMA read_uncommitted = OFF;\";\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n        return \"-- SQLite's default isolation level is SERIALIZABLE. Nothing to do.\";\n      default:\n        throw new Error(`Unknown isolation level: ${value}`);\n    }\n  }\n  replaceBooleanDefaults(sql) {\n    return sql.replace(/DEFAULT '?false'?/g, \"DEFAULT 0\").replace(/DEFAULT '?true'?/g, \"DEFAULT 1\");\n  }\n  getForeignKeysQuery(tableName) {\n    return `PRAGMA foreign_key_list(${this.quoteTable(this.addSchema(tableName))})`;\n  }\n  tableExistsQuery(tableName) {\n    return `SELECT name FROM sqlite_master WHERE type='table' AND name=${this.escape(this.addSchema(tableName))};`;\n  }\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, \"`\"), \"`\");\n  }\n}\nmodule.exports = SQLiteQueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvcXVlcnktZ2VuZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyw0RUFBYTtBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDL0MsVUFBVSxtQkFBTyxDQUFDLGlFQUFRO0FBQzFCLDRCQUE0QixtQkFBTyxDQUFDLGtIQUEwQjtBQUM5RCwrQkFBK0IsbUJBQU8sQ0FBQyx3SEFBNkI7QUFDcEU7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRCQUE0QixFQUFFLGVBQWU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzRUFBc0U7QUFDeEc7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0EsOENBQThDLE9BQU8sR0FBRyxRQUFRLEVBQUU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELElBQUk7QUFDeEQsNERBQTRELEVBQUUsc0JBQXNCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxzQkFBc0I7QUFDNUUseUJBQXlCLDJCQUEyQixFQUFFLFlBQVk7QUFDbEUsK0JBQStCLHdCQUF3QixNQUFNLFdBQVc7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEIsR0FBRyw0RUFBNEUsbUJBQW1CLEVBQUU7QUFDckosUUFBUTtBQUNSLHVCQUF1QiwwQkFBMEIsR0FBRyw0RUFBNEUsbUJBQW1CLGFBQWE7QUFDaEs7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGNBQWMsV0FBVztBQUNqRjtBQUNBLHdCQUF3Qiw0QkFBNEIsTUFBTSxrQkFBa0Isb0NBQW9DLDRCQUE0QixFQUFFLHNDQUFzQyxRQUFRLDJCQUEyQjtBQUN2TixNQUFNO0FBQ04sd0JBQXdCLDRCQUE0QixNQUFNLGtCQUFrQixFQUFFLHFDQUFxQztBQUNuSDtBQUNBLGFBQWE7QUFDYjtBQUNBLDRDQUE0QztBQUM1QztBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQsbUNBQW1DLGNBQWMsb0NBQW9DLFFBQVEsOEJBQThCLElBQUkseUVBQXlFO0FBQ3hNO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFlBQVk7QUFDekM7QUFDQTtBQUNBLHlEQUF5RCw0QkFBNEIsRUFBRSxhQUFhLFFBQVEsMkJBQTJCO0FBQ3ZJO0FBQ0EsMEJBQTBCLDRCQUE0QixFQUFFLFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZDQUE2QztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGdDQUFnQyxpQkFBaUIsR0FBRyxjQUFjO0FBQ2xFO0FBQ0EsaUNBQWlDLGdDQUFnQztBQUNqRTtBQUNBO0FBQ0EsaUNBQWlDLGdDQUFnQztBQUNqRTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQjtBQUMzRDtBQUNBO0FBQ0EsK0RBQStELFVBQVU7QUFDekU7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLEdBQUcsZ0NBQWdDO0FBQ25GO0FBQ0EsbUNBQW1DLGdDQUFnQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1Q0FBdUMsRUFBRTtBQUN6RTtBQUNBO0FBQ0EsNERBQTRELFVBQVUsRUFBRTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1EQUFtRCxjQUFjLHVCQUF1QixTQUFTLGdCQUFnQixPQUFPLGlCQUFpQixhQUFhLGlCQUFpQixFQUFFLDZDQUE2QyxjQUFjLGlCQUFpQixTQUFTLGdCQUFnQixPQUFPLHVCQUF1QixhQUFhLHVCQUF1QjtBQUM5VjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVDQUF1QyxnQkFBZ0IsbUJBQW1CLHNCQUFzQiwyQkFBMkIsbUNBQW1DLG1CQUFtQixzQkFBc0IsR0FBRyxjQUFjLHVCQUF1QixTQUFTLGdCQUFnQixPQUFPLGlCQUFpQixhQUFhLGlCQUFpQixjQUFjLHVCQUF1QixZQUFZLGlCQUFpQjtBQUM5WTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHNDQUFzQyxLQUFLLDJCQUEyQjtBQUN6SztBQUNBLGNBQWMsbURBQW1ELGNBQWMsdUJBQXVCLFNBQVMsc0JBQXNCLE9BQU8saUJBQWlCLGFBQWEsaUJBQWlCLEVBQUUsNkNBQTZDLGNBQWMsaUJBQWlCLFNBQVMsc0JBQXNCLE9BQU8sdUJBQXVCLGFBQWEsdUJBQXVCO0FBQzFXO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3Q0FBd0M7QUFDbEU7QUFDQSxvQkFBb0IsMEJBQTBCLFlBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxNQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywyQ0FBMkM7QUFDakY7QUFDQTtBQUNBLHlFQUF5RSx3Q0FBd0M7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvc3FsaXRlL3F1ZXJ5LWdlbmVyYXRvci5qcz8xZDkxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IFRyYW5zYWN0aW9uID0gcmVxdWlyZShcIi4uLy4uL3RyYW5zYWN0aW9uXCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBNeVNxbFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZShcIi4uL215c3FsL3F1ZXJ5LWdlbmVyYXRvclwiKTtcbmNvbnN0IEFic3RyYWN0UXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnktZ2VuZXJhdG9yXCIpO1xuY2xhc3MgU1FMaXRlUXVlcnlHZW5lcmF0b3IgZXh0ZW5kcyBNeVNxbFF1ZXJ5R2VuZXJhdG9yIHtcbiAgY3JlYXRlU2NoZW1hKCkge1xuICAgIHJldHVybiBcIlNFTEVDVCBuYW1lIEZST00gYHNxbGl0ZV9tYXN0ZXJgIFdIRVJFIHR5cGU9J3RhYmxlJyBhbmQgbmFtZSE9J3NxbGl0ZV9zZXF1ZW5jZSc7XCI7XG4gIH1cbiAgc2hvd1NjaGVtYXNRdWVyeSgpIHtcbiAgICByZXR1cm4gXCJTRUxFQ1QgbmFtZSBGUk9NIGBzcWxpdGVfbWFzdGVyYCBXSEVSRSB0eXBlPSd0YWJsZScgYW5kIG5hbWUhPSdzcWxpdGVfc2VxdWVuY2UnO1wiO1xuICB9XG4gIHZlcnNpb25RdWVyeSgpIHtcbiAgICByZXR1cm4gXCJTRUxFQ1Qgc3FsaXRlX3ZlcnNpb24oKSBhcyBgdmVyc2lvbmBcIjtcbiAgfVxuICBjcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHByaW1hcnlLZXlzID0gW107XG4gICAgY29uc3QgbmVlZHNNdWx0aXBsZVByaW1hcnlLZXlzID0gT2JqZWN0LnZhbHVlcyhhdHRyaWJ1dGVzKS5maWx0ZXIoKGRlZmluaXRpb24pID0+IGRlZmluaXRpb24uaW5jbHVkZXMoXCJQUklNQVJZIEtFWVwiKSkubGVuZ3RoID4gMTtcbiAgICBjb25zdCBhdHRyQXJyYXkgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGF0dHIgaW4gYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICBjb25zdCBkYXRhVHlwZSA9IGF0dHJpYnV0ZXNbYXR0cl07XG4gICAgICAgIGNvbnN0IGNvbnRhaW5zQXV0b0luY3JlbWVudCA9IGRhdGFUeXBlLmluY2x1ZGVzKFwiQVVUT0lOQ1JFTUVOVFwiKTtcbiAgICAgICAgbGV0IGRhdGFUeXBlU3RyaW5nID0gZGF0YVR5cGU7XG4gICAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIlBSSU1BUlkgS0VZXCIpKSB7XG4gICAgICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiSU5UXCIpKSB7XG4gICAgICAgICAgICBkYXRhVHlwZVN0cmluZyA9IGNvbnRhaW5zQXV0b0luY3JlbWVudCA/IFwiSU5URUdFUiBQUklNQVJZIEtFWSBBVVRPSU5DUkVNRU5UXCIgOiBcIklOVEVHRVIgUFJJTUFSWSBLRVlcIjtcbiAgICAgICAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIiBSRUZFUkVOQ0VTXCIpKSB7XG4gICAgICAgICAgICAgIGRhdGFUeXBlU3RyaW5nICs9IGRhdGFUeXBlLnN1YnN0cihkYXRhVHlwZS5pbmRleE9mKFwiIFJFRkVSRU5DRVNcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmVlZHNNdWx0aXBsZVByaW1hcnlLZXlzKSB7XG4gICAgICAgICAgICBwcmltYXJ5S2V5cy5wdXNoKGF0dHIpO1xuICAgICAgICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiTk9UIE5VTExcIikpIHtcbiAgICAgICAgICAgICAgZGF0YVR5cGVTdHJpbmcgPSBkYXRhVHlwZS5yZXBsYWNlKFwiIFBSSU1BUlkgS0VZXCIsIFwiXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGF0YVR5cGVTdHJpbmcgPSBkYXRhVHlwZS5yZXBsYWNlKFwiUFJJTUFSWSBLRVlcIiwgXCJOT1QgTlVMTFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXR0ckFycmF5LnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7ZGF0YVR5cGVTdHJpbmd9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgbGV0IGF0dHJTdHIgPSBhdHRyQXJyYXkuam9pbihcIiwgXCIpO1xuICAgIGNvbnN0IHBrU3RyaW5nID0gcHJpbWFyeUtleXMubWFwKChwaykgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIocGspKS5qb2luKFwiLCBcIik7XG4gICAgaWYgKG9wdGlvbnMudW5pcXVlS2V5cykge1xuICAgICAgXy5lYWNoKG9wdGlvbnMudW5pcXVlS2V5cywgKGNvbHVtbnMpID0+IHtcbiAgICAgICAgaWYgKGNvbHVtbnMuY3VzdG9tSW5kZXgpIHtcbiAgICAgICAgICBhdHRyU3RyICs9IGAsIFVOSVFVRSAoJHtjb2x1bW5zLmZpZWxkcy5tYXAoKGZpZWxkKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZCkpLmpvaW4oXCIsIFwiKX0pYDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwa1N0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICBhdHRyU3RyICs9IGAsIFBSSU1BUlkgS0VZICgke3BrU3RyaW5nfSlgO1xuICAgIH1cbiAgICBjb25zdCBzcWwgPSBgQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgJHt0YWJsZX0gKCR7YXR0clN0cn0pO2A7XG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZUJvb2xlYW5EZWZhdWx0cyhzcWwpO1xuICB9XG4gIGJvb2xlYW5WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA/IDEgOiAwO1xuICB9XG4gIF9jaGVja1ZhbGlkSnNvblN0YXRlbWVudChzdG10KSB7XG4gICAgaWYgKHR5cGVvZiBzdG10ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGpzb25GdW5jdGlvblJlZ2V4ID0gL15cXHMqKGpzb24oPzpfW2Etel0rKXswLDJ9KVxcKFteKV0qXFwpL2k7XG4gICAgY29uc3QgdG9rZW5DYXB0dXJlUmVnZXggPSAvXlxccyooKD86KFtgXCInXSkoPzooPyFcXDIpLnxcXDJ7Mn0pKlxcMil8W1xcd1xcZFxcc10rfFsoKS4sOystXSkvaTtcbiAgICBsZXQgY3VycmVudEluZGV4ID0gMDtcbiAgICBsZXQgb3BlbmluZ0JyYWNrZXRzID0gMDtcbiAgICBsZXQgY2xvc2luZ0JyYWNrZXRzID0gMDtcbiAgICBsZXQgaGFzSnNvbkZ1bmN0aW9uID0gZmFsc2U7XG4gICAgbGV0IGhhc0ludmFsaWRUb2tlbiA9IGZhbHNlO1xuICAgIHdoaWxlIChjdXJyZW50SW5kZXggPCBzdG10Lmxlbmd0aCkge1xuICAgICAgY29uc3Qgc3RyaW5nID0gc3RtdC5zdWJzdHIoY3VycmVudEluZGV4KTtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uTWF0Y2hlcyA9IGpzb25GdW5jdGlvblJlZ2V4LmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmIChmdW5jdGlvbk1hdGNoZXMpIHtcbiAgICAgICAgY3VycmVudEluZGV4ICs9IGZ1bmN0aW9uTWF0Y2hlc1swXS5pbmRleE9mKFwiKFwiKTtcbiAgICAgICAgaGFzSnNvbkZ1bmN0aW9uID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0b2tlbk1hdGNoZXMgPSB0b2tlbkNhcHR1cmVSZWdleC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAodG9rZW5NYXRjaGVzKSB7XG4gICAgICAgIGNvbnN0IGNhcHR1cmVkVG9rZW4gPSB0b2tlbk1hdGNoZXNbMV07XG4gICAgICAgIGlmIChjYXB0dXJlZFRva2VuID09PSBcIihcIikge1xuICAgICAgICAgIG9wZW5pbmdCcmFja2V0cysrO1xuICAgICAgICB9IGVsc2UgaWYgKGNhcHR1cmVkVG9rZW4gPT09IFwiKVwiKSB7XG4gICAgICAgICAgY2xvc2luZ0JyYWNrZXRzKys7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gXCI7XCIpIHtcbiAgICAgICAgICBoYXNJbnZhbGlkVG9rZW4gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSB0b2tlbk1hdGNoZXNbMF0ubGVuZ3RoO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBoYXNJbnZhbGlkVG9rZW4gfD0gb3BlbmluZ0JyYWNrZXRzICE9PSBjbG9zaW5nQnJhY2tldHM7XG4gICAgaWYgKGhhc0pzb25GdW5jdGlvbiAmJiBoYXNJbnZhbGlkVG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBqc29uIHN0YXRlbWVudDogJHtzdG10fWApO1xuICAgIH1cbiAgICByZXR1cm4gaGFzSnNvbkZ1bmN0aW9uO1xuICB9XG4gIF90b0pTT05WYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b0lTT1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWVbMF0gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gdmFsdWUubWFwKCh2YWwpID0+IHZhbC50b0lTT1N0cmluZygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGhhbmRsZVNlcXVlbGl6ZU1ldGhvZChzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpIHtcbiAgICBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkpzb24pIHtcbiAgICAgIHJldHVybiBzdXBlci5oYW5kbGVTZXF1ZWxpemVNZXRob2Qoc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKTtcbiAgICB9XG4gICAgaWYgKHNtdGggaW5zdGFuY2VvZiBVdGlscy5DYXN0KSB7XG4gICAgICBpZiAoL3RpbWVzdGFtcC9pLnRlc3Qoc210aC50eXBlKSkge1xuICAgICAgICBzbXRoLnR5cGUgPSBcImRhdGV0aW1lXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yLnByb3RvdHlwZS5oYW5kbGVTZXF1ZWxpemVNZXRob2QuY2FsbCh0aGlzLCBzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICB9XG4gIGFkZENvbHVtblF1ZXJ5KHRhYmxlLCBrZXksIGRhdGFUeXBlKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgIGF0dHJpYnV0ZXNba2V5XSA9IGRhdGFUeXBlO1xuICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMsIHsgY29udGV4dDogXCJhZGRDb2x1bW5cIiB9KTtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpfSAke2ZpZWxkc1trZXldfWA7XG4gICAgY29uc3Qgc3FsID0gYEFMVEVSIFRBQkxFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlKX0gQUREICR7YXR0cmlidXRlfTtgO1xuICAgIHJldHVybiB0aGlzLnJlcGxhY2VCb29sZWFuRGVmYXVsdHMoc3FsKTtcbiAgfVxuICBzaG93VGFibGVzUXVlcnkoKSB7XG4gICAgcmV0dXJuIFwiU0VMRUNUIG5hbWUgRlJPTSBgc3FsaXRlX21hc3RlcmAgV0hFUkUgdHlwZT0ndGFibGUnIGFuZCBuYW1lIT0nc3FsaXRlX3NlcXVlbmNlJztcIjtcbiAgfVxuICB1cGRhdGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJWYWx1ZUhhc2gsIHdoZXJlLCBvcHRpb25zLCBhdHRyaWJ1dGVzKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgXy5kZWZhdWx0cyhvcHRpb25zLCB0aGlzLm9wdGlvbnMpO1xuICAgIGF0dHJWYWx1ZUhhc2ggPSBVdGlscy5yZW1vdmVOdWxsVmFsdWVzRnJvbUhhc2goYXR0clZhbHVlSGFzaCwgb3B0aW9ucy5vbWl0TnVsbCwgb3B0aW9ucyk7XG4gICAgY29uc3QgbW9kZWxBdHRyaWJ1dGVNYXAgPSB7fTtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBjb25zdCBiaW5kID0gW107XG4gICAgY29uc3QgYmluZFBhcmFtID0gb3B0aW9ucy5iaW5kUGFyYW0gfHwgdGhpcy5iaW5kUGFyYW0oYmluZCk7XG4gICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgIF8uZWFjaChhdHRyaWJ1dGVzLCAoYXR0cmlidXRlLCBrZXkpID0+IHtcbiAgICAgICAgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5maWVsZCkge1xuICAgICAgICAgIG1vZGVsQXR0cmlidXRlTWFwW2F0dHJpYnV0ZS5maWVsZF0gPSBhdHRyaWJ1dGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyVmFsdWVIYXNoKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGF0dHJWYWx1ZUhhc2hba2V5XTtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCB8fCBvcHRpb25zLmJpbmRQYXJhbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFsdWVzLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KX09JHt0aGlzLmVzY2FwZSh2YWx1ZSwgbW9kZWxBdHRyaWJ1dGVNYXAgJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSB8fCB2b2lkIDAsIHsgY29udGV4dDogXCJVUERBVEVcIiB9KX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGtleSl9PSR7dGhpcy5mb3JtYXQodmFsdWUsIG1vZGVsQXR0cmlidXRlTWFwICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gfHwgdm9pZCAwLCB7IGNvbnRleHQ6IFwiVVBEQVRFXCIgfSwgYmluZFBhcmFtKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGNvbnN0IHdoZXJlT3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IGJpbmRQYXJhbSB9KTtcbiAgICBpZiAob3B0aW9ucy5saW1pdCkge1xuICAgICAgcXVlcnkgPSBgVVBEQVRFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9IFNFVCAke3ZhbHVlcy5qb2luKFwiLFwiKX0gV0hFUkUgcm93aWQgSU4gKFNFTEVDVCByb3dpZCBGUk9NICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9ICR7dGhpcy53aGVyZVF1ZXJ5KHdoZXJlLCB3aGVyZU9wdGlvbnMpfSBMSU1JVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpfSlgO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeSA9IGBVUERBVEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gU0VUICR7dmFsdWVzLmpvaW4oXCIsXCIpfSAke3RoaXMud2hlcmVRdWVyeSh3aGVyZSwgd2hlcmVPcHRpb25zKX1gO1xuICAgIH1cbiAgICByZXR1cm4geyBxdWVyeSwgYmluZCB9O1xuICB9XG4gIHRydW5jYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICBgREVMRVRFIEZST00gJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX1gLFxuICAgICAgb3B0aW9ucy5yZXN0YXJ0SWRlbnRpdHkgPyBgOyBERUxFVEUgRlJPTSAke3RoaXMucXVvdGVUYWJsZShcInNxbGl0ZV9zZXF1ZW5jZVwiKX0gV0hFUkUgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihcIm5hbWVcIil9ID0gJHtVdGlscy5hZGRUaWNrcyhVdGlscy5yZW1vdmVUaWNrcyh0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSwgXCJgXCIpLCBcIidcIil9O2AgOiBcIlwiXG4gICAgXS5qb2luKFwiXCIpO1xuICB9XG4gIGRlbGV0ZVF1ZXJ5KHRhYmxlTmFtZSwgd2hlcmUsIG9wdGlvbnMgPSB7fSwgbW9kZWwpIHtcbiAgICBfLmRlZmF1bHRzKG9wdGlvbnMsIHRoaXMub3B0aW9ucyk7XG4gICAgbGV0IHdoZXJlQ2xhdXNlID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnMod2hlcmUsIG51bGwsIG1vZGVsLCBvcHRpb25zKTtcbiAgICBpZiAod2hlcmVDbGF1c2UpIHtcbiAgICAgIHdoZXJlQ2xhdXNlID0gYFdIRVJFICR7d2hlcmVDbGF1c2V9YDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGltaXQpIHtcbiAgICAgIHdoZXJlQ2xhdXNlID0gYFdIRVJFIHJvd2lkIElOIChTRUxFQ1Qgcm93aWQgRlJPTSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSAke3doZXJlQ2xhdXNlfSBMSU1JVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpfSlgO1xuICAgIH1cbiAgICByZXR1cm4gYERFTEVURSBGUk9NICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9ICR7d2hlcmVDbGF1c2V9YDtcbiAgfVxuICBhdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICBjb25zdCBmaWVsZE5hbWUgPSBkYXRhVHlwZS5maWVsZCB8fCBuYW1lO1xuICAgICAgaWYgKF8uaXNPYmplY3QoZGF0YVR5cGUpKSB7XG4gICAgICAgIGxldCBzcWwgPSBkYXRhVHlwZS50eXBlLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YVR5cGUsIFwiYWxsb3dOdWxsXCIpICYmICFkYXRhVHlwZS5hbGxvd051bGwpIHtcbiAgICAgICAgICBzcWwgKz0gXCIgTk9UIE5VTExcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVXRpbHMuZGVmYXVsdFZhbHVlU2NoZW1hYmxlKGRhdGFUeXBlLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgICBzcWwgKz0gYCBERUZBVUxUICR7dGhpcy5lc2NhcGUoZGF0YVR5cGUuZGVmYXVsdFZhbHVlLCBkYXRhVHlwZSl9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVR5cGUudW5pcXVlID09PSB0cnVlKSB7XG4gICAgICAgICAgc3FsICs9IFwiIFVOSVFVRVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhVHlwZS5wcmltYXJ5S2V5KSB7XG4gICAgICAgICAgc3FsICs9IFwiIFBSSU1BUlkgS0VZXCI7XG4gICAgICAgICAgaWYgKGRhdGFUeXBlLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgICAgICAgIHNxbCArPSBcIiBBVVRPSU5DUkVNRU5UXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhVHlwZS5yZWZlcmVuY2VzKSB7XG4gICAgICAgICAgY29uc3QgcmVmZXJlbmNlc1RhYmxlID0gdGhpcy5xdW90ZVRhYmxlKGRhdGFUeXBlLnJlZmVyZW5jZXMubW9kZWwpO1xuICAgICAgICAgIGxldCByZWZlcmVuY2VzS2V5O1xuICAgICAgICAgIGlmIChkYXRhVHlwZS5yZWZlcmVuY2VzLmtleSkge1xuICAgICAgICAgICAgcmVmZXJlbmNlc0tleSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGRhdGFUeXBlLnJlZmVyZW5jZXMua2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVmZXJlbmNlc0tleSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKFwiaWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNxbCArPSBgIFJFRkVSRU5DRVMgJHtyZWZlcmVuY2VzVGFibGV9ICgke3JlZmVyZW5jZXNLZXl9KWA7XG4gICAgICAgICAgaWYgKGRhdGFUeXBlLm9uRGVsZXRlKSB7XG4gICAgICAgICAgICBzcWwgKz0gYCBPTiBERUxFVEUgJHtkYXRhVHlwZS5vbkRlbGV0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkYXRhVHlwZS5vblVwZGF0ZSkge1xuICAgICAgICAgICAgc3FsICs9IGAgT04gVVBEQVRFICR7ZGF0YVR5cGUub25VcGRhdGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbZmllbGROYW1lXSA9IHNxbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtmaWVsZE5hbWVdID0gZGF0YVR5cGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc2hvd0luZGV4ZXNRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gYFBSQUdNQSBJTkRFWF9MSVNUKCR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9KWA7XG4gIH1cbiAgc2hvd0NvbnN0cmFpbnRzUXVlcnkodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSkge1xuICAgIGxldCBzcWwgPSBgU0VMRUNUIHNxbCBGUk9NIHNxbGl0ZV9tYXN0ZXIgV0hFUkUgdGJsX25hbWU9JyR7dGFibGVOYW1lfSdgO1xuICAgIGlmIChjb25zdHJhaW50TmFtZSkge1xuICAgICAgc3FsICs9IGAgQU5EIHNxbCBMSUtFICclJHtjb25zdHJhaW50TmFtZX0lJ2A7XG4gICAgfVxuICAgIHJldHVybiBgJHtzcWx9O2A7XG4gIH1cbiAgcmVtb3ZlSW5kZXhRdWVyeSh0YWJsZU5hbWUsIGluZGV4TmFtZU9yQXR0cmlidXRlcykge1xuICAgIGxldCBpbmRleE5hbWUgPSBpbmRleE5hbWVPckF0dHJpYnV0ZXM7XG4gICAgaWYgKHR5cGVvZiBpbmRleE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGluZGV4TmFtZSA9IFV0aWxzLnVuZGVyc2NvcmUoYCR7dGFibGVOYW1lfV8ke2luZGV4TmFtZU9yQXR0cmlidXRlcy5qb2luKFwiX1wiKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGBEUk9QIElOREVYIElGIEVYSVNUUyAke3RoaXMucXVvdGVJZGVudGlmaWVyKGluZGV4TmFtZSl9YDtcbiAgfVxuICBkZXNjcmliZVRhYmxlUXVlcnkodGFibGVOYW1lLCBzY2hlbWEsIHNjaGVtYURlbGltaXRlcikge1xuICAgIGNvbnN0IHRhYmxlID0ge1xuICAgICAgX3NjaGVtYTogc2NoZW1hLFxuICAgICAgX3NjaGVtYURlbGltaXRlcjogc2NoZW1hRGVsaW1pdGVyLFxuICAgICAgdGFibGVOYW1lXG4gICAgfTtcbiAgICByZXR1cm4gYFBSQUdNQSBUQUJMRV9JTkZPKCR7dGhpcy5xdW90ZVRhYmxlKHRoaXMuYWRkU2NoZW1hKHRhYmxlKSl9KTtgO1xuICB9XG4gIGRlc2NyaWJlQ3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gYFNFTEVDVCBzcWwgRlJPTSBzcWxpdGVfbWFzdGVyIFdIRVJFIHRibF9uYW1lPScke3RhYmxlTmFtZX0nO2A7XG4gIH1cbiAgcmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMpO1xuICAgIGxldCBiYWNrdXBUYWJsZU5hbWU7XG4gICAgaWYgKHR5cGVvZiB0YWJsZU5hbWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGJhY2t1cFRhYmxlTmFtZSA9IHtcbiAgICAgICAgdGFibGVOYW1lOiBgJHt0YWJsZU5hbWUudGFibGVOYW1lfV9iYWNrdXBgLFxuICAgICAgICBzY2hlbWE6IHRhYmxlTmFtZS5zY2hlbWFcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhY2t1cFRhYmxlTmFtZSA9IGAke3RhYmxlTmFtZX1fYmFja3VwYDtcbiAgICB9XG4gICAgY29uc3QgcXVvdGVkVGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgY29uc3QgcXVvdGVkQmFja3VwVGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKGJhY2t1cFRhYmxlTmFtZSk7XG4gICAgY29uc3QgYXR0cmlidXRlTmFtZXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5tYXAoKGF0dHIpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpKS5qb2luKFwiLCBcIik7XG4gICAgcmV0dXJuIGAke3RoaXMuY3JlYXRlVGFibGVRdWVyeShiYWNrdXBUYWJsZU5hbWUsIGF0dHJpYnV0ZXMpfUlOU0VSVCBJTlRPICR7cXVvdGVkQmFja3VwVGFibGVOYW1lfSBTRUxFQ1QgJHthdHRyaWJ1dGVOYW1lc30gRlJPTSAke3F1b3RlZFRhYmxlTmFtZX07RFJPUCBUQUJMRSAke3F1b3RlZFRhYmxlTmFtZX07JHt0aGlzLmNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzKX1JTlNFUlQgSU5UTyAke3F1b3RlZFRhYmxlTmFtZX0gU0VMRUNUICR7YXR0cmlidXRlTmFtZXN9IEZST00gJHtxdW90ZWRCYWNrdXBUYWJsZU5hbWV9O0RST1AgVEFCTEUgJHtxdW90ZWRCYWNrdXBUYWJsZU5hbWV9O2A7XG4gIH1cbiAgX2FsdGVyQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgY3JlYXRlVGFibGVTcWwpIHtcbiAgICBsZXQgYmFja3VwVGFibGVOYW1lO1xuICAgIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXNUb1NRTChhdHRyaWJ1dGVzKTtcbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgYmFja3VwVGFibGVOYW1lID0ge1xuICAgICAgICB0YWJsZU5hbWU6IGAke3RhYmxlTmFtZS50YWJsZU5hbWV9X2JhY2t1cGAsXG4gICAgICAgIHNjaGVtYTogdGFibGVOYW1lLnNjaGVtYVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFja3VwVGFibGVOYW1lID0gYCR7dGFibGVOYW1lfV9iYWNrdXBgO1xuICAgIH1cbiAgICBjb25zdCBxdW90ZWRUYWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBjb25zdCBxdW90ZWRCYWNrdXBUYWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUoYmFja3VwVGFibGVOYW1lKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVOYW1lcyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLm1hcCgoYXR0cikgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cikpLmpvaW4oXCIsIFwiKTtcbiAgICByZXR1cm4gYCR7Y3JlYXRlVGFibGVTcWwucmVwbGFjZShgQ1JFQVRFIFRBQkxFICR7cXVvdGVkVGFibGVOYW1lfWAsIGBDUkVBVEUgVEFCTEUgJHtxdW90ZWRCYWNrdXBUYWJsZU5hbWV9YCkucmVwbGFjZShgQ1JFQVRFIFRBQkxFICR7cXVvdGVkVGFibGVOYW1lLnJlcGxhY2UoL2AvZywgJ1wiJyl9YCwgYENSRUFURSBUQUJMRSAke3F1b3RlZEJhY2t1cFRhYmxlTmFtZX1gKX1JTlNFUlQgSU5UTyAke3F1b3RlZEJhY2t1cFRhYmxlTmFtZX0gU0VMRUNUICR7YXR0cmlidXRlTmFtZXN9IEZST00gJHtxdW90ZWRUYWJsZU5hbWV9O0RST1AgVEFCTEUgJHtxdW90ZWRUYWJsZU5hbWV9O0FMVEVSIFRBQkxFICR7cXVvdGVkQmFja3VwVGFibGVOYW1lfSBSRU5BTUUgVE8gJHtxdW90ZWRUYWJsZU5hbWV9O2A7XG4gIH1cbiAgcmVuYW1lQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyTmFtZUJlZm9yZSwgYXR0ck5hbWVBZnRlciwgYXR0cmlidXRlcykge1xuICAgIGxldCBiYWNrdXBUYWJsZU5hbWU7XG4gICAgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMpO1xuICAgIGlmICh0eXBlb2YgdGFibGVOYW1lID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBiYWNrdXBUYWJsZU5hbWUgPSB7XG4gICAgICAgIHRhYmxlTmFtZTogYCR7dGFibGVOYW1lLnRhYmxlTmFtZX1fYmFja3VwYCxcbiAgICAgICAgc2NoZW1hOiB0YWJsZU5hbWUuc2NoZW1hXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBiYWNrdXBUYWJsZU5hbWUgPSBgJHt0YWJsZU5hbWV9X2JhY2t1cGA7XG4gICAgfVxuICAgIGNvbnN0IHF1b3RlZFRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIGNvbnN0IHF1b3RlZEJhY2t1cFRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZShiYWNrdXBUYWJsZU5hbWUpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWVzSW1wb3J0ID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcykubWFwKChhdHRyKSA9PiBhdHRyTmFtZUFmdGVyID09PSBhdHRyID8gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0ck5hbWVCZWZvcmUpfSBBUyAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfWAgOiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKSkuam9pbihcIiwgXCIpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWVzRXhwb3J0ID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcykubWFwKChhdHRyKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKSkuam9pbihcIiwgXCIpO1xuICAgIHJldHVybiBgJHt0aGlzLmNyZWF0ZVRhYmxlUXVlcnkoYmFja3VwVGFibGVOYW1lLCBhdHRyaWJ1dGVzKX1JTlNFUlQgSU5UTyAke3F1b3RlZEJhY2t1cFRhYmxlTmFtZX0gU0VMRUNUICR7YXR0cmlidXRlTmFtZXNJbXBvcnR9IEZST00gJHtxdW90ZWRUYWJsZU5hbWV9O0RST1AgVEFCTEUgJHtxdW90ZWRUYWJsZU5hbWV9OyR7dGhpcy5jcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcyl9SU5TRVJUIElOVE8gJHtxdW90ZWRUYWJsZU5hbWV9IFNFTEVDVCAke2F0dHJpYnV0ZU5hbWVzRXhwb3J0fSBGUk9NICR7cXVvdGVkQmFja3VwVGFibGVOYW1lfTtEUk9QIFRBQkxFICR7cXVvdGVkQmFja3VwVGFibGVOYW1lfTtgO1xuICB9XG4gIHN0YXJ0VHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIHJldHVybiBgU0FWRVBPSU5UICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodHJhbnNhY3Rpb24ubmFtZSl9O2A7XG4gICAgfVxuICAgIHJldHVybiBgQkVHSU4gJHt0cmFuc2FjdGlvbi5vcHRpb25zLnR5cGV9IFRSQU5TQUNUSU9OO2A7XG4gIH1cbiAgc2V0SXNvbGF0aW9uTGV2ZWxRdWVyeSh2YWx1ZSkge1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb24uSVNPTEFUSU9OX0xFVkVMUy5SRVBFQVRBQkxFX1JFQUQ6XG4gICAgICAgIHJldHVybiBcIi0tIFNRTGl0ZSBpcyBub3QgYWJsZSB0byBjaG9vc2UgdGhlIGlzb2xhdGlvbiBsZXZlbCBSRVBFQVRBQkxFIFJFQUQuXCI7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uLklTT0xBVElPTl9MRVZFTFMuUkVBRF9VTkNPTU1JVFRFRDpcbiAgICAgICAgcmV0dXJuIFwiUFJBR01BIHJlYWRfdW5jb21taXR0ZWQgPSBPTjtcIjtcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb24uSVNPTEFUSU9OX0xFVkVMUy5SRUFEX0NPTU1JVFRFRDpcbiAgICAgICAgcmV0dXJuIFwiUFJBR01BIHJlYWRfdW5jb21taXR0ZWQgPSBPRkY7XCI7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uLklTT0xBVElPTl9MRVZFTFMuU0VSSUFMSVpBQkxFOlxuICAgICAgICByZXR1cm4gXCItLSBTUUxpdGUncyBkZWZhdWx0IGlzb2xhdGlvbiBsZXZlbCBpcyBTRVJJQUxJWkFCTEUuIE5vdGhpbmcgdG8gZG8uXCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gaXNvbGF0aW9uIGxldmVsOiAke3ZhbHVlfWApO1xuICAgIH1cbiAgfVxuICByZXBsYWNlQm9vbGVhbkRlZmF1bHRzKHNxbCkge1xuICAgIHJldHVybiBzcWwucmVwbGFjZSgvREVGQVVMVCAnP2ZhbHNlJz8vZywgXCJERUZBVUxUIDBcIikucmVwbGFjZSgvREVGQVVMVCAnP3RydWUnPy9nLCBcIkRFRkFVTFQgMVwiKTtcbiAgfVxuICBnZXRGb3JlaWduS2V5c1F1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBgUFJBR01BIGZvcmVpZ25fa2V5X2xpc3QoJHt0aGlzLnF1b3RlVGFibGUodGhpcy5hZGRTY2hlbWEodGFibGVOYW1lKSl9KWA7XG4gIH1cbiAgdGFibGVFeGlzdHNRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gYFNFTEVDVCBuYW1lIEZST00gc3FsaXRlX21hc3RlciBXSEVSRSB0eXBlPSd0YWJsZScgQU5EIG5hbWU9JHt0aGlzLmVzY2FwZSh0aGlzLmFkZFNjaGVtYSh0YWJsZU5hbWUpKX07YDtcbiAgfVxuICBxdW90ZUlkZW50aWZpZXIoaWRlbnRpZmllciwgZm9yY2UpIHtcbiAgICByZXR1cm4gVXRpbHMuYWRkVGlja3MoVXRpbHMucmVtb3ZlVGlja3MoaWRlbnRpZmllciwgXCJgXCIpLCBcImBcIik7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gU1FMaXRlUXVlcnlHZW5lcmF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS1nZW5lcmF0b3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/sqlite/query-generator.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/sqlite/query-interface.js":
/*!************************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/sqlite/query-interface.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(action-browser)/../node_modules/sequelize/lib/query-types.js\");\nconst { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nconst { cloneDeep } = __webpack_require__(/*! ../../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nclass SQLiteQueryInterface extends QueryInterface {\n  async removeColumn(tableName, attributeName, options) {\n    options = options || {};\n    const fields = await this.describeTable(tableName, options);\n    delete fields[attributeName];\n    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(\";\").filter((q) => q !== \"\");\n    for (const subQuery of subQueries)\n      await this.sequelize.query(`${subQuery};`, __spreadValues({ raw: true }, options));\n  }\n  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    options = options || {};\n    const fields = await this.describeTable(tableName, options);\n    Object.assign(fields[attributeName], this.normalizeAttribute(dataTypeOrOptions));\n    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(\";\").filter((q) => q !== \"\");\n    for (const subQuery of subQueries)\n      await this.sequelize.query(`${subQuery};`, __spreadValues({ raw: true }, options));\n  }\n  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    const fields = await this.assertTableHasColumn(tableName, attrNameBefore, options);\n    fields[attrNameAfter] = __spreadValues({}, fields[attrNameBefore]);\n    delete fields[attrNameBefore];\n    const sql = this.queryGenerator.renameColumnQuery(tableName, attrNameBefore, attrNameAfter, fields);\n    const subQueries = sql.split(\";\").filter((q) => q !== \"\");\n    for (const subQuery of subQueries)\n      await this.sequelize.query(`${subQuery};`, __spreadValues({ raw: true }, options));\n  }\n  async removeConstraint(tableName, constraintName, options) {\n    let createTableSql;\n    const constraints = await this.showConstraint(tableName, constraintName);\n    const constraint = constraints.find((constaint) => constaint.constraintName === constraintName);\n    if (!constraint) {\n      throw new sequelizeErrors.UnknownConstraintError({\n        message: `Constraint ${constraintName} on table ${tableName} does not exist`,\n        constraint: constraintName,\n        table: tableName\n      });\n    }\n    createTableSql = constraint.sql;\n    constraint.constraintName = this.queryGenerator.quoteIdentifier(constraint.constraintName);\n    let constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType} ${constraint.constraintCondition}`;\n    if (constraint.constraintType === \"FOREIGN KEY\") {\n      const referenceTableName = this.queryGenerator.quoteTable(constraint.referenceTableName);\n      constraint.referenceTableKeys = constraint.referenceTableKeys.map((columnName) => this.queryGenerator.quoteIdentifier(columnName));\n      const referenceTableKeys = constraint.referenceTableKeys.join(\", \");\n      constraintSnippet += ` REFERENCES ${referenceTableName} (${referenceTableKeys})`;\n      constraintSnippet += ` ON UPDATE ${constraint.updateAction}`;\n      constraintSnippet += ` ON DELETE ${constraint.deleteAction}`;\n    }\n    createTableSql = createTableSql.replace(constraintSnippet, \"\");\n    createTableSql += \";\";\n    const fields = await this.describeTable(tableName, options);\n    const sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n    const subQueries = sql.split(\";\").filter((q) => q !== \"\");\n    for (const subQuery of subQueries)\n      await this.sequelize.query(`${subQuery};`, __spreadValues({ raw: true }, options));\n  }\n  async addConstraint(tableName, options) {\n    if (!options.fields) {\n      throw new Error(\"Fields must be specified through options.fields\");\n    }\n    if (!options.type) {\n      throw new Error(\"Constraint type must be specified through options.type\");\n    }\n    options = cloneDeep(options);\n    const constraintSnippet = this.queryGenerator.getConstraintSnippet(tableName, options);\n    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);\n    const constraints = await this.sequelize.query(describeCreateTableSql, __spreadProps(__spreadValues({}, options), { type: QueryTypes.SELECT, raw: true }));\n    let sql = constraints[0].sql;\n    const index = sql.length - 1;\n    const createTableSql = `${sql.substr(0, index)}, ${constraintSnippet})${sql.substr(index + 1)};`;\n    const fields = await this.describeTable(tableName, options);\n    sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n    const subQueries = sql.split(\";\").filter((q) => q !== \"\");\n    for (const subQuery of subQueries)\n      await this.sequelize.query(`${subQuery};`, __spreadValues({ raw: true }, options));\n  }\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const database = this.sequelize.config.database;\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, database);\n    const result = await this.sequelize.query(query, options);\n    return result.map((row) => ({\n      tableName,\n      columnName: row.from,\n      referencedTableName: row.table,\n      referencedColumnName: row.to,\n      tableCatalog: database,\n      referencedTableCatalog: database\n    }));\n  }\n  async dropAllTables(options) {\n    options = options || {};\n    const skip = options.skip || [];\n    const tableNames = await this.showAllTables(options);\n    await this.sequelize.query(\"PRAGMA foreign_keys = OFF\", options);\n    await this._dropAllTables(tableNames, skip, options);\n    await this.sequelize.query(\"PRAGMA foreign_keys = ON\", options);\n  }\n  async describeTable(tableName, options) {\n    let schema = null;\n    let schemaDelimiter = null;\n    if (typeof options === \"string\") {\n      schema = options;\n    } else if (typeof options === \"object\" && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n    if (typeof tableName === \"object\" && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n    options = __spreadProps(__spreadValues({}, options), { type: QueryTypes.DESCRIBE });\n    const sqlIndexes = this.queryGenerator.showIndexesQuery(tableName);\n    try {\n      const data = await this.sequelize.query(sql, options);\n      if (_.isEmpty(data)) {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n      const indexes = await this.sequelize.query(sqlIndexes, options);\n      for (const prop in data) {\n        data[prop].unique = false;\n      }\n      for (const index of indexes) {\n        for (const field of index.fields) {\n          if (index.unique !== void 0) {\n            data[field.attribute].unique = index.unique;\n          }\n        }\n      }\n      const foreignKeys = await this.getForeignKeyReferencesForTable(tableName, options);\n      for (const foreignKey of foreignKeys) {\n        data[foreignKey.columnName].references = {\n          model: foreignKey.referencedTableName,\n          key: foreignKey.referencedColumnName\n        };\n      }\n      return data;\n    } catch (e) {\n      if (e.original && e.original.code === \"ER_NO_SUCH_TABLE\") {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n      throw e;\n    }\n  }\n}\nexports.SQLiteQueryInterface = SQLiteQueryInterface;\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvcXVlcnktaW50ZXJmYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLG9GQUFjO0FBQzlDLG1CQUFtQixtQkFBTyxDQUFDLHdGQUFtQjtBQUM5QyxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsd0hBQTZCO0FBQ2hFLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsNEVBQWE7QUFDM0MsVUFBVSxtQkFBTyxDQUFDLGlFQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLG9DQUFvQyxVQUFVLG9CQUFvQixXQUFXO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLG9DQUFvQyxVQUFVLG9CQUFvQixXQUFXO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBb0MsVUFBVSxvQkFBb0IsV0FBVztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0IsV0FBVyxXQUFXO0FBQ3JFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDJCQUEyQixFQUFFLDJCQUEyQixFQUFFLCtCQUErQjtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvQkFBb0IsR0FBRyxtQkFBbUI7QUFDcEYseUNBQXlDLHdCQUF3QjtBQUNqRSx5Q0FBeUMsd0JBQXdCO0FBQ2pFO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLG9DQUFvQyxVQUFVLG9CQUFvQixXQUFXO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcsY0FBYyxvQ0FBb0M7QUFDNUo7QUFDQTtBQUNBLDhCQUE4QixxQkFBcUIsSUFBSSxrQkFBa0IsR0FBRyx1QkFBdUI7QUFDbkc7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLG9DQUFvQyxVQUFVLG9CQUFvQixXQUFXO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYywyQkFBMkI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsVUFBVSwwQ0FBMEM7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHFEQUFxRCxVQUFVLDBDQUEwQztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3NxbGl0ZS9xdWVyeS1pbnRlcmZhY2UuanM/MGFmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc1wiKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vcXVlcnktdHlwZXNcIik7XG5jb25zdCB7IFF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnktaW50ZXJmYWNlXCIpO1xuY29uc3QgeyBjbG9uZURlZXAgfSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY2xhc3MgU1FMaXRlUXVlcnlJbnRlcmZhY2UgZXh0ZW5kcyBRdWVyeUludGVyZmFjZSB7XG4gIGFzeW5jIHJlbW92ZUNvbHVtbih0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBmaWVsZHMgPSBhd2FpdCB0aGlzLmRlc2NyaWJlVGFibGUodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICBkZWxldGUgZmllbGRzW2F0dHJpYnV0ZU5hbWVdO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBmaWVsZHMpO1xuICAgIGNvbnN0IHN1YlF1ZXJpZXMgPSBzcWwuc3BsaXQoXCI7XCIpLmZpbHRlcigocSkgPT4gcSAhPT0gXCJcIik7XG4gICAgZm9yIChjb25zdCBzdWJRdWVyeSBvZiBzdWJRdWVyaWVzKVxuICAgICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoYCR7c3ViUXVlcnl9O2AsIF9fc3ByZWFkVmFsdWVzKHsgcmF3OiB0cnVlIH0sIG9wdGlvbnMpKTtcbiAgfVxuICBhc3luYyBjaGFuZ2VDb2x1bW4odGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lLCBkYXRhVHlwZU9yT3B0aW9ucywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGZpZWxkcyA9IGF3YWl0IHRoaXMuZGVzY3JpYmVUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIE9iamVjdC5hc3NpZ24oZmllbGRzW2F0dHJpYnV0ZU5hbWVdLCB0aGlzLm5vcm1hbGl6ZUF0dHJpYnV0ZShkYXRhVHlwZU9yT3B0aW9ucykpO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBmaWVsZHMpO1xuICAgIGNvbnN0IHN1YlF1ZXJpZXMgPSBzcWwuc3BsaXQoXCI7XCIpLmZpbHRlcigocSkgPT4gcSAhPT0gXCJcIik7XG4gICAgZm9yIChjb25zdCBzdWJRdWVyeSBvZiBzdWJRdWVyaWVzKVxuICAgICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoYCR7c3ViUXVlcnl9O2AsIF9fc3ByZWFkVmFsdWVzKHsgcmF3OiB0cnVlIH0sIG9wdGlvbnMpKTtcbiAgfVxuICBhc3luYyByZW5hbWVDb2x1bW4odGFibGVOYW1lLCBhdHRyTmFtZUJlZm9yZSwgYXR0ck5hbWVBZnRlciwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGZpZWxkcyA9IGF3YWl0IHRoaXMuYXNzZXJ0VGFibGVIYXNDb2x1bW4odGFibGVOYW1lLCBhdHRyTmFtZUJlZm9yZSwgb3B0aW9ucyk7XG4gICAgZmllbGRzW2F0dHJOYW1lQWZ0ZXJdID0gX19zcHJlYWRWYWx1ZXMoe30sIGZpZWxkc1thdHRyTmFtZUJlZm9yZV0pO1xuICAgIGRlbGV0ZSBmaWVsZHNbYXR0ck5hbWVCZWZvcmVdO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucmVuYW1lQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyTmFtZUJlZm9yZSwgYXR0ck5hbWVBZnRlciwgZmllbGRzKTtcbiAgICBjb25zdCBzdWJRdWVyaWVzID0gc3FsLnNwbGl0KFwiO1wiKS5maWx0ZXIoKHEpID0+IHEgIT09IFwiXCIpO1xuICAgIGZvciAoY29uc3Qgc3ViUXVlcnkgb2Ygc3ViUXVlcmllcylcbiAgICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGAke3N1YlF1ZXJ5fTtgLCBfX3NwcmVhZFZhbHVlcyh7IHJhdzogdHJ1ZSB9LCBvcHRpb25zKSk7XG4gIH1cbiAgYXN5bmMgcmVtb3ZlQ29uc3RyYWludCh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lLCBvcHRpb25zKSB7XG4gICAgbGV0IGNyZWF0ZVRhYmxlU3FsO1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gYXdhaXQgdGhpcy5zaG93Q29uc3RyYWludCh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lKTtcbiAgICBjb25zdCBjb25zdHJhaW50ID0gY29uc3RyYWludHMuZmluZCgoY29uc3RhaW50KSA9PiBjb25zdGFpbnQuY29uc3RyYWludE5hbWUgPT09IGNvbnN0cmFpbnROYW1lKTtcbiAgICBpZiAoIWNvbnN0cmFpbnQpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5rbm93bkNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBDb25zdHJhaW50ICR7Y29uc3RyYWludE5hbWV9IG9uIHRhYmxlICR7dGFibGVOYW1lfSBkb2VzIG5vdCBleGlzdGAsXG4gICAgICAgIGNvbnN0cmFpbnQ6IGNvbnN0cmFpbnROYW1lLFxuICAgICAgICB0YWJsZTogdGFibGVOYW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlVGFibGVTcWwgPSBjb25zdHJhaW50LnNxbDtcbiAgICBjb25zdHJhaW50LmNvbnN0cmFpbnROYW1lID0gdGhpcy5xdWVyeUdlbmVyYXRvci5xdW90ZUlkZW50aWZpZXIoY29uc3RyYWludC5jb25zdHJhaW50TmFtZSk7XG4gICAgbGV0IGNvbnN0cmFpbnRTbmlwcGV0ID0gYCwgQ09OU1RSQUlOVCAke2NvbnN0cmFpbnQuY29uc3RyYWludE5hbWV9ICR7Y29uc3RyYWludC5jb25zdHJhaW50VHlwZX0gJHtjb25zdHJhaW50LmNvbnN0cmFpbnRDb25kaXRpb259YDtcbiAgICBpZiAoY29uc3RyYWludC5jb25zdHJhaW50VHlwZSA9PT0gXCJGT1JFSUdOIEtFWVwiKSB7XG4gICAgICBjb25zdCByZWZlcmVuY2VUYWJsZU5hbWUgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnF1b3RlVGFibGUoY29uc3RyYWludC5yZWZlcmVuY2VUYWJsZU5hbWUpO1xuICAgICAgY29uc3RyYWludC5yZWZlcmVuY2VUYWJsZUtleXMgPSBjb25zdHJhaW50LnJlZmVyZW5jZVRhYmxlS2V5cy5tYXAoKGNvbHVtbk5hbWUpID0+IHRoaXMucXVlcnlHZW5lcmF0b3IucXVvdGVJZGVudGlmaWVyKGNvbHVtbk5hbWUpKTtcbiAgICAgIGNvbnN0IHJlZmVyZW5jZVRhYmxlS2V5cyA9IGNvbnN0cmFpbnQucmVmZXJlbmNlVGFibGVLZXlzLmpvaW4oXCIsIFwiKTtcbiAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ICs9IGAgUkVGRVJFTkNFUyAke3JlZmVyZW5jZVRhYmxlTmFtZX0gKCR7cmVmZXJlbmNlVGFibGVLZXlzfSlgO1xuICAgICAgY29uc3RyYWludFNuaXBwZXQgKz0gYCBPTiBVUERBVEUgJHtjb25zdHJhaW50LnVwZGF0ZUFjdGlvbn1gO1xuICAgICAgY29uc3RyYWludFNuaXBwZXQgKz0gYCBPTiBERUxFVEUgJHtjb25zdHJhaW50LmRlbGV0ZUFjdGlvbn1gO1xuICAgIH1cbiAgICBjcmVhdGVUYWJsZVNxbCA9IGNyZWF0ZVRhYmxlU3FsLnJlcGxhY2UoY29uc3RyYWludFNuaXBwZXQsIFwiXCIpO1xuICAgIGNyZWF0ZVRhYmxlU3FsICs9IFwiO1wiO1xuICAgIGNvbnN0IGZpZWxkcyA9IGF3YWl0IHRoaXMuZGVzY3JpYmVUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuX2FsdGVyQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgZmllbGRzLCBjcmVhdGVUYWJsZVNxbCk7XG4gICAgY29uc3Qgc3ViUXVlcmllcyA9IHNxbC5zcGxpdChcIjtcIikuZmlsdGVyKChxKSA9PiBxICE9PSBcIlwiKTtcbiAgICBmb3IgKGNvbnN0IHN1YlF1ZXJ5IG9mIHN1YlF1ZXJpZXMpXG4gICAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShgJHtzdWJRdWVyeX07YCwgX19zcHJlYWRWYWx1ZXMoeyByYXc6IHRydWUgfSwgb3B0aW9ucykpO1xuICB9XG4gIGFzeW5jIGFkZENvbnN0cmFpbnQodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmZpZWxkcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGRzIG11c3QgYmUgc3BlY2lmaWVkIHRocm91Z2ggb3B0aW9ucy5maWVsZHNcIik7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy50eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25zdHJhaW50IHR5cGUgbXVzdCBiZSBzcGVjaWZpZWQgdGhyb3VnaCBvcHRpb25zLnR5cGVcIik7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBjbG9uZURlZXAob3B0aW9ucyk7XG4gICAgY29uc3QgY29uc3RyYWludFNuaXBwZXQgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmdldENvbnN0cmFpbnRTbmlwcGV0KHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGVzY3JpYmVDcmVhdGVUYWJsZVNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZGVzY3JpYmVDcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSk7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShkZXNjcmliZUNyZWF0ZVRhYmxlU3FsLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyB0eXBlOiBRdWVyeVR5cGVzLlNFTEVDVCwgcmF3OiB0cnVlIH0pKTtcbiAgICBsZXQgc3FsID0gY29uc3RyYWludHNbMF0uc3FsO1xuICAgIGNvbnN0IGluZGV4ID0gc3FsLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgY3JlYXRlVGFibGVTcWwgPSBgJHtzcWwuc3Vic3RyKDAsIGluZGV4KX0sICR7Y29uc3RyYWludFNuaXBwZXR9KSR7c3FsLnN1YnN0cihpbmRleCArIDEpfTtgO1xuICAgIGNvbnN0IGZpZWxkcyA9IGF3YWl0IHRoaXMuZGVzY3JpYmVUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuX2FsdGVyQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgZmllbGRzLCBjcmVhdGVUYWJsZVNxbCk7XG4gICAgY29uc3Qgc3ViUXVlcmllcyA9IHNxbC5zcGxpdChcIjtcIikuZmlsdGVyKChxKSA9PiBxICE9PSBcIlwiKTtcbiAgICBmb3IgKGNvbnN0IHN1YlF1ZXJ5IG9mIHN1YlF1ZXJpZXMpXG4gICAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShgJHtzdWJRdWVyeX07YCwgX19zcHJlYWRWYWx1ZXMoeyByYXc6IHRydWUgfSwgb3B0aW9ucykpO1xuICB9XG4gIGFzeW5jIGdldEZvcmVpZ25LZXlSZWZlcmVuY2VzRm9yVGFibGUodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGF0YWJhc2UgPSB0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGF0YWJhc2U7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmdldEZvcmVpZ25LZXlzUXVlcnkodGFibGVOYW1lLCBkYXRhYmFzZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkocXVlcnksIG9wdGlvbnMpO1xuICAgIHJldHVybiByZXN1bHQubWFwKChyb3cpID0+ICh7XG4gICAgICB0YWJsZU5hbWUsXG4gICAgICBjb2x1bW5OYW1lOiByb3cuZnJvbSxcbiAgICAgIHJlZmVyZW5jZWRUYWJsZU5hbWU6IHJvdy50YWJsZSxcbiAgICAgIHJlZmVyZW5jZWRDb2x1bW5OYW1lOiByb3cudG8sXG4gICAgICB0YWJsZUNhdGFsb2c6IGRhdGFiYXNlLFxuICAgICAgcmVmZXJlbmNlZFRhYmxlQ2F0YWxvZzogZGF0YWJhc2VcbiAgICB9KSk7XG4gIH1cbiAgYXN5bmMgZHJvcEFsbFRhYmxlcyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc2tpcCA9IG9wdGlvbnMuc2tpcCB8fCBbXTtcbiAgICBjb25zdCB0YWJsZU5hbWVzID0gYXdhaXQgdGhpcy5zaG93QWxsVGFibGVzKG9wdGlvbnMpO1xuICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KFwiUFJBR01BIGZvcmVpZ25fa2V5cyA9IE9GRlwiLCBvcHRpb25zKTtcbiAgICBhd2FpdCB0aGlzLl9kcm9wQWxsVGFibGVzKHRhYmxlTmFtZXMsIHNraXAsIG9wdGlvbnMpO1xuICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KFwiUFJBR01BIGZvcmVpZ25fa2V5cyA9IE9OXCIsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGRlc2NyaWJlVGFibGUodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgbGV0IHNjaGVtYSA9IG51bGw7XG4gICAgbGV0IHNjaGVtYURlbGltaXRlciA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBzY2hlbWEgPSBvcHRpb25zO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgc2NoZW1hID0gb3B0aW9ucy5zY2hlbWEgfHwgbnVsbDtcbiAgICAgIHNjaGVtYURlbGltaXRlciA9IG9wdGlvbnMuc2NoZW1hRGVsaW1pdGVyIHx8IG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGFibGVOYW1lID09PSBcIm9iamVjdFwiICYmIHRhYmxlTmFtZSAhPT0gbnVsbCkge1xuICAgICAgc2NoZW1hID0gdGFibGVOYW1lLnNjaGVtYTtcbiAgICAgIHRhYmxlTmFtZSA9IHRhYmxlTmFtZS50YWJsZU5hbWU7XG4gICAgfVxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZGVzY3JpYmVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgc2NoZW1hLCBzY2hlbWFEZWxpbWl0ZXIpO1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyB0eXBlOiBRdWVyeVR5cGVzLkRFU0NSSUJFIH0pO1xuICAgIGNvbnN0IHNxbEluZGV4ZXMgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnNob3dJbmRleGVzUXVlcnkodGFibGVOYW1lKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgICBpZiAoXy5pc0VtcHR5KGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGVzY3JpcHRpb24gZm91bmQgZm9yIFwiJHt0YWJsZU5hbWV9XCIgdGFibGUuIENoZWNrIHRoZSB0YWJsZSBuYW1lIGFuZCBzY2hlbWE7IHJlbWVtYmVyLCB0aGV5IF9hcmVfIGNhc2Ugc2Vuc2l0aXZlLmApO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5kZXhlcyA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbEluZGV4ZXMsIG9wdGlvbnMpO1xuICAgICAgZm9yIChjb25zdCBwcm9wIGluIGRhdGEpIHtcbiAgICAgICAgZGF0YVtwcm9wXS51bmlxdWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgaW5kZXhlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGluZGV4LmZpZWxkcykge1xuICAgICAgICAgIGlmIChpbmRleC51bmlxdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGF0YVtmaWVsZC5hdHRyaWJ1dGVdLnVuaXF1ZSA9IGluZGV4LnVuaXF1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGZvcmVpZ25LZXlzID0gYXdhaXQgdGhpcy5nZXRGb3JlaWduS2V5UmVmZXJlbmNlc0ZvclRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgICBmb3IgKGNvbnN0IGZvcmVpZ25LZXkgb2YgZm9yZWlnbktleXMpIHtcbiAgICAgICAgZGF0YVtmb3JlaWduS2V5LmNvbHVtbk5hbWVdLnJlZmVyZW5jZXMgPSB7XG4gICAgICAgICAgbW9kZWw6IGZvcmVpZ25LZXkucmVmZXJlbmNlZFRhYmxlTmFtZSxcbiAgICAgICAgICBrZXk6IGZvcmVpZ25LZXkucmVmZXJlbmNlZENvbHVtbk5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm9yaWdpbmFsICYmIGUub3JpZ2luYWwuY29kZSA9PT0gXCJFUl9OT19TVUNIX1RBQkxFXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZXNjcmlwdGlvbiBmb3VuZCBmb3IgXCIke3RhYmxlTmFtZX1cIiB0YWJsZS4gQ2hlY2sgdGhlIHRhYmxlIG5hbWUgYW5kIHNjaGVtYTsgcmVtZW1iZXIsIHRoZXkgX2FyZV8gY2FzZSBzZW5zaXRpdmUuYCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0cy5TUUxpdGVRdWVyeUludGVyZmFjZSA9IFNRTGl0ZVF1ZXJ5SW50ZXJmYWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnktaW50ZXJmYWNlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/sqlite/query-interface.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/sqlite/query.js":
/*!**************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/sqlite/query.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(action-browser)/../node_modules/sequelize/lib/query-types.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(action-browser)/../node_modules/sequelize/lib/dialects/parserStore.js\")(\"sqlite\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(action-browser)/../node_modules/sequelize/lib/utils/logger.js\");\nconst debug = logger.debugContext(\"sql:sqlite\");\nfunction stringifyIfBigint(value) {\n  if (typeof value === \"bigint\") {\n    return value.toString();\n  }\n  return value;\n}\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return \"lastID\";\n  }\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam;\n    if (Array.isArray(values)) {\n      bindParam = {};\n      values.forEach((v, i) => {\n        bindParam[`$${i + 1}`] = v;\n      });\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    } else {\n      bindParam = {};\n      if (typeof values === \"object\") {\n        for (const k of Object.keys(values)) {\n          bindParam[`$${k}`] = values[k];\n        }\n      }\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    }\n    return [sql, bindParam];\n  }\n  _collectModels(include, prefix) {\n    const ret = {};\n    if (include) {\n      for (const _include of include) {\n        let key;\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = `${prefix}.${_include.as}`;\n        }\n        ret[key] = _include.model;\n        if (_include.include) {\n          _.merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n    return ret;\n  }\n  _handleQueryResponse(metaData, columnTypes, err, results, errStack) {\n    if (err) {\n      err.sql = this.sql;\n      throw this.formatError(err, errStack);\n    }\n    let result = this.instance;\n    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {\n      this.handleInsertQuery(results, metaData);\n      if (!this.instance) {\n        if (metaData.constructor.name === \"Statement\" && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n          result = [];\n          for (let i = startId; i < startId + metaData.changes; i++) {\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\n          }\n        } else {\n          result = metaData[this.getInsertIdField()];\n        }\n      }\n    }\n    if (this.isShowTablesQuery()) {\n      return results.map((row) => row.name);\n    }\n    if (this.isShowConstraintsQuery()) {\n      result = results;\n      if (results && results[0] && results[0].sql) {\n        result = this.parseConstraintsFromSql(results[0].sql);\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      if (this.options.raw) {\n        return this.handleSelectQuery(results);\n      }\n      const prefixes = this._collectModels(this.options.include);\n      results = results.map((result2) => {\n        return _.mapValues(result2, (value, name) => {\n          let model;\n          if (name.includes(\".\")) {\n            const lastind = name.lastIndexOf(\".\");\n            model = prefixes[name.substr(0, lastind)];\n            name = name.substr(lastind + 1);\n          } else {\n            model = this.options.model;\n          }\n          const tableName = model.getTableName().toString().replace(/`/g, \"\");\n          const tableTypes = columnTypes[tableName] || {};\n          if (tableTypes && !(name in tableTypes)) {\n            _.forOwn(model.rawAttributes, (attribute, key) => {\n              if (name === key && attribute.field) {\n                name = attribute.field;\n                return false;\n              }\n            });\n          }\n          return Object.prototype.hasOwnProperty.call(tableTypes, name) ? this.applyParsers(tableTypes[name], value) : value;\n        });\n      });\n      return this.handleSelectQuery(results);\n    }\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n    if (this.sql.includes(\"PRAGMA INDEX_LIST\")) {\n      return this.handleShowIndexesQuery(results);\n    }\n    if (this.sql.includes(\"PRAGMA INDEX_INFO\")) {\n      return results;\n    }\n    if (this.sql.includes(\"PRAGMA TABLE_INFO\")) {\n      result = {};\n      let defaultValue;\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          defaultValue = void 0;\n        } else if (_result.dflt_value === \"NULL\") {\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0\n        };\n        if (result[_result.name].type === \"TINYINT(1)\") {\n          result[_result.name].defaultValue = { \"0\": false, \"1\": true }[result[_result.name].defaultValue];\n        }\n        if (typeof result[_result.name].defaultValue === \"string\") {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, \"\");\n        }\n      }\n      return result;\n    }\n    if (this.sql.includes(\"PRAGMA foreign_keys;\")) {\n      return results[0];\n    }\n    if (this.sql.includes(\"PRAGMA foreign_keys\")) {\n      return results;\n    }\n    if (this.sql.includes(\"PRAGMA foreign_key_list\")) {\n      return results;\n    }\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n      return metaData.changes;\n    }\n    if (this.options.type === QueryTypes.VERSION) {\n      return results[0].version;\n    }\n    if (this.options.type === QueryTypes.RAW) {\n      return [results, metaData];\n    }\n    if (this.isUpsertQuery()) {\n      return [result, null];\n    }\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\n      return [result, metaData.changes];\n    }\n    return result;\n  }\n  async run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n    const complete = this._logQuery(sql, debug, parameters);\n    return new Promise((resolve, reject) => conn.serialize(async () => {\n      const columnTypes = {};\n      const errForStack = new Error();\n      const executeSql = () => {\n        if (sql.startsWith(\"-- \")) {\n          return resolve();\n        }\n        const query = this;\n        function afterExecute(executionError, results) {\n          try {\n            complete();\n            resolve(query._handleQueryResponse(this, columnTypes, executionError, results, errForStack.stack));\n            return;\n          } catch (error) {\n            reject(error);\n          }\n        }\n        if (!parameters)\n          parameters = [];\n        if (_.isPlainObject(parameters)) {\n          const newParameters = Object.create(null);\n          for (const key of Object.keys(parameters)) {\n            newParameters[`${key}`] = stringifyIfBigint(parameters[key]);\n          }\n          parameters = newParameters;\n        } else {\n          parameters = parameters.map(stringifyIfBigint);\n        }\n        conn[method](sql, parameters, afterExecute);\n        return null;\n      };\n      if (this.getDatabaseMethod() === \"all\") {\n        let tableNames = [];\n        if (this.options && this.options.tableNames) {\n          tableNames = this.options.tableNames;\n        } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n          tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n        }\n        tableNames = tableNames.filter((tableName) => !(tableName in columnTypes) && tableName !== \"sqlite_master\");\n        if (!tableNames.length) {\n          return executeSql();\n        }\n        await Promise.all(tableNames.map((tableName) => new Promise((resolve2) => {\n          tableName = tableName.replace(/`/g, \"\");\n          columnTypes[tableName] = {};\n          conn.all(`PRAGMA table_info(\\`${tableName}\\`)`, (err, results) => {\n            if (!err) {\n              for (const result of results) {\n                columnTypes[tableName][result.name] = result.type;\n              }\n            }\n            resolve2();\n          });\n        })));\n      }\n      return executeSql();\n    }));\n  }\n  parseConstraintsFromSql(sql) {\n    let constraints = sql.split(\"CONSTRAINT \");\n    let referenceTableName, referenceTableKeys, updateAction, deleteAction;\n    constraints.splice(0, 1);\n    constraints = constraints.map((constraintSql) => {\n      if (constraintSql.includes(\"REFERENCES\")) {\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        if (updateAction) {\n          updateAction = updateAction[1];\n        }\n        if (deleteAction) {\n          deleteAction = deleteAction[1];\n        }\n        const referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(\" \");\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\n        let columnNames = referenceConditions[2];\n        columnNames = columnNames.replace(/\\(|\\)/g, \"\").split(\", \");\n        referenceTableKeys = columnNames.map((column) => Utils.removeTicks(column));\n      }\n      const constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      constraintSql = constraintSql.replace(/\\(.+\\)/, \"\");\n      const constraint = constraintSql.split(\" \");\n      if ([\"PRIMARY\", \"FOREIGN\"].includes(constraint[1])) {\n        constraint[1] += \" KEY\";\n      }\n      return {\n        constraintName: Utils.removeTicks(constraint[0]),\n        constraintType: constraint[1],\n        updateAction,\n        deleteAction,\n        sql: sql.replace(/\"/g, \"`\"),\n        constraintCondition,\n        referenceTableName,\n        referenceTableKeys\n      };\n    });\n    return constraints;\n  }\n  applyParsers(type, value) {\n    if (type.includes(\"(\")) {\n      type = type.substr(0, type.indexOf(\"(\"));\n    }\n    type = type.replace(\"UNSIGNED\", \"\").replace(\"ZEROFILL\", \"\");\n    type = type.trim().toUpperCase();\n    const parse = parserStore.get(type);\n    if (value !== null && parse) {\n      return parse(value, { timezone: this.sequelize.options.timezone });\n    }\n    return value;\n  }\n  formatError(err, errStack) {\n    switch (err.code) {\n      case \"SQLITE_CONSTRAINT_UNIQUE\":\n      case \"SQLITE_CONSTRAINT_PRIMARYKEY\":\n      case \"SQLITE_CONSTRAINT_TRIGGER\":\n      case \"SQLITE_CONSTRAINT_FOREIGNKEY\":\n      case \"SQLITE_CONSTRAINT\": {\n        if (err.message.includes(\"FOREIGN KEY constraint failed\")) {\n          return new sequelizeErrors.ForeignKeyConstraintError({\n            parent: err,\n            stack: errStack\n          });\n        }\n        let fields = [];\n        let match = err.message.match(/columns (.*?) are/);\n        if (match !== null && match.length >= 2) {\n          fields = match[1].split(\", \");\n        } else {\n          match = err.message.match(/UNIQUE constraint failed: (.*)/);\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(\", \").map((columnWithTable) => columnWithTable.split(\".\")[1]);\n          }\n        }\n        const errors = [];\n        let message = \"Validation error\";\n        for (const field of fields) {\n          errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, this.instance && this.instance[field], this.instance, \"not_unique\"));\n        }\n        if (this.model) {\n          _.forOwn(this.model.uniqueKeys, (constraint) => {\n            if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n              message = constraint.msg;\n              return false;\n            }\n          });\n        }\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n      }\n      case \"SQLITE_BUSY\":\n        return new sequelizeErrors.TimeoutError(err, { stack: errStack });\n      default:\n        return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n    }\n  }\n  async handleShowIndexesQuery(data) {\n    return Promise.all(data.reverse().map(async (item) => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = !!item.unique;\n      item.constraintName = item.name;\n      const columns = await this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`);\n      for (const column of columns) {\n        item.fields[column.seqno] = {\n          attribute: column.name,\n          length: void 0,\n          order: void 0\n        };\n      }\n      return item;\n    }));\n  }\n  getDatabaseMethod() {\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes(\"CREATE TEMPORARY TABLE\".toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n      return \"run\";\n    }\n    return \"all\";\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports[\"default\"] = Query;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixVQUFVLG1CQUFPLENBQUMsaUVBQVE7QUFDMUIsY0FBYyxtQkFBTyxDQUFDLDRFQUFhO0FBQ25DLHNCQUFzQixtQkFBTyxDQUFDLG9HQUFtQjtBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDOUMsd0JBQXdCLG1CQUFPLENBQUMsb0ZBQWM7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsOEZBQWdCO0FBQzVDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsMEZBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUIsT0FBTztBQUNQLHVFQUF1RSx3QkFBd0I7QUFDL0YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixFQUFFO0FBQzFCO0FBQ0E7QUFDQSx1RUFBdUUsd0JBQXdCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG1CQUFtQixPQUFPLEdBQUcsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0NBQWdDO0FBQ2hFLDBCQUEwQixxRUFBcUU7QUFDL0Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx1QkFBdUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixJQUFJO0FBQ2pDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RyxFQUFFO0FBQzFHLHdHQUF3RyxFQUFFO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkNBQTJDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLDJEQUEyRCx1REFBdUQ7QUFDbEg7QUFDQTtBQUNBLHVEQUF1RCxpQkFBaUI7QUFDeEU7QUFDQSx3REFBd0QsaUJBQWlCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsVUFBVTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQix5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvc3FsaXRlL3F1ZXJ5LmpzP2U2YTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuY29uc3QgQWJzdHJhY3RRdWVyeSA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9xdWVyeVwiKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vcXVlcnktdHlwZXNcIik7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzXCIpO1xuY29uc3QgcGFyc2VyU3RvcmUgPSByZXF1aXJlKFwiLi4vcGFyc2VyU3RvcmVcIikoXCJzcWxpdGVcIik7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2xvZ2dlclwiKTtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dChcInNxbDpzcWxpdGVcIik7XG5mdW5jdGlvbiBzdHJpbmdpZnlJZkJpZ2ludCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuY2xhc3MgUXVlcnkgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5IHtcbiAgZ2V0SW5zZXJ0SWRGaWVsZCgpIHtcbiAgICByZXR1cm4gXCJsYXN0SURcIjtcbiAgfVxuICBzdGF0aWMgZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QpIHtcbiAgICBsZXQgYmluZFBhcmFtO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgIGJpbmRQYXJhbSA9IHt9O1xuICAgICAgdmFsdWVzLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgICAgYmluZFBhcmFtW2AkJHtpICsgMX1gXSA9IHY7XG4gICAgICB9KTtcbiAgICAgIHNxbCA9IEFic3RyYWN0UXVlcnkuZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QsIHsgc2tpcFZhbHVlUmVwbGFjZTogdHJ1ZSB9KVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmluZFBhcmFtID0ge307XG4gICAgICBpZiAodHlwZW9mIHZhbHVlcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXModmFsdWVzKSkge1xuICAgICAgICAgIGJpbmRQYXJhbVtgJCR7a31gXSA9IHZhbHVlc1trXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3FsID0gQWJzdHJhY3RRdWVyeS5mb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCwgeyBza2lwVmFsdWVSZXBsYWNlOiB0cnVlIH0pWzBdO1xuICAgIH1cbiAgICByZXR1cm4gW3NxbCwgYmluZFBhcmFtXTtcbiAgfVxuICBfY29sbGVjdE1vZGVscyhpbmNsdWRlLCBwcmVmaXgpIHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgZm9yIChjb25zdCBfaW5jbHVkZSBvZiBpbmNsdWRlKSB7XG4gICAgICAgIGxldCBrZXk7XG4gICAgICAgIGlmICghcHJlZml4KSB7XG4gICAgICAgICAga2V5ID0gX2luY2x1ZGUuYXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2V5ID0gYCR7cHJlZml4fS4ke19pbmNsdWRlLmFzfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0W2tleV0gPSBfaW5jbHVkZS5tb2RlbDtcbiAgICAgICAgaWYgKF9pbmNsdWRlLmluY2x1ZGUpIHtcbiAgICAgICAgICBfLm1lcmdlKHJldCwgdGhpcy5fY29sbGVjdE1vZGVscyhfaW5jbHVkZS5pbmNsdWRlLCBrZXkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIF9oYW5kbGVRdWVyeVJlc3BvbnNlKG1ldGFEYXRhLCBjb2x1bW5UeXBlcywgZXJyLCByZXN1bHRzLCBlcnJTdGFjaykge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGVyci5zcWwgPSB0aGlzLnNxbDtcbiAgICAgIHRocm93IHRoaXMuZm9ybWF0RXJyb3IoZXJyLCBlcnJTdGFjayk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSB0aGlzLmluc3RhbmNlO1xuICAgIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkocmVzdWx0cywgbWV0YURhdGEpIHx8IHRoaXMuaXNVcHNlcnRRdWVyeSgpKSB7XG4gICAgICB0aGlzLmhhbmRsZUluc2VydFF1ZXJ5KHJlc3VsdHMsIG1ldGFEYXRhKTtcbiAgICAgIGlmICghdGhpcy5pbnN0YW5jZSkge1xuICAgICAgICBpZiAobWV0YURhdGEuY29uc3RydWN0b3IubmFtZSA9PT0gXCJTdGF0ZW1lbnRcIiAmJiB0aGlzLm1vZGVsICYmIHRoaXMubW9kZWwuYXV0b0luY3JlbWVudEF0dHJpYnV0ZSAmJiB0aGlzLm1vZGVsLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUgPT09IHRoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZSAmJiB0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlXSkge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0SWQgPSBtZXRhRGF0YVt0aGlzLmdldEluc2VydElkRmllbGQoKV0gLSBtZXRhRGF0YS5jaGFuZ2VzICsgMTtcbiAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJZDsgaSA8IHN0YXJ0SWQgKyBtZXRhRGF0YS5jaGFuZ2VzOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgW3RoaXMubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVdLmZpZWxkXTogaSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gbWV0YURhdGFbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd1RhYmxlc1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiByZXN1bHRzLm1hcCgocm93KSA9PiByb3cubmFtZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd0NvbnN0cmFpbnRzUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0cztcbiAgICAgIGlmIChyZXN1bHRzICYmIHJlc3VsdHNbMF0gJiYgcmVzdWx0c1swXS5zcWwpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUNvbnN0cmFpbnRzRnJvbVNxbChyZXN1bHRzWzBdLnNxbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1NlbGVjdFF1ZXJ5KCkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmF3KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbGVjdFF1ZXJ5KHJlc3VsdHMpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJlZml4ZXMgPSB0aGlzLl9jb2xsZWN0TW9kZWxzKHRoaXMub3B0aW9ucy5pbmNsdWRlKTtcbiAgICAgIHJlc3VsdHMgPSByZXN1bHRzLm1hcCgocmVzdWx0MikgPT4ge1xuICAgICAgICByZXR1cm4gXy5tYXBWYWx1ZXMocmVzdWx0MiwgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgICAgbGV0IG1vZGVsO1xuICAgICAgICAgIGlmIChuYW1lLmluY2x1ZGVzKFwiLlwiKSkge1xuICAgICAgICAgICAgY29uc3QgbGFzdGluZCA9IG5hbWUubGFzdEluZGV4T2YoXCIuXCIpO1xuICAgICAgICAgICAgbW9kZWwgPSBwcmVmaXhlc1tuYW1lLnN1YnN0cigwLCBsYXN0aW5kKV07XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHIobGFzdGluZCArIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2RlbCA9IHRoaXMub3B0aW9ucy5tb2RlbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdGFibGVOYW1lID0gbW9kZWwuZ2V0VGFibGVOYW1lKCkudG9TdHJpbmcoKS5yZXBsYWNlKC9gL2csIFwiXCIpO1xuICAgICAgICAgIGNvbnN0IHRhYmxlVHlwZXMgPSBjb2x1bW5UeXBlc1t0YWJsZU5hbWVdIHx8IHt9O1xuICAgICAgICAgIGlmICh0YWJsZVR5cGVzICYmICEobmFtZSBpbiB0YWJsZVR5cGVzKSkge1xuICAgICAgICAgICAgXy5mb3JPd24obW9kZWwucmF3QXR0cmlidXRlcywgKGF0dHJpYnV0ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChuYW1lID09PSBrZXkgJiYgYXR0cmlidXRlLmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGF0dHJpYnV0ZS5maWVsZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhYmxlVHlwZXMsIG5hbWUpID8gdGhpcy5hcHBseVBhcnNlcnModGFibGVUeXBlc1tuYW1lXSwgdmFsdWUpIDogdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZWxlY3RRdWVyeShyZXN1bHRzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93T3JEZXNjcmliZVF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5zcWwuaW5jbHVkZXMoXCJQUkFHTUEgSU5ERVhfTElTVFwiKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShyZXN1bHRzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3FsLmluY2x1ZGVzKFwiUFJBR01BIElOREVYX0lORk9cIikpIHtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5zcWwuaW5jbHVkZXMoXCJQUkFHTUEgVEFCTEVfSU5GT1wiKSkge1xuICAgICAgcmVzdWx0ID0ge307XG4gICAgICBsZXQgZGVmYXVsdFZhbHVlO1xuICAgICAgZm9yIChjb25zdCBfcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgaWYgKF9yZXN1bHQuZGZsdF92YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgfSBlbHNlIGlmIChfcmVzdWx0LmRmbHRfdmFsdWUgPT09IFwiTlVMTFwiKSB7XG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBfcmVzdWx0LmRmbHRfdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W19yZXN1bHQubmFtZV0gPSB7XG4gICAgICAgICAgdHlwZTogX3Jlc3VsdC50eXBlLFxuICAgICAgICAgIGFsbG93TnVsbDogX3Jlc3VsdC5ub3RudWxsID09PSAwLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICBwcmltYXJ5S2V5OiBfcmVzdWx0LnBrICE9PSAwXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZXN1bHRbX3Jlc3VsdC5uYW1lXS50eXBlID09PSBcIlRJTllJTlQoMSlcIikge1xuICAgICAgICAgIHJlc3VsdFtfcmVzdWx0Lm5hbWVdLmRlZmF1bHRWYWx1ZSA9IHsgXCIwXCI6IGZhbHNlLCBcIjFcIjogdHJ1ZSB9W3Jlc3VsdFtfcmVzdWx0Lm5hbWVdLmRlZmF1bHRWYWx1ZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRbX3Jlc3VsdC5uYW1lXS5kZWZhdWx0VmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXN1bHRbX3Jlc3VsdC5uYW1lXS5kZWZhdWx0VmFsdWUgPSByZXN1bHRbX3Jlc3VsdC5uYW1lXS5kZWZhdWx0VmFsdWUucmVwbGFjZSgvJy9nLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3FsLmluY2x1ZGVzKFwiUFJBR01BIGZvcmVpZ25fa2V5cztcIikpIHtcbiAgICAgIHJldHVybiByZXN1bHRzWzBdO1xuICAgIH1cbiAgICBpZiAodGhpcy5zcWwuaW5jbHVkZXMoXCJQUkFHTUEgZm9yZWlnbl9rZXlzXCIpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgaWYgKHRoaXMuc3FsLmluY2x1ZGVzKFwiUFJBR01BIGZvcmVpZ25fa2V5X2xpc3RcIikpIHtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBpZiAoW1F1ZXJ5VHlwZXMuQlVMS1VQREFURSwgUXVlcnlUeXBlcy5CVUxLREVMRVRFXS5pbmNsdWRlcyh0aGlzLm9wdGlvbnMudHlwZSkpIHtcbiAgICAgIHJldHVybiBtZXRhRGF0YS5jaGFuZ2VzO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuVkVSU0lPTikge1xuICAgICAgcmV0dXJuIHJlc3VsdHNbMF0udmVyc2lvbjtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLlJBVykge1xuICAgICAgcmV0dXJuIFtyZXN1bHRzLCBtZXRhRGF0YV07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVXBzZXJ0UXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFtyZXN1bHQsIG51bGxdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1VwZGF0ZVF1ZXJ5KCkgfHwgdGhpcy5pc0luc2VydFF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbcmVzdWx0LCBtZXRhRGF0YS5jaGFuZ2VzXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyBydW4oc3FsLCBwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgY29ubiA9IHRoaXMuY29ubmVjdGlvbjtcbiAgICB0aGlzLnNxbCA9IHNxbDtcbiAgICBjb25zdCBtZXRob2QgPSB0aGlzLmdldERhdGFiYXNlTWV0aG9kKCk7XG4gICAgY29uc3QgY29tcGxldGUgPSB0aGlzLl9sb2dRdWVyeShzcWwsIGRlYnVnLCBwYXJhbWV0ZXJzKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gY29ubi5zZXJpYWxpemUoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29sdW1uVHlwZXMgPSB7fTtcbiAgICAgIGNvbnN0IGVyckZvclN0YWNrID0gbmV3IEVycm9yKCk7XG4gICAgICBjb25zdCBleGVjdXRlU3FsID0gKCkgPT4ge1xuICAgICAgICBpZiAoc3FsLnN0YXJ0c1dpdGgoXCItLSBcIikpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gYWZ0ZXJFeGVjdXRlKGV4ZWN1dGlvbkVycm9yLCByZXN1bHRzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgICAgICByZXNvbHZlKHF1ZXJ5Ll9oYW5kbGVRdWVyeVJlc3BvbnNlKHRoaXMsIGNvbHVtblR5cGVzLCBleGVjdXRpb25FcnJvciwgcmVzdWx0cywgZXJyRm9yU3RhY2suc3RhY2spKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJhbWV0ZXJzKVxuICAgICAgICAgIHBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChwYXJhbWV0ZXJzKSkge1xuICAgICAgICAgIGNvbnN0IG5ld1BhcmFtZXRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHBhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgICBuZXdQYXJhbWV0ZXJzW2Ake2tleX1gXSA9IHN0cmluZ2lmeUlmQmlnaW50KHBhcmFtZXRlcnNba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmFtZXRlcnMgPSBuZXdQYXJhbWV0ZXJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzLm1hcChzdHJpbmdpZnlJZkJpZ2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgY29ublttZXRob2RdKHNxbCwgcGFyYW1ldGVycywgYWZ0ZXJFeGVjdXRlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZ2V0RGF0YWJhc2VNZXRob2QoKSA9PT0gXCJhbGxcIikge1xuICAgICAgICBsZXQgdGFibGVOYW1lcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy50YWJsZU5hbWVzKSB7XG4gICAgICAgICAgdGFibGVOYW1lcyA9IHRoaXMub3B0aW9ucy50YWJsZU5hbWVzO1xuICAgICAgICB9IGVsc2UgaWYgKC9GUk9NIGAoLio/KWAvaS5leGVjKHRoaXMuc3FsKSkge1xuICAgICAgICAgIHRhYmxlTmFtZXMucHVzaCgvRlJPTSBgKC4qPylgL2kuZXhlYyh0aGlzLnNxbClbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlTmFtZXMgPSB0YWJsZU5hbWVzLmZpbHRlcigodGFibGVOYW1lKSA9PiAhKHRhYmxlTmFtZSBpbiBjb2x1bW5UeXBlcykgJiYgdGFibGVOYW1lICE9PSBcInNxbGl0ZV9tYXN0ZXJcIik7XG4gICAgICAgIGlmICghdGFibGVOYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZXhlY3V0ZVNxbCgpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRhYmxlTmFtZXMubWFwKCh0YWJsZU5hbWUpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlMikgPT4ge1xuICAgICAgICAgIHRhYmxlTmFtZSA9IHRhYmxlTmFtZS5yZXBsYWNlKC9gL2csIFwiXCIpO1xuICAgICAgICAgIGNvbHVtblR5cGVzW3RhYmxlTmFtZV0gPSB7fTtcbiAgICAgICAgICBjb25uLmFsbChgUFJBR01BIHRhYmxlX2luZm8oXFxgJHt0YWJsZU5hbWV9XFxgKWAsIChlcnIsIHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5UeXBlc1t0YWJsZU5hbWVdW3Jlc3VsdC5uYW1lXSA9IHJlc3VsdC50eXBlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlMigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4ZWN1dGVTcWwoKTtcbiAgICB9KSk7XG4gIH1cbiAgcGFyc2VDb25zdHJhaW50c0Zyb21TcWwoc3FsKSB7XG4gICAgbGV0IGNvbnN0cmFpbnRzID0gc3FsLnNwbGl0KFwiQ09OU1RSQUlOVCBcIik7XG4gICAgbGV0IHJlZmVyZW5jZVRhYmxlTmFtZSwgcmVmZXJlbmNlVGFibGVLZXlzLCB1cGRhdGVBY3Rpb24sIGRlbGV0ZUFjdGlvbjtcbiAgICBjb25zdHJhaW50cy5zcGxpY2UoMCwgMSk7XG4gICAgY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5tYXAoKGNvbnN0cmFpbnRTcWwpID0+IHtcbiAgICAgIGlmIChjb25zdHJhaW50U3FsLmluY2x1ZGVzKFwiUkVGRVJFTkNFU1wiKSkge1xuICAgICAgICB1cGRhdGVBY3Rpb24gPSBjb25zdHJhaW50U3FsLm1hdGNoKC9PTiBVUERBVEUgKENBU0NBREV8U0VUIE5VTEx8UkVTVFJJQ1R8Tk8gQUNUSU9OfFNFVCBERUZBVUxUKXsxfS8pO1xuICAgICAgICBkZWxldGVBY3Rpb24gPSBjb25zdHJhaW50U3FsLm1hdGNoKC9PTiBERUxFVEUgKENBU0NBREV8U0VUIE5VTEx8UkVTVFJJQ1R8Tk8gQUNUSU9OfFNFVCBERUZBVUxUKXsxfS8pO1xuICAgICAgICBpZiAodXBkYXRlQWN0aW9uKSB7XG4gICAgICAgICAgdXBkYXRlQWN0aW9uID0gdXBkYXRlQWN0aW9uWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWxldGVBY3Rpb24pIHtcbiAgICAgICAgICBkZWxldGVBY3Rpb24gPSBkZWxldGVBY3Rpb25bMV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVmZXJlbmNlc1JlZ2V4ID0gL1JFRkVSRU5DRVMuK1xcKCg/OlteKShdK3xcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKlxcKS87XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUNvbmRpdGlvbnMgPSBjb25zdHJhaW50U3FsLm1hdGNoKHJlZmVyZW5jZXNSZWdleClbMF0uc3BsaXQoXCIgXCIpO1xuICAgICAgICByZWZlcmVuY2VUYWJsZU5hbWUgPSBVdGlscy5yZW1vdmVUaWNrcyhyZWZlcmVuY2VDb25kaXRpb25zWzFdKTtcbiAgICAgICAgbGV0IGNvbHVtbk5hbWVzID0gcmVmZXJlbmNlQ29uZGl0aW9uc1syXTtcbiAgICAgICAgY29sdW1uTmFtZXMgPSBjb2x1bW5OYW1lcy5yZXBsYWNlKC9cXCh8XFwpL2csIFwiXCIpLnNwbGl0KFwiLCBcIik7XG4gICAgICAgIHJlZmVyZW5jZVRhYmxlS2V5cyA9IGNvbHVtbk5hbWVzLm1hcCgoY29sdW1uKSA9PiBVdGlscy5yZW1vdmVUaWNrcyhjb2x1bW4pKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnN0cmFpbnRDb25kaXRpb24gPSBjb25zdHJhaW50U3FsLm1hdGNoKC9cXCgoPzpbXikoXSt8XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSpcXCkvKVswXTtcbiAgICAgIGNvbnN0cmFpbnRTcWwgPSBjb25zdHJhaW50U3FsLnJlcGxhY2UoL1xcKC4rXFwpLywgXCJcIik7XG4gICAgICBjb25zdCBjb25zdHJhaW50ID0gY29uc3RyYWludFNxbC5zcGxpdChcIiBcIik7XG4gICAgICBpZiAoW1wiUFJJTUFSWVwiLCBcIkZPUkVJR05cIl0uaW5jbHVkZXMoY29uc3RyYWludFsxXSkpIHtcbiAgICAgICAgY29uc3RyYWludFsxXSArPSBcIiBLRVlcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN0cmFpbnROYW1lOiBVdGlscy5yZW1vdmVUaWNrcyhjb25zdHJhaW50WzBdKSxcbiAgICAgICAgY29uc3RyYWludFR5cGU6IGNvbnN0cmFpbnRbMV0sXG4gICAgICAgIHVwZGF0ZUFjdGlvbixcbiAgICAgICAgZGVsZXRlQWN0aW9uLFxuICAgICAgICBzcWw6IHNxbC5yZXBsYWNlKC9cIi9nLCBcImBcIiksXG4gICAgICAgIGNvbnN0cmFpbnRDb25kaXRpb24sXG4gICAgICAgIHJlZmVyZW5jZVRhYmxlTmFtZSxcbiAgICAgICAgcmVmZXJlbmNlVGFibGVLZXlzXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBjb25zdHJhaW50cztcbiAgfVxuICBhcHBseVBhcnNlcnModHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZS5pbmNsdWRlcyhcIihcIikpIHtcbiAgICAgIHR5cGUgPSB0eXBlLnN1YnN0cigwLCB0eXBlLmluZGV4T2YoXCIoXCIpKTtcbiAgICB9XG4gICAgdHlwZSA9IHR5cGUucmVwbGFjZShcIlVOU0lHTkVEXCIsIFwiXCIpLnJlcGxhY2UoXCJaRVJPRklMTFwiLCBcIlwiKTtcbiAgICB0eXBlID0gdHlwZS50cmltKCkudG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBwYXJzZSA9IHBhcnNlclN0b3JlLmdldCh0eXBlKTtcbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgcGFyc2UpIHtcbiAgICAgIHJldHVybiBwYXJzZSh2YWx1ZSwgeyB0aW1lem9uZTogdGhpcy5zZXF1ZWxpemUub3B0aW9ucy50aW1lem9uZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZvcm1hdEVycm9yKGVyciwgZXJyU3RhY2spIHtcbiAgICBzd2l0Y2ggKGVyci5jb2RlKSB7XG4gICAgICBjYXNlIFwiU1FMSVRFX0NPTlNUUkFJTlRfVU5JUVVFXCI6XG4gICAgICBjYXNlIFwiU1FMSVRFX0NPTlNUUkFJTlRfUFJJTUFSWUtFWVwiOlxuICAgICAgY2FzZSBcIlNRTElURV9DT05TVFJBSU5UX1RSSUdHRVJcIjpcbiAgICAgIGNhc2UgXCJTUUxJVEVfQ09OU1RSQUlOVF9GT1JFSUdOS0VZXCI6XG4gICAgICBjYXNlIFwiU1FMSVRFX0NPTlNUUkFJTlRcIjoge1xuICAgICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJGT1JFSUdOIEtFWSBjb25zdHJhaW50IGZhaWxlZFwiKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3Ioe1xuICAgICAgICAgICAgcGFyZW50OiBlcnIsXG4gICAgICAgICAgICBzdGFjazogZXJyU3RhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmllbGRzID0gW107XG4gICAgICAgIGxldCBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9jb2x1bW5zICguKj8pIGFyZS8pO1xuICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwgJiYgbWF0Y2gubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICBmaWVsZHMgPSBtYXRjaFsxXS5zcGxpdChcIiwgXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL1VOSVFVRSBjb25zdHJhaW50IGZhaWxlZDogKC4qKS8pO1xuICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgZmllbGRzID0gbWF0Y2hbMV0uc3BsaXQoXCIsIFwiKS5tYXAoKGNvbHVtbldpdGhUYWJsZSkgPT4gY29sdW1uV2l0aFRhYmxlLnNwbGl0KFwiLlwiKVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBsZXQgbWVzc2FnZSA9IFwiVmFsaWRhdGlvbiBlcnJvclwiO1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9ySXRlbSh0aGlzLmdldFVuaXF1ZUNvbnN0cmFpbnRFcnJvck1lc3NhZ2UoZmllbGQpLCBcInVuaXF1ZSB2aW9sYXRpb25cIiwgZmllbGQsIHRoaXMuaW5zdGFuY2UgJiYgdGhpcy5pbnN0YW5jZVtmaWVsZF0sIHRoaXMuaW5zdGFuY2UsIFwibm90X3VuaXF1ZVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwpIHtcbiAgICAgICAgICBfLmZvck93bih0aGlzLm1vZGVsLnVuaXF1ZUtleXMsIChjb25zdHJhaW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoXy5pc0VxdWFsKGNvbnN0cmFpbnQuZmllbGRzLCBmaWVsZHMpICYmICEhY29uc3RyYWludC5tc2cpIHtcbiAgICAgICAgICAgICAgbWVzc2FnZSA9IGNvbnN0cmFpbnQubXNnO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5pcXVlQ29uc3RyYWludEVycm9yKHsgbWVzc2FnZSwgZXJyb3JzLCBwYXJlbnQ6IGVyciwgZmllbGRzLCBzdGFjazogZXJyU3RhY2sgfSk7XG4gICAgICB9XG4gICAgICBjYXNlIFwiU1FMSVRFX0JVU1lcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuVGltZW91dEVycm9yKGVyciwgeyBzdGFjazogZXJyU3RhY2sgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5EYXRhYmFzZUVycm9yKGVyciwgeyBzdGFjazogZXJyU3RhY2sgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGhhbmRsZVNob3dJbmRleGVzUXVlcnkoZGF0YSkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChkYXRhLnJldmVyc2UoKS5tYXAoYXN5bmMgKGl0ZW0pID0+IHtcbiAgICAgIGl0ZW0uZmllbGRzID0gW107XG4gICAgICBpdGVtLnByaW1hcnkgPSBmYWxzZTtcbiAgICAgIGl0ZW0udW5pcXVlID0gISFpdGVtLnVuaXF1ZTtcbiAgICAgIGl0ZW0uY29uc3RyYWludE5hbWUgPSBpdGVtLm5hbWU7XG4gICAgICBjb25zdCBjb2x1bW5zID0gYXdhaXQgdGhpcy5ydW4oYFBSQUdNQSBJTkRFWF9JTkZPKFxcYCR7aXRlbS5uYW1lfVxcYClgKTtcbiAgICAgIGZvciAoY29uc3QgY29sdW1uIG9mIGNvbHVtbnMpIHtcbiAgICAgICAgaXRlbS5maWVsZHNbY29sdW1uLnNlcW5vXSA9IHtcbiAgICAgICAgICBhdHRyaWJ1dGU6IGNvbHVtbi5uYW1lLFxuICAgICAgICAgIGxlbmd0aDogdm9pZCAwLFxuICAgICAgICAgIG9yZGVyOiB2b2lkIDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pKTtcbiAgfVxuICBnZXREYXRhYmFzZU1ldGhvZCgpIHtcbiAgICBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KCkgfHwgdGhpcy5pc1VwZGF0ZVF1ZXJ5KCkgfHwgdGhpcy5pc1Vwc2VydFF1ZXJ5KCkgfHwgdGhpcy5pc0J1bGtVcGRhdGVRdWVyeSgpIHx8IHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJDUkVBVEUgVEVNUE9SQVJZIFRBQkxFXCIudG9Mb3dlckNhc2UoKSkgfHwgdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuQlVMS0RFTEVURSkge1xuICAgICAgcmV0dXJuIFwicnVuXCI7XG4gICAgfVxuICAgIHJldHVybiBcImFsbFwiO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuUXVlcnkgPSBRdWVyeTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBRdWVyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/sqlite/query.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/dialects/sqlite/sqlite-utils.js":
/*!*********************************************************************!*\
  !*** ../node_modules/sequelize/lib/dialects/sqlite/sqlite-utils.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("var __defProp = Object.defineProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  withSqliteForeignKeysOff: () => withSqliteForeignKeysOff\n});\nasync function withSqliteForeignKeysOff(sequelize, options, cb) {\n  try {\n    await sequelize.query(\"PRAGMA foreign_keys = OFF\", options);\n    return await cb();\n  } finally {\n    await sequelize.query(\"PRAGMA foreign_keys = ON\", options);\n  }\n}\n//# sourceMappingURL=sqlite-utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvc3FsaXRlLXV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvc3FsaXRlL3NxbGl0ZS11dGlscy5qcz9mMTc0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgd2l0aFNxbGl0ZUZvcmVpZ25LZXlzT2ZmOiAoKSA9PiB3aXRoU3FsaXRlRm9yZWlnbktleXNPZmZcbn0pO1xuYXN5bmMgZnVuY3Rpb24gd2l0aFNxbGl0ZUZvcmVpZ25LZXlzT2ZmKHNlcXVlbGl6ZSwgb3B0aW9ucywgY2IpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBzZXF1ZWxpemUucXVlcnkoXCJQUkFHTUEgZm9yZWlnbl9rZXlzID0gT0ZGXCIsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCBjYigpO1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IHNlcXVlbGl6ZS5xdWVyeShcIlBSQUdNQSBmb3JlaWduX2tleXMgPSBPTlwiLCBvcHRpb25zKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3FsaXRlLXV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/dialects/sqlite/sqlite-utils.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/aggregate-error.js":
/*!***************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/aggregate-error.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => aggregate_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/base-error.js\"));\nclass AggregateError extends import_base_error.default {\n  constructor(errors) {\n    super();\n    __publicField(this, \"errors\");\n    this.errors = errors;\n    this.name = \"AggregateError\";\n  }\n  toString() {\n    const message = `AggregateError of:\n${this.errors.map((error) => error === this ? \"[Circular AggregateError]\" : error instanceof AggregateError ? String(error).replace(/\\n$/, \"\").replace(/^/gm, \"  \") : String(error).replace(/^/gm, \"    \").substring(2)).join(\"\\n\")}\n`;\n    return message;\n  }\n}\nvar aggregate_error_default = AggregateError;\n//# sourceMappingURL=aggregate-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYWdncmVnYXRlLWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0ksbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyxtQkFBTyxDQUFDLHlGQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2FnZ3JlZ2F0ZS1lcnJvci5qcz8zYzlmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IGFnZ3JlZ2F0ZV9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfYmFzZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vYmFzZS1lcnJvclwiKSk7XG5jbGFzcyBBZ2dyZWdhdGVFcnJvciBleHRlbmRzIGltcG9ydF9iYXNlX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihlcnJvcnMpIHtcbiAgICBzdXBlcigpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJlcnJvcnNcIik7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy5uYW1lID0gXCJBZ2dyZWdhdGVFcnJvclwiO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgQWdncmVnYXRlRXJyb3Igb2Y6XG4ke3RoaXMuZXJyb3JzLm1hcCgoZXJyb3IpID0+IGVycm9yID09PSB0aGlzID8gXCJbQ2lyY3VsYXIgQWdncmVnYXRlRXJyb3JdXCIgOiBlcnJvciBpbnN0YW5jZW9mIEFnZ3JlZ2F0ZUVycm9yID8gU3RyaW5nKGVycm9yKS5yZXBsYWNlKC9cXG4kLywgXCJcIikucmVwbGFjZSgvXi9nbSwgXCIgIFwiKSA6IFN0cmluZyhlcnJvcikucmVwbGFjZSgvXi9nbSwgXCIgICAgXCIpLnN1YnN0cmluZygyKSkuam9pbihcIlxcblwiKX1cbmA7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbn1cbnZhciBhZ2dyZWdhdGVfZXJyb3JfZGVmYXVsdCA9IEFnZ3JlZ2F0ZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWdncmVnYXRlLWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/aggregate-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/association-error.js":
/*!*****************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/association-error.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => association_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/base-error.js\"));\nclass AssociationError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeAssociationError\";\n  }\n}\nvar association_error_default = AssociationError;\n//# sourceMappingURL=association-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYXNzb2NpYXRpb24tZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUMsbUJBQU8sQ0FBQyx5RkFBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9hc3NvY2lhdGlvbi1lcnJvci5qcz82Y2Y4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBhc3NvY2lhdGlvbl9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfYmFzZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vYmFzZS1lcnJvclwiKSk7XG5jbGFzcyBBc3NvY2lhdGlvbkVycm9yIGV4dGVuZHMgaW1wb3J0X2Jhc2VfZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZUFzc29jaWF0aW9uRXJyb3JcIjtcbiAgfVxufVxudmFyIGFzc29jaWF0aW9uX2Vycm9yX2RlZmF1bHQgPSBBc3NvY2lhdGlvbkVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzb2NpYXRpb24tZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/association-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/base-error.js":
/*!**********************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/base-error.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("var __defProp = Object.defineProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  default: () => base_error_default\n});\nclass BaseError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeBaseError\";\n  }\n}\nvar base_error_default = BaseError;\n//# sourceMappingURL=base-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYmFzZS1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2Jhc2UtZXJyb3IuanM/N2NjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IGJhc2VfZXJyb3JfZGVmYXVsdFxufSk7XG5jbGFzcyBCYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZUJhc2VFcnJvclwiO1xuICB9XG59XG52YXIgYmFzZV9lcnJvcl9kZWZhdWx0ID0gQmFzZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/base-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/bulk-record-error.js":
/*!*****************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/bulk-record-error.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => bulk_record_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/base-error.js\"));\nclass BulkRecordError extends import_base_error.default {\n  constructor(error, record) {\n    super(error.message);\n    __publicField(this, \"errors\");\n    __publicField(this, \"record\");\n    this.name = \"SequelizeBulkRecordError\";\n    this.errors = error;\n    this.record = record;\n  }\n}\nvar bulk_record_error_default = BulkRecordError;\n//# sourceMappingURL=bulk-record-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYnVsay1yZWNvcmQtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DLG1CQUFPLENBQUMseUZBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9idWxrLXJlY29yZC1lcnJvci5qcz80OWU4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IGJ1bGtfcmVjb3JkX2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9iYXNlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9iYXNlLWVycm9yXCIpKTtcbmNsYXNzIEJ1bGtSZWNvcmRFcnJvciBleHRlbmRzIGltcG9ydF9iYXNlX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihlcnJvciwgcmVjb3JkKSB7XG4gICAgc3VwZXIoZXJyb3IubWVzc2FnZSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImVycm9yc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVjb3JkXCIpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplQnVsa1JlY29yZEVycm9yXCI7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcjtcbiAgICB0aGlzLnJlY29yZCA9IHJlY29yZDtcbiAgfVxufVxudmFyIGJ1bGtfcmVjb3JkX2Vycm9yX2RlZmF1bHQgPSBCdWxrUmVjb3JkRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWxrLXJlY29yZC1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/bulk-record-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/connection-error.js":
/*!****************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/connection-error.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => connection_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/base-error.js\"));\nclass ConnectionError extends import_base_error.default {\n  constructor(parent) {\n    super(parent ? parent.message : \"\");\n    __publicField(this, \"parent\");\n    __publicField(this, \"original\");\n    this.name = \"SequelizeConnectionError\";\n    this.parent = parent;\n    this.original = parent;\n  }\n}\nvar connection_error_default = ConnectionError;\n//# sourceMappingURL=connection-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUMsbUJBQU8sQ0FBQyx5RkFBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2Nvbm5lY3Rpb24tZXJyb3IuanM/NGJhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBjb25uZWN0aW9uX2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9iYXNlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9iYXNlLWVycm9yXCIpKTtcbmNsYXNzIENvbm5lY3Rpb25FcnJvciBleHRlbmRzIGltcG9ydF9iYXNlX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcihwYXJlbnQgPyBwYXJlbnQubWVzc2FnZSA6IFwiXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwYXJlbnRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9yaWdpbmFsXCIpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplQ29ubmVjdGlvbkVycm9yXCI7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5vcmlnaW5hbCA9IHBhcmVudDtcbiAgfVxufVxudmFyIGNvbm5lY3Rpb25fZXJyb3JfZGVmYXVsdCA9IENvbm5lY3Rpb25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpb24tZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/connection-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/connection/access-denied-error.js":
/*!******************************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/connection/access-denied-error.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => access_denied_error_default\n});\nvar import_connection_error = __toModule(__webpack_require__(/*! ../connection-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/connection-error.js\"));\nclass AccessDeniedError extends import_connection_error.default {\n  constructor(parent) {\n    super(parent);\n    this.name = \"SequelizeAccessDeniedError\";\n  }\n}\nvar access_denied_error_default = AccessDeniedError;\n//# sourceMappingURL=access-denied-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9hY2Nlc3MtZGVuaWVkLWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUNBQXlDLG1CQUFPLENBQUMsc0dBQXFCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2Nvbm5lY3Rpb24vYWNjZXNzLWRlbmllZC1lcnJvci5qcz83NmQ1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBhY2Nlc3NfZGVuaWVkX2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9jb25uZWN0aW9uX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi4vY29ubmVjdGlvbi1lcnJvclwiKSk7XG5jbGFzcyBBY2Nlc3NEZW5pZWRFcnJvciBleHRlbmRzIGltcG9ydF9jb25uZWN0aW9uX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcihwYXJlbnQpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplQWNjZXNzRGVuaWVkRXJyb3JcIjtcbiAgfVxufVxudmFyIGFjY2Vzc19kZW5pZWRfZXJyb3JfZGVmYXVsdCA9IEFjY2Vzc0RlbmllZEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjZXNzLWRlbmllZC1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/connection/access-denied-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js":
/*!*******************************************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => connection_acquire_timeout_error_default\n});\nvar import_connection_error = __toModule(__webpack_require__(/*! ../connection-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/connection-error.js\"));\nclass ConnectionAcquireTimeoutError extends import_connection_error.default {\n  constructor(parent) {\n    super(parent);\n    this.name = \"SequelizeConnectionAcquireTimeoutError\";\n  }\n}\nvar connection_acquire_timeout_error_default = ConnectionAcquireTimeoutError;\n//# sourceMappingURL=connection-acquire-timeout-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9jb25uZWN0aW9uLWFjcXVpcmUtdGltZW91dC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHlDQUF5QyxtQkFBTyxDQUFDLHNHQUFxQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9jb25uZWN0aW9uL2Nvbm5lY3Rpb24tYWNxdWlyZS10aW1lb3V0LWVycm9yLmpzPzlmMzAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IGNvbm5lY3Rpb25fYWNxdWlyZV90aW1lb3V0X2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9jb25uZWN0aW9uX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi4vY29ubmVjdGlvbi1lcnJvclwiKSk7XG5jbGFzcyBDb25uZWN0aW9uQWNxdWlyZVRpbWVvdXRFcnJvciBleHRlbmRzIGltcG9ydF9jb25uZWN0aW9uX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcihwYXJlbnQpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplQ29ubmVjdGlvbkFjcXVpcmVUaW1lb3V0RXJyb3JcIjtcbiAgfVxufVxudmFyIGNvbm5lY3Rpb25fYWNxdWlyZV90aW1lb3V0X2Vycm9yX2RlZmF1bHQgPSBDb25uZWN0aW9uQWNxdWlyZVRpbWVvdXRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpb24tYWNxdWlyZS10aW1lb3V0LWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/connection/connection-refused-error.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/connection/connection-refused-error.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => connection_refused_error_default\n});\nvar import_connection_error = __toModule(__webpack_require__(/*! ../connection-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/connection-error.js\"));\nclass ConnectionRefusedError extends import_connection_error.default {\n  constructor(parent) {\n    super(parent);\n    this.name = \"SequelizeConnectionRefusedError\";\n  }\n}\nvar connection_refused_error_default = ConnectionRefusedError;\n//# sourceMappingURL=connection-refused-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9jb25uZWN0aW9uLXJlZnVzZWQtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5Q0FBeUMsbUJBQU8sQ0FBQyxzR0FBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9jb25uZWN0aW9uLXJlZnVzZWQtZXJyb3IuanM/N2Q5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gY29ubmVjdGlvbl9yZWZ1c2VkX2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9jb25uZWN0aW9uX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi4vY29ubmVjdGlvbi1lcnJvclwiKSk7XG5jbGFzcyBDb25uZWN0aW9uUmVmdXNlZEVycm9yIGV4dGVuZHMgaW1wb3J0X2Nvbm5lY3Rpb25fZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKHBhcmVudCk7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVDb25uZWN0aW9uUmVmdXNlZEVycm9yXCI7XG4gIH1cbn1cbnZhciBjb25uZWN0aW9uX3JlZnVzZWRfZXJyb3JfZGVmYXVsdCA9IENvbm5lY3Rpb25SZWZ1c2VkRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aW9uLXJlZnVzZWQtZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/connection/connection-refused-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => connection_timed_out_error_default\n});\nvar import_connection_error = __toModule(__webpack_require__(/*! ../connection-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/connection-error.js\"));\nclass ConnectionTimedOutError extends import_connection_error.default {\n  constructor(parent) {\n    super(parent);\n    this.name = \"SequelizeConnectionTimedOutError\";\n  }\n}\nvar connection_timed_out_error_default = ConnectionTimedOutError;\n//# sourceMappingURL=connection-timed-out-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9jb25uZWN0aW9uLXRpbWVkLW91dC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHlDQUF5QyxtQkFBTyxDQUFDLHNHQUFxQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9jb25uZWN0aW9uL2Nvbm5lY3Rpb24tdGltZWQtb3V0LWVycm9yLmpzPzViNTQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IGNvbm5lY3Rpb25fdGltZWRfb3V0X2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9jb25uZWN0aW9uX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi4vY29ubmVjdGlvbi1lcnJvclwiKSk7XG5jbGFzcyBDb25uZWN0aW9uVGltZWRPdXRFcnJvciBleHRlbmRzIGltcG9ydF9jb25uZWN0aW9uX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcihwYXJlbnQpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplQ29ubmVjdGlvblRpbWVkT3V0RXJyb3JcIjtcbiAgfVxufVxudmFyIGNvbm5lY3Rpb25fdGltZWRfb3V0X2Vycm9yX2RlZmF1bHQgPSBDb25uZWN0aW9uVGltZWRPdXRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpb24tdGltZWQtb3V0LWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/connection/host-not-found-error.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/connection/host-not-found-error.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => host_not_found_error_default\n});\nvar import_connection_error = __toModule(__webpack_require__(/*! ../connection-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/connection-error.js\"));\nclass HostNotFoundError extends import_connection_error.default {\n  constructor(parent) {\n    super(parent);\n    this.name = \"SequelizeHostNotFoundError\";\n  }\n}\nvar host_not_found_error_default = HostNotFoundError;\n//# sourceMappingURL=host-not-found-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9ob3N0LW5vdC1mb3VuZC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHlDQUF5QyxtQkFBTyxDQUFDLHNHQUFxQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9jb25uZWN0aW9uL2hvc3Qtbm90LWZvdW5kLWVycm9yLmpzP2JmNTUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IGhvc3Rfbm90X2ZvdW5kX2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9jb25uZWN0aW9uX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi4vY29ubmVjdGlvbi1lcnJvclwiKSk7XG5jbGFzcyBIb3N0Tm90Rm91bmRFcnJvciBleHRlbmRzIGltcG9ydF9jb25uZWN0aW9uX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcihwYXJlbnQpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplSG9zdE5vdEZvdW5kRXJyb3JcIjtcbiAgfVxufVxudmFyIGhvc3Rfbm90X2ZvdW5kX2Vycm9yX2RlZmF1bHQgPSBIb3N0Tm90Rm91bmRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvc3Qtbm90LWZvdW5kLWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/connection/host-not-found-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => host_not_reachable_error_default\n});\nvar import_connection_error = __toModule(__webpack_require__(/*! ../connection-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/connection-error.js\"));\nclass HostNotReachableError extends import_connection_error.default {\n  constructor(parent) {\n    super(parent);\n    this.name = \"SequelizeHostNotReachableError\";\n  }\n}\nvar host_not_reachable_error_default = HostNotReachableError;\n//# sourceMappingURL=host-not-reachable-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9ob3N0LW5vdC1yZWFjaGFibGUtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5Q0FBeUMsbUJBQU8sQ0FBQyxzR0FBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9ob3N0LW5vdC1yZWFjaGFibGUtZXJyb3IuanM/NGEzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gaG9zdF9ub3RfcmVhY2hhYmxlX2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9jb25uZWN0aW9uX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi4vY29ubmVjdGlvbi1lcnJvclwiKSk7XG5jbGFzcyBIb3N0Tm90UmVhY2hhYmxlRXJyb3IgZXh0ZW5kcyBpbXBvcnRfY29ubmVjdGlvbl9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIocGFyZW50KTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZUhvc3ROb3RSZWFjaGFibGVFcnJvclwiO1xuICB9XG59XG52YXIgaG9zdF9ub3RfcmVhY2hhYmxlX2Vycm9yX2RlZmF1bHQgPSBIb3N0Tm90UmVhY2hhYmxlRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob3N0LW5vdC1yZWFjaGFibGUtZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/connection/invalid-connection-error.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/connection/invalid-connection-error.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => invalid_connection_error_default\n});\nvar import_connection_error = __toModule(__webpack_require__(/*! ../connection-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/connection-error.js\"));\nclass InvalidConnectionError extends import_connection_error.default {\n  constructor(parent) {\n    super(parent);\n    this.name = \"SequelizeInvalidConnectionError\";\n  }\n}\nvar invalid_connection_error_default = InvalidConnectionError;\n//# sourceMappingURL=invalid-connection-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9pbnZhbGlkLWNvbm5lY3Rpb24tZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5Q0FBeUMsbUJBQU8sQ0FBQyxzR0FBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9pbnZhbGlkLWNvbm5lY3Rpb24tZXJyb3IuanM/ZDg2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gaW52YWxpZF9jb25uZWN0aW9uX2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9jb25uZWN0aW9uX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi4vY29ubmVjdGlvbi1lcnJvclwiKSk7XG5jbGFzcyBJbnZhbGlkQ29ubmVjdGlvbkVycm9yIGV4dGVuZHMgaW1wb3J0X2Nvbm5lY3Rpb25fZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKHBhcmVudCk7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVJbnZhbGlkQ29ubmVjdGlvbkVycm9yXCI7XG4gIH1cbn1cbnZhciBpbnZhbGlkX2Nvbm5lY3Rpb25fZXJyb3JfZGVmYXVsdCA9IEludmFsaWRDb25uZWN0aW9uRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnZhbGlkLWNvbm5lY3Rpb24tZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/connection/invalid-connection-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/database-error.js":
/*!**************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/database-error.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => database_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/base-error.js\"));\nclass DatabaseError extends import_base_error.default {\n  constructor(parent, options = {}) {\n    super(parent.message);\n    __publicField(this, \"parent\");\n    __publicField(this, \"original\");\n    __publicField(this, \"sql\");\n    __publicField(this, \"parameters\");\n    var _a;\n    this.name = \"SequelizeDatabaseError\";\n    this.parent = parent;\n    this.original = parent;\n    this.sql = parent.sql;\n    this.parameters = (_a = parent.parameters) != null ? _a : {};\n    if (options.stack) {\n      this.stack = options.stack;\n    }\n  }\n}\nvar database_error_default = DatabaseError;\n//# sourceMappingURL=database-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DLG1CQUFPLENBQUMseUZBQWM7QUFDekQ7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9kYXRhYmFzZS1lcnJvci5qcz8zMGYxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IGRhdGFiYXNlX2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9iYXNlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9iYXNlLWVycm9yXCIpKTtcbmNsYXNzIERhdGFiYXNlRXJyb3IgZXh0ZW5kcyBpbXBvcnRfYmFzZV9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IocGFyZW50LCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihwYXJlbnQubWVzc2FnZSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBhcmVudFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib3JpZ2luYWxcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNxbFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicGFyYW1ldGVyc1wiKTtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVEYXRhYmFzZUVycm9yXCI7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5vcmlnaW5hbCA9IHBhcmVudDtcbiAgICB0aGlzLnNxbCA9IHBhcmVudC5zcWw7XG4gICAgdGhpcy5wYXJhbWV0ZXJzID0gKF9hID0gcGFyZW50LnBhcmFtZXRlcnMpICE9IG51bGwgPyBfYSA6IHt9O1xuICAgIGlmIChvcHRpb25zLnN0YWNrKSB7XG4gICAgICB0aGlzLnN0YWNrID0gb3B0aW9ucy5zdGFjaztcbiAgICB9XG4gIH1cbn1cbnZhciBkYXRhYmFzZV9lcnJvcl9kZWZhdWx0ID0gRGF0YWJhc2VFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGFiYXNlLWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/database-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => exclusion_constraint_error_default\n});\nvar import_database_error = __toModule(__webpack_require__(/*! ../database-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/database-error.js\"));\nclass ExclusionConstraintError extends import_database_error.default {\n  constructor(options) {\n    options = options || {};\n    options.parent = options.parent || { sql: \"\", name: \"\", message: \"\" };\n    super(options.parent, { stack: options.stack });\n    __publicField(this, \"constraint\");\n    __publicField(this, \"fields\");\n    __publicField(this, \"table\");\n    this.name = \"SequelizeExclusionConstraintError\";\n    this.message = options.message || options.parent.message || \"\";\n    this.constraint = options.constraint;\n    this.fields = options.fields;\n    this.table = options.table;\n  }\n}\nvar exclusion_constraint_error_default = ExclusionConstraintError;\n//# sourceMappingURL=exclusion-constraint-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UvZXhjbHVzaW9uLWNvbnN0cmFpbnQtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUNBQXVDLG1CQUFPLENBQUMsa0dBQW1CO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UvZXhjbHVzaW9uLWNvbnN0cmFpbnQtZXJyb3IuanM/NTNhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBleGNsdXNpb25fY29uc3RyYWludF9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfZGF0YWJhc2VfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuLi9kYXRhYmFzZS1lcnJvclwiKSk7XG5jbGFzcyBFeGNsdXNpb25Db25zdHJhaW50RXJyb3IgZXh0ZW5kcyBpbXBvcnRfZGF0YWJhc2VfZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnBhcmVudCA9IG9wdGlvbnMucGFyZW50IHx8IHsgc3FsOiBcIlwiLCBuYW1lOiBcIlwiLCBtZXNzYWdlOiBcIlwiIH07XG4gICAgc3VwZXIob3B0aW9ucy5wYXJlbnQsIHsgc3RhY2s6IG9wdGlvbnMuc3RhY2sgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbnN0cmFpbnRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZpZWxkc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidGFibGVcIik7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVFeGNsdXNpb25Db25zdHJhaW50RXJyb3JcIjtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UgfHwgb3B0aW9ucy5wYXJlbnQubWVzc2FnZSB8fCBcIlwiO1xuICAgIHRoaXMuY29uc3RyYWludCA9IG9wdGlvbnMuY29uc3RyYWludDtcbiAgICB0aGlzLmZpZWxkcyA9IG9wdGlvbnMuZmllbGRzO1xuICAgIHRoaXMudGFibGUgPSBvcHRpb25zLnRhYmxlO1xuICB9XG59XG52YXIgZXhjbHVzaW9uX2NvbnN0cmFpbnRfZXJyb3JfZGVmYXVsdCA9IEV4Y2x1c2lvbkNvbnN0cmFpbnRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4Y2x1c2lvbi1jb25zdHJhaW50LWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  RelationshipType: () => RelationshipType,\n  default: () => foreign_key_constraint_error_default\n});\nvar import_database_error = __toModule(__webpack_require__(/*! ../database-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/database-error.js\"));\nvar RelationshipType = /* @__PURE__ */ ((RelationshipType2) => {\n  RelationshipType2[\"parent\"] = \"parent\";\n  RelationshipType2[\"child\"] = \"child\";\n  return RelationshipType2;\n})(RelationshipType || {});\nclass ForeignKeyConstraintError extends import_database_error.default {\n  constructor(options) {\n    options = options || {};\n    options.parent = options.parent || { sql: \"\", name: \"\", message: \"\" };\n    super(options.parent, { stack: options.stack });\n    __publicField(this, \"table\");\n    __publicField(this, \"fields\");\n    __publicField(this, \"value\");\n    __publicField(this, \"index\");\n    __publicField(this, \"reltype\");\n    this.name = \"SequelizeForeignKeyConstraintError\";\n    this.message = options.message || options.parent.message || \"Database Error\";\n    this.fields = options.fields;\n    this.table = options.table;\n    this.value = options.value;\n    this.index = options.index;\n    this.reltype = options.reltype;\n  }\n}\nvar foreign_key_constraint_error_default = ForeignKeyConstraintError;\n//# sourceMappingURL=foreign-key-constraint-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UvZm9yZWlnbi1rZXktY29uc3RyYWludC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVDQUF1QyxtQkFBTyxDQUFDLGtHQUFtQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9kYXRhYmFzZS9mb3JlaWduLWtleS1jb25zdHJhaW50LWVycm9yLmpzP2JjMTkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgUmVsYXRpb25zaGlwVHlwZTogKCkgPT4gUmVsYXRpb25zaGlwVHlwZSxcbiAgZGVmYXVsdDogKCkgPT4gZm9yZWlnbl9rZXlfY29uc3RyYWludF9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfZGF0YWJhc2VfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuLi9kYXRhYmFzZS1lcnJvclwiKSk7XG52YXIgUmVsYXRpb25zaGlwVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFJlbGF0aW9uc2hpcFR5cGUyKSA9PiB7XG4gIFJlbGF0aW9uc2hpcFR5cGUyW1wicGFyZW50XCJdID0gXCJwYXJlbnRcIjtcbiAgUmVsYXRpb25zaGlwVHlwZTJbXCJjaGlsZFwiXSA9IFwiY2hpbGRcIjtcbiAgcmV0dXJuIFJlbGF0aW9uc2hpcFR5cGUyO1xufSkoUmVsYXRpb25zaGlwVHlwZSB8fCB7fSk7XG5jbGFzcyBGb3JlaWduS2V5Q29uc3RyYWludEVycm9yIGV4dGVuZHMgaW1wb3J0X2RhdGFiYXNlX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudCB8fCB7IHNxbDogXCJcIiwgbmFtZTogXCJcIiwgbWVzc2FnZTogXCJcIiB9O1xuICAgIHN1cGVyKG9wdGlvbnMucGFyZW50LCB7IHN0YWNrOiBvcHRpb25zLnN0YWNrIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0YWJsZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZmllbGRzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ2YWx1ZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaW5kZXhcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlbHR5cGVcIik7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVGb3JlaWduS2V5Q29uc3RyYWludEVycm9yXCI7XG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlIHx8IG9wdGlvbnMucGFyZW50Lm1lc3NhZ2UgfHwgXCJEYXRhYmFzZSBFcnJvclwiO1xuICAgIHRoaXMuZmllbGRzID0gb3B0aW9ucy5maWVsZHM7XG4gICAgdGhpcy50YWJsZSA9IG9wdGlvbnMudGFibGU7XG4gICAgdGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG4gICAgdGhpcy5yZWx0eXBlID0gb3B0aW9ucy5yZWx0eXBlO1xuICB9XG59XG52YXIgZm9yZWlnbl9rZXlfY29uc3RyYWludF9lcnJvcl9kZWZhdWx0ID0gRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcmVpZ24ta2V5LWNvbnN0cmFpbnQtZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/database/timeout-error.js":
/*!**********************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/database/timeout-error.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => timeout_error_default\n});\nvar import_database_error = __toModule(__webpack_require__(/*! ../database-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/database-error.js\"));\nclass TimeoutError extends import_database_error.default {\n  constructor(parent, options = {}) {\n    super(parent, options);\n    this.name = \"SequelizeTimeoutError\";\n  }\n}\nvar timeout_error_default = TimeoutError;\n//# sourceMappingURL=timeout-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UvdGltZW91dC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVDQUF1QyxtQkFBTyxDQUFDLGtHQUFtQjtBQUNsRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2RhdGFiYXNlL3RpbWVvdXQtZXJyb3IuanM/YmQ2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gdGltZW91dF9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfZGF0YWJhc2VfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuLi9kYXRhYmFzZS1lcnJvclwiKSk7XG5jbGFzcyBUaW1lb3V0RXJyb3IgZXh0ZW5kcyBpbXBvcnRfZGF0YWJhc2VfZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIocGFyZW50LCBvcHRpb25zKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZVRpbWVvdXRFcnJvclwiO1xuICB9XG59XG52YXIgdGltZW91dF9lcnJvcl9kZWZhdWx0ID0gVGltZW91dEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZW91dC1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/database/timeout-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/database/unknown-constraint-error.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/database/unknown-constraint-error.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => unknown_constraint_error_default\n});\nvar import_database_error = __toModule(__webpack_require__(/*! ../database-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/database-error.js\"));\nclass UnknownConstraintError extends import_database_error.default {\n  constructor(options) {\n    options = options || {};\n    options.parent = options.parent || { sql: \"\", name: \"\", message: \"\" };\n    super(options.parent, { stack: options.stack });\n    __publicField(this, \"constraint\");\n    __publicField(this, \"fields\");\n    __publicField(this, \"table\");\n    this.name = \"SequelizeUnknownConstraintError\";\n    this.message = options.message || \"The specified constraint does not exist\";\n    this.constraint = options.constraint;\n    this.fields = options.fields;\n    this.table = options.table;\n  }\n}\nvar unknown_constraint_error_default = UnknownConstraintError;\n//# sourceMappingURL=unknown-constraint-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UvdW5rbm93bi1jb25zdHJhaW50LWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0ksbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVDQUF1QyxtQkFBTyxDQUFDLGtHQUFtQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2RhdGFiYXNlL3Vua25vd24tY29uc3RyYWludC1lcnJvci5qcz9jNDNiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IHVua25vd25fY29uc3RyYWludF9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfZGF0YWJhc2VfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuLi9kYXRhYmFzZS1lcnJvclwiKSk7XG5jbGFzcyBVbmtub3duQ29uc3RyYWludEVycm9yIGV4dGVuZHMgaW1wb3J0X2RhdGFiYXNlX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudCB8fCB7IHNxbDogXCJcIiwgbmFtZTogXCJcIiwgbWVzc2FnZTogXCJcIiB9O1xuICAgIHN1cGVyKG9wdGlvbnMucGFyZW50LCB7IHN0YWNrOiBvcHRpb25zLnN0YWNrIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjb25zdHJhaW50XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmaWVsZHNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRhYmxlXCIpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplVW5rbm93bkNvbnN0cmFpbnRFcnJvclwiO1xuICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSB8fCBcIlRoZSBzcGVjaWZpZWQgY29uc3RyYWludCBkb2VzIG5vdCBleGlzdFwiO1xuICAgIHRoaXMuY29uc3RyYWludCA9IG9wdGlvbnMuY29uc3RyYWludDtcbiAgICB0aGlzLmZpZWxkcyA9IG9wdGlvbnMuZmllbGRzO1xuICAgIHRoaXMudGFibGUgPSBvcHRpb25zLnRhYmxlO1xuICB9XG59XG52YXIgdW5rbm93bl9jb25zdHJhaW50X2Vycm9yX2RlZmF1bHQgPSBVbmtub3duQ29uc3RyYWludEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5rbm93bi1jb25zdHJhaW50LWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/database/unknown-constraint-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/eager-loading-error.js":
/*!*******************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/eager-loading-error.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => eager_loading_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/base-error.js\"));\nclass EagerLoadingError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeEagerLoadingError\";\n  }\n}\nvar eager_loading_error_default = EagerLoadingError;\n//# sourceMappingURL=eager-loading-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZWFnZXItbG9hZGluZy1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyxtQkFBTyxDQUFDLHlGQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2VhZ2VyLWxvYWRpbmctZXJyb3IuanM/Yjg1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gZWFnZXJfbG9hZGluZ19lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfYmFzZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vYmFzZS1lcnJvclwiKSk7XG5jbGFzcyBFYWdlckxvYWRpbmdFcnJvciBleHRlbmRzIGltcG9ydF9iYXNlX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVFYWdlckxvYWRpbmdFcnJvclwiO1xuICB9XG59XG52YXIgZWFnZXJfbG9hZGluZ19lcnJvcl9kZWZhdWx0ID0gRWFnZXJMb2FkaW5nRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lYWdlci1sb2FkaW5nLWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/eager-loading-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/empty-result-error.js":
/*!******************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/empty-result-error.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => empty_result_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/base-error.js\"));\nclass EmptyResultError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeEmptyResultError\";\n  }\n}\nvar empty_result_error_default = EmptyResultError;\n//# sourceMappingURL=empty-result-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZW1wdHktcmVzdWx0LWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DLG1CQUFPLENBQUMseUZBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZW1wdHktcmVzdWx0LWVycm9yLmpzP2FhYzAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IGVtcHR5X3Jlc3VsdF9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfYmFzZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vYmFzZS1lcnJvclwiKSk7XG5jbGFzcyBFbXB0eVJlc3VsdEVycm9yIGV4dGVuZHMgaW1wb3J0X2Jhc2VfZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZUVtcHR5UmVzdWx0RXJyb3JcIjtcbiAgfVxufVxudmFyIGVtcHR5X3Jlc3VsdF9lcnJvcl9kZWZhdWx0ID0gRW1wdHlSZXN1bHRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVtcHR5LXJlc3VsdC1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/empty-result-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/index.js":
/*!*****************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  AccessDeniedError: () => import_access_denied_error.default,\n  AggregateError: () => import_aggregate_error.default,\n  AssociationError: () => import_association_error.default,\n  AsyncQueueError: () => import_async_queue.AsyncQueueError,\n  BaseError: () => import_base_error.default,\n  BulkRecordError: () => import_bulk_record_error.default,\n  ConnectionAcquireTimeoutError: () => import_connection_acquire_timeout_error.default,\n  ConnectionError: () => import_connection_error.default,\n  ConnectionRefusedError: () => import_connection_refused_error.default,\n  ConnectionTimedOutError: () => import_connection_timed_out_error.default,\n  DatabaseError: () => import_database_error.default,\n  EagerLoadingError: () => import_eager_loading_error.default,\n  EmptyResultError: () => import_empty_result_error.default,\n  ExclusionConstraintError: () => import_exclusion_constraint_error.default,\n  ForeignKeyConstraintError: () => import_foreign_key_constraint_error.default,\n  HostNotFoundError: () => import_host_not_found_error.default,\n  HostNotReachableError: () => import_host_not_reachable_error.default,\n  InstanceError: () => import_instance_error.default,\n  InvalidConnectionError: () => import_invalid_connection_error.default,\n  OptimisticLockError: () => import_optimistic_lock_error.default,\n  QueryError: () => import_query_error.default,\n  SequelizeScopeError: () => import_sequelize_scope_error.default,\n  TimeoutError: () => import_timeout_error.default,\n  UniqueConstraintError: () => import_unique_constraint_error.default,\n  UnknownConstraintError: () => import_unknown_constraint_error.default,\n  ValidationError: () => import_validation_error.default,\n  ValidationErrorItem: () => import_validation_error.ValidationErrorItem,\n  ValidationErrorItemOrigin: () => import_validation_error.ValidationErrorItemOrigin,\n  ValidationErrorItemType: () => import_validation_error.ValidationErrorItemType\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/base-error.js\"));\nvar import_database_error = __toModule(__webpack_require__(/*! ./database-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/database-error.js\"));\nvar import_aggregate_error = __toModule(__webpack_require__(/*! ./aggregate-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/aggregate-error.js\"));\nvar import_association_error = __toModule(__webpack_require__(/*! ./association-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/association-error.js\"));\nvar import_bulk_record_error = __toModule(__webpack_require__(/*! ./bulk-record-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/bulk-record-error.js\"));\nvar import_connection_error = __toModule(__webpack_require__(/*! ./connection-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/connection-error.js\"));\nvar import_eager_loading_error = __toModule(__webpack_require__(/*! ./eager-loading-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/eager-loading-error.js\"));\nvar import_empty_result_error = __toModule(__webpack_require__(/*! ./empty-result-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/empty-result-error.js\"));\nvar import_instance_error = __toModule(__webpack_require__(/*! ./instance-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/instance-error.js\"));\nvar import_optimistic_lock_error = __toModule(__webpack_require__(/*! ./optimistic-lock-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/optimistic-lock-error.js\"));\nvar import_query_error = __toModule(__webpack_require__(/*! ./query-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/query-error.js\"));\nvar import_sequelize_scope_error = __toModule(__webpack_require__(/*! ./sequelize-scope-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/sequelize-scope-error.js\"));\nvar import_validation_error = __toModule(__webpack_require__(/*! ./validation-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/validation-error.js\"));\nvar import_access_denied_error = __toModule(__webpack_require__(/*! ./connection/access-denied-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/connection/access-denied-error.js\"));\nvar import_connection_acquire_timeout_error = __toModule(__webpack_require__(/*! ./connection/connection-acquire-timeout-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js\"));\nvar import_connection_refused_error = __toModule(__webpack_require__(/*! ./connection/connection-refused-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/connection/connection-refused-error.js\"));\nvar import_connection_timed_out_error = __toModule(__webpack_require__(/*! ./connection/connection-timed-out-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js\"));\nvar import_host_not_found_error = __toModule(__webpack_require__(/*! ./connection/host-not-found-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/connection/host-not-found-error.js\"));\nvar import_host_not_reachable_error = __toModule(__webpack_require__(/*! ./connection/host-not-reachable-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js\"));\nvar import_invalid_connection_error = __toModule(__webpack_require__(/*! ./connection/invalid-connection-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/connection/invalid-connection-error.js\"));\nvar import_exclusion_constraint_error = __toModule(__webpack_require__(/*! ./database/exclusion-constraint-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js\"));\nvar import_foreign_key_constraint_error = __toModule(__webpack_require__(/*! ./database/foreign-key-constraint-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js\"));\nvar import_timeout_error = __toModule(__webpack_require__(/*! ./database/timeout-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/database/timeout-error.js\"));\nvar import_unknown_constraint_error = __toModule(__webpack_require__(/*! ./database/unknown-constraint-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/database/unknown-constraint-error.js\"));\nvar import_unique_constraint_error = __toModule(__webpack_require__(/*! ./validation/unique-constraint-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/validation/unique-constraint-error.js\"));\nvar import_async_queue = __toModule(__webpack_require__(/*! ../dialects/mssql/async-queue */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mssql/async-queue.js\"));\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyxtQkFBTyxDQUFDLHlGQUFjO0FBQ3pELHVDQUF1QyxtQkFBTyxDQUFDLGlHQUFrQjtBQUNqRSx3Q0FBd0MsbUJBQU8sQ0FBQyxtR0FBbUI7QUFDbkUsMENBQTBDLG1CQUFPLENBQUMsdUdBQXFCO0FBQ3ZFLDBDQUEwQyxtQkFBTyxDQUFDLHVHQUFxQjtBQUN2RSx5Q0FBeUMsbUJBQU8sQ0FBQyxxR0FBb0I7QUFDckUsNENBQTRDLG1CQUFPLENBQUMsMkdBQXVCO0FBQzNFLDJDQUEyQyxtQkFBTyxDQUFDLHlHQUFzQjtBQUN6RSx1Q0FBdUMsbUJBQU8sQ0FBQyxpR0FBa0I7QUFDakUsOENBQThDLG1CQUFPLENBQUMsK0dBQXlCO0FBQy9FLG9DQUFvQyxtQkFBTyxDQUFDLDJGQUFlO0FBQzNELDhDQUE4QyxtQkFBTyxDQUFDLCtHQUF5QjtBQUMvRSx5Q0FBeUMsbUJBQU8sQ0FBQyxxR0FBb0I7QUFDckUsNENBQTRDLG1CQUFPLENBQUMsaUlBQWtDO0FBQ3RGLHlEQUF5RCxtQkFBTyxDQUFDLDJKQUErQztBQUNoSCxpREFBaUQsbUJBQU8sQ0FBQywySUFBdUM7QUFDaEcsbURBQW1ELG1CQUFPLENBQUMsK0lBQXlDO0FBQ3BHLDZDQUE2QyxtQkFBTyxDQUFDLG1JQUFtQztBQUN4RixpREFBaUQsbUJBQU8sQ0FBQywySUFBdUM7QUFDaEcsaURBQWlELG1CQUFPLENBQUMsMklBQXVDO0FBQ2hHLG1EQUFtRCxtQkFBTyxDQUFDLDJJQUF1QztBQUNsRyxxREFBcUQsbUJBQU8sQ0FBQywrSUFBeUM7QUFDdEcsc0NBQXNDLG1CQUFPLENBQUMsaUhBQTBCO0FBQ3hFLGlEQUFpRCxtQkFBTyxDQUFDLHVJQUFxQztBQUM5RixnREFBZ0QsbUJBQU8sQ0FBQyx5SUFBc0M7QUFDOUYsb0NBQW9DLG1CQUFPLENBQUMsbUhBQStCO0FBQzNFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9pbmRleC5qcz8yODQ2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBBY2Nlc3NEZW5pZWRFcnJvcjogKCkgPT4gaW1wb3J0X2FjY2Vzc19kZW5pZWRfZXJyb3IuZGVmYXVsdCxcbiAgQWdncmVnYXRlRXJyb3I6ICgpID0+IGltcG9ydF9hZ2dyZWdhdGVfZXJyb3IuZGVmYXVsdCxcbiAgQXNzb2NpYXRpb25FcnJvcjogKCkgPT4gaW1wb3J0X2Fzc29jaWF0aW9uX2Vycm9yLmRlZmF1bHQsXG4gIEFzeW5jUXVldWVFcnJvcjogKCkgPT4gaW1wb3J0X2FzeW5jX3F1ZXVlLkFzeW5jUXVldWVFcnJvcixcbiAgQmFzZUVycm9yOiAoKSA9PiBpbXBvcnRfYmFzZV9lcnJvci5kZWZhdWx0LFxuICBCdWxrUmVjb3JkRXJyb3I6ICgpID0+IGltcG9ydF9idWxrX3JlY29yZF9lcnJvci5kZWZhdWx0LFxuICBDb25uZWN0aW9uQWNxdWlyZVRpbWVvdXRFcnJvcjogKCkgPT4gaW1wb3J0X2Nvbm5lY3Rpb25fYWNxdWlyZV90aW1lb3V0X2Vycm9yLmRlZmF1bHQsXG4gIENvbm5lY3Rpb25FcnJvcjogKCkgPT4gaW1wb3J0X2Nvbm5lY3Rpb25fZXJyb3IuZGVmYXVsdCxcbiAgQ29ubmVjdGlvblJlZnVzZWRFcnJvcjogKCkgPT4gaW1wb3J0X2Nvbm5lY3Rpb25fcmVmdXNlZF9lcnJvci5kZWZhdWx0LFxuICBDb25uZWN0aW9uVGltZWRPdXRFcnJvcjogKCkgPT4gaW1wb3J0X2Nvbm5lY3Rpb25fdGltZWRfb3V0X2Vycm9yLmRlZmF1bHQsXG4gIERhdGFiYXNlRXJyb3I6ICgpID0+IGltcG9ydF9kYXRhYmFzZV9lcnJvci5kZWZhdWx0LFxuICBFYWdlckxvYWRpbmdFcnJvcjogKCkgPT4gaW1wb3J0X2VhZ2VyX2xvYWRpbmdfZXJyb3IuZGVmYXVsdCxcbiAgRW1wdHlSZXN1bHRFcnJvcjogKCkgPT4gaW1wb3J0X2VtcHR5X3Jlc3VsdF9lcnJvci5kZWZhdWx0LFxuICBFeGNsdXNpb25Db25zdHJhaW50RXJyb3I6ICgpID0+IGltcG9ydF9leGNsdXNpb25fY29uc3RyYWludF9lcnJvci5kZWZhdWx0LFxuICBGb3JlaWduS2V5Q29uc3RyYWludEVycm9yOiAoKSA9PiBpbXBvcnRfZm9yZWlnbl9rZXlfY29uc3RyYWludF9lcnJvci5kZWZhdWx0LFxuICBIb3N0Tm90Rm91bmRFcnJvcjogKCkgPT4gaW1wb3J0X2hvc3Rfbm90X2ZvdW5kX2Vycm9yLmRlZmF1bHQsXG4gIEhvc3ROb3RSZWFjaGFibGVFcnJvcjogKCkgPT4gaW1wb3J0X2hvc3Rfbm90X3JlYWNoYWJsZV9lcnJvci5kZWZhdWx0LFxuICBJbnN0YW5jZUVycm9yOiAoKSA9PiBpbXBvcnRfaW5zdGFuY2VfZXJyb3IuZGVmYXVsdCxcbiAgSW52YWxpZENvbm5lY3Rpb25FcnJvcjogKCkgPT4gaW1wb3J0X2ludmFsaWRfY29ubmVjdGlvbl9lcnJvci5kZWZhdWx0LFxuICBPcHRpbWlzdGljTG9ja0Vycm9yOiAoKSA9PiBpbXBvcnRfb3B0aW1pc3RpY19sb2NrX2Vycm9yLmRlZmF1bHQsXG4gIFF1ZXJ5RXJyb3I6ICgpID0+IGltcG9ydF9xdWVyeV9lcnJvci5kZWZhdWx0LFxuICBTZXF1ZWxpemVTY29wZUVycm9yOiAoKSA9PiBpbXBvcnRfc2VxdWVsaXplX3Njb3BlX2Vycm9yLmRlZmF1bHQsXG4gIFRpbWVvdXRFcnJvcjogKCkgPT4gaW1wb3J0X3RpbWVvdXRfZXJyb3IuZGVmYXVsdCxcbiAgVW5pcXVlQ29uc3RyYWludEVycm9yOiAoKSA9PiBpbXBvcnRfdW5pcXVlX2NvbnN0cmFpbnRfZXJyb3IuZGVmYXVsdCxcbiAgVW5rbm93bkNvbnN0cmFpbnRFcnJvcjogKCkgPT4gaW1wb3J0X3Vua25vd25fY29uc3RyYWludF9lcnJvci5kZWZhdWx0LFxuICBWYWxpZGF0aW9uRXJyb3I6ICgpID0+IGltcG9ydF92YWxpZGF0aW9uX2Vycm9yLmRlZmF1bHQsXG4gIFZhbGlkYXRpb25FcnJvckl0ZW06ICgpID0+IGltcG9ydF92YWxpZGF0aW9uX2Vycm9yLlZhbGlkYXRpb25FcnJvckl0ZW0sXG4gIFZhbGlkYXRpb25FcnJvckl0ZW1PcmlnaW46ICgpID0+IGltcG9ydF92YWxpZGF0aW9uX2Vycm9yLlZhbGlkYXRpb25FcnJvckl0ZW1PcmlnaW4sXG4gIFZhbGlkYXRpb25FcnJvckl0ZW1UeXBlOiAoKSA9PiBpbXBvcnRfdmFsaWRhdGlvbl9lcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtVHlwZVxufSk7XG52YXIgaW1wb3J0X2Jhc2VfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Jhc2UtZXJyb3JcIikpO1xudmFyIGltcG9ydF9kYXRhYmFzZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vZGF0YWJhc2UtZXJyb3JcIikpO1xudmFyIGltcG9ydF9hZ2dyZWdhdGVfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2FnZ3JlZ2F0ZS1lcnJvclwiKSk7XG52YXIgaW1wb3J0X2Fzc29jaWF0aW9uX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9hc3NvY2lhdGlvbi1lcnJvclwiKSk7XG52YXIgaW1wb3J0X2J1bGtfcmVjb3JkX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9idWxrLXJlY29yZC1lcnJvclwiKSk7XG52YXIgaW1wb3J0X2Nvbm5lY3Rpb25fZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24tZXJyb3JcIikpO1xudmFyIGltcG9ydF9lYWdlcl9sb2FkaW5nX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9lYWdlci1sb2FkaW5nLWVycm9yXCIpKTtcbnZhciBpbXBvcnRfZW1wdHlfcmVzdWx0X2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9lbXB0eS1yZXN1bHQtZXJyb3JcIikpO1xudmFyIGltcG9ydF9pbnN0YW5jZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vaW5zdGFuY2UtZXJyb3JcIikpO1xudmFyIGltcG9ydF9vcHRpbWlzdGljX2xvY2tfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL29wdGltaXN0aWMtbG9jay1lcnJvclwiKSk7XG52YXIgaW1wb3J0X3F1ZXJ5X2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9xdWVyeS1lcnJvclwiKSk7XG52YXIgaW1wb3J0X3NlcXVlbGl6ZV9zY29wZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vc2VxdWVsaXplLXNjb3BlLWVycm9yXCIpKTtcbnZhciBpbXBvcnRfdmFsaWRhdGlvbl9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vdmFsaWRhdGlvbi1lcnJvclwiKSk7XG52YXIgaW1wb3J0X2FjY2Vzc19kZW5pZWRfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24vYWNjZXNzLWRlbmllZC1lcnJvclwiKSk7XG52YXIgaW1wb3J0X2Nvbm5lY3Rpb25fYWNxdWlyZV90aW1lb3V0X2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9jb25uZWN0aW9uL2Nvbm5lY3Rpb24tYWNxdWlyZS10aW1lb3V0LWVycm9yXCIpKTtcbnZhciBpbXBvcnRfY29ubmVjdGlvbl9yZWZ1c2VkX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9jb25uZWN0aW9uL2Nvbm5lY3Rpb24tcmVmdXNlZC1lcnJvclwiKSk7XG52YXIgaW1wb3J0X2Nvbm5lY3Rpb25fdGltZWRfb3V0X2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9jb25uZWN0aW9uL2Nvbm5lY3Rpb24tdGltZWQtb3V0LWVycm9yXCIpKTtcbnZhciBpbXBvcnRfaG9zdF9ub3RfZm91bmRfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24vaG9zdC1ub3QtZm91bmQtZXJyb3JcIikpO1xudmFyIGltcG9ydF9ob3N0X25vdF9yZWFjaGFibGVfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24vaG9zdC1ub3QtcmVhY2hhYmxlLWVycm9yXCIpKTtcbnZhciBpbXBvcnRfaW52YWxpZF9jb25uZWN0aW9uX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9jb25uZWN0aW9uL2ludmFsaWQtY29ubmVjdGlvbi1lcnJvclwiKSk7XG52YXIgaW1wb3J0X2V4Y2x1c2lvbl9jb25zdHJhaW50X2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9kYXRhYmFzZS9leGNsdXNpb24tY29uc3RyYWludC1lcnJvclwiKSk7XG52YXIgaW1wb3J0X2ZvcmVpZ25fa2V5X2NvbnN0cmFpbnRfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2RhdGFiYXNlL2ZvcmVpZ24ta2V5LWNvbnN0cmFpbnQtZXJyb3JcIikpO1xudmFyIGltcG9ydF90aW1lb3V0X2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9kYXRhYmFzZS90aW1lb3V0LWVycm9yXCIpKTtcbnZhciBpbXBvcnRfdW5rbm93bl9jb25zdHJhaW50X2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9kYXRhYmFzZS91bmtub3duLWNvbnN0cmFpbnQtZXJyb3JcIikpO1xudmFyIGltcG9ydF91bmlxdWVfY29uc3RyYWludF9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vdmFsaWRhdGlvbi91bmlxdWUtY29uc3RyYWludC1lcnJvclwiKSk7XG52YXIgaW1wb3J0X2FzeW5jX3F1ZXVlID0gX190b01vZHVsZShyZXF1aXJlKFwiLi4vZGlhbGVjdHMvbXNzcWwvYXN5bmMtcXVldWVcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/index.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/instance-error.js":
/*!**************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/instance-error.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => instance_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/base-error.js\"));\nclass InstanceError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeInstanceError\";\n  }\n}\nvar instance_error_default = InstanceError;\n//# sourceMappingURL=instance-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvaW5zdGFuY2UtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUMsbUJBQU8sQ0FBQyx5RkFBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9pbnN0YW5jZS1lcnJvci5qcz8zMzNiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBpbnN0YW5jZV9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfYmFzZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vYmFzZS1lcnJvclwiKSk7XG5jbGFzcyBJbnN0YW5jZUVycm9yIGV4dGVuZHMgaW1wb3J0X2Jhc2VfZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZUluc3RhbmNlRXJyb3JcIjtcbiAgfVxufVxudmFyIGluc3RhbmNlX2Vycm9yX2RlZmF1bHQgPSBJbnN0YW5jZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5zdGFuY2UtZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/instance-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/optimistic-lock-error.js":
/*!*********************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/optimistic-lock-error.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => optimistic_lock_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/base-error.js\"));\nclass OptimisticLockError extends import_base_error.default {\n  constructor(options) {\n    options = options || {};\n    options.message = options.message || `Attempting to update a stale model instance: ${options.modelName}`;\n    super(options.message);\n    __publicField(this, \"modelName\");\n    __publicField(this, \"values\");\n    __publicField(this, \"where\");\n    this.name = \"SequelizeOptimisticLockError\";\n    this.modelName = options.modelName;\n    this.values = options.values;\n    this.where = options.where;\n  }\n}\nvar optimistic_lock_error_default = OptimisticLockError;\n//# sourceMappingURL=optimistic-lock-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvb3B0aW1pc3RpYy1sb2NrLWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0ksbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyxtQkFBTyxDQUFDLHlGQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixrQkFBa0I7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9vcHRpbWlzdGljLWxvY2stZXJyb3IuanM/MmI2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBvcHRpbWlzdGljX2xvY2tfZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2Jhc2VfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Jhc2UtZXJyb3JcIikpO1xuY2xhc3MgT3B0aW1pc3RpY0xvY2tFcnJvciBleHRlbmRzIGltcG9ydF9iYXNlX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlIHx8IGBBdHRlbXB0aW5nIHRvIHVwZGF0ZSBhIHN0YWxlIG1vZGVsIGluc3RhbmNlOiAke29wdGlvbnMubW9kZWxOYW1lfWA7XG4gICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibW9kZWxOYW1lXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ2YWx1ZXNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIndoZXJlXCIpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplT3B0aW1pc3RpY0xvY2tFcnJvclwiO1xuICAgIHRoaXMubW9kZWxOYW1lID0gb3B0aW9ucy5tb2RlbE5hbWU7XG4gICAgdGhpcy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcztcbiAgICB0aGlzLndoZXJlID0gb3B0aW9ucy53aGVyZTtcbiAgfVxufVxudmFyIG9wdGltaXN0aWNfbG9ja19lcnJvcl9kZWZhdWx0ID0gT3B0aW1pc3RpY0xvY2tFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wdGltaXN0aWMtbG9jay1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/optimistic-lock-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/query-error.js":
/*!***********************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/query-error.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => query_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/base-error.js\"));\nclass QueryError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeQueryError\";\n  }\n}\nvar query_error_default = QueryError;\n//# sourceMappingURL=query-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvcXVlcnktZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUMsbUJBQU8sQ0FBQyx5RkFBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9xdWVyeS1lcnJvci5qcz8zZmQ1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBxdWVyeV9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfYmFzZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vYmFzZS1lcnJvclwiKSk7XG5jbGFzcyBRdWVyeUVycm9yIGV4dGVuZHMgaW1wb3J0X2Jhc2VfZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZVF1ZXJ5RXJyb3JcIjtcbiAgfVxufVxudmFyIHF1ZXJ5X2Vycm9yX2RlZmF1bHQgPSBRdWVyeUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnktZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/query-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/sequelize-scope-error.js":
/*!*********************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/sequelize-scope-error.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => sequelize_scope_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/base-error.js\"));\nclass SequelizeScopeError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeScopeError\";\n  }\n}\nvar sequelize_scope_error_default = SequelizeScopeError;\n//# sourceMappingURL=sequelize-scope-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvc2VxdWVsaXplLXNjb3BlLWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DLG1CQUFPLENBQUMseUZBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvc2VxdWVsaXplLXNjb3BlLWVycm9yLmpzPzI0MDAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IHNlcXVlbGl6ZV9zY29wZV9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfYmFzZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vYmFzZS1lcnJvclwiKSk7XG5jbGFzcyBTZXF1ZWxpemVTY29wZUVycm9yIGV4dGVuZHMgaW1wb3J0X2Jhc2VfZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZVNjb3BlRXJyb3JcIjtcbiAgfVxufVxudmFyIHNlcXVlbGl6ZV9zY29wZV9lcnJvcl9kZWZhdWx0ID0gU2VxdWVsaXplU2NvcGVFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcXVlbGl6ZS1zY29wZS1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/sequelize-scope-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/validation-error.js":
/*!****************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/validation-error.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  ValidationErrorItem: () => ValidationErrorItem,\n  ValidationErrorItemOrigin: () => ValidationErrorItemOrigin,\n  ValidationErrorItemType: () => ValidationErrorItemType,\n  default: () => validation_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/base-error.js\"));\nvar ValidationErrorItemType = /* @__PURE__ */ ((ValidationErrorItemType2) => {\n  ValidationErrorItemType2[\"notnull violation\"] = \"CORE\";\n  ValidationErrorItemType2[\"string violation\"] = \"CORE\";\n  ValidationErrorItemType2[\"unique violation\"] = \"DB\";\n  ValidationErrorItemType2[\"validation error\"] = \"FUNCTION\";\n  return ValidationErrorItemType2;\n})(ValidationErrorItemType || {});\nvar ValidationErrorItemOrigin = /* @__PURE__ */ ((ValidationErrorItemOrigin2) => {\n  ValidationErrorItemOrigin2[\"CORE\"] = \"CORE\";\n  ValidationErrorItemOrigin2[\"DB\"] = \"DB\";\n  ValidationErrorItemOrigin2[\"FUNCTION\"] = \"FUNCTION\";\n  return ValidationErrorItemOrigin2;\n})(ValidationErrorItemOrigin || {});\nclass ValidationErrorItem {\n  constructor(message, type, path, value, instance, validatorKey, fnName, fnArgs) {\n    __publicField(this, \"message\");\n    __publicField(this, \"type\");\n    __publicField(this, \"path\");\n    __publicField(this, \"value\");\n    __publicField(this, \"origin\");\n    __publicField(this, \"instance\");\n    __publicField(this, \"validatorKey\");\n    __publicField(this, \"validatorName\");\n    __publicField(this, \"validatorArgs\");\n    this.message = message || \"\";\n    this.type = null;\n    this.path = path || null;\n    this.value = value !== void 0 ? value : null;\n    this.origin = null;\n    this.instance = instance || null;\n    this.validatorKey = validatorKey || null;\n    this.validatorName = fnName || null;\n    this.validatorArgs = fnArgs || [];\n    if (type) {\n      if (this.isValidationErrorItemOrigin(type)) {\n        this.origin = type;\n      } else {\n        const lowercaseType = this.normalizeString(type);\n        const realType = ValidationErrorItemType[lowercaseType];\n        if (realType && ValidationErrorItemOrigin[realType]) {\n          this.origin = realType;\n          this.type = type;\n        }\n      }\n    }\n  }\n  isValidationErrorItemOrigin(origin) {\n    return ValidationErrorItemOrigin[origin] !== void 0;\n  }\n  normalizeString(str) {\n    return str.toLowerCase().trim();\n  }\n  getValidatorKey(useTypeAsNS, NSSeparator) {\n    const useTANS = useTypeAsNS === void 0 || !!useTypeAsNS;\n    const NSSep = NSSeparator === void 0 ? \".\" : NSSeparator;\n    const type = this.origin;\n    const key = this.validatorKey || this.validatorName;\n    const useNS = useTANS && type && ValidationErrorItemOrigin[type];\n    if (useNS && (typeof NSSep !== \"string\" || !NSSep.length)) {\n      throw new Error(\"Invalid namespace separator given, must be a non-empty string\");\n    }\n    if (!(typeof key === \"string\" && key.length)) {\n      return \"\";\n    }\n    return (useNS ? [this.origin, key].join(NSSep) : key).toLowerCase().trim();\n  }\n}\n__publicField(ValidationErrorItem, \"TypeStringMap\", ValidationErrorItemType);\n__publicField(ValidationErrorItem, \"Origins\", ValidationErrorItemOrigin);\nclass ValidationError extends import_base_error.default {\n  constructor(message, errors, options = {}) {\n    super(message);\n    __publicField(this, \"errors\");\n    this.name = \"SequelizeValidationError\";\n    this.message = \"Validation Error\";\n    this.errors = errors || [];\n    if (message) {\n      this.message = message;\n    } else if (this.errors.length > 0 && this.errors[0].message) {\n      this.message = this.errors.map((err) => `${err.type || err.origin}: ${err.message}`).join(\",\\n\");\n    }\n    if (options.stack) {\n      this.stack = options.stack;\n    }\n  }\n  get(path) {\n    return this.errors.reduce((reduced, error) => {\n      if (error.path === path) {\n        reduced.push(error);\n      }\n      return reduced;\n    }, []);\n  }\n}\nvar validation_error_default = ValidationError;\n//# sourceMappingURL=validation-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvdmFsaWRhdGlvbi1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUMsbUJBQU8sQ0FBQyx5RkFBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLCtCQUErQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQ0FBaUM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04saURBQWlELHVCQUF1QixJQUFJLFlBQVk7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvdmFsaWRhdGlvbi1lcnJvci5qcz84YzdjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIFZhbGlkYXRpb25FcnJvckl0ZW06ICgpID0+IFZhbGlkYXRpb25FcnJvckl0ZW0sXG4gIFZhbGlkYXRpb25FcnJvckl0ZW1PcmlnaW46ICgpID0+IFZhbGlkYXRpb25FcnJvckl0ZW1PcmlnaW4sXG4gIFZhbGlkYXRpb25FcnJvckl0ZW1UeXBlOiAoKSA9PiBWYWxpZGF0aW9uRXJyb3JJdGVtVHlwZSxcbiAgZGVmYXVsdDogKCkgPT4gdmFsaWRhdGlvbl9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfYmFzZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vYmFzZS1lcnJvclwiKSk7XG52YXIgVmFsaWRhdGlvbkVycm9ySXRlbVR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChWYWxpZGF0aW9uRXJyb3JJdGVtVHlwZTIpID0+IHtcbiAgVmFsaWRhdGlvbkVycm9ySXRlbVR5cGUyW1wibm90bnVsbCB2aW9sYXRpb25cIl0gPSBcIkNPUkVcIjtcbiAgVmFsaWRhdGlvbkVycm9ySXRlbVR5cGUyW1wic3RyaW5nIHZpb2xhdGlvblwiXSA9IFwiQ09SRVwiO1xuICBWYWxpZGF0aW9uRXJyb3JJdGVtVHlwZTJbXCJ1bmlxdWUgdmlvbGF0aW9uXCJdID0gXCJEQlwiO1xuICBWYWxpZGF0aW9uRXJyb3JJdGVtVHlwZTJbXCJ2YWxpZGF0aW9uIGVycm9yXCJdID0gXCJGVU5DVElPTlwiO1xuICByZXR1cm4gVmFsaWRhdGlvbkVycm9ySXRlbVR5cGUyO1xufSkoVmFsaWRhdGlvbkVycm9ySXRlbVR5cGUgfHwge30pO1xudmFyIFZhbGlkYXRpb25FcnJvckl0ZW1PcmlnaW4gPSAvKiBAX19QVVJFX18gKi8gKChWYWxpZGF0aW9uRXJyb3JJdGVtT3JpZ2luMikgPT4ge1xuICBWYWxpZGF0aW9uRXJyb3JJdGVtT3JpZ2luMltcIkNPUkVcIl0gPSBcIkNPUkVcIjtcbiAgVmFsaWRhdGlvbkVycm9ySXRlbU9yaWdpbjJbXCJEQlwiXSA9IFwiREJcIjtcbiAgVmFsaWRhdGlvbkVycm9ySXRlbU9yaWdpbjJbXCJGVU5DVElPTlwiXSA9IFwiRlVOQ1RJT05cIjtcbiAgcmV0dXJuIFZhbGlkYXRpb25FcnJvckl0ZW1PcmlnaW4yO1xufSkoVmFsaWRhdGlvbkVycm9ySXRlbU9yaWdpbiB8fCB7fSk7XG5jbGFzcyBWYWxpZGF0aW9uRXJyb3JJdGVtIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgdHlwZSwgcGF0aCwgdmFsdWUsIGluc3RhbmNlLCB2YWxpZGF0b3JLZXksIGZuTmFtZSwgZm5BcmdzKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1lc3NhZ2VcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInR5cGVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBhdGhcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInZhbHVlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJvcmlnaW5cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImluc3RhbmNlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ2YWxpZGF0b3JLZXlcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInZhbGlkYXRvck5hbWVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInZhbGlkYXRvckFyZ3NcIik7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCBcIlwiO1xuICAgIHRoaXMudHlwZSA9IG51bGw7XG4gICAgdGhpcy5wYXRoID0gcGF0aCB8fCBudWxsO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiBudWxsO1xuICAgIHRoaXMub3JpZ2luID0gbnVsbDtcbiAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2UgfHwgbnVsbDtcbiAgICB0aGlzLnZhbGlkYXRvcktleSA9IHZhbGlkYXRvcktleSB8fCBudWxsO1xuICAgIHRoaXMudmFsaWRhdG9yTmFtZSA9IGZuTmFtZSB8fCBudWxsO1xuICAgIHRoaXMudmFsaWRhdG9yQXJncyA9IGZuQXJncyB8fCBbXTtcbiAgICBpZiAodHlwZSkge1xuICAgICAgaWYgKHRoaXMuaXNWYWxpZGF0aW9uRXJyb3JJdGVtT3JpZ2luKHR5cGUpKSB7XG4gICAgICAgIHRoaXMub3JpZ2luID0gdHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGxvd2VyY2FzZVR5cGUgPSB0aGlzLm5vcm1hbGl6ZVN0cmluZyh0eXBlKTtcbiAgICAgICAgY29uc3QgcmVhbFR5cGUgPSBWYWxpZGF0aW9uRXJyb3JJdGVtVHlwZVtsb3dlcmNhc2VUeXBlXTtcbiAgICAgICAgaWYgKHJlYWxUeXBlICYmIFZhbGlkYXRpb25FcnJvckl0ZW1PcmlnaW5bcmVhbFR5cGVdKSB7XG4gICAgICAgICAgdGhpcy5vcmlnaW4gPSByZWFsVHlwZTtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlzVmFsaWRhdGlvbkVycm9ySXRlbU9yaWdpbihvcmlnaW4pIHtcbiAgICByZXR1cm4gVmFsaWRhdGlvbkVycm9ySXRlbU9yaWdpbltvcmlnaW5dICE9PSB2b2lkIDA7XG4gIH1cbiAgbm9ybWFsaXplU3RyaW5nKHN0cikge1xuICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIH1cbiAgZ2V0VmFsaWRhdG9yS2V5KHVzZVR5cGVBc05TLCBOU1NlcGFyYXRvcikge1xuICAgIGNvbnN0IHVzZVRBTlMgPSB1c2VUeXBlQXNOUyA9PT0gdm9pZCAwIHx8ICEhdXNlVHlwZUFzTlM7XG4gICAgY29uc3QgTlNTZXAgPSBOU1NlcGFyYXRvciA9PT0gdm9pZCAwID8gXCIuXCIgOiBOU1NlcGFyYXRvcjtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5vcmlnaW47XG4gICAgY29uc3Qga2V5ID0gdGhpcy52YWxpZGF0b3JLZXkgfHwgdGhpcy52YWxpZGF0b3JOYW1lO1xuICAgIGNvbnN0IHVzZU5TID0gdXNlVEFOUyAmJiB0eXBlICYmIFZhbGlkYXRpb25FcnJvckl0ZW1PcmlnaW5bdHlwZV07XG4gICAgaWYgKHVzZU5TICYmICh0eXBlb2YgTlNTZXAgIT09IFwic3RyaW5nXCIgfHwgIU5TU2VwLmxlbmd0aCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbmFtZXNwYWNlIHNlcGFyYXRvciBnaXZlbiwgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIik7XG4gICAgfVxuICAgIGlmICghKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgJiYga2V5Lmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gKHVzZU5TID8gW3RoaXMub3JpZ2luLCBrZXldLmpvaW4oTlNTZXApIDoga2V5KS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgfVxufVxuX19wdWJsaWNGaWVsZChWYWxpZGF0aW9uRXJyb3JJdGVtLCBcIlR5cGVTdHJpbmdNYXBcIiwgVmFsaWRhdGlvbkVycm9ySXRlbVR5cGUpO1xuX19wdWJsaWNGaWVsZChWYWxpZGF0aW9uRXJyb3JJdGVtLCBcIk9yaWdpbnNcIiwgVmFsaWRhdGlvbkVycm9ySXRlbU9yaWdpbik7XG5jbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBpbXBvcnRfYmFzZV9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgZXJyb3JzLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZXJyb3JzXCIpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplVmFsaWRhdGlvbkVycm9yXCI7XG4gICAgdGhpcy5tZXNzYWdlID0gXCJWYWxpZGF0aW9uIEVycm9yXCI7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnMgfHwgW107XG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVycm9ycy5sZW5ndGggPiAwICYmIHRoaXMuZXJyb3JzWzBdLm1lc3NhZ2UpIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuZXJyb3JzLm1hcCgoZXJyKSA9PiBgJHtlcnIudHlwZSB8fCBlcnIub3JpZ2lufTogJHtlcnIubWVzc2FnZX1gKS5qb2luKFwiLFxcblwiKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3RhY2spIHtcbiAgICAgIHRoaXMuc3RhY2sgPSBvcHRpb25zLnN0YWNrO1xuICAgIH1cbiAgfVxuICBnZXQocGF0aCkge1xuICAgIHJldHVybiB0aGlzLmVycm9ycy5yZWR1Y2UoKHJlZHVjZWQsIGVycm9yKSA9PiB7XG4gICAgICBpZiAoZXJyb3IucGF0aCA9PT0gcGF0aCkge1xuICAgICAgICByZWR1Y2VkLnB1c2goZXJyb3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlZHVjZWQ7XG4gICAgfSwgW10pO1xuICB9XG59XG52YXIgdmFsaWRhdGlvbl9lcnJvcl9kZWZhdWx0ID0gVmFsaWRhdGlvbkVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGlvbi1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/validation-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/errors/validation/unique-constraint-error.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/sequelize/lib/errors/validation/unique-constraint-error.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => unique_constraint_error_default\n});\nvar import_validation_error = __toModule(__webpack_require__(/*! ../validation-error */ \"(action-browser)/../node_modules/sequelize/lib/errors/validation-error.js\"));\nclass UniqueConstraintError extends import_validation_error.default {\n  constructor(options) {\n    var _a, _b, _c;\n    options = options != null ? options : {};\n    options.parent = (_a = options.parent) != null ? _a : { sql: \"\", name: \"\", message: \"\" };\n    options.message = options.message || options.parent.message || \"Validation Error\";\n    options.errors = (_b = options.errors) != null ? _b : [];\n    super(options.message, options.errors, { stack: options.stack });\n    __publicField(this, \"parent\");\n    __publicField(this, \"original\");\n    __publicField(this, \"fields\");\n    __publicField(this, \"sql\");\n    this.name = \"SequelizeUniqueConstraintError\";\n    this.fields = (_c = options.fields) != null ? _c : {};\n    this.parent = options.parent;\n    this.original = options.parent;\n    this.sql = options.parent.sql;\n  }\n}\nvar unique_constraint_error_default = UniqueConstraintError;\n//# sourceMappingURL=unique-constraint-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvdmFsaWRhdGlvbi91bmlxdWUtY29uc3RyYWludC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5Q0FBeUMsbUJBQU8sQ0FBQyxzR0FBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLDZDQUE2QyxzQkFBc0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL3ZhbGlkYXRpb24vdW5pcXVlLWNvbnN0cmFpbnQtZXJyb3IuanM/NmJiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiB1bmlxdWVfY29uc3RyYWludF9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfdmFsaWRhdGlvbl9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4uL3ZhbGlkYXRpb24tZXJyb3JcIikpO1xuY2xhc3MgVW5pcXVlQ29uc3RyYWludEVycm9yIGV4dGVuZHMgaW1wb3J0X3ZhbGlkYXRpb25fZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBvcHRpb25zID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHt9O1xuICAgIG9wdGlvbnMucGFyZW50ID0gKF9hID0gb3B0aW9ucy5wYXJlbnQpICE9IG51bGwgPyBfYSA6IHsgc3FsOiBcIlwiLCBuYW1lOiBcIlwiLCBtZXNzYWdlOiBcIlwiIH07XG4gICAgb3B0aW9ucy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlIHx8IG9wdGlvbnMucGFyZW50Lm1lc3NhZ2UgfHwgXCJWYWxpZGF0aW9uIEVycm9yXCI7XG4gICAgb3B0aW9ucy5lcnJvcnMgPSAoX2IgPSBvcHRpb25zLmVycm9ycykgIT0gbnVsbCA/IF9iIDogW107XG4gICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlLCBvcHRpb25zLmVycm9ycywgeyBzdGFjazogb3B0aW9ucy5zdGFjayB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicGFyZW50XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJvcmlnaW5hbFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZmllbGRzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzcWxcIik7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVVbmlxdWVDb25zdHJhaW50RXJyb3JcIjtcbiAgICB0aGlzLmZpZWxkcyA9IChfYyA9IG9wdGlvbnMuZmllbGRzKSAhPSBudWxsID8gX2MgOiB7fTtcbiAgICB0aGlzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICAgIHRoaXMub3JpZ2luYWwgPSBvcHRpb25zLnBhcmVudDtcbiAgICB0aGlzLnNxbCA9IG9wdGlvbnMucGFyZW50LnNxbDtcbiAgfVxufVxudmFyIHVuaXF1ZV9jb25zdHJhaW50X2Vycm9yX2RlZmF1bHQgPSBVbmlxdWVDb25zdHJhaW50RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmlxdWUtY29uc3RyYWludC1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/errors/validation/unique-constraint-error.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/hooks.js":
/*!**********************************************!*\
  !*** ../node_modules/sequelize/lib/hooks.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst { logger } = __webpack_require__(/*! ./utils/logger */ \"(action-browser)/../node_modules/sequelize/lib/utils/logger.js\");\nconst debug = logger.debugContext(\"hooks\");\nconst hookTypes = {\n  beforeValidate: { params: 2 },\n  afterValidate: { params: 2 },\n  validationFailed: { params: 3 },\n  beforeCreate: { params: 2 },\n  afterCreate: { params: 2 },\n  beforeDestroy: { params: 2 },\n  afterDestroy: { params: 2 },\n  beforeRestore: { params: 2 },\n  afterRestore: { params: 2 },\n  beforeUpdate: { params: 2 },\n  afterUpdate: { params: 2 },\n  beforeSave: { params: 2, proxies: [\"beforeUpdate\", \"beforeCreate\"] },\n  afterSave: { params: 2, proxies: [\"afterUpdate\", \"afterCreate\"] },\n  beforeUpsert: { params: 2 },\n  afterUpsert: { params: 2 },\n  beforeBulkCreate: { params: 2 },\n  afterBulkCreate: { params: 2 },\n  beforeBulkDestroy: { params: 1 },\n  afterBulkDestroy: { params: 1 },\n  beforeBulkRestore: { params: 1 },\n  afterBulkRestore: { params: 1 },\n  beforeBulkUpdate: { params: 1 },\n  afterBulkUpdate: { params: 1 },\n  beforeFind: { params: 1 },\n  beforeFindAfterExpandIncludeAll: { params: 1 },\n  beforeFindAfterOptions: { params: 1 },\n  afterFind: { params: 2 },\n  beforeCount: { params: 1 },\n  beforeDefine: { params: 2, sync: true, noModel: true },\n  afterDefine: { params: 1, sync: true, noModel: true },\n  beforeInit: { params: 2, sync: true, noModel: true },\n  afterInit: { params: 1, sync: true, noModel: true },\n  beforeAssociate: { params: 2, sync: true },\n  afterAssociate: { params: 2, sync: true },\n  beforeConnect: { params: 1, noModel: true },\n  afterConnect: { params: 2, noModel: true },\n  beforeDisconnect: { params: 1, noModel: true },\n  afterDisconnect: { params: 1, noModel: true },\n  beforePoolAcquire: { params: 1, noModel: true },\n  afterPoolAcquire: { params: 2, noModel: true },\n  beforeSync: { params: 1 },\n  afterSync: { params: 1 },\n  beforeBulkSync: { params: 1 },\n  afterBulkSync: { params: 1 },\n  beforeQuery: { params: 2 },\n  afterQuery: { params: 2 }\n};\nexports.hooks = hookTypes;\nconst getProxiedHooks = (hookType) => hookTypes[hookType].proxies ? hookTypes[hookType].proxies.concat(hookType) : [hookType];\nfunction getHooks(hooked, hookType) {\n  return (hooked.options.hooks || {})[hookType] || [];\n}\nconst Hooks = {\n  _setupHooks(hooks) {\n    this.options.hooks = {};\n    _.map(hooks || {}, (hooksArray, hookName) => {\n      if (!Array.isArray(hooksArray))\n        hooksArray = [hooksArray];\n      hooksArray.forEach((hookFn) => this.addHook(hookName, hookFn));\n    });\n  },\n  async runHooks(hooks, ...hookArgs) {\n    if (!hooks)\n      throw new Error(\"runHooks requires at least 1 argument\");\n    let hookType;\n    if (typeof hooks === \"string\") {\n      hookType = hooks;\n      hooks = getHooks(this, hookType);\n      if (this.sequelize) {\n        hooks = hooks.concat(getHooks(this.sequelize, hookType));\n      }\n    }\n    if (!Array.isArray(hooks)) {\n      hooks = [hooks];\n    }\n    if (hookTypes[hookType] && hookTypes[hookType].sync) {\n      for (let hook of hooks) {\n        if (typeof hook === \"object\") {\n          hook = hook.fn;\n        }\n        debug(`running hook(sync) ${hookType}`);\n        hook.apply(this, hookArgs);\n      }\n      return;\n    }\n    for (let hook of hooks) {\n      if (typeof hook === \"object\") {\n        hook = hook.fn;\n      }\n      debug(`running hook ${hookType}`);\n      await hook.apply(this, hookArgs);\n    }\n  },\n  addHook(hookType, name, fn) {\n    if (typeof name === \"function\") {\n      fn = name;\n      name = null;\n    }\n    debug(`adding hook ${hookType}`);\n    hookType = getProxiedHooks(hookType);\n    hookType.forEach((type) => {\n      const hooks = getHooks(this, type);\n      hooks.push(name ? { name, fn } : fn);\n      this.options.hooks[type] = hooks;\n    });\n    return this;\n  },\n  removeHook(hookType, name) {\n    const isReference = typeof name === \"function\" ? true : false;\n    if (!this.hasHook(hookType)) {\n      return this;\n    }\n    debug(`removing hook ${hookType}`);\n    hookType = getProxiedHooks(hookType);\n    for (const type of hookType) {\n      this.options.hooks[type] = this.options.hooks[type].filter((hook) => {\n        if (isReference && typeof hook === \"function\") {\n          return hook !== name;\n        }\n        if (!isReference && typeof hook === \"object\") {\n          return hook.name !== name;\n        }\n        return true;\n      });\n    }\n    return this;\n  },\n  hasHook(hookType) {\n    return this.options.hooks[hookType] && !!this.options.hooks[hookType].length;\n  }\n};\nHooks.hasHooks = Hooks.hasHook;\nfunction applyTo(target, isModel = false) {\n  _.mixin(target, Hooks);\n  for (const hook of Object.keys(hookTypes)) {\n    if (isModel && hookTypes[hook].noModel) {\n      continue;\n    }\n    target[hook] = function(name, callback) {\n      return this.addHook(hook, name, callback);\n    };\n  }\n}\nexports.applyTo = applyTo;\n//# sourceMappingURL=hooks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9ob29rcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFVBQVUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMxQixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNGQUFnQjtBQUMzQztBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0IsbUJBQW1CLFdBQVc7QUFDOUIsc0JBQXNCLFdBQVc7QUFDakMsa0JBQWtCLFdBQVc7QUFDN0IsaUJBQWlCLFdBQVc7QUFDNUIsbUJBQW1CLFdBQVc7QUFDOUIsa0JBQWtCLFdBQVc7QUFDN0IsbUJBQW1CLFdBQVc7QUFDOUIsa0JBQWtCLFdBQVc7QUFDN0Isa0JBQWtCLFdBQVc7QUFDN0IsaUJBQWlCLFdBQVc7QUFDNUIsZ0JBQWdCLHNEQUFzRDtBQUN0RSxlQUFlLG9EQUFvRDtBQUNuRSxrQkFBa0IsV0FBVztBQUM3QixpQkFBaUIsV0FBVztBQUM1QixzQkFBc0IsV0FBVztBQUNqQyxxQkFBcUIsV0FBVztBQUNoQyx1QkFBdUIsV0FBVztBQUNsQyxzQkFBc0IsV0FBVztBQUNqQyx1QkFBdUIsV0FBVztBQUNsQyxzQkFBc0IsV0FBVztBQUNqQyxzQkFBc0IsV0FBVztBQUNqQyxxQkFBcUIsV0FBVztBQUNoQyxnQkFBZ0IsV0FBVztBQUMzQixxQ0FBcUMsV0FBVztBQUNoRCw0QkFBNEIsV0FBVztBQUN2QyxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCLFdBQVc7QUFDNUIsa0JBQWtCLHNDQUFzQztBQUN4RCxpQkFBaUIsc0NBQXNDO0FBQ3ZELGdCQUFnQixzQ0FBc0M7QUFDdEQsZUFBZSxzQ0FBc0M7QUFDckQscUJBQXFCLHVCQUF1QjtBQUM1QyxvQkFBb0IsdUJBQXVCO0FBQzNDLG1CQUFtQiwwQkFBMEI7QUFDN0Msa0JBQWtCLDBCQUEwQjtBQUM1QyxzQkFBc0IsMEJBQTBCO0FBQ2hELHFCQUFxQiwwQkFBMEI7QUFDL0MsdUJBQXVCLDBCQUEwQjtBQUNqRCxzQkFBc0IsMEJBQTBCO0FBQ2hELGdCQUFnQixXQUFXO0FBQzNCLGVBQWUsV0FBVztBQUMxQixvQkFBb0IsV0FBVztBQUMvQixtQkFBbUIsV0FBVztBQUM5QixpQkFBaUIsV0FBVztBQUM1QixnQkFBZ0I7QUFDaEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2hvb2tzLmpzP2QzNDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKFwiLi91dGlscy9sb2dnZXJcIik7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoXCJob29rc1wiKTtcbmNvbnN0IGhvb2tUeXBlcyA9IHtcbiAgYmVmb3JlVmFsaWRhdGU6IHsgcGFyYW1zOiAyIH0sXG4gIGFmdGVyVmFsaWRhdGU6IHsgcGFyYW1zOiAyIH0sXG4gIHZhbGlkYXRpb25GYWlsZWQ6IHsgcGFyYW1zOiAzIH0sXG4gIGJlZm9yZUNyZWF0ZTogeyBwYXJhbXM6IDIgfSxcbiAgYWZ0ZXJDcmVhdGU6IHsgcGFyYW1zOiAyIH0sXG4gIGJlZm9yZURlc3Ryb3k6IHsgcGFyYW1zOiAyIH0sXG4gIGFmdGVyRGVzdHJveTogeyBwYXJhbXM6IDIgfSxcbiAgYmVmb3JlUmVzdG9yZTogeyBwYXJhbXM6IDIgfSxcbiAgYWZ0ZXJSZXN0b3JlOiB7IHBhcmFtczogMiB9LFxuICBiZWZvcmVVcGRhdGU6IHsgcGFyYW1zOiAyIH0sXG4gIGFmdGVyVXBkYXRlOiB7IHBhcmFtczogMiB9LFxuICBiZWZvcmVTYXZlOiB7IHBhcmFtczogMiwgcHJveGllczogW1wiYmVmb3JlVXBkYXRlXCIsIFwiYmVmb3JlQ3JlYXRlXCJdIH0sXG4gIGFmdGVyU2F2ZTogeyBwYXJhbXM6IDIsIHByb3hpZXM6IFtcImFmdGVyVXBkYXRlXCIsIFwiYWZ0ZXJDcmVhdGVcIl0gfSxcbiAgYmVmb3JlVXBzZXJ0OiB7IHBhcmFtczogMiB9LFxuICBhZnRlclVwc2VydDogeyBwYXJhbXM6IDIgfSxcbiAgYmVmb3JlQnVsa0NyZWF0ZTogeyBwYXJhbXM6IDIgfSxcbiAgYWZ0ZXJCdWxrQ3JlYXRlOiB7IHBhcmFtczogMiB9LFxuICBiZWZvcmVCdWxrRGVzdHJveTogeyBwYXJhbXM6IDEgfSxcbiAgYWZ0ZXJCdWxrRGVzdHJveTogeyBwYXJhbXM6IDEgfSxcbiAgYmVmb3JlQnVsa1Jlc3RvcmU6IHsgcGFyYW1zOiAxIH0sXG4gIGFmdGVyQnVsa1Jlc3RvcmU6IHsgcGFyYW1zOiAxIH0sXG4gIGJlZm9yZUJ1bGtVcGRhdGU6IHsgcGFyYW1zOiAxIH0sXG4gIGFmdGVyQnVsa1VwZGF0ZTogeyBwYXJhbXM6IDEgfSxcbiAgYmVmb3JlRmluZDogeyBwYXJhbXM6IDEgfSxcbiAgYmVmb3JlRmluZEFmdGVyRXhwYW5kSW5jbHVkZUFsbDogeyBwYXJhbXM6IDEgfSxcbiAgYmVmb3JlRmluZEFmdGVyT3B0aW9uczogeyBwYXJhbXM6IDEgfSxcbiAgYWZ0ZXJGaW5kOiB7IHBhcmFtczogMiB9LFxuICBiZWZvcmVDb3VudDogeyBwYXJhbXM6IDEgfSxcbiAgYmVmb3JlRGVmaW5lOiB7IHBhcmFtczogMiwgc3luYzogdHJ1ZSwgbm9Nb2RlbDogdHJ1ZSB9LFxuICBhZnRlckRlZmluZTogeyBwYXJhbXM6IDEsIHN5bmM6IHRydWUsIG5vTW9kZWw6IHRydWUgfSxcbiAgYmVmb3JlSW5pdDogeyBwYXJhbXM6IDIsIHN5bmM6IHRydWUsIG5vTW9kZWw6IHRydWUgfSxcbiAgYWZ0ZXJJbml0OiB7IHBhcmFtczogMSwgc3luYzogdHJ1ZSwgbm9Nb2RlbDogdHJ1ZSB9LFxuICBiZWZvcmVBc3NvY2lhdGU6IHsgcGFyYW1zOiAyLCBzeW5jOiB0cnVlIH0sXG4gIGFmdGVyQXNzb2NpYXRlOiB7IHBhcmFtczogMiwgc3luYzogdHJ1ZSB9LFxuICBiZWZvcmVDb25uZWN0OiB7IHBhcmFtczogMSwgbm9Nb2RlbDogdHJ1ZSB9LFxuICBhZnRlckNvbm5lY3Q6IHsgcGFyYW1zOiAyLCBub01vZGVsOiB0cnVlIH0sXG4gIGJlZm9yZURpc2Nvbm5lY3Q6IHsgcGFyYW1zOiAxLCBub01vZGVsOiB0cnVlIH0sXG4gIGFmdGVyRGlzY29ubmVjdDogeyBwYXJhbXM6IDEsIG5vTW9kZWw6IHRydWUgfSxcbiAgYmVmb3JlUG9vbEFjcXVpcmU6IHsgcGFyYW1zOiAxLCBub01vZGVsOiB0cnVlIH0sXG4gIGFmdGVyUG9vbEFjcXVpcmU6IHsgcGFyYW1zOiAyLCBub01vZGVsOiB0cnVlIH0sXG4gIGJlZm9yZVN5bmM6IHsgcGFyYW1zOiAxIH0sXG4gIGFmdGVyU3luYzogeyBwYXJhbXM6IDEgfSxcbiAgYmVmb3JlQnVsa1N5bmM6IHsgcGFyYW1zOiAxIH0sXG4gIGFmdGVyQnVsa1N5bmM6IHsgcGFyYW1zOiAxIH0sXG4gIGJlZm9yZVF1ZXJ5OiB7IHBhcmFtczogMiB9LFxuICBhZnRlclF1ZXJ5OiB7IHBhcmFtczogMiB9XG59O1xuZXhwb3J0cy5ob29rcyA9IGhvb2tUeXBlcztcbmNvbnN0IGdldFByb3hpZWRIb29rcyA9IChob29rVHlwZSkgPT4gaG9va1R5cGVzW2hvb2tUeXBlXS5wcm94aWVzID8gaG9va1R5cGVzW2hvb2tUeXBlXS5wcm94aWVzLmNvbmNhdChob29rVHlwZSkgOiBbaG9va1R5cGVdO1xuZnVuY3Rpb24gZ2V0SG9va3MoaG9va2VkLCBob29rVHlwZSkge1xuICByZXR1cm4gKGhvb2tlZC5vcHRpb25zLmhvb2tzIHx8IHt9KVtob29rVHlwZV0gfHwgW107XG59XG5jb25zdCBIb29rcyA9IHtcbiAgX3NldHVwSG9va3MoaG9va3MpIHtcbiAgICB0aGlzLm9wdGlvbnMuaG9va3MgPSB7fTtcbiAgICBfLm1hcChob29rcyB8fCB7fSwgKGhvb2tzQXJyYXksIGhvb2tOYW1lKSA9PiB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaG9va3NBcnJheSkpXG4gICAgICAgIGhvb2tzQXJyYXkgPSBbaG9va3NBcnJheV07XG4gICAgICBob29rc0FycmF5LmZvckVhY2goKGhvb2tGbikgPT4gdGhpcy5hZGRIb29rKGhvb2tOYW1lLCBob29rRm4pKTtcbiAgICB9KTtcbiAgfSxcbiAgYXN5bmMgcnVuSG9va3MoaG9va3MsIC4uLmhvb2tBcmdzKSB7XG4gICAgaWYgKCFob29rcylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInJ1bkhvb2tzIHJlcXVpcmVzIGF0IGxlYXN0IDEgYXJndW1lbnRcIik7XG4gICAgbGV0IGhvb2tUeXBlO1xuICAgIGlmICh0eXBlb2YgaG9va3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGhvb2tUeXBlID0gaG9va3M7XG4gICAgICBob29rcyA9IGdldEhvb2tzKHRoaXMsIGhvb2tUeXBlKTtcbiAgICAgIGlmICh0aGlzLnNlcXVlbGl6ZSkge1xuICAgICAgICBob29rcyA9IGhvb2tzLmNvbmNhdChnZXRIb29rcyh0aGlzLnNlcXVlbGl6ZSwgaG9va1R5cGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGhvb2tzKSkge1xuICAgICAgaG9va3MgPSBbaG9va3NdO1xuICAgIH1cbiAgICBpZiAoaG9va1R5cGVzW2hvb2tUeXBlXSAmJiBob29rVHlwZXNbaG9va1R5cGVdLnN5bmMpIHtcbiAgICAgIGZvciAobGV0IGhvb2sgb2YgaG9va3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBob29rID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgaG9vayA9IGhvb2suZm47XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoYHJ1bm5pbmcgaG9vayhzeW5jKSAke2hvb2tUeXBlfWApO1xuICAgICAgICBob29rLmFwcGx5KHRoaXMsIGhvb2tBcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaG9vayBvZiBob29rcykge1xuICAgICAgaWYgKHR5cGVvZiBob29rID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGhvb2sgPSBob29rLmZuO1xuICAgICAgfVxuICAgICAgZGVidWcoYHJ1bm5pbmcgaG9vayAke2hvb2tUeXBlfWApO1xuICAgICAgYXdhaXQgaG9vay5hcHBseSh0aGlzLCBob29rQXJncyk7XG4gICAgfVxuICB9LFxuICBhZGRIb29rKGhvb2tUeXBlLCBuYW1lLCBmbikge1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmbiA9IG5hbWU7XG4gICAgICBuYW1lID0gbnVsbDtcbiAgICB9XG4gICAgZGVidWcoYGFkZGluZyBob29rICR7aG9va1R5cGV9YCk7XG4gICAgaG9va1R5cGUgPSBnZXRQcm94aWVkSG9va3MoaG9va1R5cGUpO1xuICAgIGhvb2tUeXBlLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgIGNvbnN0IGhvb2tzID0gZ2V0SG9va3ModGhpcywgdHlwZSk7XG4gICAgICBob29rcy5wdXNoKG5hbWUgPyB7IG5hbWUsIGZuIH0gOiBmbik7XG4gICAgICB0aGlzLm9wdGlvbnMuaG9va3NbdHlwZV0gPSBob29rcztcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVtb3ZlSG9vayhob29rVHlwZSwgbmFtZSkge1xuICAgIGNvbnN0IGlzUmVmZXJlbmNlID0gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IHRydWUgOiBmYWxzZTtcbiAgICBpZiAoIXRoaXMuaGFzSG9vayhob29rVHlwZSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWJ1ZyhgcmVtb3ZpbmcgaG9vayAke2hvb2tUeXBlfWApO1xuICAgIGhvb2tUeXBlID0gZ2V0UHJveGllZEhvb2tzKGhvb2tUeXBlKTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgaG9va1R5cGUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5ob29rc1t0eXBlXSA9IHRoaXMub3B0aW9ucy5ob29rc1t0eXBlXS5maWx0ZXIoKGhvb2spID0+IHtcbiAgICAgICAgaWYgKGlzUmVmZXJlbmNlICYmIHR5cGVvZiBob29rID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gaG9vayAhPT0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUmVmZXJlbmNlICYmIHR5cGVvZiBob29rID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGhvb2submFtZSAhPT0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgaGFzSG9vayhob29rVHlwZSkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaG9va3NbaG9va1R5cGVdICYmICEhdGhpcy5vcHRpb25zLmhvb2tzW2hvb2tUeXBlXS5sZW5ndGg7XG4gIH1cbn07XG5Ib29rcy5oYXNIb29rcyA9IEhvb2tzLmhhc0hvb2s7XG5mdW5jdGlvbiBhcHBseVRvKHRhcmdldCwgaXNNb2RlbCA9IGZhbHNlKSB7XG4gIF8ubWl4aW4odGFyZ2V0LCBIb29rcyk7XG4gIGZvciAoY29uc3QgaG9vayBvZiBPYmplY3Qua2V5cyhob29rVHlwZXMpKSB7XG4gICAgaWYgKGlzTW9kZWwgJiYgaG9va1R5cGVzW2hvb2tdLm5vTW9kZWwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0YXJnZXRbaG9va10gPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkSG9vayhob29rLCBuYW1lLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgfVxufVxuZXhwb3J0cy5hcHBseVRvID0gYXBwbHlUbztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvb2tzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/hooks.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/index-hints.js":
/*!****************************************************!*\
  !*** ../node_modules/sequelize/lib/index-hints.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\nconst IndexHints = module.exports = {\n  USE: \"USE\",\n  FORCE: \"FORCE\",\n  IGNORE: \"IGNORE\"\n};\n//# sourceMappingURL=index-hints.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9pbmRleC1oaW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9pbmRleC1oaW50cy5qcz9kODhkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgSW5kZXhIaW50cyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBVU0U6IFwiVVNFXCIsXG4gIEZPUkNFOiBcIkZPUkNFXCIsXG4gIElHTk9SRTogXCJJR05PUkVcIlxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LWhpbnRzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/index-hints.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/index.js":
/*!**********************************************!*\
  !*** ../node_modules/sequelize/lib/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = __webpack_require__(/*! ./sequelize */ \"(action-browser)/../node_modules/sequelize/lib/sequelize.js\");\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHNIQUF1QztBQUN2QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9pbmRleC5qcz83ZDI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9zZXF1ZWxpemVcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/index.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/instance-validator.js":
/*!***********************************************************!*\
  !*** ../node_modules/sequelize/lib/instance-validator.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ./utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst sequelizeError = __webpack_require__(/*! ./errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst DataTypes = __webpack_require__(/*! ./data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\");\nconst BelongsTo = __webpack_require__(/*! ./associations/belongs-to */ \"(action-browser)/../node_modules/sequelize/lib/associations/belongs-to.js\");\nconst validator = (__webpack_require__(/*! ./utils/validator-extras */ \"(action-browser)/../node_modules/sequelize/lib/utils/validator-extras.js\").validator);\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nclass InstanceValidator {\n  constructor(modelInstance, options) {\n    options = __spreadValues({\n      hooks: true\n    }, options);\n    if (options.fields && !options.skip) {\n      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);\n    } else {\n      options.skip = options.skip || [];\n    }\n    this.options = options;\n    this.modelInstance = modelInstance;\n    this.validator = validator;\n    this.errors = [];\n    this.inProgress = false;\n  }\n  async _validate() {\n    if (this.inProgress)\n      throw new Error(\"Validations already in progress.\");\n    this.inProgress = true;\n    await Promise.all([\n      this._perAttributeValidators(),\n      this._customValidators()\n    ]);\n    if (this.errors.length) {\n      throw new sequelizeError.ValidationError(null, this.errors);\n    }\n  }\n  async validate() {\n    return await (this.options.hooks ? this._validateAndRunHooks() : this._validate());\n  }\n  async _validateAndRunHooks() {\n    const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);\n    await runHooks(\"beforeValidate\", this.modelInstance, this.options);\n    try {\n      await this._validate();\n    } catch (error) {\n      const newError = await runHooks(\"validationFailed\", this.modelInstance, this.options, error);\n      throw newError || error;\n    }\n    await runHooks(\"afterValidate\", this.modelInstance, this.options);\n    return this.modelInstance;\n  }\n  async _perAttributeValidators() {\n    const validators = [];\n    _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {\n      if (this.options.skip.includes(field)) {\n        return;\n      }\n      const value = this.modelInstance.dataValues[field];\n      if (value instanceof Utils.SequelizeMethod) {\n        return;\n      }\n      if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {\n        this._validateSchema(rawAttribute, field, value);\n      }\n      if (Object.prototype.hasOwnProperty.call(this.modelInstance.validators, field)) {\n        validators.push(this._singleAttrValidate(value, field, rawAttribute.allowNull));\n      }\n    });\n    return await Promise.all(validators);\n  }\n  async _customValidators() {\n    const validators = [];\n    _.each(this.modelInstance.constructor.options.validate, (validator2, validatorType) => {\n      if (this.options.skip.includes(validatorType)) {\n        return;\n      }\n      const valprom = this._invokeCustomValidator(validator2, validatorType).catch(() => {\n      });\n      validators.push(valprom);\n    });\n    return await Promise.all(validators);\n  }\n  async _singleAttrValidate(value, field, allowNull) {\n    if ((value === null || value === void 0) && !allowNull) {\n      return;\n    }\n    const validators = [];\n    _.forIn(this.modelInstance.validators[field], (test, validatorType) => {\n      if ([\"isUrl\", \"isURL\", \"isEmail\"].includes(validatorType)) {\n        if (typeof test === \"object\" && test !== null && test.msg) {\n          test = {\n            msg: test.msg\n          };\n        } else if (test === true) {\n          test = {};\n        }\n      }\n      if (typeof test === \"function\") {\n        validators.push(this._invokeCustomValidator(test, validatorType, true, value, field));\n        return;\n      }\n      if (value === null || value === void 0) {\n        return;\n      }\n      const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field);\n      validatorPromise.catch(() => {\n      });\n      validators.push(validatorPromise);\n    });\n    return Promise.all(validators.map((validator2) => validator2.catch((rejection) => {\n      const isBuiltIn = !!rejection.validatorName;\n      this._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);\n    })));\n  }\n  async _invokeCustomValidator(validator2, validatorType, optAttrDefined, optValue, optField) {\n    let isAsync = false;\n    const validatorArity = validator2.length;\n    let asyncArity = 1;\n    let errorKey = validatorType;\n    let invokeArgs;\n    if (optAttrDefined) {\n      asyncArity = 2;\n      invokeArgs = optValue;\n      errorKey = optField;\n    }\n    if (validatorArity === asyncArity) {\n      isAsync = true;\n    }\n    if (isAsync) {\n      try {\n        if (optAttrDefined) {\n          return await promisify(validator2.bind(this.modelInstance, invokeArgs))();\n        }\n        return await promisify(validator2.bind(this.modelInstance))();\n      } catch (e) {\n        return this._pushError(false, errorKey, e, optValue, validatorType);\n      }\n    }\n    try {\n      return await validator2.call(this.modelInstance, invokeArgs);\n    } catch (e) {\n      return this._pushError(false, errorKey, e, optValue, validatorType);\n    }\n  }\n  async _invokeBuiltinValidator(value, test, validatorType, field) {\n    const valueString = String(value);\n    if (typeof validator[validatorType] !== \"function\") {\n      throw new Error(`Invalid validator function: ${validatorType}`);\n    }\n    const validatorArgs = this._extractValidatorArgs(test, validatorType, field);\n    if (!validator[validatorType](valueString, ...validatorArgs)) {\n      throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), { validatorName: validatorType, validatorArgs });\n    }\n  }\n  _extractValidatorArgs(test, validatorType, field) {\n    let validatorArgs = test.args || test;\n    const isLocalizedValidator = typeof validatorArgs !== \"string\" && [\"isAlpha\", \"isAlphanumeric\", \"isMobilePhone\"].includes(validatorType);\n    if (!Array.isArray(validatorArgs)) {\n      if (validatorType === \"isImmutable\") {\n        validatorArgs = [validatorArgs, field, this.modelInstance];\n      } else if (isLocalizedValidator || validatorType === \"isIP\") {\n        validatorArgs = [];\n      } else {\n        validatorArgs = [validatorArgs];\n      }\n    } else {\n      validatorArgs = validatorArgs.slice(0);\n    }\n    return validatorArgs;\n  }\n  _validateSchema(rawAttribute, field, value) {\n    if (rawAttribute.allowNull === false && (value === null || value === void 0)) {\n      const association = Object.values(this.modelInstance.constructor.associations).find((association2) => association2 instanceof BelongsTo && association2.foreignKey === rawAttribute.fieldName);\n      if (!association || !this.modelInstance.get(association.associationAccessor)) {\n        const validators = this.modelInstance.validators[field];\n        const errMsg = _.get(validators, \"notNull.msg\", `${this.modelInstance.constructor.name}.${field} cannot be null`);\n        this.errors.push(new sequelizeError.ValidationErrorItem(errMsg, \"notNull Violation\", field, value, this.modelInstance, \"is_null\"));\n      }\n    }\n    if (rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type instanceof DataTypes.TEXT || rawAttribute.type instanceof DataTypes.CITEXT) {\n      if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {\n        this.errors.push(new sequelizeError.ValidationErrorItem(`${field} cannot be an array or an object`, \"string violation\", field, value, this.modelInstance, \"not_a_string\"));\n      }\n    }\n  }\n  _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {\n    const message = rawError.message || rawError || \"Validation error\";\n    const error = new sequelizeError.ValidationErrorItem(message, \"Validation error\", errorKey, value, this.modelInstance, fnName, isBuiltin ? fnName : void 0, isBuiltin ? fnArgs : void 0);\n    error[InstanceValidator.RAW_KEY_NAME] = rawError;\n    this.errors.push(error);\n  }\n}\nInstanceValidator.RAW_KEY_NAME = \"original\";\nmodule.exports = InstanceValidator;\nmodule.exports.InstanceValidator = InstanceValidator;\nmodule.exports[\"default\"] = InstanceValidator;\n//# sourceMappingURL=instance-validator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9pbnN0YW5jZS12YWxpZGF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLGlFQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyx3RUFBUztBQUMvQix1QkFBdUIsbUJBQU8sQ0FBQyxnRkFBVTtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQyxrRkFBYztBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQyw0R0FBMkI7QUFDckQsa0JBQWtCLDJJQUE2QztBQUMvRCxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsOERBQThELGVBQWUsS0FBSyxPQUFPLFlBQVksNkNBQTZDO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsb0NBQW9DLEdBQUcsT0FBTztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLE9BQU87QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9pbnN0YW5jZS12YWxpZGF0b3IuanM/MzYwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9yID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4vZGF0YS10eXBlc1wiKTtcbmNvbnN0IEJlbG9uZ3NUbyA9IHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvXCIpO1xuY29uc3QgdmFsaWRhdG9yID0gcmVxdWlyZShcIi4vdXRpbHMvdmFsaWRhdG9yLWV4dHJhc1wiKS52YWxpZGF0b3I7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZShcInV0aWxcIik7XG5jbGFzcyBJbnN0YW5jZVZhbGlkYXRvciB7XG4gIGNvbnN0cnVjdG9yKG1vZGVsSW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgaG9va3M6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5maWVsZHMgJiYgIW9wdGlvbnMuc2tpcCkge1xuICAgICAgb3B0aW9ucy5za2lwID0gXy5kaWZmZXJlbmNlKE9iamVjdC5rZXlzKG1vZGVsSW5zdGFuY2UuY29uc3RydWN0b3IucmF3QXR0cmlidXRlcyksIG9wdGlvbnMuZmllbGRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5za2lwID0gb3B0aW9ucy5za2lwIHx8IFtdO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMubW9kZWxJbnN0YW5jZSA9IG1vZGVsSW5zdGFuY2U7XG4gICAgdGhpcy52YWxpZGF0b3IgPSB2YWxpZGF0b3I7XG4gICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICB0aGlzLmluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgfVxuICBhc3luYyBfdmFsaWRhdGUoKSB7XG4gICAgaWYgKHRoaXMuaW5Qcm9ncmVzcylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRpb25zIGFscmVhZHkgaW4gcHJvZ3Jlc3MuXCIpO1xuICAgIHRoaXMuaW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5fcGVyQXR0cmlidXRlVmFsaWRhdG9ycygpLFxuICAgICAgdGhpcy5fY3VzdG9tVmFsaWRhdG9ycygpXG4gICAgXSk7XG4gICAgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9yLlZhbGlkYXRpb25FcnJvcihudWxsLCB0aGlzLmVycm9ycyk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHZhbGlkYXRlKCkge1xuICAgIHJldHVybiBhd2FpdCAodGhpcy5vcHRpb25zLmhvb2tzID8gdGhpcy5fdmFsaWRhdGVBbmRSdW5Ib29rcygpIDogdGhpcy5fdmFsaWRhdGUoKSk7XG4gIH1cbiAgYXN5bmMgX3ZhbGlkYXRlQW5kUnVuSG9va3MoKSB7XG4gICAgY29uc3QgcnVuSG9va3MgPSB0aGlzLm1vZGVsSW5zdGFuY2UuY29uc3RydWN0b3IucnVuSG9va3MuYmluZCh0aGlzLm1vZGVsSW5zdGFuY2UuY29uc3RydWN0b3IpO1xuICAgIGF3YWl0IHJ1bkhvb2tzKFwiYmVmb3JlVmFsaWRhdGVcIiwgdGhpcy5tb2RlbEluc3RhbmNlLCB0aGlzLm9wdGlvbnMpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl92YWxpZGF0ZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBuZXdFcnJvciA9IGF3YWl0IHJ1bkhvb2tzKFwidmFsaWRhdGlvbkZhaWxlZFwiLCB0aGlzLm1vZGVsSW5zdGFuY2UsIHRoaXMub3B0aW9ucywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3RXJyb3IgfHwgZXJyb3I7XG4gICAgfVxuICAgIGF3YWl0IHJ1bkhvb2tzKFwiYWZ0ZXJWYWxpZGF0ZVwiLCB0aGlzLm1vZGVsSW5zdGFuY2UsIHRoaXMub3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMubW9kZWxJbnN0YW5jZTtcbiAgfVxuICBhc3luYyBfcGVyQXR0cmlidXRlVmFsaWRhdG9ycygpIHtcbiAgICBjb25zdCB2YWxpZGF0b3JzID0gW107XG4gICAgXy5mb3JJbih0aGlzLm1vZGVsSW5zdGFuY2UucmF3QXR0cmlidXRlcywgKHJhd0F0dHJpYnV0ZSwgZmllbGQpID0+IHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2tpcC5pbmNsdWRlcyhmaWVsZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLm1vZGVsSW5zdGFuY2UuZGF0YVZhbHVlc1tmaWVsZF07XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFyYXdBdHRyaWJ1dGUuX2F1dG9HZW5lcmF0ZWQgJiYgIXJhd0F0dHJpYnV0ZS5hdXRvSW5jcmVtZW50KSB7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlU2NoZW1hKHJhd0F0dHJpYnV0ZSwgZmllbGQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5tb2RlbEluc3RhbmNlLnZhbGlkYXRvcnMsIGZpZWxkKSkge1xuICAgICAgICB2YWxpZGF0b3JzLnB1c2godGhpcy5fc2luZ2xlQXR0clZhbGlkYXRlKHZhbHVlLCBmaWVsZCwgcmF3QXR0cmlidXRlLmFsbG93TnVsbCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbCh2YWxpZGF0b3JzKTtcbiAgfVxuICBhc3luYyBfY3VzdG9tVmFsaWRhdG9ycygpIHtcbiAgICBjb25zdCB2YWxpZGF0b3JzID0gW107XG4gICAgXy5lYWNoKHRoaXMubW9kZWxJbnN0YW5jZS5jb25zdHJ1Y3Rvci5vcHRpb25zLnZhbGlkYXRlLCAodmFsaWRhdG9yMiwgdmFsaWRhdG9yVHlwZSkgPT4ge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5za2lwLmluY2x1ZGVzKHZhbGlkYXRvclR5cGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHByb20gPSB0aGlzLl9pbnZva2VDdXN0b21WYWxpZGF0b3IodmFsaWRhdG9yMiwgdmFsaWRhdG9yVHlwZSkuY2F0Y2goKCkgPT4ge1xuICAgICAgfSk7XG4gICAgICB2YWxpZGF0b3JzLnB1c2godmFscHJvbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHZhbGlkYXRvcnMpO1xuICB9XG4gIGFzeW5jIF9zaW5nbGVBdHRyVmFsaWRhdGUodmFsdWUsIGZpZWxkLCBhbGxvd051bGwpIHtcbiAgICBpZiAoKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDApICYmICFhbGxvd051bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdG9ycyA9IFtdO1xuICAgIF8uZm9ySW4odGhpcy5tb2RlbEluc3RhbmNlLnZhbGlkYXRvcnNbZmllbGRdLCAodGVzdCwgdmFsaWRhdG9yVHlwZSkgPT4ge1xuICAgICAgaWYgKFtcImlzVXJsXCIsIFwiaXNVUkxcIiwgXCJpc0VtYWlsXCJdLmluY2x1ZGVzKHZhbGlkYXRvclR5cGUpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGVzdCA9PT0gXCJvYmplY3RcIiAmJiB0ZXN0ICE9PSBudWxsICYmIHRlc3QubXNnKSB7XG4gICAgICAgICAgdGVzdCA9IHtcbiAgICAgICAgICAgIG1zZzogdGVzdC5tc2dcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHRlc3QgPT09IHRydWUpIHtcbiAgICAgICAgICB0ZXN0ID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdGVzdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhbGlkYXRvcnMucHVzaCh0aGlzLl9pbnZva2VDdXN0b21WYWxpZGF0b3IodGVzdCwgdmFsaWRhdG9yVHlwZSwgdHJ1ZSwgdmFsdWUsIGZpZWxkKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbGlkYXRvclByb21pc2UgPSB0aGlzLl9pbnZva2VCdWlsdGluVmFsaWRhdG9yKHZhbHVlLCB0ZXN0LCB2YWxpZGF0b3JUeXBlLCBmaWVsZCk7XG4gICAgICB2YWxpZGF0b3JQcm9taXNlLmNhdGNoKCgpID0+IHtcbiAgICAgIH0pO1xuICAgICAgdmFsaWRhdG9ycy5wdXNoKHZhbGlkYXRvclByb21pc2UpO1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbCh2YWxpZGF0b3JzLm1hcCgodmFsaWRhdG9yMikgPT4gdmFsaWRhdG9yMi5jYXRjaCgocmVqZWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBpc0J1aWx0SW4gPSAhIXJlamVjdGlvbi52YWxpZGF0b3JOYW1lO1xuICAgICAgdGhpcy5fcHVzaEVycm9yKGlzQnVpbHRJbiwgZmllbGQsIHJlamVjdGlvbiwgdmFsdWUsIHJlamVjdGlvbi52YWxpZGF0b3JOYW1lLCByZWplY3Rpb24udmFsaWRhdG9yQXJncyk7XG4gICAgfSkpKTtcbiAgfVxuICBhc3luYyBfaW52b2tlQ3VzdG9tVmFsaWRhdG9yKHZhbGlkYXRvcjIsIHZhbGlkYXRvclR5cGUsIG9wdEF0dHJEZWZpbmVkLCBvcHRWYWx1ZSwgb3B0RmllbGQpIHtcbiAgICBsZXQgaXNBc3luYyA9IGZhbHNlO1xuICAgIGNvbnN0IHZhbGlkYXRvckFyaXR5ID0gdmFsaWRhdG9yMi5sZW5ndGg7XG4gICAgbGV0IGFzeW5jQXJpdHkgPSAxO1xuICAgIGxldCBlcnJvcktleSA9IHZhbGlkYXRvclR5cGU7XG4gICAgbGV0IGludm9rZUFyZ3M7XG4gICAgaWYgKG9wdEF0dHJEZWZpbmVkKSB7XG4gICAgICBhc3luY0FyaXR5ID0gMjtcbiAgICAgIGludm9rZUFyZ3MgPSBvcHRWYWx1ZTtcbiAgICAgIGVycm9yS2V5ID0gb3B0RmllbGQ7XG4gICAgfVxuICAgIGlmICh2YWxpZGF0b3JBcml0eSA9PT0gYXN5bmNBcml0eSkge1xuICAgICAgaXNBc3luYyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpc0FzeW5jKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAob3B0QXR0ckRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvbWlzaWZ5KHZhbGlkYXRvcjIuYmluZCh0aGlzLm1vZGVsSW5zdGFuY2UsIGludm9rZUFyZ3MpKSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm9taXNpZnkodmFsaWRhdG9yMi5iaW5kKHRoaXMubW9kZWxJbnN0YW5jZSkpKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoRXJyb3IoZmFsc2UsIGVycm9yS2V5LCBlLCBvcHRWYWx1ZSwgdmFsaWRhdG9yVHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdmFsaWRhdG9yMi5jYWxsKHRoaXMubW9kZWxJbnN0YW5jZSwgaW52b2tlQXJncyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hFcnJvcihmYWxzZSwgZXJyb3JLZXksIGUsIG9wdFZhbHVlLCB2YWxpZGF0b3JUeXBlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgX2ludm9rZUJ1aWx0aW5WYWxpZGF0b3IodmFsdWUsIHRlc3QsIHZhbGlkYXRvclR5cGUsIGZpZWxkKSB7XG4gICAgY29uc3QgdmFsdWVTdHJpbmcgPSBTdHJpbmcodmFsdWUpO1xuICAgIGlmICh0eXBlb2YgdmFsaWRhdG9yW3ZhbGlkYXRvclR5cGVdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWxpZGF0b3IgZnVuY3Rpb246ICR7dmFsaWRhdG9yVHlwZX1gKTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdG9yQXJncyA9IHRoaXMuX2V4dHJhY3RWYWxpZGF0b3JBcmdzKHRlc3QsIHZhbGlkYXRvclR5cGUsIGZpZWxkKTtcbiAgICBpZiAoIXZhbGlkYXRvclt2YWxpZGF0b3JUeXBlXSh2YWx1ZVN0cmluZywgLi4udmFsaWRhdG9yQXJncykpIHtcbiAgICAgIHRocm93IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKHRlc3QubXNnIHx8IGBWYWxpZGF0aW9uICR7dmFsaWRhdG9yVHlwZX0gb24gJHtmaWVsZH0gZmFpbGVkYCksIHsgdmFsaWRhdG9yTmFtZTogdmFsaWRhdG9yVHlwZSwgdmFsaWRhdG9yQXJncyB9KTtcbiAgICB9XG4gIH1cbiAgX2V4dHJhY3RWYWxpZGF0b3JBcmdzKHRlc3QsIHZhbGlkYXRvclR5cGUsIGZpZWxkKSB7XG4gICAgbGV0IHZhbGlkYXRvckFyZ3MgPSB0ZXN0LmFyZ3MgfHwgdGVzdDtcbiAgICBjb25zdCBpc0xvY2FsaXplZFZhbGlkYXRvciA9IHR5cGVvZiB2YWxpZGF0b3JBcmdzICE9PSBcInN0cmluZ1wiICYmIFtcImlzQWxwaGFcIiwgXCJpc0FscGhhbnVtZXJpY1wiLCBcImlzTW9iaWxlUGhvbmVcIl0uaW5jbHVkZXModmFsaWRhdG9yVHlwZSk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbGlkYXRvckFyZ3MpKSB7XG4gICAgICBpZiAodmFsaWRhdG9yVHlwZSA9PT0gXCJpc0ltbXV0YWJsZVwiKSB7XG4gICAgICAgIHZhbGlkYXRvckFyZ3MgPSBbdmFsaWRhdG9yQXJncywgZmllbGQsIHRoaXMubW9kZWxJbnN0YW5jZV07XG4gICAgICB9IGVsc2UgaWYgKGlzTG9jYWxpemVkVmFsaWRhdG9yIHx8IHZhbGlkYXRvclR5cGUgPT09IFwiaXNJUFwiKSB7XG4gICAgICAgIHZhbGlkYXRvckFyZ3MgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbGlkYXRvckFyZ3MgPSBbdmFsaWRhdG9yQXJnc107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRvckFyZ3MgPSB2YWxpZGF0b3JBcmdzLnNsaWNlKDApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdG9yQXJncztcbiAgfVxuICBfdmFsaWRhdGVTY2hlbWEocmF3QXR0cmlidXRlLCBmaWVsZCwgdmFsdWUpIHtcbiAgICBpZiAocmF3QXR0cmlidXRlLmFsbG93TnVsbCA9PT0gZmFsc2UgJiYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDApKSB7XG4gICAgICBjb25zdCBhc3NvY2lhdGlvbiA9IE9iamVjdC52YWx1ZXModGhpcy5tb2RlbEluc3RhbmNlLmNvbnN0cnVjdG9yLmFzc29jaWF0aW9ucykuZmluZCgoYXNzb2NpYXRpb24yKSA9PiBhc3NvY2lhdGlvbjIgaW5zdGFuY2VvZiBCZWxvbmdzVG8gJiYgYXNzb2NpYXRpb24yLmZvcmVpZ25LZXkgPT09IHJhd0F0dHJpYnV0ZS5maWVsZE5hbWUpO1xuICAgICAgaWYgKCFhc3NvY2lhdGlvbiB8fCAhdGhpcy5tb2RlbEluc3RhbmNlLmdldChhc3NvY2lhdGlvbi5hc3NvY2lhdGlvbkFjY2Vzc29yKSkge1xuICAgICAgICBjb25zdCB2YWxpZGF0b3JzID0gdGhpcy5tb2RlbEluc3RhbmNlLnZhbGlkYXRvcnNbZmllbGRdO1xuICAgICAgICBjb25zdCBlcnJNc2cgPSBfLmdldCh2YWxpZGF0b3JzLCBcIm5vdE51bGwubXNnXCIsIGAke3RoaXMubW9kZWxJbnN0YW5jZS5jb25zdHJ1Y3Rvci5uYW1lfS4ke2ZpZWxkfSBjYW5ub3QgYmUgbnVsbGApO1xuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtKGVyck1zZywgXCJub3ROdWxsIFZpb2xhdGlvblwiLCBmaWVsZCwgdmFsdWUsIHRoaXMubW9kZWxJbnN0YW5jZSwgXCJpc19udWxsXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJhd0F0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLlNUUklORyB8fCByYXdBdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5URVhUIHx8IHJhd0F0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkNJVEVYVCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IF8uaXNPYmplY3QodmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpICYmICFCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IHNlcXVlbGl6ZUVycm9yLlZhbGlkYXRpb25FcnJvckl0ZW0oYCR7ZmllbGR9IGNhbm5vdCBiZSBhbiBhcnJheSBvciBhbiBvYmplY3RgLCBcInN0cmluZyB2aW9sYXRpb25cIiwgZmllbGQsIHZhbHVlLCB0aGlzLm1vZGVsSW5zdGFuY2UsIFwibm90X2Ffc3RyaW5nXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3B1c2hFcnJvcihpc0J1aWx0aW4sIGVycm9yS2V5LCByYXdFcnJvciwgdmFsdWUsIGZuTmFtZSwgZm5BcmdzKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHJhd0Vycm9yLm1lc3NhZ2UgfHwgcmF3RXJyb3IgfHwgXCJWYWxpZGF0aW9uIGVycm9yXCI7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgc2VxdWVsaXplRXJyb3IuVmFsaWRhdGlvbkVycm9ySXRlbShtZXNzYWdlLCBcIlZhbGlkYXRpb24gZXJyb3JcIiwgZXJyb3JLZXksIHZhbHVlLCB0aGlzLm1vZGVsSW5zdGFuY2UsIGZuTmFtZSwgaXNCdWlsdGluID8gZm5OYW1lIDogdm9pZCAwLCBpc0J1aWx0aW4gPyBmbkFyZ3MgOiB2b2lkIDApO1xuICAgIGVycm9yW0luc3RhbmNlVmFsaWRhdG9yLlJBV19LRVlfTkFNRV0gPSByYXdFcnJvcjtcbiAgICB0aGlzLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgfVxufVxuSW5zdGFuY2VWYWxpZGF0b3IuUkFXX0tFWV9OQU1FID0gXCJvcmlnaW5hbFwiO1xubW9kdWxlLmV4cG9ydHMgPSBJbnN0YW5jZVZhbGlkYXRvcjtcbm1vZHVsZS5leHBvcnRzLkluc3RhbmNlVmFsaWRhdG9yID0gSW5zdGFuY2VWYWxpZGF0b3I7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gSW5zdGFuY2VWYWxpZGF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnN0YW5jZS12YWxpZGF0b3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/instance-validator.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/model-manager.js":
/*!******************************************************!*\
  !*** ../node_modules/sequelize/lib/model-manager.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Toposort = __webpack_require__(/*! toposort-class */ \"(action-browser)/../node_modules/toposort-class/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nclass ModelManager {\n  constructor(sequelize) {\n    this.models = [];\n    this.sequelize = sequelize;\n  }\n  addModel(model) {\n    this.models.push(model);\n    this.sequelize.models[model.name] = model;\n    return model;\n  }\n  removeModel(modelToRemove) {\n    this.models = this.models.filter((model) => model.name !== modelToRemove.name);\n    delete this.sequelize.models[modelToRemove.name];\n  }\n  getModel(against, options) {\n    options = _.defaults(options || {}, {\n      attribute: \"name\"\n    });\n    return this.models.find((model) => model[options.attribute] === against);\n  }\n  findModel(callback) {\n    return this.models.find(callback);\n  }\n  get all() {\n    return this.models;\n  }\n  getModelsTopoSortedByForeignKey() {\n    const models = /* @__PURE__ */ new Map();\n    const sorter = new Toposort();\n    for (const model of this.models) {\n      let deps = [];\n      let tableName = model.getTableName();\n      if (_.isObject(tableName)) {\n        tableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n      models.set(tableName, model);\n      for (const attrName in model.rawAttributes) {\n        if (Object.prototype.hasOwnProperty.call(model.rawAttributes, attrName)) {\n          const attribute = model.rawAttributes[attrName];\n          if (attribute.references) {\n            let dep = attribute.references.model;\n            if (_.isObject(dep)) {\n              dep = `${dep.schema}.${dep.tableName}`;\n            }\n            deps.push(dep);\n          }\n        }\n      }\n      deps = deps.filter((dep) => tableName !== dep);\n      sorter.add(tableName, deps);\n    }\n    let sorted;\n    try {\n      sorted = sorter.sort();\n    } catch (e) {\n      if (!e.message.startsWith(\"Cyclic dependency found.\")) {\n        throw e;\n      }\n      return null;\n    }\n    return sorted.map((modelName) => {\n      return models.get(modelName);\n    }).filter(Boolean);\n  }\n  forEachModel(iterator, options) {\n    const sortedModels = this.getModelsTopoSortedByForeignKey();\n    if (sortedModels == null) {\n      throw new Error(\"Cyclic dependency found.\");\n    }\n    options = _.defaults(options || {}, {\n      reverse: true\n    });\n    if (options.reverse) {\n      sortedModels.reverse();\n    }\n    for (const model of sortedModels) {\n      iterator(model);\n    }\n  }\n}\nmodule.exports = ModelManager;\nmodule.exports.ModelManager = ModelManager;\nmodule.exports[\"default\"] = ModelManager;\n//# sourceMappingURL=model-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9tb2RlbC1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQWdCO0FBQ3pDLFVBQVUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQixHQUFHLG9CQUFvQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVcsR0FBRyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQix5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvbW9kZWwtbWFuYWdlci5qcz83NDViIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgVG9wb3NvcnQgPSByZXF1aXJlKFwidG9wb3NvcnQtY2xhc3NcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNsYXNzIE1vZGVsTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKHNlcXVlbGl6ZSkge1xuICAgIHRoaXMubW9kZWxzID0gW107XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gIH1cbiAgYWRkTW9kZWwobW9kZWwpIHtcbiAgICB0aGlzLm1vZGVscy5wdXNoKG1vZGVsKTtcbiAgICB0aGlzLnNlcXVlbGl6ZS5tb2RlbHNbbW9kZWwubmFtZV0gPSBtb2RlbDtcbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgcmVtb3ZlTW9kZWwobW9kZWxUb1JlbW92ZSkge1xuICAgIHRoaXMubW9kZWxzID0gdGhpcy5tb2RlbHMuZmlsdGVyKChtb2RlbCkgPT4gbW9kZWwubmFtZSAhPT0gbW9kZWxUb1JlbW92ZS5uYW1lKTtcbiAgICBkZWxldGUgdGhpcy5zZXF1ZWxpemUubW9kZWxzW21vZGVsVG9SZW1vdmUubmFtZV07XG4gIH1cbiAgZ2V0TW9kZWwoYWdhaW5zdCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMgfHwge30sIHtcbiAgICAgIGF0dHJpYnV0ZTogXCJuYW1lXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5tb2RlbHMuZmluZCgobW9kZWwpID0+IG1vZGVsW29wdGlvbnMuYXR0cmlidXRlXSA9PT0gYWdhaW5zdCk7XG4gIH1cbiAgZmluZE1vZGVsKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZWxzLmZpbmQoY2FsbGJhY2spO1xuICB9XG4gIGdldCBhbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZWxzO1xuICB9XG4gIGdldE1vZGVsc1RvcG9Tb3J0ZWRCeUZvcmVpZ25LZXkoKSB7XG4gICAgY29uc3QgbW9kZWxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBzb3J0ZXIgPSBuZXcgVG9wb3NvcnQoKTtcbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHRoaXMubW9kZWxzKSB7XG4gICAgICBsZXQgZGVwcyA9IFtdO1xuICAgICAgbGV0IHRhYmxlTmFtZSA9IG1vZGVsLmdldFRhYmxlTmFtZSgpO1xuICAgICAgaWYgKF8uaXNPYmplY3QodGFibGVOYW1lKSkge1xuICAgICAgICB0YWJsZU5hbWUgPSBgJHt0YWJsZU5hbWUuc2NoZW1hfS4ke3RhYmxlTmFtZS50YWJsZU5hbWV9YDtcbiAgICAgIH1cbiAgICAgIG1vZGVscy5zZXQodGFibGVOYW1lLCBtb2RlbCk7XG4gICAgICBmb3IgKGNvbnN0IGF0dHJOYW1lIGluIG1vZGVsLnJhd0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2RlbC5yYXdBdHRyaWJ1dGVzLCBhdHRyTmFtZSkpIHtcbiAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBtb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJOYW1lXTtcbiAgICAgICAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIGxldCBkZXAgPSBhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbDtcbiAgICAgICAgICAgIGlmIChfLmlzT2JqZWN0KGRlcCkpIHtcbiAgICAgICAgICAgICAgZGVwID0gYCR7ZGVwLnNjaGVtYX0uJHtkZXAudGFibGVOYW1lfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXBzLnB1c2goZGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlcHMgPSBkZXBzLmZpbHRlcigoZGVwKSA9PiB0YWJsZU5hbWUgIT09IGRlcCk7XG4gICAgICBzb3J0ZXIuYWRkKHRhYmxlTmFtZSwgZGVwcyk7XG4gICAgfVxuICAgIGxldCBzb3J0ZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHNvcnRlZCA9IHNvcnRlci5zb3J0KCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCFlLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkN5Y2xpYyBkZXBlbmRlbmN5IGZvdW5kLlwiKSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBzb3J0ZWQubWFwKChtb2RlbE5hbWUpID0+IHtcbiAgICAgIHJldHVybiBtb2RlbHMuZ2V0KG1vZGVsTmFtZSk7XG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICB9XG4gIGZvckVhY2hNb2RlbChpdGVyYXRvciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNvcnRlZE1vZGVscyA9IHRoaXMuZ2V0TW9kZWxzVG9wb1NvcnRlZEJ5Rm9yZWlnbktleSgpO1xuICAgIGlmIChzb3J0ZWRNb2RlbHMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3ljbGljIGRlcGVuZGVuY3kgZm91bmQuXCIpO1xuICAgIH1cbiAgICBvcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zIHx8IHt9LCB7XG4gICAgICByZXZlcnNlOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgc29ydGVkTW9kZWxzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiBzb3J0ZWRNb2RlbHMpIHtcbiAgICAgIGl0ZXJhdG9yKG1vZGVsKTtcbiAgICB9XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gTW9kZWxNYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuTW9kZWxNYW5hZ2VyID0gTW9kZWxNYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IE1vZGVsTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGVsLW1hbmFnZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/model-manager.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/model.js":
/*!**********************************************!*\
  !*** ../node_modules/sequelize/lib/model.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst Dottie = __webpack_require__(/*! dottie */ \"(action-browser)/../node_modules/dottie/dottie.js\");\nconst Utils = __webpack_require__(/*! ./utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst { logger } = __webpack_require__(/*! ./utils/logger */ \"(action-browser)/../node_modules/sequelize/lib/utils/logger.js\");\nconst BelongsTo = __webpack_require__(/*! ./associations/belongs-to */ \"(action-browser)/../node_modules/sequelize/lib/associations/belongs-to.js\");\nconst BelongsToMany = __webpack_require__(/*! ./associations/belongs-to-many */ \"(action-browser)/../node_modules/sequelize/lib/associations/belongs-to-many.js\");\nconst InstanceValidator = __webpack_require__(/*! ./instance-validator */ \"(action-browser)/../node_modules/sequelize/lib/instance-validator.js\");\nconst QueryTypes = __webpack_require__(/*! ./query-types */ \"(action-browser)/../node_modules/sequelize/lib/query-types.js\");\nconst sequelizeErrors = __webpack_require__(/*! ./errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst Association = __webpack_require__(/*! ./associations/base */ \"(action-browser)/../node_modules/sequelize/lib/associations/base.js\");\nconst HasMany = __webpack_require__(/*! ./associations/has-many */ \"(action-browser)/../node_modules/sequelize/lib/associations/has-many.js\");\nconst DataTypes = __webpack_require__(/*! ./data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\");\nconst Hooks = __webpack_require__(/*! ./hooks */ \"(action-browser)/../node_modules/sequelize/lib/hooks.js\");\nconst associationsMixin = __webpack_require__(/*! ./associations/mixin */ \"(action-browser)/../node_modules/sequelize/lib/associations/mixin.js\");\nconst Op = __webpack_require__(/*! ./operators */ \"(action-browser)/../node_modules/sequelize/lib/operators.js\");\nconst { noDoubleNestedGroup } = __webpack_require__(/*! ./utils/deprecations */ \"(action-browser)/../node_modules/sequelize/lib/utils/deprecations.js\");\nconst validQueryKeywords = /* @__PURE__ */ new Set([\n  \"where\",\n  \"attributes\",\n  \"paranoid\",\n  \"include\",\n  \"order\",\n  \"limit\",\n  \"offset\",\n  \"transaction\",\n  \"lock\",\n  \"raw\",\n  \"logging\",\n  \"benchmark\",\n  \"having\",\n  \"searchPath\",\n  \"rejectOnEmpty\",\n  \"plain\",\n  \"scope\",\n  \"group\",\n  \"through\",\n  \"defaults\",\n  \"distinct\",\n  \"primary\",\n  \"exception\",\n  \"type\",\n  \"hooks\",\n  \"force\",\n  \"name\"\n]);\nconst nonCascadingOptions = [\"include\", \"attributes\", \"originalAttributes\", \"order\", \"where\", \"limit\", \"offset\", \"plain\", \"group\", \"having\"];\nclass Model {\n  static get queryInterface() {\n    return this.sequelize.getQueryInterface();\n  }\n  static get queryGenerator() {\n    return this.queryInterface.queryGenerator;\n  }\n  get sequelize() {\n    return this.constructor.sequelize;\n  }\n  constructor(values = {}, options = {}) {\n    if (!this.constructor._overwrittenAttributesChecked) {\n      this.constructor._overwrittenAttributesChecked = true;\n      setTimeout(() => {\n        const overwrittenAttributes = [];\n        for (const key of Object.keys(this.constructor._attributeManipulation)) {\n          if (Object.prototype.hasOwnProperty.call(this, key)) {\n            overwrittenAttributes.push(key);\n          }\n        }\n        if (overwrittenAttributes.length > 0) {\n          logger.warn(`Model ${JSON.stringify(this.constructor.name)} is declaring public class fields for attribute(s): ${overwrittenAttributes.map((attr) => JSON.stringify(attr)).join(\", \")}.\nThese class fields are shadowing Sequelize's attribute getters & setters.\nSee https://sequelize.org/main/manual/model-basics.html#caveat-with-public-class-fields`);\n        }\n      }, 0);\n    }\n    options = __spreadValues({\n      isNewRecord: true,\n      _schema: this.constructor._schema,\n      _schemaDelimiter: this.constructor._schemaDelimiter\n    }, options);\n    if (options.attributes) {\n      options.attributes = options.attributes.map((attribute) => Array.isArray(attribute) ? attribute[1] : attribute);\n    }\n    if (!options.includeValidated) {\n      this.constructor._conformIncludes(options, this.constructor);\n      if (options.include) {\n        this.constructor._expandIncludeAll(options);\n        this.constructor._validateIncludedElements(options);\n      }\n    }\n    this.dataValues = {};\n    this._previousDataValues = {};\n    this.uniqno = 1;\n    this._changed = /* @__PURE__ */ new Set();\n    this._options = options;\n    this.isNewRecord = options.isNewRecord;\n    this._initValues(values, options);\n  }\n  _initValues(values, options) {\n    let defaults;\n    let key;\n    values = __spreadValues({}, values);\n    if (options.isNewRecord) {\n      defaults = {};\n      if (this.constructor._hasDefaultValues) {\n        defaults = _.mapValues(this.constructor._defaultValues, (valueFn) => {\n          const value = valueFn();\n          return value && value instanceof Utils.SequelizeMethod ? value : _.cloneDeep(value);\n        });\n      }\n      if (this.constructor.primaryKeyAttributes.length) {\n        this.constructor.primaryKeyAttributes.forEach((primaryKeyAttribute) => {\n          if (!Object.prototype.hasOwnProperty.call(defaults, primaryKeyAttribute)) {\n            defaults[primaryKeyAttribute] = null;\n          }\n        });\n      }\n      if (this.constructor._timestampAttributes.createdAt && defaults[this.constructor._timestampAttributes.createdAt]) {\n        this.dataValues[this.constructor._timestampAttributes.createdAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.createdAt], this.sequelize.options.dialect);\n        delete defaults[this.constructor._timestampAttributes.createdAt];\n      }\n      if (this.constructor._timestampAttributes.updatedAt && defaults[this.constructor._timestampAttributes.updatedAt]) {\n        this.dataValues[this.constructor._timestampAttributes.updatedAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.updatedAt], this.sequelize.options.dialect);\n        delete defaults[this.constructor._timestampAttributes.updatedAt];\n      }\n      if (this.constructor._timestampAttributes.deletedAt && defaults[this.constructor._timestampAttributes.deletedAt]) {\n        this.dataValues[this.constructor._timestampAttributes.deletedAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.deletedAt], this.sequelize.options.dialect);\n        delete defaults[this.constructor._timestampAttributes.deletedAt];\n      }\n      for (key in defaults) {\n        if (values[key] === void 0) {\n          this.set(key, Utils.toDefaultValue(defaults[key], this.sequelize.options.dialect), { raw: true });\n          delete values[key];\n        }\n      }\n    }\n    this.set(values, options);\n  }\n  static _paranoidClause(model, options = {}) {\n    if (options.include) {\n      for (const include of options.include) {\n        this._paranoidClause(include.model, include);\n      }\n    }\n    if (_.get(options, \"groupedLimit.on.options.paranoid\")) {\n      const throughModel = _.get(options, \"groupedLimit.on.through.model\");\n      if (throughModel) {\n        options.groupedLimit.through = this._paranoidClause(throughModel, options.groupedLimit.through);\n      }\n    }\n    if (!model.options.timestamps || !model.options.paranoid || options.paranoid === false) {\n      return options;\n    }\n    const deletedAtCol = model._timestampAttributes.deletedAt;\n    const deletedAtAttribute = model.rawAttributes[deletedAtCol];\n    const deletedAtObject = {};\n    let deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, \"defaultValue\") ? deletedAtAttribute.defaultValue : null;\n    deletedAtDefaultValue = deletedAtDefaultValue || {\n      [Op.eq]: null\n    };\n    deletedAtObject[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;\n    if (Utils.isWhereEmpty(options.where)) {\n      options.where = deletedAtObject;\n    } else {\n      options.where = { [Op.and]: [deletedAtObject, options.where] };\n    }\n    return options;\n  }\n  static _addDefaultAttributes() {\n    const tail = {};\n    let head = {};\n    if (!_.some(this.rawAttributes, \"primaryKey\")) {\n      if (\"id\" in this.rawAttributes) {\n        throw new Error(`A column called 'id' was added to the attributes of '${this.tableName}' but not marked with 'primaryKey: true'`);\n      }\n      head = {\n        id: {\n          type: new DataTypes.INTEGER(),\n          allowNull: false,\n          primaryKey: true,\n          autoIncrement: true,\n          _autoGenerated: true\n        }\n      };\n    }\n    if (this._timestampAttributes.createdAt) {\n      tail[this._timestampAttributes.createdAt] = {\n        type: DataTypes.DATE,\n        allowNull: false,\n        _autoGenerated: true\n      };\n    }\n    if (this._timestampAttributes.updatedAt) {\n      tail[this._timestampAttributes.updatedAt] = {\n        type: DataTypes.DATE,\n        allowNull: false,\n        _autoGenerated: true\n      };\n    }\n    if (this._timestampAttributes.deletedAt) {\n      tail[this._timestampAttributes.deletedAt] = {\n        type: DataTypes.DATE,\n        _autoGenerated: true\n      };\n    }\n    if (this._versionAttribute) {\n      tail[this._versionAttribute] = {\n        type: DataTypes.INTEGER,\n        allowNull: false,\n        defaultValue: 0,\n        _autoGenerated: true\n      };\n    }\n    const newRawAttributes = __spreadValues(__spreadValues({}, head), this.rawAttributes);\n    _.each(tail, (value, attr) => {\n      if (newRawAttributes[attr] === void 0) {\n        newRawAttributes[attr] = value;\n      }\n    });\n    this.rawAttributes = newRawAttributes;\n    if (!Object.keys(this.primaryKeys).length) {\n      this.primaryKeys.id = this.rawAttributes.id;\n    }\n  }\n  static getAttributes() {\n    return this.rawAttributes;\n  }\n  static _findAutoIncrementAttribute() {\n    this.autoIncrementAttribute = null;\n    for (const name in this.rawAttributes) {\n      if (Object.prototype.hasOwnProperty.call(this.rawAttributes, name)) {\n        const definition = this.rawAttributes[name];\n        if (definition && definition.autoIncrement) {\n          if (this.autoIncrementAttribute) {\n            throw new Error(\"Invalid Instance definition. Only one autoincrement field allowed.\");\n          }\n          this.autoIncrementAttribute = name;\n        }\n      }\n    }\n  }\n  static _conformIncludes(options, self) {\n    if (!options.include)\n      return;\n    if (!Array.isArray(options.include)) {\n      options.include = [options.include];\n    } else if (!options.include.length) {\n      delete options.include;\n      return;\n    }\n    options.include = options.include.map((include) => this._conformInclude(include, self));\n  }\n  static _transformStringAssociation(include, self) {\n    if (self && typeof include === \"string\") {\n      if (!Object.prototype.hasOwnProperty.call(self.associations, include)) {\n        throw new Error(`Association with alias \"${include}\" does not exist on ${self.name}`);\n      }\n      return self.associations[include];\n    }\n    return include;\n  }\n  static _conformInclude(include, self) {\n    if (include) {\n      let model;\n      if (include._pseudo)\n        return include;\n      include = this._transformStringAssociation(include, self);\n      if (include instanceof Association) {\n        if (self && include.target.name === self.name) {\n          model = include.source;\n        } else {\n          model = include.target;\n        }\n        return { model, association: include, as: include.as };\n      }\n      if (include.prototype && include.prototype instanceof Model) {\n        return { model: include };\n      }\n      if (_.isPlainObject(include)) {\n        if (include.association) {\n          include.association = this._transformStringAssociation(include.association, self);\n          if (self && include.association.target.name === self.name) {\n            model = include.association.source;\n          } else {\n            model = include.association.target;\n          }\n          if (!include.model)\n            include.model = model;\n          if (!include.as)\n            include.as = include.association.as;\n          this._conformIncludes(include, model);\n          return include;\n        }\n        if (include.model) {\n          this._conformIncludes(include, include.model);\n          return include;\n        }\n        if (include.all) {\n          this._conformIncludes(include);\n          return include;\n        }\n      }\n    }\n    throw new Error(\"Include unexpected. Element has to be either a Model, an Association or an object.\");\n  }\n  static _expandIncludeAllElement(includes, include) {\n    let all = include.all;\n    delete include.all;\n    if (all !== true) {\n      if (!Array.isArray(all)) {\n        all = [all];\n      }\n      const validTypes = {\n        BelongsTo: true,\n        HasOne: true,\n        HasMany: true,\n        One: [\"BelongsTo\", \"HasOne\"],\n        Has: [\"HasOne\", \"HasMany\"],\n        Many: [\"HasMany\"]\n      };\n      for (let i = 0; i < all.length; i++) {\n        const type = all[i];\n        if (type === \"All\") {\n          all = true;\n          break;\n        }\n        const types = validTypes[type];\n        if (!types) {\n          throw new sequelizeErrors.EagerLoadingError(`include all '${type}' is not valid - must be BelongsTo, HasOne, HasMany, One, Has, Many or All`);\n        }\n        if (types !== true) {\n          all.splice(i, 1);\n          i--;\n          for (let j = 0; j < types.length; j++) {\n            if (!all.includes(types[j])) {\n              all.unshift(types[j]);\n              i++;\n            }\n          }\n        }\n      }\n    }\n    const nested = include.nested;\n    if (nested) {\n      delete include.nested;\n      if (!include.include) {\n        include.include = [];\n      } else if (!Array.isArray(include.include)) {\n        include.include = [include.include];\n      }\n    }\n    const used = [];\n    (function addAllIncludes(parent, includes2) {\n      _.forEach(parent.associations, (association) => {\n        if (all !== true && !all.includes(association.associationType)) {\n          return;\n        }\n        const model = association.target;\n        const as = association.options.as;\n        const predicate = { model };\n        if (as) {\n          predicate.as = as;\n        }\n        if (_.some(includes2, predicate)) {\n          return;\n        }\n        if (nested && used.includes(model)) {\n          return;\n        }\n        used.push(parent);\n        const thisInclude = Utils.cloneDeep(include);\n        thisInclude.model = model;\n        if (as) {\n          thisInclude.as = as;\n        }\n        includes2.push(thisInclude);\n        if (nested) {\n          addAllIncludes(model, thisInclude.include);\n          if (thisInclude.include.length === 0)\n            delete thisInclude.include;\n        }\n      });\n      used.pop();\n    })(this, includes);\n  }\n  static _validateIncludedElements(options, tableNames) {\n    if (!options.model)\n      options.model = this;\n    tableNames = tableNames || {};\n    options.includeNames = [];\n    options.includeMap = {};\n    options.hasSingleAssociation = false;\n    options.hasMultiAssociation = false;\n    if (!options.parent) {\n      options.topModel = options.model;\n      options.topLimit = options.limit;\n    }\n    options.include = options.include.map((include) => {\n      include = this._conformInclude(include);\n      include.parent = options;\n      include.topLimit = options.topLimit;\n      this._validateIncludedElement.call(options.model, include, tableNames, options);\n      if (include.duplicating === void 0) {\n        include.duplicating = include.association.isMultiAssociation;\n      }\n      include.hasDuplicating = include.hasDuplicating || include.duplicating;\n      include.hasRequired = include.hasRequired || include.required;\n      options.hasDuplicating = options.hasDuplicating || include.hasDuplicating;\n      options.hasRequired = options.hasRequired || include.required;\n      options.hasWhere = options.hasWhere || include.hasWhere || !!include.where;\n      return include;\n    });\n    for (const include of options.include) {\n      include.hasParentWhere = options.hasParentWhere || !!options.where;\n      include.hasParentRequired = options.hasParentRequired || !!options.required;\n      if (include.subQuery !== false && options.hasDuplicating && options.topLimit) {\n        if (include.duplicating) {\n          include.subQuery = include.subQuery || false;\n          include.subQueryFilter = include.hasRequired;\n        } else {\n          include.subQuery = include.hasRequired;\n          include.subQueryFilter = false;\n        }\n      } else {\n        include.subQuery = include.subQuery || false;\n        if (include.duplicating) {\n          include.subQueryFilter = include.subQuery;\n        } else {\n          include.subQueryFilter = false;\n          include.subQuery = include.subQuery || include.hasParentRequired && include.hasRequired && !include.separate;\n        }\n      }\n      options.includeMap[include.as] = include;\n      options.includeNames.push(include.as);\n      if (options.topModel === options.model && options.subQuery === void 0 && options.topLimit) {\n        if (include.subQuery) {\n          options.subQuery = include.subQuery;\n        } else if (include.hasDuplicating) {\n          options.subQuery = true;\n        }\n      }\n      options.hasIncludeWhere = options.hasIncludeWhere || include.hasIncludeWhere || !!include.where;\n      options.hasIncludeRequired = options.hasIncludeRequired || include.hasIncludeRequired || !!include.required;\n      if (include.association.isMultiAssociation || include.hasMultiAssociation) {\n        options.hasMultiAssociation = true;\n      }\n      if (include.association.isSingleAssociation || include.hasSingleAssociation) {\n        options.hasSingleAssociation = true;\n      }\n    }\n    if (options.topModel === options.model && options.subQuery === void 0) {\n      options.subQuery = false;\n    }\n    return options;\n  }\n  static _validateIncludedElement(include, tableNames, options) {\n    tableNames[include.model.getTableName()] = true;\n    if (include.attributes && !options.raw) {\n      include.model._expandAttributes(include);\n      include.originalAttributes = include.model._injectDependentVirtualAttributes(include.attributes);\n      include = Utils.mapFinderOptions(include, include.model);\n      if (include.attributes.length) {\n        _.each(include.model.primaryKeys, (attr, key) => {\n          if (!include.attributes.some((includeAttr) => {\n            if (attr.field !== key) {\n              return Array.isArray(includeAttr) && includeAttr[0] === attr.field && includeAttr[1] === key;\n            }\n            return includeAttr === key;\n          })) {\n            include.attributes.unshift(key);\n          }\n        });\n      }\n    } else {\n      include = Utils.mapFinderOptions(include, include.model);\n    }\n    if (include._pseudo) {\n      if (!include.attributes) {\n        include.attributes = Object.keys(include.model.tableAttributes);\n      }\n      return Utils.mapFinderOptions(include, include.model);\n    }\n    const association = include.association || this._getIncludedAssociation(include.model, include.as);\n    include.association = association;\n    include.as = association.as;\n    if (include.association.through && Object(include.association.through.model) === include.association.through.model) {\n      if (!include.include)\n        include.include = [];\n      const through = include.association.through;\n      include.through = _.defaults(include.through || {}, {\n        model: through.model,\n        as: through.model.name,\n        association: {\n          isSingleAssociation: true\n        },\n        _pseudo: true,\n        parent: include\n      });\n      if (through.scope) {\n        include.through.where = include.through.where ? { [Op.and]: [include.through.where, through.scope] } : through.scope;\n      }\n      include.include.push(include.through);\n      tableNames[through.tableName] = true;\n    }\n    let model;\n    if (include.model.scoped === true) {\n      model = include.model;\n    } else {\n      model = include.association.target.name === include.model.name ? include.association.target : include.association.source;\n    }\n    model._injectScope(include);\n    if (!include.attributes) {\n      include.attributes = Object.keys(include.model.tableAttributes);\n    }\n    include = Utils.mapFinderOptions(include, include.model);\n    if (include.required === void 0) {\n      include.required = !!include.where;\n    }\n    if (include.association.scope) {\n      include.where = include.where ? { [Op.and]: [include.where, include.association.scope] } : include.association.scope;\n    }\n    if (include.limit && include.separate === void 0) {\n      include.separate = true;\n    }\n    if (include.separate === true) {\n      if (!(include.association instanceof HasMany)) {\n        throw new Error(\"Only HasMany associations support include.separate\");\n      }\n      include.duplicating = false;\n      if (options.attributes && options.attributes.length && !_.flattenDepth(options.attributes, 2).includes(association.sourceKey)) {\n        options.attributes.push(association.sourceKey);\n      }\n      if (include.attributes && include.attributes.length && !_.flattenDepth(include.attributes, 2).includes(association.foreignKey)) {\n        include.attributes.push(association.foreignKey);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(include, \"include\")) {\n      this._validateIncludedElements.call(include.model, include, tableNames);\n    }\n    return include;\n  }\n  static _getIncludedAssociation(targetModel, targetAlias) {\n    const associations = this.getAssociations(targetModel);\n    let association = null;\n    if (associations.length === 0) {\n      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is not associated to ${this.name}!`);\n    }\n    if (associations.length === 1) {\n      association = this.getAssociationForAlias(targetModel, targetAlias);\n      if (association) {\n        return association;\n      }\n      if (targetAlias) {\n        const existingAliases = this.getAssociations(targetModel).map((association2) => association2.as);\n        throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} using an alias. You've included an alias (${targetAlias}), but it does not match the alias(es) defined in your association (${existingAliases.join(\", \")}).`);\n      }\n      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} using an alias. You must use the 'as' keyword to specify the alias within your include statement.`);\n    }\n    association = this.getAssociationForAlias(targetModel, targetAlias);\n    if (!association) {\n      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} multiple times. To identify the correct association, you must use the 'as' keyword to specify the alias of the association you want to include.`);\n    }\n    return association;\n  }\n  static _expandIncludeAll(options) {\n    const includes = options.include;\n    if (!includes) {\n      return;\n    }\n    for (let index = 0; index < includes.length; index++) {\n      const include = includes[index];\n      if (include.all) {\n        includes.splice(index, 1);\n        index--;\n        this._expandIncludeAllElement(includes, include);\n      }\n    }\n    includes.forEach((include) => {\n      this._expandIncludeAll.call(include.model, include);\n    });\n  }\n  static _conformIndex(index) {\n    if (!index.fields) {\n      throw new Error('Missing \"fields\" property for index definition');\n    }\n    index = _.defaults(index, {\n      type: \"\",\n      parser: null\n    });\n    if (index.type && index.type.toLowerCase() === \"unique\") {\n      index.unique = true;\n      delete index.type;\n    }\n    return index;\n  }\n  static _uniqIncludes(options) {\n    if (!options.include)\n      return;\n    options.include = _(options.include).groupBy((include) => `${include.model && include.model.name}-${include.as}`).map((includes) => this._assignOptions(...includes)).value();\n  }\n  static _baseMerge(...args) {\n    _.assignWith(...args);\n    this._conformIncludes(args[0], this);\n    this._uniqIncludes(args[0]);\n    return args[0];\n  }\n  static _mergeFunction(objValue, srcValue, key) {\n    if (Array.isArray(objValue) && Array.isArray(srcValue)) {\n      return _.union(objValue, srcValue);\n    }\n    if ([\"where\", \"having\"].includes(key)) {\n      if (this.options && this.options.whereMergeStrategy === \"and\") {\n        return combineWheresWithAnd(objValue, srcValue);\n      }\n      if (srcValue instanceof Utils.SequelizeMethod) {\n        srcValue = { [Op.and]: srcValue };\n      }\n      if (_.isPlainObject(objValue) && _.isPlainObject(srcValue)) {\n        return Object.assign(objValue, srcValue);\n      }\n    } else if (key === \"attributes\" && _.isPlainObject(objValue) && _.isPlainObject(srcValue)) {\n      return _.assignWith(objValue, srcValue, (objValue2, srcValue2) => {\n        if (Array.isArray(objValue2) && Array.isArray(srcValue2)) {\n          return _.union(objValue2, srcValue2);\n        }\n      });\n    }\n    if (srcValue) {\n      return Utils.cloneDeep(srcValue, true);\n    }\n    return srcValue === void 0 ? objValue : srcValue;\n  }\n  static _assignOptions(...args) {\n    return this._baseMerge(...args, this._mergeFunction.bind(this));\n  }\n  static _defaultsOptions(target, opts) {\n    return this._baseMerge(target, opts, (srcValue, objValue, key) => {\n      return this._mergeFunction(objValue, srcValue, key);\n    });\n  }\n  static init(attributes, options = {}) {\n    if (!options.sequelize) {\n      throw new Error(\"No Sequelize instance passed\");\n    }\n    this.sequelize = options.sequelize;\n    const globalOptions = this.sequelize.options;\n    options = Utils.merge(_.cloneDeep(globalOptions.define), options);\n    if (!options.modelName) {\n      options.modelName = this.name;\n    }\n    options = Utils.merge({\n      name: {\n        plural: Utils.pluralize(options.modelName),\n        singular: Utils.singularize(options.modelName)\n      },\n      indexes: [],\n      omitNull: globalOptions.omitNull,\n      schema: globalOptions.schema\n    }, options);\n    this.sequelize.runHooks(\"beforeDefine\", attributes, options);\n    if (options.modelName !== this.name) {\n      Object.defineProperty(this, \"name\", { value: options.modelName });\n    }\n    delete options.modelName;\n    this.options = __spreadValues({\n      timestamps: true,\n      validate: {},\n      freezeTableName: false,\n      underscored: false,\n      paranoid: false,\n      rejectOnEmpty: false,\n      whereCollection: null,\n      schema: null,\n      schemaDelimiter: \"\",\n      defaultScope: {},\n      scopes: {},\n      indexes: [],\n      whereMergeStrategy: \"overwrite\"\n    }, options);\n    if (this.sequelize.isDefined(this.name)) {\n      this.sequelize.modelManager.removeModel(this.sequelize.modelManager.getModel(this.name));\n    }\n    this.associations = {};\n    this._setupHooks(options.hooks);\n    this.underscored = this.options.underscored;\n    if (!this.options.tableName) {\n      this.tableName = this.options.freezeTableName ? this.name : Utils.underscoredIf(Utils.pluralize(this.name), this.underscored);\n    } else {\n      this.tableName = this.options.tableName;\n    }\n    this._schema = this.options.schema;\n    this._schemaDelimiter = this.options.schemaDelimiter;\n    _.each(options.validate, (validator, validatorType) => {\n      if (Object.prototype.hasOwnProperty.call(attributes, validatorType)) {\n        throw new Error(`A model validator function must not have the same name as a field. Model: ${this.name}, field/validation name: ${validatorType}`);\n      }\n      if (typeof validator !== \"function\") {\n        throw new Error(`Members of the validate option must be functions. Model: ${this.name}, error with validate member ${validatorType}`);\n      }\n    });\n    if (!_.includes([\"and\", \"overwrite\"], this.options && this.options.whereMergeStrategy)) {\n      throw new Error(`Invalid value ${this.options && this.options.whereMergeStrategy} for whereMergeStrategy. Allowed values are 'and' and 'overwrite'.`);\n    }\n    this.rawAttributes = _.mapValues(attributes, (attribute, name) => {\n      attribute = this.sequelize.normalizeAttribute(attribute);\n      if (attribute.type === void 0) {\n        throw new Error(`Unrecognized datatype for attribute \"${this.name}.${name}\"`);\n      }\n      if (attribute.allowNull !== false && _.get(attribute, \"validate.notNull\")) {\n        throw new Error(`Invalid definition for \"${this.name}.${name}\", \"notNull\" validator is only allowed with \"allowNull:false\"`);\n      }\n      if (_.get(attribute, \"references.model.prototype\") instanceof Model) {\n        attribute.references.model = attribute.references.model.getTableName();\n      }\n      return attribute;\n    });\n    const tableName = this.getTableName();\n    this._indexes = this.options.indexes.map((index) => Utils.nameIndex(this._conformIndex(index), tableName));\n    this.primaryKeys = {};\n    this._readOnlyAttributes = /* @__PURE__ */ new Set();\n    this._timestampAttributes = {};\n    if (this.options.timestamps) {\n      for (const key of [\"createdAt\", \"updatedAt\", \"deletedAt\"]) {\n        if (![\"undefined\", \"string\", \"boolean\"].includes(typeof this.options[key])) {\n          throw new Error(`Value for \"${key}\" option must be a string or a boolean, got ${typeof this.options[key]}`);\n        }\n        if (this.options[key] === \"\") {\n          throw new Error(`Value for \"${key}\" option cannot be an empty string`);\n        }\n      }\n      if (this.options.createdAt !== false) {\n        this._timestampAttributes.createdAt = typeof this.options.createdAt === \"string\" ? this.options.createdAt : \"createdAt\";\n        this._readOnlyAttributes.add(this._timestampAttributes.createdAt);\n      }\n      if (this.options.updatedAt !== false) {\n        this._timestampAttributes.updatedAt = typeof this.options.updatedAt === \"string\" ? this.options.updatedAt : \"updatedAt\";\n        this._readOnlyAttributes.add(this._timestampAttributes.updatedAt);\n      }\n      if (this.options.paranoid && this.options.deletedAt !== false) {\n        this._timestampAttributes.deletedAt = typeof this.options.deletedAt === \"string\" ? this.options.deletedAt : \"deletedAt\";\n        this._readOnlyAttributes.add(this._timestampAttributes.deletedAt);\n      }\n    }\n    if (this.options.version) {\n      this._versionAttribute = typeof this.options.version === \"string\" ? this.options.version : \"version\";\n      this._readOnlyAttributes.add(this._versionAttribute);\n    }\n    this._hasReadOnlyAttributes = this._readOnlyAttributes.size > 0;\n    this._addDefaultAttributes();\n    this.refreshAttributes();\n    this._findAutoIncrementAttribute();\n    this._scope = this.options.defaultScope;\n    this._scopeNames = [\"defaultScope\"];\n    this.sequelize.modelManager.addModel(this);\n    this.sequelize.runHooks(\"afterDefine\", this);\n    return this;\n  }\n  static refreshAttributes() {\n    const attributeManipulation = {};\n    this.prototype._customGetters = {};\n    this.prototype._customSetters = {};\n    [\"get\", \"set\"].forEach((type) => {\n      const opt = `${type}terMethods`;\n      const funcs = __spreadValues({}, this.options[opt]);\n      const _custom = type === \"get\" ? this.prototype._customGetters : this.prototype._customSetters;\n      _.each(funcs, (method, attribute) => {\n        _custom[attribute] = method;\n        if (type === \"get\") {\n          funcs[attribute] = function() {\n            return this.get(attribute);\n          };\n        }\n        if (type === \"set\") {\n          funcs[attribute] = function(value) {\n            return this.set(attribute, value);\n          };\n        }\n      });\n      _.each(this.rawAttributes, (options, attribute) => {\n        if (Object.prototype.hasOwnProperty.call(options, type)) {\n          _custom[attribute] = options[type];\n        }\n        if (type === \"get\") {\n          funcs[attribute] = function() {\n            return this.get(attribute);\n          };\n        }\n        if (type === \"set\") {\n          funcs[attribute] = function(value) {\n            return this.set(attribute, value);\n          };\n        }\n      });\n      _.each(funcs, (fct, name) => {\n        if (!attributeManipulation[name]) {\n          attributeManipulation[name] = {\n            configurable: true\n          };\n        }\n        attributeManipulation[name][type] = fct;\n      });\n    });\n    this._dataTypeChanges = {};\n    this._dataTypeSanitizers = {};\n    this._hasBooleanAttributes = false;\n    this._hasDateAttributes = false;\n    this._jsonAttributes = /* @__PURE__ */ new Set();\n    this._virtualAttributes = /* @__PURE__ */ new Set();\n    this._defaultValues = {};\n    this.prototype.validators = {};\n    this.fieldRawAttributesMap = {};\n    this.primaryKeys = {};\n    this.uniqueKeys = {};\n    _.each(this.rawAttributes, (definition, name) => {\n      definition.type = this.sequelize.normalizeDataType(definition.type);\n      definition.Model = this;\n      definition.fieldName = name;\n      definition._modelAttribute = true;\n      if (definition.field === void 0) {\n        definition.field = Utils.underscoredIf(name, this.underscored);\n      }\n      if (definition.primaryKey === true) {\n        this.primaryKeys[name] = definition;\n      }\n      this.fieldRawAttributesMap[definition.field] = definition;\n      if (definition.type._sanitize) {\n        this._dataTypeSanitizers[name] = definition.type._sanitize;\n      }\n      if (definition.type._isChanged) {\n        this._dataTypeChanges[name] = definition.type._isChanged;\n      }\n      if (definition.type instanceof DataTypes.BOOLEAN) {\n        this._hasBooleanAttributes = true;\n      } else if (definition.type instanceof DataTypes.DATE || definition.type instanceof DataTypes.DATEONLY) {\n        this._hasDateAttributes = true;\n      } else if (definition.type instanceof DataTypes.JSON) {\n        this._jsonAttributes.add(name);\n      } else if (definition.type instanceof DataTypes.VIRTUAL) {\n        this._virtualAttributes.add(name);\n      }\n      if (Object.prototype.hasOwnProperty.call(definition, \"defaultValue\")) {\n        this._defaultValues[name] = () => Utils.toDefaultValue(definition.defaultValue, this.sequelize.options.dialect);\n      }\n      if (Object.prototype.hasOwnProperty.call(definition, \"unique\") && definition.unique) {\n        let idxName;\n        if (typeof definition.unique === \"object\" && Object.prototype.hasOwnProperty.call(definition.unique, \"name\")) {\n          idxName = definition.unique.name;\n        } else if (typeof definition.unique === \"string\") {\n          idxName = definition.unique;\n        } else {\n          idxName = `${this.tableName}_${name}_unique`;\n        }\n        const idx = this.uniqueKeys[idxName] || { fields: [] };\n        idx.fields.push(definition.field);\n        idx.msg = idx.msg || definition.unique.msg || null;\n        idx.name = idxName || false;\n        idx.column = name;\n        idx.customIndex = definition.unique !== true;\n        this.uniqueKeys[idxName] = idx;\n      }\n      if (Object.prototype.hasOwnProperty.call(definition, \"validate\")) {\n        this.prototype.validators[name] = definition.validate;\n      }\n      if (definition.index === true && definition.type instanceof DataTypes.JSONB) {\n        this._indexes.push(Utils.nameIndex(this._conformIndex({\n          fields: [definition.field || name],\n          using: \"gin\"\n        }), this.getTableName()));\n        delete definition.index;\n      }\n    });\n    this.fieldAttributeMap = _.reduce(this.fieldRawAttributesMap, (map, value, key) => {\n      if (key !== value.fieldName) {\n        map[key] = value.fieldName;\n      }\n      return map;\n    }, {});\n    this._hasJsonAttributes = !!this._jsonAttributes.size;\n    this._hasVirtualAttributes = !!this._virtualAttributes.size;\n    this._hasDefaultValues = !_.isEmpty(this._defaultValues);\n    this.tableAttributes = _.omitBy(this.rawAttributes, (_a, key) => this._virtualAttributes.has(key));\n    this.prototype._hasCustomGetters = Object.keys(this.prototype._customGetters).length;\n    this.prototype._hasCustomSetters = Object.keys(this.prototype._customSetters).length;\n    for (const key of Object.keys(attributeManipulation)) {\n      if (Object.prototype.hasOwnProperty.call(Model.prototype, key)) {\n        this.sequelize.log(`Not overriding built-in method from model attribute: ${key}`);\n        continue;\n      }\n      Object.defineProperty(this.prototype, key, attributeManipulation[key]);\n    }\n    this.prototype.rawAttributes = this.rawAttributes;\n    this.prototype._isAttribute = (key) => Object.prototype.hasOwnProperty.call(this.prototype.rawAttributes, key);\n    this.primaryKeyAttributes = Object.keys(this.primaryKeys);\n    this.primaryKeyAttribute = this.primaryKeyAttributes[0];\n    if (this.primaryKeyAttribute) {\n      this.primaryKeyField = this.rawAttributes[this.primaryKeyAttribute].field || this.primaryKeyAttribute;\n    }\n    this._hasPrimaryKeys = this.primaryKeyAttributes.length > 0;\n    this._isPrimaryKey = (key) => this.primaryKeyAttributes.includes(key);\n    this._attributeManipulation = attributeManipulation;\n  }\n  static removeAttribute(attribute) {\n    delete this.rawAttributes[attribute];\n    this.refreshAttributes();\n  }\n  static async sync(options) {\n    options = __spreadValues(__spreadValues({}, this.options), options);\n    options.hooks = options.hooks === void 0 ? true : !!options.hooks;\n    const attributes = this.tableAttributes;\n    const rawAttributes = this.fieldRawAttributesMap;\n    if (options.hooks) {\n      await this.runHooks(\"beforeSync\", options);\n    }\n    const tableName = this.getTableName(options);\n    let tableExists;\n    if (options.force) {\n      await this.drop(options);\n      tableExists = false;\n    } else {\n      tableExists = await this.queryInterface.tableExists(tableName, options);\n    }\n    if (!tableExists) {\n      await this.queryInterface.createTable(tableName, attributes, options, this);\n    } else {\n      await this.queryInterface.ensureEnums(tableName, attributes, options, this);\n    }\n    if (tableExists && options.alter) {\n      const tableInfos = await Promise.all([\n        this.queryInterface.describeTable(tableName, options),\n        this.queryInterface.getForeignKeyReferencesForTable(tableName, options)\n      ]);\n      const columns = tableInfos[0];\n      const foreignKeyReferences = tableInfos[1];\n      const removedConstraints = {};\n      for (const columnName in attributes) {\n        if (!Object.prototype.hasOwnProperty.call(attributes, columnName))\n          continue;\n        if (!columns[columnName] && !columns[attributes[columnName].field]) {\n          await this.queryInterface.addColumn(tableName, attributes[columnName].field || columnName, attributes[columnName], options);\n        }\n      }\n      if (options.alter === true || typeof options.alter === \"object\" && options.alter.drop !== false) {\n        for (const columnName in columns) {\n          if (!Object.prototype.hasOwnProperty.call(columns, columnName))\n            continue;\n          const currentAttribute = rawAttributes[columnName];\n          if (!currentAttribute) {\n            await this.queryInterface.removeColumn(tableName, columnName, options);\n            continue;\n          }\n          if (currentAttribute.primaryKey)\n            continue;\n          const references = currentAttribute.references;\n          if (currentAttribute.references) {\n            const database = this.sequelize.config.database;\n            const schema = this.sequelize.config.schema;\n            for (const foreignKeyReference of foreignKeyReferences) {\n              const constraintName = foreignKeyReference.constraintName;\n              if (!!constraintName && foreignKeyReference.tableCatalog === database && (schema ? foreignKeyReference.tableSchema === schema : true) && foreignKeyReference.referencedTableName === references.model && foreignKeyReference.referencedColumnName === references.key && (schema ? foreignKeyReference.referencedTableSchema === schema : true) && !removedConstraints[constraintName]) {\n                await this.queryInterface.removeConstraint(tableName, constraintName, options);\n                removedConstraints[constraintName] = true;\n              }\n            }\n          }\n          await this.queryInterface.changeColumn(tableName, columnName, currentAttribute, options);\n        }\n      }\n    }\n    const existingIndexes = await this.queryInterface.showIndex(tableName, options);\n    const missingIndexes = this._indexes.filter((item1) => !existingIndexes.some((item2) => item1.name === item2.name)).sort((index1, index2) => {\n      if (this.sequelize.options.dialect === \"postgres\") {\n        if (index1.concurrently === true)\n          return 1;\n        if (index2.concurrently === true)\n          return -1;\n      }\n      return 0;\n    });\n    for (const index of missingIndexes) {\n      await this.queryInterface.addIndex(tableName, __spreadValues(__spreadValues({}, options), index));\n    }\n    if (options.hooks) {\n      await this.runHooks(\"afterSync\", options);\n    }\n    return this;\n  }\n  static async drop(options) {\n    return await this.queryInterface.dropTable(this.getTableName(options), options);\n  }\n  static async dropSchema(schema) {\n    return await this.queryInterface.dropSchema(schema);\n  }\n  static schema(schema, options) {\n    const clone = class extends this {\n    };\n    Object.defineProperty(clone, \"name\", { value: this.name });\n    clone._schema = schema;\n    if (options) {\n      if (typeof options === \"string\") {\n        clone._schemaDelimiter = options;\n      } else if (options.schemaDelimiter) {\n        clone._schemaDelimiter = options.schemaDelimiter;\n      }\n    }\n    return clone;\n  }\n  static getTableName() {\n    return this.queryGenerator.addSchema(this);\n  }\n  static unscoped() {\n    return this.scope();\n  }\n  static addScope(name, scope, options) {\n    options = __spreadValues({ override: false }, options);\n    if ((name === \"defaultScope\" && Object.keys(this.options.defaultScope).length > 0 || name in this.options.scopes) && options.override === false) {\n      throw new Error(`The scope ${name} already exists. Pass { override: true } as options to silence this error`);\n    }\n    if (name === \"defaultScope\") {\n      this.options.defaultScope = this._scope = scope;\n    } else {\n      this.options.scopes[name] = scope;\n    }\n  }\n  static scope(option) {\n    const self = class extends this {\n    };\n    let scope;\n    let scopeName;\n    Object.defineProperty(self, \"name\", { value: this.name });\n    self._scope = {};\n    self._scopeNames = [];\n    self.scoped = true;\n    if (!option) {\n      return self;\n    }\n    const options = _.flatten(arguments);\n    for (const option2 of options) {\n      scope = null;\n      scopeName = null;\n      if (_.isPlainObject(option2)) {\n        if (option2.method) {\n          if (Array.isArray(option2.method) && !!self.options.scopes[option2.method[0]]) {\n            scopeName = option2.method[0];\n            scope = self.options.scopes[scopeName].apply(self, option2.method.slice(1));\n          } else if (self.options.scopes[option2.method]) {\n            scopeName = option2.method;\n            scope = self.options.scopes[scopeName].apply(self);\n          }\n        } else {\n          scope = option2;\n        }\n      } else if (option2 === \"defaultScope\" && _.isPlainObject(self.options.defaultScope)) {\n        scope = self.options.defaultScope;\n      } else {\n        scopeName = option2;\n        scope = self.options.scopes[scopeName];\n        if (typeof scope === \"function\") {\n          scope = scope();\n        }\n      }\n      if (scope) {\n        this._conformIncludes(scope, this);\n        this._assignOptions(self._scope, Utils.cloneDeep(scope));\n        self._scopeNames.push(scopeName ? scopeName : \"defaultScope\");\n      } else {\n        throw new sequelizeErrors.SequelizeScopeError(`Invalid scope ${scopeName} called.`);\n      }\n    }\n    return self;\n  }\n  static async findAll(options) {\n    if (options !== void 0 && !_.isPlainObject(options)) {\n      throw new sequelizeErrors.QueryError(\"The argument passed to findAll must be an options object, use findByPk if you wish to pass a single primary key value\");\n    }\n    if (options !== void 0 && options.attributes) {\n      if (!Array.isArray(options.attributes) && !_.isPlainObject(options.attributes)) {\n        throw new sequelizeErrors.QueryError(\"The attributes option must be an array of column names or an object\");\n      }\n    }\n    this.warnOnInvalidOptions(options, Object.keys(this.rawAttributes));\n    const tableNames = {};\n    tableNames[this.getTableName(options)] = true;\n    options = Utils.cloneDeep(options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    _.defaults(options, { hooks: true });\n    options.rejectOnEmpty = Object.prototype.hasOwnProperty.call(options, \"rejectOnEmpty\") ? options.rejectOnEmpty : this.options.rejectOnEmpty;\n    this._injectScope(options);\n    if (options.hooks) {\n      await this.runHooks(\"beforeFind\", options);\n    }\n    this._conformIncludes(options, this);\n    this._expandAttributes(options);\n    this._expandIncludeAll(options);\n    if (options.hooks) {\n      await this.runHooks(\"beforeFindAfterExpandIncludeAll\", options);\n    }\n    options.originalAttributes = this._injectDependentVirtualAttributes(options.attributes);\n    if (options.include) {\n      options.hasJoin = true;\n      this._validateIncludedElements(options, tableNames);\n      if (options.attributes && !options.raw && this.primaryKeyAttribute && !options.attributes.includes(this.primaryKeyAttribute) && (!options.group || !options.hasSingleAssociation || options.hasMultiAssociation)) {\n        options.attributes = [this.primaryKeyAttribute].concat(options.attributes);\n      }\n    }\n    if (!options.attributes) {\n      options.attributes = Object.keys(this.rawAttributes);\n      options.originalAttributes = this._injectDependentVirtualAttributes(options.attributes);\n    }\n    this.options.whereCollection = options.where || null;\n    Utils.mapFinderOptions(options, this);\n    options = this._paranoidClause(this, options);\n    if (options.hooks) {\n      await this.runHooks(\"beforeFindAfterOptions\", options);\n    }\n    const selectOptions = __spreadProps(__spreadValues({}, options), { tableNames: Object.keys(tableNames) });\n    const results = await this.queryInterface.select(this, this.getTableName(selectOptions), selectOptions);\n    if (options.hooks) {\n      await this.runHooks(\"afterFind\", results, options);\n    }\n    if (_.isEmpty(results) && options.rejectOnEmpty) {\n      if (typeof options.rejectOnEmpty === \"function\") {\n        throw new options.rejectOnEmpty();\n      }\n      if (typeof options.rejectOnEmpty === \"object\") {\n        throw options.rejectOnEmpty;\n      }\n      throw new sequelizeErrors.EmptyResultError();\n    }\n    return await Model._findSeparate(results, options);\n  }\n  static warnOnInvalidOptions(options, validColumnNames) {\n    if (!_.isPlainObject(options)) {\n      return;\n    }\n    const unrecognizedOptions = Object.keys(options).filter((k) => !validQueryKeywords.has(k));\n    const unexpectedModelAttributes = _.intersection(unrecognizedOptions, validColumnNames);\n    if (!options.where && unexpectedModelAttributes.length > 0) {\n      logger.warn(`Model attributes (${unexpectedModelAttributes.join(\", \")}) passed into finder method options of model ${this.name}, but the options.where object is empty. Did you forget to use options.where?`);\n    }\n  }\n  static _injectDependentVirtualAttributes(attributes) {\n    if (!this._hasVirtualAttributes)\n      return attributes;\n    if (!attributes || !Array.isArray(attributes))\n      return attributes;\n    for (const attribute of attributes) {\n      if (this._virtualAttributes.has(attribute) && this.rawAttributes[attribute].type.fields) {\n        attributes = attributes.concat(this.rawAttributes[attribute].type.fields);\n      }\n    }\n    attributes = _.uniq(attributes);\n    return attributes;\n  }\n  static async _findSeparate(results, options) {\n    if (!options.include || options.raw || !results)\n      return results;\n    const original = results;\n    if (options.plain)\n      results = [results];\n    if (!results.length)\n      return original;\n    await Promise.all(options.include.map(async (include) => {\n      if (!include.separate) {\n        return await Model._findSeparate(results.reduce((memo, result) => {\n          let associations = result.get(include.association.as);\n          if (!associations)\n            return memo;\n          if (!Array.isArray(associations))\n            associations = [associations];\n          for (let i = 0, len = associations.length; i !== len; ++i) {\n            memo.push(associations[i]);\n          }\n          return memo;\n        }, []), __spreadProps(__spreadValues({}, _.omit(options, \"include\", \"attributes\", \"order\", \"where\", \"limit\", \"offset\", \"plain\", \"scope\")), {\n          include: include.include || []\n        }));\n      }\n      const map = await include.association.get(results, __spreadValues(__spreadValues({}, _.omit(options, nonCascadingOptions)), _.omit(include, [\"parent\", \"association\", \"as\", \"originalAttributes\"])));\n      for (const result of results) {\n        result.set(include.association.as, map[result.get(include.association.sourceKey)], { raw: true });\n      }\n    }));\n    return original;\n  }\n  static async findByPk(param, options) {\n    if ([null, void 0].includes(param)) {\n      return null;\n    }\n    options = Utils.cloneDeep(options) || {};\n    if (typeof param === \"number\" || typeof param === \"bigint\" || typeof param === \"string\" || Buffer.isBuffer(param)) {\n      options.where = {\n        [this.primaryKeyAttribute]: param\n      };\n    } else {\n      throw new Error(`Argument passed to findByPk is invalid: ${param}`);\n    }\n    return await this.findOne(options);\n  }\n  static async findOne(options) {\n    if (options !== void 0 && !_.isPlainObject(options)) {\n      throw new Error(\"The argument passed to findOne must be an options object, use findByPk if you wish to pass a single primary key value\");\n    }\n    options = Utils.cloneDeep(options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    if (options.limit === void 0) {\n      const uniqueSingleColumns = _.chain(this.uniqueKeys).values().filter((c) => c.fields.length === 1).map(\"column\").value();\n      if (!options.where || !_.some(options.where, (value, key) => (key === this.primaryKeyAttribute || uniqueSingleColumns.includes(key)) && (Utils.isPrimitive(value) || Buffer.isBuffer(value)))) {\n        options.limit = 1;\n      }\n    }\n    return await this.findAll(_.defaults(options, {\n      plain: true\n    }));\n  }\n  static async aggregate(attribute, aggregateFunction, options) {\n    options = Utils.cloneDeep(options);\n    const prevAttributes = options.attributes;\n    this._injectScope(options);\n    options.attributes = prevAttributes;\n    this._conformIncludes(options, this);\n    if (options.include) {\n      this._expandIncludeAll(options);\n      this._validateIncludedElements(options);\n    }\n    const attrOptions = this.rawAttributes[attribute];\n    const field = attrOptions && attrOptions.field || attribute;\n    let aggregateColumn = this.sequelize.col(field);\n    if (options.distinct) {\n      aggregateColumn = this.sequelize.fn(\"DISTINCT\", aggregateColumn);\n    }\n    let { group } = options;\n    if (Array.isArray(group) && Array.isArray(group[0])) {\n      noDoubleNestedGroup();\n      group = _.flatten(group);\n    }\n    options.attributes = _.unionBy(options.attributes, group, [[this.sequelize.fn(aggregateFunction, aggregateColumn), aggregateFunction]], (a) => Array.isArray(a) ? a[1] : a);\n    if (!options.dataType) {\n      if (attrOptions) {\n        options.dataType = attrOptions.type;\n      } else {\n        options.dataType = new DataTypes.FLOAT();\n      }\n    } else {\n      options.dataType = this.sequelize.normalizeDataType(options.dataType);\n    }\n    Utils.mapOptionFieldNames(options, this);\n    options = this._paranoidClause(this, options);\n    const value = await this.queryInterface.rawSelect(this.getTableName(options), options, aggregateFunction, this);\n    return value;\n  }\n  static async count(options) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, { hooks: true });\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    options.raw = true;\n    if (options.hooks) {\n      await this.runHooks(\"beforeCount\", options);\n    }\n    let col = options.col || \"*\";\n    if (options.include) {\n      col = `${this.name}.${options.col || this.primaryKeyField}`;\n    }\n    if (options.distinct && col === \"*\") {\n      col = this.primaryKeyField;\n    }\n    options.plain = !options.group;\n    options.dataType = new DataTypes.INTEGER();\n    options.includeIgnoreAttributes = false;\n    options.limit = null;\n    options.offset = null;\n    options.order = null;\n    const result = await this.aggregate(col, \"count\", options);\n    if (Array.isArray(result)) {\n      return result.map((item) => __spreadProps(__spreadValues({}, item), {\n        count: Number(item.count)\n      }));\n    }\n    return result;\n  }\n  static async findAndCountAll(options) {\n    if (options !== void 0 && !_.isPlainObject(options)) {\n      throw new Error(\"The argument passed to findAndCountAll must be an options object, use findByPk if you wish to pass a single primary key value\");\n    }\n    const countOptions = Utils.cloneDeep(options);\n    if (countOptions.attributes) {\n      countOptions.attributes = void 0;\n    }\n    const [count, rows] = await Promise.all([\n      this.count(countOptions),\n      this.findAll(options)\n    ]);\n    return {\n      count,\n      rows: count === 0 ? [] : rows\n    };\n  }\n  static async max(field, options) {\n    return await this.aggregate(field, \"max\", options);\n  }\n  static async min(field, options) {\n    return await this.aggregate(field, \"min\", options);\n  }\n  static async sum(field, options) {\n    return await this.aggregate(field, \"sum\", options);\n  }\n  static build(values, options) {\n    if (Array.isArray(values)) {\n      return this.bulkBuild(values, options);\n    }\n    return new this(values, options);\n  }\n  static bulkBuild(valueSets, options) {\n    options = __spreadValues({ isNewRecord: true }, options);\n    if (!options.includeValidated) {\n      this._conformIncludes(options, this);\n      if (options.include) {\n        this._expandIncludeAll(options);\n        this._validateIncludedElements(options);\n      }\n    }\n    if (options.attributes) {\n      options.attributes = options.attributes.map((attribute) => Array.isArray(attribute) ? attribute[1] : attribute);\n    }\n    return valueSets.map((values) => this.build(values, options));\n  }\n  static async create(values, options) {\n    options = Utils.cloneDeep(options || {});\n    return await this.build(values, {\n      isNewRecord: true,\n      attributes: options.fields,\n      include: options.include,\n      raw: options.raw,\n      silent: options.silent\n    }).save(options);\n  }\n  static async findOrBuild(options) {\n    if (!options || !options.where || arguments.length > 1) {\n      throw new Error(\"Missing where attribute in the options parameter passed to findOrBuild. Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)\");\n    }\n    let values;\n    let instance = await this.findOne(options);\n    if (instance === null) {\n      values = __spreadValues({}, options.defaults);\n      if (_.isPlainObject(options.where)) {\n        values = Utils.defaults(values, options.where);\n      }\n      instance = this.build(values, options);\n      return [instance, true];\n    }\n    return [instance, false];\n  }\n  static async findOrCreate(options) {\n    if (!options || !options.where || arguments.length > 1) {\n      throw new Error(\"Missing where attribute in the options parameter passed to findOrCreate. Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)\");\n    }\n    options = __spreadValues({}, options);\n    if (options.defaults) {\n      const defaults = Object.keys(options.defaults);\n      const unknownDefaults = defaults.filter((name) => !this.rawAttributes[name]);\n      if (unknownDefaults.length) {\n        logger.warn(`Unknown attributes (${unknownDefaults}) passed to defaults option of findOrCreate`);\n      }\n    }\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    const internalTransaction = !options.transaction;\n    let values;\n    let transaction;\n    try {\n      const t = await this.sequelize.transaction(options);\n      transaction = t;\n      options.transaction = t;\n      const found = await this.findOne(Utils.defaults({ transaction }, options));\n      if (found !== null) {\n        return [found, false];\n      }\n      values = __spreadValues({}, options.defaults);\n      if (_.isPlainObject(options.where)) {\n        values = Utils.defaults(values, options.where);\n      }\n      options.exception = true;\n      options.returning = true;\n      try {\n        const created = await this.create(values, options);\n        if (created.get(this.primaryKeyAttribute, { raw: true }) === null) {\n          throw new sequelizeErrors.UniqueConstraintError();\n        }\n        return [created, true];\n      } catch (err) {\n        if (!(err instanceof sequelizeErrors.UniqueConstraintError))\n          throw err;\n        const flattenedWhere = Utils.flattenObjectDeep(options.where);\n        const flattenedWhereKeys = Object.keys(flattenedWhere).map((name) => _.last(name.split(\".\")));\n        const whereFields = flattenedWhereKeys.map((name) => _.get(this.rawAttributes, `${name}.field`, name));\n        const defaultFields = options.defaults && Object.keys(options.defaults).filter((name) => this.rawAttributes[name]).map((name) => this.rawAttributes[name].field || name);\n        const errFieldKeys = Object.keys(err.fields);\n        const errFieldsWhereIntersects = Utils.intersects(errFieldKeys, whereFields);\n        if (defaultFields && !errFieldsWhereIntersects && Utils.intersects(errFieldKeys, defaultFields)) {\n          throw err;\n        }\n        if (errFieldsWhereIntersects) {\n          _.each(err.fields, (value, key) => {\n            const name = this.fieldRawAttributesMap[key].fieldName;\n            if (value.toString() !== options.where[name].toString()) {\n              throw new Error(`${this.name}#findOrCreate: value used for ${name} was not equal for both the find and the create calls, '${options.where[name]}' vs '${value}'`);\n            }\n          });\n        }\n        const otherCreated = await this.findOne(Utils.defaults({\n          transaction: internalTransaction ? null : transaction\n        }, options));\n        if (otherCreated === null)\n          throw err;\n        return [otherCreated, false];\n      }\n    } finally {\n      if (internalTransaction && transaction) {\n        await transaction.commit();\n      }\n    }\n  }\n  static async findCreateFind(options) {\n    if (!options || !options.where) {\n      throw new Error(\"Missing where attribute in the options parameter passed to findCreateFind.\");\n    }\n    let values = __spreadValues({}, options.defaults);\n    if (_.isPlainObject(options.where)) {\n      values = Utils.defaults(values, options.where);\n    }\n    const found = await this.findOne(options);\n    if (found)\n      return [found, false];\n    try {\n      const createOptions = __spreadValues({}, options);\n      if (this.sequelize.options.dialect === \"postgres\" && options.transaction) {\n        createOptions.ignoreDuplicates = true;\n      }\n      const created = await this.create(values, createOptions);\n      return [created, true];\n    } catch (err) {\n      if (!(err instanceof sequelizeErrors.UniqueConstraintError || err instanceof sequelizeErrors.EmptyResultError)) {\n        throw err;\n      }\n      const foundAgain = await this.findOne(options);\n      return [foundAgain, false];\n    }\n  }\n  static async upsert(values, options) {\n    options = __spreadValues({\n      hooks: true,\n      returning: true,\n      validate: true\n    }, Utils.cloneDeep(options));\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    const createdAtAttr = this._timestampAttributes.createdAt;\n    const updatedAtAttr = this._timestampAttributes.updatedAt;\n    const hasPrimary = this.primaryKeyField in values || this.primaryKeyAttribute in values;\n    const instance = this.build(values);\n    options.model = this;\n    options.instance = instance;\n    const changed = Array.from(instance._changed);\n    if (!options.fields) {\n      options.fields = changed;\n    }\n    if (options.validate) {\n      await instance.validate(options);\n    }\n    const updatedDataValues = _.pick(instance.dataValues, changed);\n    const insertValues = Utils.mapValueFieldNames(instance.dataValues, Object.keys(instance.rawAttributes), this);\n    const updateValues = Utils.mapValueFieldNames(updatedDataValues, options.fields, this);\n    const now = Utils.now(this.sequelize.options.dialect);\n    if (createdAtAttr && !insertValues[createdAtAttr]) {\n      const field = this.rawAttributes[createdAtAttr].field || createdAtAttr;\n      insertValues[field] = this._getDefaultTimestamp(createdAtAttr) || now;\n    }\n    if (updatedAtAttr && !insertValues[updatedAtAttr]) {\n      const field = this.rawAttributes[updatedAtAttr].field || updatedAtAttr;\n      insertValues[field] = updateValues[field] = this._getDefaultTimestamp(updatedAtAttr) || now;\n    }\n    if (this.sequelize.options.dialect === \"db2\") {\n      this.uniqno = this.sequelize.dialect.queryGenerator.addUniqueFields(insertValues, this.rawAttributes, this.uniqno);\n    }\n    if (!hasPrimary && this.primaryKeyAttribute && !this.rawAttributes[this.primaryKeyAttribute].defaultValue) {\n      delete insertValues[this.primaryKeyField];\n      delete updateValues[this.primaryKeyField];\n    }\n    if (options.hooks) {\n      await this.runHooks(\"beforeUpsert\", values, options);\n    }\n    const result = await this.queryInterface.upsert(this.getTableName(options), insertValues, updateValues, instance.where(), options);\n    const [record] = result;\n    record.isNewRecord = false;\n    if (options.hooks) {\n      await this.runHooks(\"afterUpsert\", result, options);\n      return result;\n    }\n    return result;\n  }\n  static async bulkCreate(records, options = {}) {\n    if (!records.length) {\n      return [];\n    }\n    const dialect = this.sequelize.options.dialect;\n    const now = Utils.now(this.sequelize.options.dialect);\n    options = Utils.cloneDeep(options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    options.model = this;\n    if (!options.includeValidated) {\n      this._conformIncludes(options, this);\n      if (options.include) {\n        this._expandIncludeAll(options);\n        this._validateIncludedElements(options);\n      }\n    }\n    const instances = records.map((values) => this.build(values, { isNewRecord: true, include: options.include }));\n    const recursiveBulkCreate = async (instances2, options2) => {\n      options2 = __spreadValues({\n        validate: false,\n        hooks: true,\n        individualHooks: false,\n        ignoreDuplicates: false\n      }, options2);\n      if (options2.returning === void 0) {\n        if (options2.association) {\n          options2.returning = false;\n        } else {\n          options2.returning = true;\n        }\n      }\n      if (options2.ignoreDuplicates && !this.sequelize.dialect.supports.inserts.ignoreDuplicates && !this.sequelize.dialect.supports.inserts.onConflictDoNothing) {\n        throw new Error(`${dialect} does not support the ignoreDuplicates option.`);\n      }\n      if (options2.updateOnDuplicate && (dialect !== \"mysql\" && dialect !== \"mariadb\" && dialect !== \"sqlite\" && dialect !== \"postgres\")) {\n        throw new Error(`${dialect} does not support the updateOnDuplicate option.`);\n      }\n      const model = options2.model;\n      options2.fields = options2.fields || Object.keys(model.rawAttributes);\n      const createdAtAttr = model._timestampAttributes.createdAt;\n      const updatedAtAttr = model._timestampAttributes.updatedAt;\n      if (options2.updateOnDuplicate !== void 0) {\n        if (Array.isArray(options2.updateOnDuplicate) && options2.updateOnDuplicate.length) {\n          options2.updateOnDuplicate = _.intersection(_.without(Object.keys(model.tableAttributes), createdAtAttr), options2.updateOnDuplicate);\n        } else {\n          throw new Error(\"updateOnDuplicate option only supports non-empty array.\");\n        }\n      }\n      if (options2.hooks) {\n        await model.runHooks(\"beforeBulkCreate\", instances2, options2);\n      }\n      if (options2.validate) {\n        const errors = [];\n        const validateOptions = __spreadValues({}, options2);\n        validateOptions.hooks = options2.individualHooks;\n        await Promise.all(instances2.map(async (instance) => {\n          try {\n            await instance.validate(validateOptions);\n          } catch (err) {\n            errors.push(new sequelizeErrors.BulkRecordError(err, instance));\n          }\n        }));\n        delete options2.skip;\n        if (errors.length) {\n          throw new sequelizeErrors.AggregateError(errors);\n        }\n      }\n      if (options2.individualHooks) {\n        await Promise.all(instances2.map(async (instance) => {\n          const individualOptions = __spreadProps(__spreadValues({}, options2), {\n            validate: false,\n            hooks: true\n          });\n          delete individualOptions.fields;\n          delete individualOptions.individualHooks;\n          delete individualOptions.ignoreDuplicates;\n          await instance.save(individualOptions);\n        }));\n      } else {\n        if (options2.include && options2.include.length) {\n          await Promise.all(options2.include.filter((include) => include.association instanceof BelongsTo).map(async (include) => {\n            const associationInstances = [];\n            const associationInstanceIndexToInstanceMap = [];\n            for (const instance of instances2) {\n              const associationInstance = instance.get(include.as);\n              if (associationInstance) {\n                associationInstances.push(associationInstance);\n                associationInstanceIndexToInstanceMap.push(instance);\n              }\n            }\n            if (!associationInstances.length) {\n              return;\n            }\n            const includeOptions = _(Utils.cloneDeep(include)).omit([\"association\"]).defaults({\n              transaction: options2.transaction,\n              logging: options2.logging\n            }).value();\n            const createdAssociationInstances = await recursiveBulkCreate(associationInstances, includeOptions);\n            for (const idx in createdAssociationInstances) {\n              const associationInstance = createdAssociationInstances[idx];\n              const instance = associationInstanceIndexToInstanceMap[idx];\n              await include.association.set(instance, associationInstance, { save: false, logging: options2.logging });\n            }\n          }));\n        }\n        records = instances2.map((instance) => {\n          const values = instance.dataValues;\n          if (createdAtAttr && !values[createdAtAttr]) {\n            values[createdAtAttr] = now;\n            if (!options2.fields.includes(createdAtAttr)) {\n              options2.fields.push(createdAtAttr);\n            }\n          }\n          if (updatedAtAttr && !values[updatedAtAttr]) {\n            values[updatedAtAttr] = now;\n            if (!options2.fields.includes(updatedAtAttr)) {\n              options2.fields.push(updatedAtAttr);\n            }\n          }\n          const out = Utils.mapValueFieldNames(values, options2.fields, model);\n          for (const key of model._virtualAttributes) {\n            delete out[key];\n          }\n          return out;\n        });\n        const fieldMappedAttributes = {};\n        for (const attr in model.tableAttributes) {\n          fieldMappedAttributes[model.rawAttributes[attr].field || attr] = model.rawAttributes[attr];\n        }\n        if (options2.updateOnDuplicate) {\n          options2.updateOnDuplicate = options2.updateOnDuplicate.map((attr) => model.rawAttributes[attr].field || attr);\n          if (options2.conflictAttributes) {\n            options2.upsertKeys = options2.conflictAttributes.map((attrName) => model.rawAttributes[attrName].field || attrName);\n          } else {\n            const upsertKeys = [];\n            for (const i of model._indexes) {\n              if (i.unique && !i.where) {\n                upsertKeys.push(...i.fields);\n              }\n            }\n            const firstUniqueKey = Object.values(model.uniqueKeys).find((c) => c.fields.length > 0);\n            if (firstUniqueKey && firstUniqueKey.fields) {\n              upsertKeys.push(...firstUniqueKey.fields);\n            }\n            options2.upsertKeys = upsertKeys.length > 0 ? upsertKeys : Object.values(model.primaryKeys).map((x) => x.field);\n          }\n        }\n        if (options2.returning && Array.isArray(options2.returning)) {\n          options2.returning = options2.returning.map((attr) => _.get(model.rawAttributes[attr], \"field\", attr));\n        }\n        const results = await model.queryInterface.bulkInsert(model.getTableName(options2), records, options2, fieldMappedAttributes);\n        if (Array.isArray(results)) {\n          results.forEach((result, i) => {\n            const instance = instances2[i];\n            for (const key in result) {\n              if (!instance || key === model.primaryKeyAttribute && instance.get(model.primaryKeyAttribute) && [\"mysql\", \"mariadb\", \"sqlite\"].includes(dialect)) {\n                continue;\n              }\n              if (Object.prototype.hasOwnProperty.call(result, key)) {\n                const record = result[key];\n                const attr = _.find(model.rawAttributes, (attribute) => attribute.fieldName === key || attribute.field === key);\n                instance.dataValues[attr && attr.fieldName || key] = record;\n              }\n            }\n          });\n        }\n      }\n      if (options2.include && options2.include.length) {\n        await Promise.all(options2.include.filter((include) => !(include.association instanceof BelongsTo || include.parent && include.parent.association instanceof BelongsToMany)).map(async (include) => {\n          const associationInstances = [];\n          const associationInstanceIndexToInstanceMap = [];\n          for (const instance of instances2) {\n            let associated = instance.get(include.as);\n            if (!Array.isArray(associated))\n              associated = [associated];\n            for (const associationInstance of associated) {\n              if (associationInstance) {\n                if (!(include.association instanceof BelongsToMany)) {\n                  associationInstance.set(include.association.foreignKey, instance.get(include.association.sourceKey || instance.constructor.primaryKeyAttribute, { raw: true }), { raw: true });\n                  Object.assign(associationInstance, include.association.scope);\n                }\n                associationInstances.push(associationInstance);\n                associationInstanceIndexToInstanceMap.push(instance);\n              }\n            }\n          }\n          if (!associationInstances.length) {\n            return;\n          }\n          const includeOptions = _(Utils.cloneDeep(include)).omit([\"association\"]).defaults({\n            transaction: options2.transaction,\n            logging: options2.logging\n          }).value();\n          const createdAssociationInstances = await recursiveBulkCreate(associationInstances, includeOptions);\n          if (include.association instanceof BelongsToMany) {\n            const valueSets = [];\n            for (const idx in createdAssociationInstances) {\n              const associationInstance = createdAssociationInstances[idx];\n              const instance = associationInstanceIndexToInstanceMap[idx];\n              const values = __spreadValues({\n                [include.association.foreignKey]: instance.get(instance.constructor.primaryKeyAttribute, { raw: true }),\n                [include.association.otherKey]: associationInstance.get(associationInstance.constructor.primaryKeyAttribute, { raw: true })\n              }, include.association.through.scope);\n              if (associationInstance[include.association.through.model.name]) {\n                for (const attr of Object.keys(include.association.through.model.rawAttributes)) {\n                  if (include.association.through.model.rawAttributes[attr]._autoGenerated || attr === include.association.foreignKey || attr === include.association.otherKey || typeof associationInstance[include.association.through.model.name][attr] === \"undefined\") {\n                    continue;\n                  }\n                  values[attr] = associationInstance[include.association.through.model.name][attr];\n                }\n              }\n              valueSets.push(values);\n            }\n            const throughOptions = _(Utils.cloneDeep(include)).omit([\"association\", \"attributes\"]).defaults({\n              transaction: options2.transaction,\n              logging: options2.logging\n            }).value();\n            throughOptions.model = include.association.throughModel;\n            const throughInstances = include.association.throughModel.bulkBuild(valueSets, throughOptions);\n            await recursiveBulkCreate(throughInstances, throughOptions);\n          }\n        }));\n      }\n      instances2.forEach((instance) => {\n        for (const attr in model.rawAttributes) {\n          if (model.rawAttributes[attr].field && instance.dataValues[model.rawAttributes[attr].field] !== void 0 && model.rawAttributes[attr].field !== attr) {\n            instance.dataValues[attr] = instance.dataValues[model.rawAttributes[attr].field];\n            delete instance.dataValues[model.rawAttributes[attr].field];\n          }\n          instance._previousDataValues[attr] = instance.dataValues[attr];\n          instance.changed(attr, false);\n        }\n        instance.isNewRecord = false;\n      });\n      if (options2.hooks) {\n        await model.runHooks(\"afterBulkCreate\", instances2, options2);\n      }\n      return instances2;\n    };\n    return await recursiveBulkCreate(instances, options);\n  }\n  static async truncate(options) {\n    options = Utils.cloneDeep(options) || {};\n    options.truncate = true;\n    return await this.destroy(options);\n  }\n  static async destroy(options) {\n    options = Utils.cloneDeep(options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    this._injectScope(options);\n    if (!options || !(options.where || options.truncate)) {\n      throw new Error(\"Missing where or truncate attribute in the options parameter of model.destroy.\");\n    }\n    if (!options.truncate && !_.isPlainObject(options.where) && !Array.isArray(options.where) && !(options.where instanceof Utils.SequelizeMethod)) {\n      throw new Error(\"Expected plain object, array or sequelize method in the options.where parameter of model.destroy.\");\n    }\n    options = _.defaults(options, {\n      hooks: true,\n      individualHooks: false,\n      force: false,\n      cascade: false,\n      restartIdentity: false\n    });\n    options.type = QueryTypes.BULKDELETE;\n    Utils.mapOptionFieldNames(options, this);\n    options.model = this;\n    if (options.hooks) {\n      await this.runHooks(\"beforeBulkDestroy\", options);\n    }\n    let instances;\n    if (options.individualHooks) {\n      instances = await this.findAll({ where: options.where, transaction: options.transaction, logging: options.logging, benchmark: options.benchmark });\n      await Promise.all(instances.map((instance) => this.runHooks(\"beforeDestroy\", instance, options)));\n    }\n    let result;\n    if (this._timestampAttributes.deletedAt && !options.force) {\n      options.type = QueryTypes.BULKUPDATE;\n      const attrValueHash = {};\n      const deletedAtAttribute = this.rawAttributes[this._timestampAttributes.deletedAt];\n      const field = this.rawAttributes[this._timestampAttributes.deletedAt].field;\n      const where = {\n        [field]: Object.prototype.hasOwnProperty.call(deletedAtAttribute, \"defaultValue\") ? deletedAtAttribute.defaultValue : null\n      };\n      attrValueHash[field] = Utils.now(this.sequelize.options.dialect);\n      result = await this.queryInterface.bulkUpdate(this.getTableName(options), attrValueHash, Object.assign(where, options.where), options, this.rawAttributes);\n    } else {\n      result = await this.queryInterface.bulkDelete(this.getTableName(options), options.where, options, this);\n    }\n    if (options.individualHooks) {\n      await Promise.all(instances.map((instance) => this.runHooks(\"afterDestroy\", instance, options)));\n    }\n    if (options.hooks) {\n      await this.runHooks(\"afterBulkDestroy\", options);\n    }\n    return result;\n  }\n  static async restore(options) {\n    if (!this._timestampAttributes.deletedAt)\n      throw new Error(\"Model is not paranoid\");\n    options = __spreadValues({\n      hooks: true,\n      individualHooks: false\n    }, options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    options.type = QueryTypes.RAW;\n    options.model = this;\n    Utils.mapOptionFieldNames(options, this);\n    if (options.hooks) {\n      await this.runHooks(\"beforeBulkRestore\", options);\n    }\n    let instances;\n    if (options.individualHooks) {\n      instances = await this.findAll({ where: options.where, transaction: options.transaction, logging: options.logging, benchmark: options.benchmark, paranoid: false });\n      await Promise.all(instances.map((instance) => this.runHooks(\"beforeRestore\", instance, options)));\n    }\n    const attrValueHash = {};\n    const deletedAtCol = this._timestampAttributes.deletedAt;\n    const deletedAtAttribute = this.rawAttributes[deletedAtCol];\n    const deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, \"defaultValue\") ? deletedAtAttribute.defaultValue : null;\n    attrValueHash[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;\n    options.omitNull = false;\n    const result = await this.queryInterface.bulkUpdate(this.getTableName(options), attrValueHash, options.where, options, this.rawAttributes);\n    if (options.individualHooks) {\n      await Promise.all(instances.map((instance) => this.runHooks(\"afterRestore\", instance, options)));\n    }\n    if (options.hooks) {\n      await this.runHooks(\"afterBulkRestore\", options);\n    }\n    return result;\n  }\n  static async update(values, options) {\n    options = Utils.cloneDeep(options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    this._injectScope(options);\n    this._optionsMustContainWhere(options);\n    options = this._paranoidClause(this, _.defaults(options, {\n      validate: true,\n      hooks: true,\n      individualHooks: false,\n      returning: false,\n      force: false,\n      sideEffects: true\n    }));\n    options.type = QueryTypes.BULKUPDATE;\n    values = _.omitBy(values, (value) => value === void 0);\n    if (options.fields && options.fields instanceof Array) {\n      for (const key of Object.keys(values)) {\n        if (!options.fields.includes(key)) {\n          delete values[key];\n        }\n      }\n    } else {\n      const updatedAtAttr = this._timestampAttributes.updatedAt;\n      options.fields = _.intersection(Object.keys(values), Object.keys(this.tableAttributes));\n      if (updatedAtAttr && !options.fields.includes(updatedAtAttr)) {\n        options.fields.push(updatedAtAttr);\n      }\n    }\n    if (this._timestampAttributes.updatedAt && !options.silent) {\n      values[this._timestampAttributes.updatedAt] = this._getDefaultTimestamp(this._timestampAttributes.updatedAt) || Utils.now(this.sequelize.options.dialect);\n    }\n    options.model = this;\n    let valuesUse;\n    if (options.validate) {\n      const build = this.build(values);\n      build.set(this._timestampAttributes.updatedAt, values[this._timestampAttributes.updatedAt], { raw: true });\n      if (options.sideEffects) {\n        Object.assign(values, _.pick(build.get(), build.changed()));\n        options.fields = _.union(options.fields, Object.keys(values));\n      }\n      options.skip = _.difference(Object.keys(this.rawAttributes), Object.keys(values));\n      const attributes = await build.validate(options);\n      options.skip = void 0;\n      if (attributes && attributes.dataValues) {\n        values = _.pick(attributes.dataValues, Object.keys(values));\n      }\n    }\n    if (options.hooks) {\n      options.attributes = values;\n      await this.runHooks(\"beforeBulkUpdate\", options);\n      values = options.attributes;\n      delete options.attributes;\n    }\n    valuesUse = values;\n    let instances;\n    let updateDoneRowByRow = false;\n    if (options.individualHooks) {\n      instances = await this.findAll({\n        where: options.where,\n        transaction: options.transaction,\n        logging: options.logging,\n        benchmark: options.benchmark,\n        paranoid: options.paranoid\n      });\n      if (instances.length) {\n        let changedValues;\n        let different = false;\n        instances = await Promise.all(instances.map(async (instance) => {\n          Object.assign(instance.dataValues, values);\n          _.forIn(valuesUse, (newValue, attr) => {\n            if (newValue !== instance._previousDataValues[attr]) {\n              instance.setDataValue(attr, newValue);\n            }\n          });\n          await this.runHooks(\"beforeUpdate\", instance, options);\n          if (!different) {\n            const thisChangedValues = {};\n            _.forIn(instance.dataValues, (newValue, attr) => {\n              if (newValue !== instance._previousDataValues[attr]) {\n                thisChangedValues[attr] = newValue;\n              }\n            });\n            if (!changedValues) {\n              changedValues = thisChangedValues;\n            } else {\n              different = !_.isEqual(changedValues, thisChangedValues);\n            }\n          }\n          return instance;\n        }));\n        if (!different) {\n          const keys = Object.keys(changedValues);\n          if (keys.length) {\n            valuesUse = changedValues;\n            options.fields = _.union(options.fields, keys);\n          }\n        } else {\n          instances = await Promise.all(instances.map(async (instance) => {\n            const individualOptions = __spreadProps(__spreadValues({}, options), {\n              hooks: false,\n              validate: false\n            });\n            delete individualOptions.individualHooks;\n            return instance.save(individualOptions);\n          }));\n          updateDoneRowByRow = true;\n        }\n      }\n    }\n    let result;\n    if (updateDoneRowByRow) {\n      result = [instances.length, instances];\n    } else if (_.isEmpty(valuesUse) || Object.keys(valuesUse).length === 1 && valuesUse[this._timestampAttributes.updatedAt]) {\n      result = [0];\n    } else {\n      valuesUse = Utils.mapValueFieldNames(valuesUse, options.fields, this);\n      options = Utils.mapOptionFieldNames(options, this);\n      options.hasTrigger = this.options ? this.options.hasTrigger : false;\n      const affectedRows = await this.queryInterface.bulkUpdate(this.getTableName(options), valuesUse, options.where, options, this.tableAttributes);\n      if (options.returning) {\n        result = [affectedRows.length, affectedRows];\n        instances = affectedRows;\n      } else {\n        result = [affectedRows];\n      }\n    }\n    if (options.individualHooks) {\n      await Promise.all(instances.map((instance) => this.runHooks(\"afterUpdate\", instance, options)));\n      result[1] = instances;\n    }\n    if (options.hooks) {\n      options.attributes = values;\n      await this.runHooks(\"afterBulkUpdate\", options);\n      delete options.attributes;\n    }\n    return result;\n  }\n  static async describe(schema, options) {\n    return await this.queryInterface.describeTable(this.tableName, __spreadValues({ schema: schema || this._schema || void 0 }, options));\n  }\n  static _getDefaultTimestamp(attr) {\n    if (!!this.rawAttributes[attr] && !!this.rawAttributes[attr].defaultValue) {\n      return Utils.toDefaultValue(this.rawAttributes[attr].defaultValue, this.sequelize.options.dialect);\n    }\n    return void 0;\n  }\n  static _expandAttributes(options) {\n    if (!_.isPlainObject(options.attributes)) {\n      return;\n    }\n    let attributes = Object.keys(this.rawAttributes);\n    if (options.attributes.exclude) {\n      attributes = attributes.filter((elem) => !options.attributes.exclude.includes(elem));\n    }\n    if (options.attributes.include) {\n      attributes = attributes.concat(options.attributes.include);\n    }\n    options.attributes = attributes;\n  }\n  static _injectScope(options) {\n    const scope = Utils.cloneDeep(this._scope);\n    this._defaultsOptions(options, scope);\n  }\n  static [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.name;\n  }\n  static hasAlias(alias) {\n    return Object.prototype.hasOwnProperty.call(this.associations, alias);\n  }\n  static async increment(fields, options) {\n    options = options || {};\n    if (typeof fields === \"string\")\n      fields = [fields];\n    if (Array.isArray(fields)) {\n      fields = fields.map((f) => {\n        if (this.rawAttributes[f] && this.rawAttributes[f].field && this.rawAttributes[f].field !== f) {\n          return this.rawAttributes[f].field;\n        }\n        return f;\n      });\n    } else if (fields && typeof fields === \"object\") {\n      fields = Object.keys(fields).reduce((rawFields, f) => {\n        if (this.rawAttributes[f] && this.rawAttributes[f].field && this.rawAttributes[f].field !== f) {\n          rawFields[this.rawAttributes[f].field] = fields[f];\n        } else {\n          rawFields[f] = fields[f];\n        }\n        return rawFields;\n      }, {});\n    }\n    this._injectScope(options);\n    this._optionsMustContainWhere(options);\n    options = Utils.defaults({}, options, {\n      by: 1,\n      where: {},\n      increment: true\n    });\n    const isSubtraction = !options.increment;\n    Utils.mapOptionFieldNames(options, this);\n    const where = __spreadValues({}, options.where);\n    let incrementAmountsByField = {};\n    if (Array.isArray(fields)) {\n      incrementAmountsByField = {};\n      for (const field of fields) {\n        incrementAmountsByField[field] = options.by;\n      }\n    } else {\n      incrementAmountsByField = fields;\n    }\n    if (this._versionAttribute) {\n      incrementAmountsByField[this._versionAttribute] = isSubtraction ? -1 : 1;\n    }\n    const extraAttributesToBeUpdated = {};\n    const updatedAtAttr = this._timestampAttributes.updatedAt;\n    if (!options.silent && updatedAtAttr && !incrementAmountsByField[updatedAtAttr]) {\n      const attrName = this.rawAttributes[updatedAtAttr].field || updatedAtAttr;\n      extraAttributesToBeUpdated[attrName] = this._getDefaultTimestamp(updatedAtAttr) || Utils.now(this.sequelize.options.dialect);\n    }\n    const tableName = this.getTableName(options);\n    let affectedRows;\n    if (isSubtraction) {\n      affectedRows = await this.queryInterface.decrement(this, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n    } else {\n      affectedRows = await this.queryInterface.increment(this, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n    }\n    if (options.returning) {\n      return [affectedRows, affectedRows.length];\n    }\n    return [affectedRows];\n  }\n  static async decrement(fields, options) {\n    return this.increment(fields, __spreadProps(__spreadValues({\n      by: 1\n    }, options), {\n      increment: false\n    }));\n  }\n  static _optionsMustContainWhere(options) {\n    assert(options && options.where, \"Missing where attribute in the options parameter\");\n    assert(_.isPlainObject(options.where) || Array.isArray(options.where) || options.where instanceof Utils.SequelizeMethod, \"Expected plain object, array or sequelize method in the options.where parameter\");\n  }\n  where(checkVersion) {\n    const where = this.constructor.primaryKeyAttributes.reduce((result, attribute) => {\n      result[attribute] = this.get(attribute, { raw: true });\n      return result;\n    }, {});\n    if (_.size(where) === 0) {\n      return this.constructor.options.whereCollection;\n    }\n    const versionAttr = this.constructor._versionAttribute;\n    if (checkVersion && versionAttr) {\n      where[versionAttr] = this.get(versionAttr, { raw: true });\n    }\n    return Utils.mapWhereFieldNames(where, this.constructor);\n  }\n  toString() {\n    return `[object SequelizeInstance:${this.constructor.name}]`;\n  }\n  getDataValue(key) {\n    return this.dataValues[key];\n  }\n  setDataValue(key, value) {\n    const originalValue = this._previousDataValues[key];\n    if (!_.isEqual(value, originalValue)) {\n      this.changed(key, true);\n    }\n    this.dataValues[key] = value;\n  }\n  get(key, options) {\n    if (options === void 0 && typeof key === \"object\") {\n      options = key;\n      key = void 0;\n    }\n    options = options || {};\n    if (key) {\n      if (Object.prototype.hasOwnProperty.call(this._customGetters, key) && !options.raw) {\n        return this._customGetters[key].call(this, key, options);\n      }\n      if (options.plain && this._options.include && this._options.includeNames.includes(key)) {\n        if (Array.isArray(this.dataValues[key])) {\n          return this.dataValues[key].map((instance) => instance.get(options));\n        }\n        if (this.dataValues[key] instanceof Model) {\n          return this.dataValues[key].get(options);\n        }\n        return this.dataValues[key];\n      }\n      return this.dataValues[key];\n    }\n    if (this._hasCustomGetters || options.plain && this._options.include || options.clone) {\n      const values = {};\n      let _key;\n      if (this._hasCustomGetters) {\n        for (_key in this._customGetters) {\n          if (this._options.attributes && !this._options.attributes.includes(_key)) {\n            continue;\n          }\n          if (Object.prototype.hasOwnProperty.call(this._customGetters, _key)) {\n            values[_key] = this.get(_key, options);\n          }\n        }\n      }\n      for (_key in this.dataValues) {\n        if (!Object.prototype.hasOwnProperty.call(values, _key) && Object.prototype.hasOwnProperty.call(this.dataValues, _key)) {\n          values[_key] = this.get(_key, options);\n        }\n      }\n      return values;\n    }\n    return this.dataValues;\n  }\n  set(key, value, options) {\n    let values;\n    let originalValue;\n    if (typeof key === \"object\" && key !== null) {\n      values = key;\n      options = value || {};\n      if (options.reset) {\n        this.dataValues = {};\n        for (const key2 in values) {\n          this.changed(key2, false);\n        }\n      }\n      if (options.raw && !(this._options && this._options.include) && !(options && options.attributes) && !this.constructor._hasDateAttributes && !this.constructor._hasBooleanAttributes) {\n        if (Object.keys(this.dataValues).length) {\n          Object.assign(this.dataValues, values);\n        } else {\n          this.dataValues = values;\n        }\n        this._previousDataValues = __spreadValues({}, this.dataValues);\n      } else {\n        if (options.attributes) {\n          const setKeys = (data) => {\n            for (const k of data) {\n              if (values[k] === void 0) {\n                continue;\n              }\n              this.set(k, values[k], options);\n            }\n          };\n          setKeys(options.attributes);\n          if (this.constructor._hasVirtualAttributes) {\n            setKeys(this.constructor._virtualAttributes);\n          }\n          if (this._options.includeNames) {\n            setKeys(this._options.includeNames);\n          }\n        } else {\n          for (const key2 in values) {\n            this.set(key2, values[key2], options);\n          }\n        }\n        if (options.raw) {\n          this._previousDataValues = __spreadValues({}, this.dataValues);\n        }\n      }\n      return this;\n    }\n    if (!options)\n      options = {};\n    if (!options.raw) {\n      originalValue = this.dataValues[key];\n    }\n    if (!options.raw && this._customSetters[key]) {\n      this._customSetters[key].call(this, value, key);\n      const newValue = this.dataValues[key];\n      if (!_.isEqual(newValue, originalValue)) {\n        this._previousDataValues[key] = originalValue;\n        this.changed(key, true);\n      }\n    } else {\n      if (this._options && this._options.include && this._options.includeNames.includes(key)) {\n        this._setInclude(key, value, options);\n        return this;\n      }\n      if (!options.raw) {\n        if (!this._isAttribute(key)) {\n          if (key.includes(\".\") && this.constructor._jsonAttributes.has(key.split(\".\")[0])) {\n            const previousNestedValue = Dottie.get(this.dataValues, key);\n            if (!_.isEqual(previousNestedValue, value)) {\n              Dottie.set(this.dataValues, key, value);\n              this.changed(key.split(\".\")[0], true);\n            }\n          }\n          return this;\n        }\n        if (this.constructor._hasPrimaryKeys && originalValue && this.constructor._isPrimaryKey(key)) {\n          return this;\n        }\n        if (!this.isNewRecord && this.constructor._hasReadOnlyAttributes && this.constructor._readOnlyAttributes.has(key)) {\n          return this;\n        }\n      }\n      if (!(value instanceof Utils.SequelizeMethod) && Object.prototype.hasOwnProperty.call(this.constructor._dataTypeSanitizers, key)) {\n        value = this.constructor._dataTypeSanitizers[key].call(this, value, options);\n      }\n      if (!options.raw && (value instanceof Utils.SequelizeMethod || !(value instanceof Utils.SequelizeMethod) && this.constructor._dataTypeChanges[key] && this.constructor._dataTypeChanges[key].call(this, value, originalValue, options) || !this.constructor._dataTypeChanges[key] && !_.isEqual(value, originalValue))) {\n        this._previousDataValues[key] = originalValue;\n        this.changed(key, true);\n      }\n      this.dataValues[key] = value;\n    }\n    return this;\n  }\n  setAttributes(updates) {\n    return this.set(updates);\n  }\n  changed(key, value) {\n    if (key === void 0) {\n      if (this._changed.size > 0) {\n        return Array.from(this._changed);\n      }\n      return false;\n    }\n    if (value === true) {\n      this._changed.add(key);\n      return this;\n    }\n    if (value === false) {\n      this._changed.delete(key);\n      return this;\n    }\n    return this._changed.has(key);\n  }\n  previous(key) {\n    if (key) {\n      return this._previousDataValues[key];\n    }\n    return _.pickBy(this._previousDataValues, (value, key2) => this.changed(key2));\n  }\n  _setInclude(key, value, options) {\n    if (!Array.isArray(value))\n      value = [value];\n    if (value[0] instanceof Model) {\n      value = value.map((instance) => instance.dataValues);\n    }\n    const include = this._options.includeMap[key];\n    const association = include.association;\n    const accessor = key;\n    const primaryKeyAttribute = include.model.primaryKeyAttribute;\n    const childOptions = {\n      isNewRecord: this.isNewRecord,\n      include: include.include,\n      includeNames: include.includeNames,\n      includeMap: include.includeMap,\n      includeValidated: true,\n      raw: options.raw,\n      attributes: include.originalAttributes\n    };\n    let isEmpty;\n    if (include.originalAttributes === void 0 || include.originalAttributes.length) {\n      if (association.isSingleAssociation) {\n        if (Array.isArray(value)) {\n          value = value[0];\n        }\n        isEmpty = value && value[primaryKeyAttribute] === null || value === null;\n        this[accessor] = this.dataValues[accessor] = isEmpty ? null : include.model.build(value, childOptions);\n      } else {\n        isEmpty = value[0] && value[0][primaryKeyAttribute] === null;\n        this[accessor] = this.dataValues[accessor] = isEmpty ? [] : include.model.bulkBuild(value, childOptions);\n      }\n    }\n  }\n  async save(options) {\n    if (arguments.length > 1) {\n      throw new Error(\"The second argument was removed in favor of the options object.\");\n    }\n    options = Utils.cloneDeep(options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    options = _.defaults(options, {\n      hooks: true,\n      validate: true\n    });\n    if (!options.fields) {\n      if (this.isNewRecord) {\n        options.fields = Object.keys(this.constructor.rawAttributes);\n      } else {\n        options.fields = _.intersection(this.changed(), Object.keys(this.constructor.rawAttributes));\n      }\n      options.defaultFields = options.fields;\n    }\n    if (options.returning === void 0) {\n      if (options.association) {\n        options.returning = false;\n      } else if (this.isNewRecord) {\n        options.returning = true;\n      }\n    }\n    const primaryKeyName = this.constructor.primaryKeyAttribute;\n    const primaryKeyAttribute = primaryKeyName && this.constructor.rawAttributes[primaryKeyName];\n    const createdAtAttr = this.constructor._timestampAttributes.createdAt;\n    const versionAttr = this.constructor._versionAttribute;\n    const hook = this.isNewRecord ? \"Create\" : \"Update\";\n    const wasNewRecord = this.isNewRecord;\n    const now = Utils.now(this.sequelize.options.dialect);\n    let updatedAtAttr = this.constructor._timestampAttributes.updatedAt;\n    if (updatedAtAttr && options.fields.length > 0 && !options.fields.includes(updatedAtAttr)) {\n      options.fields.push(updatedAtAttr);\n    }\n    if (versionAttr && options.fields.length > 0 && !options.fields.includes(versionAttr)) {\n      options.fields.push(versionAttr);\n    }\n    if (options.silent === true && !(this.isNewRecord && this.get(updatedAtAttr, { raw: true }))) {\n      _.remove(options.fields, (val) => val === updatedAtAttr);\n      updatedAtAttr = false;\n    }\n    if (this.isNewRecord === true) {\n      if (createdAtAttr && !options.fields.includes(createdAtAttr)) {\n        options.fields.push(createdAtAttr);\n      }\n      if (primaryKeyAttribute && primaryKeyAttribute.defaultValue && !options.fields.includes(primaryKeyName)) {\n        options.fields.unshift(primaryKeyName);\n      }\n    }\n    if (this.isNewRecord === false) {\n      if (primaryKeyName && this.get(primaryKeyName, { raw: true }) === void 0) {\n        throw new Error(\"You attempted to save an instance with no primary key, this is not allowed since it would result in a global update\");\n      }\n    }\n    if (updatedAtAttr && !options.silent && options.fields.includes(updatedAtAttr)) {\n      this.dataValues[updatedAtAttr] = this.constructor._getDefaultTimestamp(updatedAtAttr) || now;\n    }\n    if (this.isNewRecord && createdAtAttr && !this.dataValues[createdAtAttr]) {\n      this.dataValues[createdAtAttr] = this.constructor._getDefaultTimestamp(createdAtAttr) || now;\n    }\n    if (this.sequelize.options.dialect === \"db2\" && this.isNewRecord) {\n      this.uniqno = this.sequelize.dialect.queryGenerator.addUniqueFields(this.dataValues, this.constructor.rawAttributes, this.uniqno);\n    }\n    if (options.validate) {\n      await this.validate(options);\n    }\n    if (options.hooks) {\n      const beforeHookValues = _.pick(this.dataValues, options.fields);\n      let ignoreChanged = _.difference(this.changed(), options.fields);\n      let hookChanged;\n      let afterHookValues;\n      if (updatedAtAttr && options.fields.includes(updatedAtAttr)) {\n        ignoreChanged = _.without(ignoreChanged, updatedAtAttr);\n      }\n      await this.constructor.runHooks(`before${hook}`, this, options);\n      if (options.defaultFields && !this.isNewRecord) {\n        afterHookValues = _.pick(this.dataValues, _.difference(this.changed(), ignoreChanged));\n        hookChanged = [];\n        for (const key of Object.keys(afterHookValues)) {\n          if (afterHookValues[key] !== beforeHookValues[key]) {\n            hookChanged.push(key);\n          }\n        }\n        options.fields = _.uniq(options.fields.concat(hookChanged));\n      }\n      if (hookChanged) {\n        if (options.validate) {\n          options.skip = _.difference(Object.keys(this.constructor.rawAttributes), hookChanged);\n          await this.validate(options);\n          delete options.skip;\n        }\n      }\n    }\n    if (options.fields.length && this.isNewRecord && this._options.include && this._options.include.length) {\n      await Promise.all(this._options.include.filter((include) => include.association instanceof BelongsTo).map(async (include) => {\n        const instance = this.get(include.as);\n        if (!instance)\n          return;\n        const includeOptions = _(Utils.cloneDeep(include)).omit([\"association\"]).defaults({\n          transaction: options.transaction,\n          logging: options.logging,\n          parentRecord: this\n        }).value();\n        await instance.save(includeOptions);\n        await this[include.association.accessors.set](instance, { save: false, logging: options.logging });\n      }));\n    }\n    const realFields = options.fields.filter((field) => !this.constructor._virtualAttributes.has(field));\n    if (!realFields.length)\n      return this;\n    if (!this.changed() && !this.isNewRecord)\n      return this;\n    const versionFieldName = _.get(this.constructor.rawAttributes[versionAttr], \"field\") || versionAttr;\n    const values = Utils.mapValueFieldNames(this.dataValues, options.fields, this.constructor);\n    let query = null;\n    let args = [];\n    let where;\n    if (this.isNewRecord) {\n      query = \"insert\";\n      args = [this, this.constructor.getTableName(options), values, options];\n    } else {\n      where = this.where(true);\n      if (versionAttr) {\n        values[versionFieldName] = parseInt(values[versionFieldName], 10) + 1;\n      }\n      query = \"update\";\n      args = [this, this.constructor.getTableName(options), values, where, options];\n    }\n    const [result, rowsUpdated] = await this.constructor.queryInterface[query](...args);\n    if (versionAttr) {\n      if (rowsUpdated < 1) {\n        throw new sequelizeErrors.OptimisticLockError({\n          modelName: this.constructor.name,\n          values,\n          where\n        });\n      } else {\n        result.dataValues[versionAttr] = values[versionFieldName];\n      }\n    }\n    for (const attr of Object.keys(this.constructor.rawAttributes)) {\n      if (this.constructor.rawAttributes[attr].field && values[this.constructor.rawAttributes[attr].field] !== void 0 && this.constructor.rawAttributes[attr].field !== attr) {\n        values[attr] = values[this.constructor.rawAttributes[attr].field];\n        delete values[this.constructor.rawAttributes[attr].field];\n      }\n    }\n    Object.assign(values, result.dataValues);\n    Object.assign(result.dataValues, values);\n    if (wasNewRecord && this._options.include && this._options.include.length) {\n      await Promise.all(this._options.include.filter((include) => !(include.association instanceof BelongsTo || include.parent && include.parent.association instanceof BelongsToMany)).map(async (include) => {\n        let instances = this.get(include.as);\n        if (!instances)\n          return;\n        if (!Array.isArray(instances))\n          instances = [instances];\n        const includeOptions = _(Utils.cloneDeep(include)).omit([\"association\"]).defaults({\n          transaction: options.transaction,\n          logging: options.logging,\n          parentRecord: this\n        }).value();\n        await Promise.all(instances.map(async (instance) => {\n          if (include.association instanceof BelongsToMany) {\n            await instance.save(includeOptions);\n            const values0 = __spreadValues({\n              [include.association.foreignKey]: this.get(this.constructor.primaryKeyAttribute, { raw: true }),\n              [include.association.otherKey]: instance.get(instance.constructor.primaryKeyAttribute, { raw: true })\n            }, include.association.through.scope);\n            if (instance[include.association.through.model.name]) {\n              for (const attr of Object.keys(include.association.through.model.rawAttributes)) {\n                if (include.association.through.model.rawAttributes[attr]._autoGenerated || attr === include.association.foreignKey || attr === include.association.otherKey || typeof instance[include.association.through.model.name][attr] === \"undefined\") {\n                  continue;\n                }\n                values0[attr] = instance[include.association.through.model.name][attr];\n              }\n            }\n            await include.association.throughModel.create(values0, includeOptions);\n          } else {\n            instance.set(include.association.foreignKey, this.get(include.association.sourceKey || this.constructor.primaryKeyAttribute, { raw: true }), { raw: true });\n            Object.assign(instance, include.association.scope);\n            await instance.save(includeOptions);\n          }\n        }));\n      }));\n    }\n    if (options.hooks) {\n      await this.constructor.runHooks(`after${hook}`, result, options);\n    }\n    for (const field of options.fields) {\n      result._previousDataValues[field] = result.dataValues[field];\n      this.changed(field, false);\n    }\n    this.isNewRecord = false;\n    return result;\n  }\n  async reload(options) {\n    options = Utils.defaults({\n      where: this.where()\n    }, options, {\n      include: this._options.include || void 0\n    });\n    const reloaded = await this.constructor.findOne(options);\n    if (!reloaded) {\n      throw new sequelizeErrors.InstanceError(\"Instance could not be reloaded because it does not exist anymore (find call returned null)\");\n    }\n    this._options = reloaded._options;\n    this.set(reloaded.dataValues, {\n      raw: true,\n      reset: !options.attributes\n    });\n    return this;\n  }\n  async validate(options) {\n    return new InstanceValidator(this, options).validate();\n  }\n  async update(values, options) {\n    values = _.omitBy(values, (value) => value === void 0);\n    const changedBefore = this.changed() || [];\n    options = options || {};\n    if (Array.isArray(options))\n      options = { fields: options };\n    options = Utils.cloneDeep(options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    const setOptions = Utils.cloneDeep(options);\n    setOptions.attributes = options.fields;\n    this.set(values, setOptions);\n    const sideEffects = _.without(this.changed(), ...changedBefore);\n    const fields = _.union(Object.keys(values), sideEffects);\n    if (!options.fields) {\n      options.fields = _.intersection(fields, this.changed());\n      options.defaultFields = options.fields;\n    }\n    return await this.save(options);\n  }\n  async destroy(options) {\n    options = __spreadValues({\n      hooks: true,\n      force: false\n    }, options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    if (options.hooks) {\n      await this.constructor.runHooks(\"beforeDestroy\", this, options);\n    }\n    const where = this.where(true);\n    let result;\n    if (this.constructor._timestampAttributes.deletedAt && options.force === false) {\n      const attributeName = this.constructor._timestampAttributes.deletedAt;\n      const attribute = this.constructor.rawAttributes[attributeName];\n      const defaultValue = Object.prototype.hasOwnProperty.call(attribute, \"defaultValue\") ? attribute.defaultValue : null;\n      const currentValue = this.getDataValue(attributeName);\n      const undefinedOrNull = currentValue == null && defaultValue == null;\n      if (undefinedOrNull || _.isEqual(currentValue, defaultValue)) {\n        this.setDataValue(attributeName, new Date());\n      }\n      result = await this.save(__spreadProps(__spreadValues({}, options), { hooks: false }));\n    } else {\n      result = await this.constructor.queryInterface.delete(this, this.constructor.getTableName(options), where, __spreadValues({ type: QueryTypes.DELETE, limit: null }, options));\n    }\n    if (options.hooks) {\n      await this.constructor.runHooks(\"afterDestroy\", this, options);\n    }\n    return result;\n  }\n  isSoftDeleted() {\n    if (!this.constructor._timestampAttributes.deletedAt) {\n      throw new Error(\"Model is not paranoid\");\n    }\n    const deletedAtAttribute = this.constructor.rawAttributes[this.constructor._timestampAttributes.deletedAt];\n    const defaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, \"defaultValue\") ? deletedAtAttribute.defaultValue : null;\n    const deletedAt = this.get(this.constructor._timestampAttributes.deletedAt) || null;\n    const isSet = deletedAt !== defaultValue;\n    return isSet;\n  }\n  async restore(options) {\n    if (!this.constructor._timestampAttributes.deletedAt)\n      throw new Error(\"Model is not paranoid\");\n    options = __spreadValues({\n      hooks: true,\n      force: false\n    }, options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    if (options.hooks) {\n      await this.constructor.runHooks(\"beforeRestore\", this, options);\n    }\n    const deletedAtCol = this.constructor._timestampAttributes.deletedAt;\n    const deletedAtAttribute = this.constructor.rawAttributes[deletedAtCol];\n    const deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, \"defaultValue\") ? deletedAtAttribute.defaultValue : null;\n    this.setDataValue(deletedAtCol, deletedAtDefaultValue);\n    const result = await this.save(__spreadProps(__spreadValues({}, options), { hooks: false, omitNull: false }));\n    if (options.hooks) {\n      await this.constructor.runHooks(\"afterRestore\", this, options);\n      return result;\n    }\n    return result;\n  }\n  async increment(fields, options) {\n    const identifier = this.where();\n    options = Utils.cloneDeep(options);\n    options.where = __spreadValues(__spreadValues({}, options.where), identifier);\n    options.instance = this;\n    await this.constructor.increment(fields, options);\n    return this;\n  }\n  async decrement(fields, options) {\n    return this.increment(fields, __spreadProps(__spreadValues({\n      by: 1\n    }, options), {\n      increment: false\n    }));\n  }\n  equals(other) {\n    if (!other || !other.constructor) {\n      return false;\n    }\n    if (!(other instanceof this.constructor)) {\n      return false;\n    }\n    return this.constructor.primaryKeyAttributes.every((attribute) => this.get(attribute, { raw: true }) === other.get(attribute, { raw: true }));\n  }\n  equalsOneOf(others) {\n    return others.some((other) => this.equals(other));\n  }\n  setValidators(attribute, validators) {\n    this.validators[attribute] = validators;\n  }\n  toJSON() {\n    return _.cloneDeep(this.get({\n      plain: true\n    }));\n  }\n  static hasMany(target, options) {\n  }\n  static belongsToMany(target, options) {\n  }\n  static hasOne(target, options) {\n  }\n  static belongsTo(target, options) {\n  }\n}\nfunction unpackAnd(where) {\n  if (!_.isObject(where)) {\n    return where;\n  }\n  const keys = Utils.getComplexKeys(where);\n  if (keys.length === 0) {\n    return;\n  }\n  if (keys.length !== 1 || keys[0] !== Op.and) {\n    return where;\n  }\n  const andParts = where[Op.and];\n  return andParts;\n}\nfunction combineWheresWithAnd(whereA, whereB) {\n  const unpackedA = unpackAnd(whereA);\n  if (unpackedA === void 0) {\n    return whereB;\n  }\n  const unpackedB = unpackAnd(whereB);\n  if (unpackedB === void 0) {\n    return whereA;\n  }\n  return {\n    [Op.and]: _.flatten([unpackedA, unpackedB])\n  };\n}\nObject.assign(Model, associationsMixin);\nHooks.applyTo(Model, true);\nmodule.exports = Model;\n//# sourceMappingURL=model.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9tb2RlbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsVUFBVSxtQkFBTyxDQUFDLGlFQUFRO0FBQzFCLGVBQWUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMvQixjQUFjLG1CQUFPLENBQUMsd0VBQVM7QUFDL0IsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzRkFBZ0I7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsNEdBQTJCO0FBQ3JELHNCQUFzQixtQkFBTyxDQUFDLHNIQUFnQztBQUM5RCwwQkFBMEIsbUJBQU8sQ0FBQyxrR0FBc0I7QUFDeEQsbUJBQW1CLG1CQUFPLENBQUMsb0ZBQWU7QUFDMUMsd0JBQXdCLG1CQUFPLENBQUMsZ0ZBQVU7QUFDMUMsb0JBQW9CLG1CQUFPLENBQUMsZ0dBQXFCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLHdHQUF5QjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxrRkFBYztBQUN4QyxjQUFjLG1CQUFPLENBQUMsd0VBQVM7QUFDL0IsMEJBQTBCLG1CQUFPLENBQUMsa0dBQXNCO0FBQ3hELFdBQVcsbUJBQU8sQ0FBQyxnRkFBYTtBQUNoQyxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsa0dBQXNCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUNBQXVDLHFEQUFxRCxxRUFBcUU7QUFDaE07QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLFdBQVc7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixlQUFlO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRLHNCQUFzQixVQUFVO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLEtBQUs7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDBEQUEwRCxtREFBbUQ7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx1REFBdUQ7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0JBQWtCLHVCQUF1QixVQUFVO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsa0JBQWtCLG1CQUFtQixXQUFXLDRDQUE0QyxZQUFZLHNFQUFzRSwyQkFBMkI7QUFDaFE7QUFDQSxxREFBcUQsa0JBQWtCLG1CQUFtQixXQUFXO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxrQkFBa0IsbUJBQW1CLFdBQVc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLG9DQUFvQyxHQUFHLFdBQVc7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNENBQTRDLDBCQUEwQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyxVQUFVLDJCQUEyQixjQUFjO0FBQ3hKO0FBQ0E7QUFDQSxvRkFBb0YsVUFBVSwrQkFBK0IsY0FBYztBQUMzSTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QyxpREFBaUQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsVUFBVSxHQUFHLEtBQUs7QUFDbEY7QUFDQTtBQUNBLG1EQUFtRCxVQUFVLEdBQUcsS0FBSztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSSw4Q0FBOEMseUJBQXlCO0FBQ25IO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1YsdUJBQXVCLGVBQWUsR0FBRyxLQUFLO0FBQzlDO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixJQUFJO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrQkFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBLG1DQUFtQyxNQUFNLHVCQUF1QixpQkFBaUI7QUFDakY7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix1RUFBdUUsV0FBVztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxjQUFjLHFDQUFxQztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxQ0FBcUMsK0NBQStDLFVBQVU7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsV0FBVztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNDQUFzQztBQUMvQztBQUNBLFNBQVM7QUFDVDtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBLDZGQUE2RixXQUFXO0FBQ3hHO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04saUVBQWlFLE1BQU07QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVLEdBQUcsb0NBQW9DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGFBQWE7QUFDckU7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFdBQVc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLEtBQUs7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVSxnQ0FBZ0MsTUFBTSx5REFBeUQsb0JBQW9CLFFBQVEsTUFBTTtBQUM1SztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSw2Q0FBNkM7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHdDQUF3QztBQUNySDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0tBQW9LLFdBQVcsS0FBSyxXQUFXO0FBQy9MO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLFdBQVc7QUFDdEgsK0hBQStILFdBQVc7QUFDMUksZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0hBQWdIO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaUlBQWlJO0FBQ3hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csV0FBVztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsMENBQTBDO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxXQUFXO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFdBQVc7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVc7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxLQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtFQUFrRSx1Q0FBdUM7QUFDekcsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsV0FBVztBQUM1Ryx1R0FBdUcsV0FBVztBQUNsSCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLDJJQUEySSxXQUFXLEtBQUssV0FBVztBQUN0SztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxjQUFjLGNBQWM7QUFDMUYsTUFBTTtBQUNOLGtJQUFrSSxzQ0FBc0M7QUFDeEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsY0FBYywrQkFBK0I7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsV0FBVyw2QkFBNkIsV0FBVztBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL21vZGVsLmpzP2Y4YjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IERvdHRpZSA9IHJlcXVpcmUoXCJkb3R0aWVcIik7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoXCIuL3V0aWxzL2xvZ2dlclwiKTtcbmNvbnN0IEJlbG9uZ3NUbyA9IHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvXCIpO1xuY29uc3QgQmVsb25nc1RvTWFueSA9IHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvLW1hbnlcIik7XG5jb25zdCBJbnN0YW5jZVZhbGlkYXRvciA9IHJlcXVpcmUoXCIuL2luc3RhbmNlLXZhbGlkYXRvclwiKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKFwiLi9xdWVyeS10eXBlc1wiKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IEFzc29jaWF0aW9uID0gcmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL2Jhc2VcIik7XG5jb25zdCBIYXNNYW55ID0gcmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL2hhcy1tYW55XCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4vZGF0YS10eXBlc1wiKTtcbmNvbnN0IEhvb2tzID0gcmVxdWlyZShcIi4vaG9va3NcIik7XG5jb25zdCBhc3NvY2lhdGlvbnNNaXhpbiA9IHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9taXhpblwiKTtcbmNvbnN0IE9wID0gcmVxdWlyZShcIi4vb3BlcmF0b3JzXCIpO1xuY29uc3QgeyBub0RvdWJsZU5lc3RlZEdyb3VwIH0gPSByZXF1aXJlKFwiLi91dGlscy9kZXByZWNhdGlvbnNcIik7XG5jb25zdCB2YWxpZFF1ZXJ5S2V5d29yZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwid2hlcmVcIixcbiAgXCJhdHRyaWJ1dGVzXCIsXG4gIFwicGFyYW5vaWRcIixcbiAgXCJpbmNsdWRlXCIsXG4gIFwib3JkZXJcIixcbiAgXCJsaW1pdFwiLFxuICBcIm9mZnNldFwiLFxuICBcInRyYW5zYWN0aW9uXCIsXG4gIFwibG9ja1wiLFxuICBcInJhd1wiLFxuICBcImxvZ2dpbmdcIixcbiAgXCJiZW5jaG1hcmtcIixcbiAgXCJoYXZpbmdcIixcbiAgXCJzZWFyY2hQYXRoXCIsXG4gIFwicmVqZWN0T25FbXB0eVwiLFxuICBcInBsYWluXCIsXG4gIFwic2NvcGVcIixcbiAgXCJncm91cFwiLFxuICBcInRocm91Z2hcIixcbiAgXCJkZWZhdWx0c1wiLFxuICBcImRpc3RpbmN0XCIsXG4gIFwicHJpbWFyeVwiLFxuICBcImV4Y2VwdGlvblwiLFxuICBcInR5cGVcIixcbiAgXCJob29rc1wiLFxuICBcImZvcmNlXCIsXG4gIFwibmFtZVwiXG5dKTtcbmNvbnN0IG5vbkNhc2NhZGluZ09wdGlvbnMgPSBbXCJpbmNsdWRlXCIsIFwiYXR0cmlidXRlc1wiLCBcIm9yaWdpbmFsQXR0cmlidXRlc1wiLCBcIm9yZGVyXCIsIFwid2hlcmVcIiwgXCJsaW1pdFwiLCBcIm9mZnNldFwiLCBcInBsYWluXCIsIFwiZ3JvdXBcIiwgXCJoYXZpbmdcIl07XG5jbGFzcyBNb2RlbCB7XG4gIHN0YXRpYyBnZXQgcXVlcnlJbnRlcmZhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLmdldFF1ZXJ5SW50ZXJmYWNlKCk7XG4gIH1cbiAgc3RhdGljIGdldCBxdWVyeUdlbmVyYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeUludGVyZmFjZS5xdWVyeUdlbmVyYXRvcjtcbiAgfVxuICBnZXQgc2VxdWVsaXplKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnNlcXVlbGl6ZTtcbiAgfVxuICBjb25zdHJ1Y3Rvcih2YWx1ZXMgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLl9vdmVyd3JpdHRlbkF0dHJpYnV0ZXNDaGVja2VkKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLl9vdmVyd3JpdHRlbkF0dHJpYnV0ZXNDaGVja2VkID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBvdmVyd3JpdHRlbkF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5jb25zdHJ1Y3Rvci5fYXR0cmlidXRlTWFuaXB1bGF0aW9uKSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywga2V5KSkge1xuICAgICAgICAgICAgb3ZlcndyaXR0ZW5BdHRyaWJ1dGVzLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG92ZXJ3cml0dGVuQXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYE1vZGVsICR7SlNPTi5zdHJpbmdpZnkodGhpcy5jb25zdHJ1Y3Rvci5uYW1lKX0gaXMgZGVjbGFyaW5nIHB1YmxpYyBjbGFzcyBmaWVsZHMgZm9yIGF0dHJpYnV0ZShzKTogJHtvdmVyd3JpdHRlbkF0dHJpYnV0ZXMubWFwKChhdHRyKSA9PiBKU09OLnN0cmluZ2lmeShhdHRyKSkuam9pbihcIiwgXCIpfS5cblRoZXNlIGNsYXNzIGZpZWxkcyBhcmUgc2hhZG93aW5nIFNlcXVlbGl6ZSdzIGF0dHJpYnV0ZSBnZXR0ZXJzICYgc2V0dGVycy5cblNlZSBodHRwczovL3NlcXVlbGl6ZS5vcmcvbWFpbi9tYW51YWwvbW9kZWwtYmFzaWNzLmh0bWwjY2F2ZWF0LXdpdGgtcHVibGljLWNsYXNzLWZpZWxkc2ApO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGlzTmV3UmVjb3JkOiB0cnVlLFxuICAgICAgX3NjaGVtYTogdGhpcy5jb25zdHJ1Y3Rvci5fc2NoZW1hLFxuICAgICAgX3NjaGVtYURlbGltaXRlcjogdGhpcy5jb25zdHJ1Y3Rvci5fc2NoZW1hRGVsaW1pdGVyXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzLm1hcCgoYXR0cmlidXRlKSA9PiBBcnJheS5pc0FycmF5KGF0dHJpYnV0ZSkgPyBhdHRyaWJ1dGVbMV0gOiBhdHRyaWJ1dGUpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZVZhbGlkYXRlZCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fY29uZm9ybUluY2x1ZGVzKG9wdGlvbnMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLl9leHBhbmRJbmNsdWRlQWxsKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLl92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHMob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGF0YVZhbHVlcyA9IHt9O1xuICAgIHRoaXMuX3ByZXZpb3VzRGF0YVZhbHVlcyA9IHt9O1xuICAgIHRoaXMudW5pcW5vID0gMTtcbiAgICB0aGlzLl9jaGFuZ2VkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmlzTmV3UmVjb3JkID0gb3B0aW9ucy5pc05ld1JlY29yZDtcbiAgICB0aGlzLl9pbml0VmFsdWVzKHZhbHVlcywgb3B0aW9ucyk7XG4gIH1cbiAgX2luaXRWYWx1ZXModmFsdWVzLCBvcHRpb25zKSB7XG4gICAgbGV0IGRlZmF1bHRzO1xuICAgIGxldCBrZXk7XG4gICAgdmFsdWVzID0gX19zcHJlYWRWYWx1ZXMoe30sIHZhbHVlcyk7XG4gICAgaWYgKG9wdGlvbnMuaXNOZXdSZWNvcmQpIHtcbiAgICAgIGRlZmF1bHRzID0ge307XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5faGFzRGVmYXVsdFZhbHVlcykge1xuICAgICAgICBkZWZhdWx0cyA9IF8ubWFwVmFsdWVzKHRoaXMuY29uc3RydWN0b3IuX2RlZmF1bHRWYWx1ZXMsICh2YWx1ZUZuKSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZUZuKCk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kID8gdmFsdWUgOiBfLmNsb25lRGVlcCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZXMuZm9yRWFjaCgocHJpbWFyeUtleUF0dHJpYnV0ZSkgPT4ge1xuICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmF1bHRzLCBwcmltYXJ5S2V5QXR0cmlidXRlKSkge1xuICAgICAgICAgICAgZGVmYXVsdHNbcHJpbWFyeUtleUF0dHJpYnV0ZV0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXQgJiYgZGVmYXVsdHNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXRdKSB7XG4gICAgICAgIHRoaXMuZGF0YVZhbHVlc1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdF0gPSBVdGlscy50b0RlZmF1bHRWYWx1ZShkZWZhdWx0c1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdF0sIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgICAgIGRlbGV0ZSBkZWZhdWx0c1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdF07XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQgJiYgZGVmYXVsdHNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXRdKSB7XG4gICAgICAgIHRoaXMuZGF0YVZhbHVlc1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdF0gPSBVdGlscy50b0RlZmF1bHRWYWx1ZShkZWZhdWx0c1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdF0sIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgICAgIGRlbGV0ZSBkZWZhdWx0c1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdF07XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQgJiYgZGVmYXVsdHNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXRdKSB7XG4gICAgICAgIHRoaXMuZGF0YVZhbHVlc1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdF0gPSBVdGlscy50b0RlZmF1bHRWYWx1ZShkZWZhdWx0c1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdF0sIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgICAgIGRlbGV0ZSBkZWZhdWx0c1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdF07XG4gICAgICB9XG4gICAgICBmb3IgKGtleSBpbiBkZWZhdWx0cykge1xuICAgICAgICBpZiAodmFsdWVzW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgIHRoaXMuc2V0KGtleSwgVXRpbHMudG9EZWZhdWx0VmFsdWUoZGVmYXVsdHNba2V5XSwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KSwgeyByYXc6IHRydWUgfSk7XG4gICAgICAgICAgZGVsZXRlIHZhbHVlc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2V0KHZhbHVlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIF9wYXJhbm9pZENsYXVzZShtb2RlbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgZm9yIChjb25zdCBpbmNsdWRlIG9mIG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgICB0aGlzLl9wYXJhbm9pZENsYXVzZShpbmNsdWRlLm1vZGVsLCBpbmNsdWRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKF8uZ2V0KG9wdGlvbnMsIFwiZ3JvdXBlZExpbWl0Lm9uLm9wdGlvbnMucGFyYW5vaWRcIikpIHtcbiAgICAgIGNvbnN0IHRocm91Z2hNb2RlbCA9IF8uZ2V0KG9wdGlvbnMsIFwiZ3JvdXBlZExpbWl0Lm9uLnRocm91Z2gubW9kZWxcIik7XG4gICAgICBpZiAodGhyb3VnaE1vZGVsKSB7XG4gICAgICAgIG9wdGlvbnMuZ3JvdXBlZExpbWl0LnRocm91Z2ggPSB0aGlzLl9wYXJhbm9pZENsYXVzZSh0aHJvdWdoTW9kZWwsIG9wdGlvbnMuZ3JvdXBlZExpbWl0LnRocm91Z2gpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW1vZGVsLm9wdGlvbnMudGltZXN0YW1wcyB8fCAhbW9kZWwub3B0aW9ucy5wYXJhbm9pZCB8fCBvcHRpb25zLnBhcmFub2lkID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIGNvbnN0IGRlbGV0ZWRBdENvbCA9IG1vZGVsLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdDtcbiAgICBjb25zdCBkZWxldGVkQXRBdHRyaWJ1dGUgPSBtb2RlbC5yYXdBdHRyaWJ1dGVzW2RlbGV0ZWRBdENvbF07XG4gICAgY29uc3QgZGVsZXRlZEF0T2JqZWN0ID0ge307XG4gICAgbGV0IGRlbGV0ZWRBdERlZmF1bHRWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWxldGVkQXRBdHRyaWJ1dGUsIFwiZGVmYXVsdFZhbHVlXCIpID8gZGVsZXRlZEF0QXR0cmlidXRlLmRlZmF1bHRWYWx1ZSA6IG51bGw7XG4gICAgZGVsZXRlZEF0RGVmYXVsdFZhbHVlID0gZGVsZXRlZEF0RGVmYXVsdFZhbHVlIHx8IHtcbiAgICAgIFtPcC5lcV06IG51bGxcbiAgICB9O1xuICAgIGRlbGV0ZWRBdE9iamVjdFtkZWxldGVkQXRBdHRyaWJ1dGUuZmllbGQgfHwgZGVsZXRlZEF0Q29sXSA9IGRlbGV0ZWRBdERlZmF1bHRWYWx1ZTtcbiAgICBpZiAoVXRpbHMuaXNXaGVyZUVtcHR5KG9wdGlvbnMud2hlcmUpKSB7XG4gICAgICBvcHRpb25zLndoZXJlID0gZGVsZXRlZEF0T2JqZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLndoZXJlID0geyBbT3AuYW5kXTogW2RlbGV0ZWRBdE9iamVjdCwgb3B0aW9ucy53aGVyZV0gfTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbiAgc3RhdGljIF9hZGREZWZhdWx0QXR0cmlidXRlcygpIHtcbiAgICBjb25zdCB0YWlsID0ge307XG4gICAgbGV0IGhlYWQgPSB7fTtcbiAgICBpZiAoIV8uc29tZSh0aGlzLnJhd0F0dHJpYnV0ZXMsIFwicHJpbWFyeUtleVwiKSkge1xuICAgICAgaWYgKFwiaWRcIiBpbiB0aGlzLnJhd0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGNvbHVtbiBjYWxsZWQgJ2lkJyB3YXMgYWRkZWQgdG8gdGhlIGF0dHJpYnV0ZXMgb2YgJyR7dGhpcy50YWJsZU5hbWV9JyBidXQgbm90IG1hcmtlZCB3aXRoICdwcmltYXJ5S2V5OiB0cnVlJ2ApO1xuICAgICAgfVxuICAgICAgaGVhZCA9IHtcbiAgICAgICAgaWQ6IHtcbiAgICAgICAgICB0eXBlOiBuZXcgRGF0YVR5cGVzLklOVEVHRVIoKSxcbiAgICAgICAgICBhbGxvd051bGw6IGZhbHNlLFxuICAgICAgICAgIHByaW1hcnlLZXk6IHRydWUsXG4gICAgICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICBfYXV0b0dlbmVyYXRlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXQpIHtcbiAgICAgIHRhaWxbdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXRdID0ge1xuICAgICAgICB0eXBlOiBEYXRhVHlwZXMuREFURSxcbiAgICAgICAgYWxsb3dOdWxsOiBmYWxzZSxcbiAgICAgICAgX2F1dG9HZW5lcmF0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdCkge1xuICAgICAgdGFpbFt0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdF0gPSB7XG4gICAgICAgIHR5cGU6IERhdGFUeXBlcy5EQVRFLFxuICAgICAgICBhbGxvd051bGw6IGZhbHNlLFxuICAgICAgICBfYXV0b0dlbmVyYXRlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0KSB7XG4gICAgICB0YWlsW3RoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0XSA9IHtcbiAgICAgICAgdHlwZTogRGF0YVR5cGVzLkRBVEUsXG4gICAgICAgIF9hdXRvR2VuZXJhdGVkOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fdmVyc2lvbkF0dHJpYnV0ZSkge1xuICAgICAgdGFpbFt0aGlzLl92ZXJzaW9uQXR0cmlidXRlXSA9IHtcbiAgICAgICAgdHlwZTogRGF0YVR5cGVzLklOVEVHRVIsXG4gICAgICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogMCxcbiAgICAgICAgX2F1dG9HZW5lcmF0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG5ld1Jhd0F0dHJpYnV0ZXMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgaGVhZCksIHRoaXMucmF3QXR0cmlidXRlcyk7XG4gICAgXy5lYWNoKHRhaWwsICh2YWx1ZSwgYXR0cikgPT4ge1xuICAgICAgaWYgKG5ld1Jhd0F0dHJpYnV0ZXNbYXR0cl0gPT09IHZvaWQgMCkge1xuICAgICAgICBuZXdSYXdBdHRyaWJ1dGVzW2F0dHJdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5yYXdBdHRyaWJ1dGVzID0gbmV3UmF3QXR0cmlidXRlcztcbiAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMucHJpbWFyeUtleXMpLmxlbmd0aCkge1xuICAgICAgdGhpcy5wcmltYXJ5S2V5cy5pZCA9IHRoaXMucmF3QXR0cmlidXRlcy5pZDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmF3QXR0cmlidXRlcztcbiAgfVxuICBzdGF0aWMgX2ZpbmRBdXRvSW5jcmVtZW50QXR0cmlidXRlKCkge1xuICAgIHRoaXMuYXV0b0luY3JlbWVudEF0dHJpYnV0ZSA9IG51bGw7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMucmF3QXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnJhd0F0dHJpYnV0ZXMsIG5hbWUpKSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLnJhd0F0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIGlmIChkZWZpbml0aW9uICYmIGRlZmluaXRpb24uYXV0b0luY3JlbWVudCkge1xuICAgICAgICAgIGlmICh0aGlzLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgSW5zdGFuY2UgZGVmaW5pdGlvbi4gT25seSBvbmUgYXV0b2luY3JlbWVudCBmaWVsZCBhbGxvd2VkLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hdXRvSW5jcmVtZW50QXR0cmlidXRlID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgX2NvbmZvcm1JbmNsdWRlcyhvcHRpb25zLCBzZWxmKSB7XG4gICAgaWYgKCFvcHRpb25zLmluY2x1ZGUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuaW5jbHVkZSkpIHtcbiAgICAgIG9wdGlvbnMuaW5jbHVkZSA9IFtvcHRpb25zLmluY2x1ZGVdO1xuICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuaW5jbHVkZS5sZW5ndGgpIHtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLmluY2x1ZGU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9wdGlvbnMuaW5jbHVkZSA9IG9wdGlvbnMuaW5jbHVkZS5tYXAoKGluY2x1ZGUpID0+IHRoaXMuX2NvbmZvcm1JbmNsdWRlKGluY2x1ZGUsIHNlbGYpKTtcbiAgfVxuICBzdGF0aWMgX3RyYW5zZm9ybVN0cmluZ0Fzc29jaWF0aW9uKGluY2x1ZGUsIHNlbGYpIHtcbiAgICBpZiAoc2VsZiAmJiB0eXBlb2YgaW5jbHVkZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2VsZi5hc3NvY2lhdGlvbnMsIGluY2x1ZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXNzb2NpYXRpb24gd2l0aCBhbGlhcyBcIiR7aW5jbHVkZX1cIiBkb2VzIG5vdCBleGlzdCBvbiAke3NlbGYubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLmFzc29jaWF0aW9uc1tpbmNsdWRlXTtcbiAgICB9XG4gICAgcmV0dXJuIGluY2x1ZGU7XG4gIH1cbiAgc3RhdGljIF9jb25mb3JtSW5jbHVkZShpbmNsdWRlLCBzZWxmKSB7XG4gICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgIGxldCBtb2RlbDtcbiAgICAgIGlmIChpbmNsdWRlLl9wc2V1ZG8pXG4gICAgICAgIHJldHVybiBpbmNsdWRlO1xuICAgICAgaW5jbHVkZSA9IHRoaXMuX3RyYW5zZm9ybVN0cmluZ0Fzc29jaWF0aW9uKGluY2x1ZGUsIHNlbGYpO1xuICAgICAgaWYgKGluY2x1ZGUgaW5zdGFuY2VvZiBBc3NvY2lhdGlvbikge1xuICAgICAgICBpZiAoc2VsZiAmJiBpbmNsdWRlLnRhcmdldC5uYW1lID09PSBzZWxmLm5hbWUpIHtcbiAgICAgICAgICBtb2RlbCA9IGluY2x1ZGUuc291cmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGVsID0gaW5jbHVkZS50YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbW9kZWwsIGFzc29jaWF0aW9uOiBpbmNsdWRlLCBhczogaW5jbHVkZS5hcyB9O1xuICAgICAgfVxuICAgICAgaWYgKGluY2x1ZGUucHJvdG90eXBlICYmIGluY2x1ZGUucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHsgbW9kZWw6IGluY2x1ZGUgfTtcbiAgICAgIH1cbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3QoaW5jbHVkZSkpIHtcbiAgICAgICAgaWYgKGluY2x1ZGUuYXNzb2NpYXRpb24pIHtcbiAgICAgICAgICBpbmNsdWRlLmFzc29jaWF0aW9uID0gdGhpcy5fdHJhbnNmb3JtU3RyaW5nQXNzb2NpYXRpb24oaW5jbHVkZS5hc3NvY2lhdGlvbiwgc2VsZik7XG4gICAgICAgICAgaWYgKHNlbGYgJiYgaW5jbHVkZS5hc3NvY2lhdGlvbi50YXJnZXQubmFtZSA9PT0gc2VsZi5uYW1lKSB7XG4gICAgICAgICAgICBtb2RlbCA9IGluY2x1ZGUuYXNzb2NpYXRpb24uc291cmNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2RlbCA9IGluY2x1ZGUuYXNzb2NpYXRpb24udGFyZ2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWluY2x1ZGUubW9kZWwpXG4gICAgICAgICAgICBpbmNsdWRlLm1vZGVsID0gbW9kZWw7XG4gICAgICAgICAgaWYgKCFpbmNsdWRlLmFzKVxuICAgICAgICAgICAgaW5jbHVkZS5hcyA9IGluY2x1ZGUuYXNzb2NpYXRpb24uYXM7XG4gICAgICAgICAgdGhpcy5fY29uZm9ybUluY2x1ZGVzKGluY2x1ZGUsIG1vZGVsKTtcbiAgICAgICAgICByZXR1cm4gaW5jbHVkZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jbHVkZS5tb2RlbCkge1xuICAgICAgICAgIHRoaXMuX2NvbmZvcm1JbmNsdWRlcyhpbmNsdWRlLCBpbmNsdWRlLm1vZGVsKTtcbiAgICAgICAgICByZXR1cm4gaW5jbHVkZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jbHVkZS5hbGwpIHtcbiAgICAgICAgICB0aGlzLl9jb25mb3JtSW5jbHVkZXMoaW5jbHVkZSk7XG4gICAgICAgICAgcmV0dXJuIGluY2x1ZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jbHVkZSB1bmV4cGVjdGVkLiBFbGVtZW50IGhhcyB0byBiZSBlaXRoZXIgYSBNb2RlbCwgYW4gQXNzb2NpYXRpb24gb3IgYW4gb2JqZWN0LlwiKTtcbiAgfVxuICBzdGF0aWMgX2V4cGFuZEluY2x1ZGVBbGxFbGVtZW50KGluY2x1ZGVzLCBpbmNsdWRlKSB7XG4gICAgbGV0IGFsbCA9IGluY2x1ZGUuYWxsO1xuICAgIGRlbGV0ZSBpbmNsdWRlLmFsbDtcbiAgICBpZiAoYWxsICE9PSB0cnVlKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYWxsKSkge1xuICAgICAgICBhbGwgPSBbYWxsXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbGlkVHlwZXMgPSB7XG4gICAgICAgIEJlbG9uZ3NUbzogdHJ1ZSxcbiAgICAgICAgSGFzT25lOiB0cnVlLFxuICAgICAgICBIYXNNYW55OiB0cnVlLFxuICAgICAgICBPbmU6IFtcIkJlbG9uZ3NUb1wiLCBcIkhhc09uZVwiXSxcbiAgICAgICAgSGFzOiBbXCJIYXNPbmVcIiwgXCJIYXNNYW55XCJdLFxuICAgICAgICBNYW55OiBbXCJIYXNNYW55XCJdXG4gICAgICB9O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGFsbFtpXTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiQWxsXCIpIHtcbiAgICAgICAgICBhbGwgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGVzID0gdmFsaWRUeXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKCF0eXBlcykge1xuICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuRWFnZXJMb2FkaW5nRXJyb3IoYGluY2x1ZGUgYWxsICcke3R5cGV9JyBpcyBub3QgdmFsaWQgLSBtdXN0IGJlIEJlbG9uZ3NUbywgSGFzT25lLCBIYXNNYW55LCBPbmUsIEhhcywgTWFueSBvciBBbGxgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZXMgIT09IHRydWUpIHtcbiAgICAgICAgICBhbGwuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHR5cGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoIWFsbC5pbmNsdWRlcyh0eXBlc1tqXSkpIHtcbiAgICAgICAgICAgICAgYWxsLnVuc2hpZnQodHlwZXNbal0pO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5lc3RlZCA9IGluY2x1ZGUubmVzdGVkO1xuICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgIGRlbGV0ZSBpbmNsdWRlLm5lc3RlZDtcbiAgICAgIGlmICghaW5jbHVkZS5pbmNsdWRlKSB7XG4gICAgICAgIGluY2x1ZGUuaW5jbHVkZSA9IFtdO1xuICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShpbmNsdWRlLmluY2x1ZGUpKSB7XG4gICAgICAgIGluY2x1ZGUuaW5jbHVkZSA9IFtpbmNsdWRlLmluY2x1ZGVdO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1c2VkID0gW107XG4gICAgKGZ1bmN0aW9uIGFkZEFsbEluY2x1ZGVzKHBhcmVudCwgaW5jbHVkZXMyKSB7XG4gICAgICBfLmZvckVhY2gocGFyZW50LmFzc29jaWF0aW9ucywgKGFzc29jaWF0aW9uKSA9PiB7XG4gICAgICAgIGlmIChhbGwgIT09IHRydWUgJiYgIWFsbC5pbmNsdWRlcyhhc3NvY2lhdGlvbi5hc3NvY2lhdGlvblR5cGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGVsID0gYXNzb2NpYXRpb24udGFyZ2V0O1xuICAgICAgICBjb25zdCBhcyA9IGFzc29jaWF0aW9uLm9wdGlvbnMuYXM7XG4gICAgICAgIGNvbnN0IHByZWRpY2F0ZSA9IHsgbW9kZWwgfTtcbiAgICAgICAgaWYgKGFzKSB7XG4gICAgICAgICAgcHJlZGljYXRlLmFzID0gYXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF8uc29tZShpbmNsdWRlczIsIHByZWRpY2F0ZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lc3RlZCAmJiB1c2VkLmluY2x1ZGVzKG1vZGVsKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1c2VkLnB1c2gocGFyZW50KTtcbiAgICAgICAgY29uc3QgdGhpc0luY2x1ZGUgPSBVdGlscy5jbG9uZURlZXAoaW5jbHVkZSk7XG4gICAgICAgIHRoaXNJbmNsdWRlLm1vZGVsID0gbW9kZWw7XG4gICAgICAgIGlmIChhcykge1xuICAgICAgICAgIHRoaXNJbmNsdWRlLmFzID0gYXM7XG4gICAgICAgIH1cbiAgICAgICAgaW5jbHVkZXMyLnB1c2godGhpc0luY2x1ZGUpO1xuICAgICAgICBpZiAobmVzdGVkKSB7XG4gICAgICAgICAgYWRkQWxsSW5jbHVkZXMobW9kZWwsIHRoaXNJbmNsdWRlLmluY2x1ZGUpO1xuICAgICAgICAgIGlmICh0aGlzSW5jbHVkZS5pbmNsdWRlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzSW5jbHVkZS5pbmNsdWRlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHVzZWQucG9wKCk7XG4gICAgfSkodGhpcywgaW5jbHVkZXMpO1xuICB9XG4gIHN0YXRpYyBfdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnRzKG9wdGlvbnMsIHRhYmxlTmFtZXMpIHtcbiAgICBpZiAoIW9wdGlvbnMubW9kZWwpXG4gICAgICBvcHRpb25zLm1vZGVsID0gdGhpcztcbiAgICB0YWJsZU5hbWVzID0gdGFibGVOYW1lcyB8fCB7fTtcbiAgICBvcHRpb25zLmluY2x1ZGVOYW1lcyA9IFtdO1xuICAgIG9wdGlvbnMuaW5jbHVkZU1hcCA9IHt9O1xuICAgIG9wdGlvbnMuaGFzU2luZ2xlQXNzb2NpYXRpb24gPSBmYWxzZTtcbiAgICBvcHRpb25zLmhhc011bHRpQXNzb2NpYXRpb24gPSBmYWxzZTtcbiAgICBpZiAoIW9wdGlvbnMucGFyZW50KSB7XG4gICAgICBvcHRpb25zLnRvcE1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICAgIG9wdGlvbnMudG9wTGltaXQgPSBvcHRpb25zLmxpbWl0O1xuICAgIH1cbiAgICBvcHRpb25zLmluY2x1ZGUgPSBvcHRpb25zLmluY2x1ZGUubWFwKChpbmNsdWRlKSA9PiB7XG4gICAgICBpbmNsdWRlID0gdGhpcy5fY29uZm9ybUluY2x1ZGUoaW5jbHVkZSk7XG4gICAgICBpbmNsdWRlLnBhcmVudCA9IG9wdGlvbnM7XG4gICAgICBpbmNsdWRlLnRvcExpbWl0ID0gb3B0aW9ucy50b3BMaW1pdDtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50LmNhbGwob3B0aW9ucy5tb2RlbCwgaW5jbHVkZSwgdGFibGVOYW1lcywgb3B0aW9ucyk7XG4gICAgICBpZiAoaW5jbHVkZS5kdXBsaWNhdGluZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGluY2x1ZGUuZHVwbGljYXRpbmcgPSBpbmNsdWRlLmFzc29jaWF0aW9uLmlzTXVsdGlBc3NvY2lhdGlvbjtcbiAgICAgIH1cbiAgICAgIGluY2x1ZGUuaGFzRHVwbGljYXRpbmcgPSBpbmNsdWRlLmhhc0R1cGxpY2F0aW5nIHx8IGluY2x1ZGUuZHVwbGljYXRpbmc7XG4gICAgICBpbmNsdWRlLmhhc1JlcXVpcmVkID0gaW5jbHVkZS5oYXNSZXF1aXJlZCB8fCBpbmNsdWRlLnJlcXVpcmVkO1xuICAgICAgb3B0aW9ucy5oYXNEdXBsaWNhdGluZyA9IG9wdGlvbnMuaGFzRHVwbGljYXRpbmcgfHwgaW5jbHVkZS5oYXNEdXBsaWNhdGluZztcbiAgICAgIG9wdGlvbnMuaGFzUmVxdWlyZWQgPSBvcHRpb25zLmhhc1JlcXVpcmVkIHx8IGluY2x1ZGUucmVxdWlyZWQ7XG4gICAgICBvcHRpb25zLmhhc1doZXJlID0gb3B0aW9ucy5oYXNXaGVyZSB8fCBpbmNsdWRlLmhhc1doZXJlIHx8ICEhaW5jbHVkZS53aGVyZTtcbiAgICAgIHJldHVybiBpbmNsdWRlO1xuICAgIH0pO1xuICAgIGZvciAoY29uc3QgaW5jbHVkZSBvZiBvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgIGluY2x1ZGUuaGFzUGFyZW50V2hlcmUgPSBvcHRpb25zLmhhc1BhcmVudFdoZXJlIHx8ICEhb3B0aW9ucy53aGVyZTtcbiAgICAgIGluY2x1ZGUuaGFzUGFyZW50UmVxdWlyZWQgPSBvcHRpb25zLmhhc1BhcmVudFJlcXVpcmVkIHx8ICEhb3B0aW9ucy5yZXF1aXJlZDtcbiAgICAgIGlmIChpbmNsdWRlLnN1YlF1ZXJ5ICE9PSBmYWxzZSAmJiBvcHRpb25zLmhhc0R1cGxpY2F0aW5nICYmIG9wdGlvbnMudG9wTGltaXQpIHtcbiAgICAgICAgaWYgKGluY2x1ZGUuZHVwbGljYXRpbmcpIHtcbiAgICAgICAgICBpbmNsdWRlLnN1YlF1ZXJ5ID0gaW5jbHVkZS5zdWJRdWVyeSB8fCBmYWxzZTtcbiAgICAgICAgICBpbmNsdWRlLnN1YlF1ZXJ5RmlsdGVyID0gaW5jbHVkZS5oYXNSZXF1aXJlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmNsdWRlLnN1YlF1ZXJ5ID0gaW5jbHVkZS5oYXNSZXF1aXJlZDtcbiAgICAgICAgICBpbmNsdWRlLnN1YlF1ZXJ5RmlsdGVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluY2x1ZGUuc3ViUXVlcnkgPSBpbmNsdWRlLnN1YlF1ZXJ5IHx8IGZhbHNlO1xuICAgICAgICBpZiAoaW5jbHVkZS5kdXBsaWNhdGluZykge1xuICAgICAgICAgIGluY2x1ZGUuc3ViUXVlcnlGaWx0ZXIgPSBpbmNsdWRlLnN1YlF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluY2x1ZGUuc3ViUXVlcnlGaWx0ZXIgPSBmYWxzZTtcbiAgICAgICAgICBpbmNsdWRlLnN1YlF1ZXJ5ID0gaW5jbHVkZS5zdWJRdWVyeSB8fCBpbmNsdWRlLmhhc1BhcmVudFJlcXVpcmVkICYmIGluY2x1ZGUuaGFzUmVxdWlyZWQgJiYgIWluY2x1ZGUuc2VwYXJhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuaW5jbHVkZU1hcFtpbmNsdWRlLmFzXSA9IGluY2x1ZGU7XG4gICAgICBvcHRpb25zLmluY2x1ZGVOYW1lcy5wdXNoKGluY2x1ZGUuYXMpO1xuICAgICAgaWYgKG9wdGlvbnMudG9wTW9kZWwgPT09IG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5zdWJRdWVyeSA9PT0gdm9pZCAwICYmIG9wdGlvbnMudG9wTGltaXQpIHtcbiAgICAgICAgaWYgKGluY2x1ZGUuc3ViUXVlcnkpIHtcbiAgICAgICAgICBvcHRpb25zLnN1YlF1ZXJ5ID0gaW5jbHVkZS5zdWJRdWVyeTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmNsdWRlLmhhc0R1cGxpY2F0aW5nKSB7XG4gICAgICAgICAgb3B0aW9ucy5zdWJRdWVyeSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuaGFzSW5jbHVkZVdoZXJlID0gb3B0aW9ucy5oYXNJbmNsdWRlV2hlcmUgfHwgaW5jbHVkZS5oYXNJbmNsdWRlV2hlcmUgfHwgISFpbmNsdWRlLndoZXJlO1xuICAgICAgb3B0aW9ucy5oYXNJbmNsdWRlUmVxdWlyZWQgPSBvcHRpb25zLmhhc0luY2x1ZGVSZXF1aXJlZCB8fCBpbmNsdWRlLmhhc0luY2x1ZGVSZXF1aXJlZCB8fCAhIWluY2x1ZGUucmVxdWlyZWQ7XG4gICAgICBpZiAoaW5jbHVkZS5hc3NvY2lhdGlvbi5pc011bHRpQXNzb2NpYXRpb24gfHwgaW5jbHVkZS5oYXNNdWx0aUFzc29jaWF0aW9uKSB7XG4gICAgICAgIG9wdGlvbnMuaGFzTXVsdGlBc3NvY2lhdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZS5hc3NvY2lhdGlvbi5pc1NpbmdsZUFzc29jaWF0aW9uIHx8IGluY2x1ZGUuaGFzU2luZ2xlQXNzb2NpYXRpb24pIHtcbiAgICAgICAgb3B0aW9ucy5oYXNTaW5nbGVBc3NvY2lhdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRvcE1vZGVsID09PSBvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMuc3ViUXVlcnkgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucy5zdWJRdWVyeSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICBzdGF0aWMgX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50KGluY2x1ZGUsIHRhYmxlTmFtZXMsIG9wdGlvbnMpIHtcbiAgICB0YWJsZU5hbWVzW2luY2x1ZGUubW9kZWwuZ2V0VGFibGVOYW1lKCldID0gdHJ1ZTtcbiAgICBpZiAoaW5jbHVkZS5hdHRyaWJ1dGVzICYmICFvcHRpb25zLnJhdykge1xuICAgICAgaW5jbHVkZS5tb2RlbC5fZXhwYW5kQXR0cmlidXRlcyhpbmNsdWRlKTtcbiAgICAgIGluY2x1ZGUub3JpZ2luYWxBdHRyaWJ1dGVzID0gaW5jbHVkZS5tb2RlbC5faW5qZWN0RGVwZW5kZW50VmlydHVhbEF0dHJpYnV0ZXMoaW5jbHVkZS5hdHRyaWJ1dGVzKTtcbiAgICAgIGluY2x1ZGUgPSBVdGlscy5tYXBGaW5kZXJPcHRpb25zKGluY2x1ZGUsIGluY2x1ZGUubW9kZWwpO1xuICAgICAgaWYgKGluY2x1ZGUuYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgICAgXy5lYWNoKGluY2x1ZGUubW9kZWwucHJpbWFyeUtleXMsIChhdHRyLCBrZXkpID0+IHtcbiAgICAgICAgICBpZiAoIWluY2x1ZGUuYXR0cmlidXRlcy5zb21lKChpbmNsdWRlQXR0cikgPT4ge1xuICAgICAgICAgICAgaWYgKGF0dHIuZmllbGQgIT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShpbmNsdWRlQXR0cikgJiYgaW5jbHVkZUF0dHJbMF0gPT09IGF0dHIuZmllbGQgJiYgaW5jbHVkZUF0dHJbMV0gPT09IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbmNsdWRlQXR0ciA9PT0ga2V5O1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBpbmNsdWRlLmF0dHJpYnV0ZXMudW5zaGlmdChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluY2x1ZGUgPSBVdGlscy5tYXBGaW5kZXJPcHRpb25zKGluY2x1ZGUsIGluY2x1ZGUubW9kZWwpO1xuICAgIH1cbiAgICBpZiAoaW5jbHVkZS5fcHNldWRvKSB7XG4gICAgICBpZiAoIWluY2x1ZGUuYXR0cmlidXRlcykge1xuICAgICAgICBpbmNsdWRlLmF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhpbmNsdWRlLm1vZGVsLnRhYmxlQXR0cmlidXRlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gVXRpbHMubWFwRmluZGVyT3B0aW9ucyhpbmNsdWRlLCBpbmNsdWRlLm1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgYXNzb2NpYXRpb24gPSBpbmNsdWRlLmFzc29jaWF0aW9uIHx8IHRoaXMuX2dldEluY2x1ZGVkQXNzb2NpYXRpb24oaW5jbHVkZS5tb2RlbCwgaW5jbHVkZS5hcyk7XG4gICAgaW5jbHVkZS5hc3NvY2lhdGlvbiA9IGFzc29jaWF0aW9uO1xuICAgIGluY2x1ZGUuYXMgPSBhc3NvY2lhdGlvbi5hcztcbiAgICBpZiAoaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoICYmIE9iamVjdChpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwpID09PSBpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwpIHtcbiAgICAgIGlmICghaW5jbHVkZS5pbmNsdWRlKVxuICAgICAgICBpbmNsdWRlLmluY2x1ZGUgPSBbXTtcbiAgICAgIGNvbnN0IHRocm91Z2ggPSBpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2g7XG4gICAgICBpbmNsdWRlLnRocm91Z2ggPSBfLmRlZmF1bHRzKGluY2x1ZGUudGhyb3VnaCB8fCB7fSwge1xuICAgICAgICBtb2RlbDogdGhyb3VnaC5tb2RlbCxcbiAgICAgICAgYXM6IHRocm91Z2gubW9kZWwubmFtZSxcbiAgICAgICAgYXNzb2NpYXRpb246IHtcbiAgICAgICAgICBpc1NpbmdsZUFzc29jaWF0aW9uOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIF9wc2V1ZG86IHRydWUsXG4gICAgICAgIHBhcmVudDogaW5jbHVkZVxuICAgICAgfSk7XG4gICAgICBpZiAodGhyb3VnaC5zY29wZSkge1xuICAgICAgICBpbmNsdWRlLnRocm91Z2gud2hlcmUgPSBpbmNsdWRlLnRocm91Z2gud2hlcmUgPyB7IFtPcC5hbmRdOiBbaW5jbHVkZS50aHJvdWdoLndoZXJlLCB0aHJvdWdoLnNjb3BlXSB9IDogdGhyb3VnaC5zY29wZTtcbiAgICAgIH1cbiAgICAgIGluY2x1ZGUuaW5jbHVkZS5wdXNoKGluY2x1ZGUudGhyb3VnaCk7XG4gICAgICB0YWJsZU5hbWVzW3Rocm91Z2gudGFibGVOYW1lXSA9IHRydWU7XG4gICAgfVxuICAgIGxldCBtb2RlbDtcbiAgICBpZiAoaW5jbHVkZS5tb2RlbC5zY29wZWQgPT09IHRydWUpIHtcbiAgICAgIG1vZGVsID0gaW5jbHVkZS5tb2RlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZWwgPSBpbmNsdWRlLmFzc29jaWF0aW9uLnRhcmdldC5uYW1lID09PSBpbmNsdWRlLm1vZGVsLm5hbWUgPyBpbmNsdWRlLmFzc29jaWF0aW9uLnRhcmdldCA6IGluY2x1ZGUuYXNzb2NpYXRpb24uc291cmNlO1xuICAgIH1cbiAgICBtb2RlbC5faW5qZWN0U2NvcGUoaW5jbHVkZSk7XG4gICAgaWYgKCFpbmNsdWRlLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGluY2x1ZGUuYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKGluY2x1ZGUubW9kZWwudGFibGVBdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgaW5jbHVkZSA9IFV0aWxzLm1hcEZpbmRlck9wdGlvbnMoaW5jbHVkZSwgaW5jbHVkZS5tb2RlbCk7XG4gICAgaWYgKGluY2x1ZGUucmVxdWlyZWQgPT09IHZvaWQgMCkge1xuICAgICAgaW5jbHVkZS5yZXF1aXJlZCA9ICEhaW5jbHVkZS53aGVyZTtcbiAgICB9XG4gICAgaWYgKGluY2x1ZGUuYXNzb2NpYXRpb24uc2NvcGUpIHtcbiAgICAgIGluY2x1ZGUud2hlcmUgPSBpbmNsdWRlLndoZXJlID8geyBbT3AuYW5kXTogW2luY2x1ZGUud2hlcmUsIGluY2x1ZGUuYXNzb2NpYXRpb24uc2NvcGVdIH0gOiBpbmNsdWRlLmFzc29jaWF0aW9uLnNjb3BlO1xuICAgIH1cbiAgICBpZiAoaW5jbHVkZS5saW1pdCAmJiBpbmNsdWRlLnNlcGFyYXRlID09PSB2b2lkIDApIHtcbiAgICAgIGluY2x1ZGUuc2VwYXJhdGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaW5jbHVkZS5zZXBhcmF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKCEoaW5jbHVkZS5hc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEhhc01hbnkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgSGFzTWFueSBhc3NvY2lhdGlvbnMgc3VwcG9ydCBpbmNsdWRlLnNlcGFyYXRlXCIpO1xuICAgICAgfVxuICAgICAgaW5jbHVkZS5kdXBsaWNhdGluZyA9IGZhbHNlO1xuICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcyAmJiBvcHRpb25zLmF0dHJpYnV0ZXMubGVuZ3RoICYmICFfLmZsYXR0ZW5EZXB0aChvcHRpb25zLmF0dHJpYnV0ZXMsIDIpLmluY2x1ZGVzKGFzc29jaWF0aW9uLnNvdXJjZUtleSkpIHtcbiAgICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzLnB1c2goYXNzb2NpYXRpb24uc291cmNlS2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNsdWRlLmF0dHJpYnV0ZXMgJiYgaW5jbHVkZS5hdHRyaWJ1dGVzLmxlbmd0aCAmJiAhXy5mbGF0dGVuRGVwdGgoaW5jbHVkZS5hdHRyaWJ1dGVzLCAyKS5pbmNsdWRlcyhhc3NvY2lhdGlvbi5mb3JlaWduS2V5KSkge1xuICAgICAgICBpbmNsdWRlLmF0dHJpYnV0ZXMucHVzaChhc3NvY2lhdGlvbi5mb3JlaWduS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpbmNsdWRlLCBcImluY2x1ZGVcIikpIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cy5jYWxsKGluY2x1ZGUubW9kZWwsIGluY2x1ZGUsIHRhYmxlTmFtZXMpO1xuICAgIH1cbiAgICByZXR1cm4gaW5jbHVkZTtcbiAgfVxuICBzdGF0aWMgX2dldEluY2x1ZGVkQXNzb2NpYXRpb24odGFyZ2V0TW9kZWwsIHRhcmdldEFsaWFzKSB7XG4gICAgY29uc3QgYXNzb2NpYXRpb25zID0gdGhpcy5nZXRBc3NvY2lhdGlvbnModGFyZ2V0TW9kZWwpO1xuICAgIGxldCBhc3NvY2lhdGlvbiA9IG51bGw7XG4gICAgaWYgKGFzc29jaWF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuRWFnZXJMb2FkaW5nRXJyb3IoYCR7dGFyZ2V0TW9kZWwubmFtZX0gaXMgbm90IGFzc29jaWF0ZWQgdG8gJHt0aGlzLm5hbWV9IWApO1xuICAgIH1cbiAgICBpZiAoYXNzb2NpYXRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgYXNzb2NpYXRpb24gPSB0aGlzLmdldEFzc29jaWF0aW9uRm9yQWxpYXModGFyZ2V0TW9kZWwsIHRhcmdldEFsaWFzKTtcbiAgICAgIGlmIChhc3NvY2lhdGlvbikge1xuICAgICAgICByZXR1cm4gYXNzb2NpYXRpb247XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0QWxpYXMpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdBbGlhc2VzID0gdGhpcy5nZXRBc3NvY2lhdGlvbnModGFyZ2V0TW9kZWwpLm1hcCgoYXNzb2NpYXRpb24yKSA9PiBhc3NvY2lhdGlvbjIuYXMpO1xuICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkVhZ2VyTG9hZGluZ0Vycm9yKGAke3RhcmdldE1vZGVsLm5hbWV9IGlzIGFzc29jaWF0ZWQgdG8gJHt0aGlzLm5hbWV9IHVzaW5nIGFuIGFsaWFzLiBZb3UndmUgaW5jbHVkZWQgYW4gYWxpYXMgKCR7dGFyZ2V0QWxpYXN9KSwgYnV0IGl0IGRvZXMgbm90IG1hdGNoIHRoZSBhbGlhcyhlcykgZGVmaW5lZCBpbiB5b3VyIGFzc29jaWF0aW9uICgke2V4aXN0aW5nQWxpYXNlcy5qb2luKFwiLCBcIil9KS5gKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuRWFnZXJMb2FkaW5nRXJyb3IoYCR7dGFyZ2V0TW9kZWwubmFtZX0gaXMgYXNzb2NpYXRlZCB0byAke3RoaXMubmFtZX0gdXNpbmcgYW4gYWxpYXMuIFlvdSBtdXN0IHVzZSB0aGUgJ2FzJyBrZXl3b3JkIHRvIHNwZWNpZnkgdGhlIGFsaWFzIHdpdGhpbiB5b3VyIGluY2x1ZGUgc3RhdGVtZW50LmApO1xuICAgIH1cbiAgICBhc3NvY2lhdGlvbiA9IHRoaXMuZ2V0QXNzb2NpYXRpb25Gb3JBbGlhcyh0YXJnZXRNb2RlbCwgdGFyZ2V0QWxpYXMpO1xuICAgIGlmICghYXNzb2NpYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuRWFnZXJMb2FkaW5nRXJyb3IoYCR7dGFyZ2V0TW9kZWwubmFtZX0gaXMgYXNzb2NpYXRlZCB0byAke3RoaXMubmFtZX0gbXVsdGlwbGUgdGltZXMuIFRvIGlkZW50aWZ5IHRoZSBjb3JyZWN0IGFzc29jaWF0aW9uLCB5b3UgbXVzdCB1c2UgdGhlICdhcycga2V5d29yZCB0byBzcGVjaWZ5IHRoZSBhbGlhcyBvZiB0aGUgYXNzb2NpYXRpb24geW91IHdhbnQgdG8gaW5jbHVkZS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc29jaWF0aW9uO1xuICB9XG4gIHN0YXRpYyBfZXhwYW5kSW5jbHVkZUFsbChvcHRpb25zKSB7XG4gICAgY29uc3QgaW5jbHVkZXMgPSBvcHRpb25zLmluY2x1ZGU7XG4gICAgaWYgKCFpbmNsdWRlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgaW5jbHVkZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBpbmNsdWRlID0gaW5jbHVkZXNbaW5kZXhdO1xuICAgICAgaWYgKGluY2x1ZGUuYWxsKSB7XG4gICAgICAgIGluY2x1ZGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICAgIHRoaXMuX2V4cGFuZEluY2x1ZGVBbGxFbGVtZW50KGluY2x1ZGVzLCBpbmNsdWRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaW5jbHVkZXMuZm9yRWFjaCgoaW5jbHVkZSkgPT4ge1xuICAgICAgdGhpcy5fZXhwYW5kSW5jbHVkZUFsbC5jYWxsKGluY2x1ZGUubW9kZWwsIGluY2x1ZGUpO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBfY29uZm9ybUluZGV4KGluZGV4KSB7XG4gICAgaWYgKCFpbmRleC5maWVsZHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBcImZpZWxkc1wiIHByb3BlcnR5IGZvciBpbmRleCBkZWZpbml0aW9uJyk7XG4gICAgfVxuICAgIGluZGV4ID0gXy5kZWZhdWx0cyhpbmRleCwge1xuICAgICAgdHlwZTogXCJcIixcbiAgICAgIHBhcnNlcjogbnVsbFxuICAgIH0pO1xuICAgIGlmIChpbmRleC50eXBlICYmIGluZGV4LnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJ1bmlxdWVcIikge1xuICAgICAgaW5kZXgudW5pcXVlID0gdHJ1ZTtcbiAgICAgIGRlbGV0ZSBpbmRleC50eXBlO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cbiAgc3RhdGljIF91bmlxSW5jbHVkZXMob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlKVxuICAgICAgcmV0dXJuO1xuICAgIG9wdGlvbnMuaW5jbHVkZSA9IF8ob3B0aW9ucy5pbmNsdWRlKS5ncm91cEJ5KChpbmNsdWRlKSA9PiBgJHtpbmNsdWRlLm1vZGVsICYmIGluY2x1ZGUubW9kZWwubmFtZX0tJHtpbmNsdWRlLmFzfWApLm1hcCgoaW5jbHVkZXMpID0+IHRoaXMuX2Fzc2lnbk9wdGlvbnMoLi4uaW5jbHVkZXMpKS52YWx1ZSgpO1xuICB9XG4gIHN0YXRpYyBfYmFzZU1lcmdlKC4uLmFyZ3MpIHtcbiAgICBfLmFzc2lnbldpdGgoLi4uYXJncyk7XG4gICAgdGhpcy5fY29uZm9ybUluY2x1ZGVzKGFyZ3NbMF0sIHRoaXMpO1xuICAgIHRoaXMuX3VuaXFJbmNsdWRlcyhhcmdzWzBdKTtcbiAgICByZXR1cm4gYXJnc1swXTtcbiAgfVxuICBzdGF0aWMgX21lcmdlRnVuY3Rpb24ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpWYWx1ZSkgJiYgQXJyYXkuaXNBcnJheShzcmNWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBfLnVuaW9uKG9ialZhbHVlLCBzcmNWYWx1ZSk7XG4gICAgfVxuICAgIGlmIChbXCJ3aGVyZVwiLCBcImhhdmluZ1wiXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy53aGVyZU1lcmdlU3RyYXRlZ3kgPT09IFwiYW5kXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVXaGVyZXNXaXRoQW5kKG9ialZhbHVlLCBzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3JjVmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgc3JjVmFsdWUgPSB7IFtPcC5hbmRdOiBzcmNWYWx1ZSB9O1xuICAgICAgfVxuICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChvYmpWYWx1ZSkgJiYgXy5pc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvYmpWYWx1ZSwgc3JjVmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcImF0dHJpYnV0ZXNcIiAmJiBfLmlzUGxhaW5PYmplY3Qob2JqVmFsdWUpICYmIF8uaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBfLmFzc2lnbldpdGgob2JqVmFsdWUsIHNyY1ZhbHVlLCAob2JqVmFsdWUyLCBzcmNWYWx1ZTIpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqVmFsdWUyKSAmJiBBcnJheS5pc0FycmF5KHNyY1ZhbHVlMikpIHtcbiAgICAgICAgICByZXR1cm4gXy51bmlvbihvYmpWYWx1ZTIsIHNyY1ZhbHVlMik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3JjVmFsdWUpIHtcbiAgICAgIHJldHVybiBVdGlscy5jbG9uZURlZXAoc3JjVmFsdWUsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gc3JjVmFsdWUgPT09IHZvaWQgMCA/IG9ialZhbHVlIDogc3JjVmFsdWU7XG4gIH1cbiAgc3RhdGljIF9hc3NpZ25PcHRpb25zKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFzZU1lcmdlKC4uLmFyZ3MsIHRoaXMuX21lcmdlRnVuY3Rpb24uYmluZCh0aGlzKSk7XG4gIH1cbiAgc3RhdGljIF9kZWZhdWx0c09wdGlvbnModGFyZ2V0LCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jhc2VNZXJnZSh0YXJnZXQsIG9wdHMsIChzcmNWYWx1ZSwgb2JqVmFsdWUsIGtleSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuX21lcmdlRnVuY3Rpb24ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXkpO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBpbml0KGF0dHJpYnV0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghb3B0aW9ucy5zZXF1ZWxpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFNlcXVlbGl6ZSBpbnN0YW5jZSBwYXNzZWRcIik7XG4gICAgfVxuICAgIHRoaXMuc2VxdWVsaXplID0gb3B0aW9ucy5zZXF1ZWxpemU7XG4gICAgY29uc3QgZ2xvYmFsT3B0aW9ucyA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IFV0aWxzLm1lcmdlKF8uY2xvbmVEZWVwKGdsb2JhbE9wdGlvbnMuZGVmaW5lKSwgb3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zLm1vZGVsTmFtZSkge1xuICAgICAgb3B0aW9ucy5tb2RlbE5hbWUgPSB0aGlzLm5hbWU7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBVdGlscy5tZXJnZSh7XG4gICAgICBuYW1lOiB7XG4gICAgICAgIHBsdXJhbDogVXRpbHMucGx1cmFsaXplKG9wdGlvbnMubW9kZWxOYW1lKSxcbiAgICAgICAgc2luZ3VsYXI6IFV0aWxzLnNpbmd1bGFyaXplKG9wdGlvbnMubW9kZWxOYW1lKVxuICAgICAgfSxcbiAgICAgIGluZGV4ZXM6IFtdLFxuICAgICAgb21pdE51bGw6IGdsb2JhbE9wdGlvbnMub21pdE51bGwsXG4gICAgICBzY2hlbWE6IGdsb2JhbE9wdGlvbnMuc2NoZW1hXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgdGhpcy5zZXF1ZWxpemUucnVuSG9va3MoXCJiZWZvcmVEZWZpbmVcIiwgYXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMubW9kZWxOYW1lICE9PSB0aGlzLm5hbWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwgeyB2YWx1ZTogb3B0aW9ucy5tb2RlbE5hbWUgfSk7XG4gICAgfVxuICAgIGRlbGV0ZSBvcHRpb25zLm1vZGVsTmFtZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICB0aW1lc3RhbXBzOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6IHt9LFxuICAgICAgZnJlZXplVGFibGVOYW1lOiBmYWxzZSxcbiAgICAgIHVuZGVyc2NvcmVkOiBmYWxzZSxcbiAgICAgIHBhcmFub2lkOiBmYWxzZSxcbiAgICAgIHJlamVjdE9uRW1wdHk6IGZhbHNlLFxuICAgICAgd2hlcmVDb2xsZWN0aW9uOiBudWxsLFxuICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgc2NoZW1hRGVsaW1pdGVyOiBcIlwiLFxuICAgICAgZGVmYXVsdFNjb3BlOiB7fSxcbiAgICAgIHNjb3Blczoge30sXG4gICAgICBpbmRleGVzOiBbXSxcbiAgICAgIHdoZXJlTWVyZ2VTdHJhdGVneTogXCJvdmVyd3JpdGVcIlxuICAgIH0sIG9wdGlvbnMpO1xuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5pc0RlZmluZWQodGhpcy5uYW1lKSkge1xuICAgICAgdGhpcy5zZXF1ZWxpemUubW9kZWxNYW5hZ2VyLnJlbW92ZU1vZGVsKHRoaXMuc2VxdWVsaXplLm1vZGVsTWFuYWdlci5nZXRNb2RlbCh0aGlzLm5hbWUpKTtcbiAgICB9XG4gICAgdGhpcy5hc3NvY2lhdGlvbnMgPSB7fTtcbiAgICB0aGlzLl9zZXR1cEhvb2tzKG9wdGlvbnMuaG9va3MpO1xuICAgIHRoaXMudW5kZXJzY29yZWQgPSB0aGlzLm9wdGlvbnMudW5kZXJzY29yZWQ7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMudGFibGVOYW1lKSB7XG4gICAgICB0aGlzLnRhYmxlTmFtZSA9IHRoaXMub3B0aW9ucy5mcmVlemVUYWJsZU5hbWUgPyB0aGlzLm5hbWUgOiBVdGlscy51bmRlcnNjb3JlZElmKFV0aWxzLnBsdXJhbGl6ZSh0aGlzLm5hbWUpLCB0aGlzLnVuZGVyc2NvcmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YWJsZU5hbWUgPSB0aGlzLm9wdGlvbnMudGFibGVOYW1lO1xuICAgIH1cbiAgICB0aGlzLl9zY2hlbWEgPSB0aGlzLm9wdGlvbnMuc2NoZW1hO1xuICAgIHRoaXMuX3NjaGVtYURlbGltaXRlciA9IHRoaXMub3B0aW9ucy5zY2hlbWFEZWxpbWl0ZXI7XG4gICAgXy5lYWNoKG9wdGlvbnMudmFsaWRhdGUsICh2YWxpZGF0b3IsIHZhbGlkYXRvclR5cGUpID0+IHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgdmFsaWRhdG9yVHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIG1vZGVsIHZhbGlkYXRvciBmdW5jdGlvbiBtdXN0IG5vdCBoYXZlIHRoZSBzYW1lIG5hbWUgYXMgYSBmaWVsZC4gTW9kZWw6ICR7dGhpcy5uYW1lfSwgZmllbGQvdmFsaWRhdGlvbiBuYW1lOiAke3ZhbGlkYXRvclR5cGV9YCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbGlkYXRvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWVtYmVycyBvZiB0aGUgdmFsaWRhdGUgb3B0aW9uIG11c3QgYmUgZnVuY3Rpb25zLiBNb2RlbDogJHt0aGlzLm5hbWV9LCBlcnJvciB3aXRoIHZhbGlkYXRlIG1lbWJlciAke3ZhbGlkYXRvclR5cGV9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFfLmluY2x1ZGVzKFtcImFuZFwiLCBcIm92ZXJ3cml0ZVwiXSwgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy53aGVyZU1lcmdlU3RyYXRlZ3kpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWUgJHt0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLndoZXJlTWVyZ2VTdHJhdGVneX0gZm9yIHdoZXJlTWVyZ2VTdHJhdGVneS4gQWxsb3dlZCB2YWx1ZXMgYXJlICdhbmQnIGFuZCAnb3ZlcndyaXRlJy5gKTtcbiAgICB9XG4gICAgdGhpcy5yYXdBdHRyaWJ1dGVzID0gXy5tYXBWYWx1ZXMoYXR0cmlidXRlcywgKGF0dHJpYnV0ZSwgbmFtZSkgPT4ge1xuICAgICAgYXR0cmlidXRlID0gdGhpcy5zZXF1ZWxpemUubm9ybWFsaXplQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICBpZiAoYXR0cmlidXRlLnR5cGUgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBkYXRhdHlwZSBmb3IgYXR0cmlidXRlIFwiJHt0aGlzLm5hbWV9LiR7bmFtZX1cImApO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZS5hbGxvd051bGwgIT09IGZhbHNlICYmIF8uZ2V0KGF0dHJpYnV0ZSwgXCJ2YWxpZGF0ZS5ub3ROdWxsXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkZWZpbml0aW9uIGZvciBcIiR7dGhpcy5uYW1lfS4ke25hbWV9XCIsIFwibm90TnVsbFwiIHZhbGlkYXRvciBpcyBvbmx5IGFsbG93ZWQgd2l0aCBcImFsbG93TnVsbDpmYWxzZVwiYCk7XG4gICAgICB9XG4gICAgICBpZiAoXy5nZXQoYXR0cmlidXRlLCBcInJlZmVyZW5jZXMubW9kZWwucHJvdG90eXBlXCIpIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwgPSBhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbC5nZXRUYWJsZU5hbWUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGU7XG4gICAgfSk7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGhpcy5nZXRUYWJsZU5hbWUoKTtcbiAgICB0aGlzLl9pbmRleGVzID0gdGhpcy5vcHRpb25zLmluZGV4ZXMubWFwKChpbmRleCkgPT4gVXRpbHMubmFtZUluZGV4KHRoaXMuX2NvbmZvcm1JbmRleChpbmRleCksIHRhYmxlTmFtZSkpO1xuICAgIHRoaXMucHJpbWFyeUtleXMgPSB7fTtcbiAgICB0aGlzLl9yZWFkT25seUF0dHJpYnV0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMgPSB7fTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRpbWVzdGFtcHMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIFtcImNyZWF0ZWRBdFwiLCBcInVwZGF0ZWRBdFwiLCBcImRlbGV0ZWRBdFwiXSkge1xuICAgICAgICBpZiAoIVtcInVuZGVmaW5lZFwiLCBcInN0cmluZ1wiLCBcImJvb2xlYW5cIl0uaW5jbHVkZXModHlwZW9mIHRoaXMub3B0aW9uc1trZXldKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgZm9yIFwiJHtrZXl9XCIgb3B0aW9uIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBib29sZWFuLCBnb3QgJHt0eXBlb2YgdGhpcy5vcHRpb25zW2tleV19YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1trZXldID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWx1ZSBmb3IgXCIke2tleX1cIiBvcHRpb24gY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZ2ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNyZWF0ZWRBdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXQgPSB0eXBlb2YgdGhpcy5vcHRpb25zLmNyZWF0ZWRBdCA9PT0gXCJzdHJpbmdcIiA/IHRoaXMub3B0aW9ucy5jcmVhdGVkQXQgOiBcImNyZWF0ZWRBdFwiO1xuICAgICAgICB0aGlzLl9yZWFkT25seUF0dHJpYnV0ZXMuYWRkKHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBkYXRlZEF0ICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdCA9IHR5cGVvZiB0aGlzLm9wdGlvbnMudXBkYXRlZEF0ID09PSBcInN0cmluZ1wiID8gdGhpcy5vcHRpb25zLnVwZGF0ZWRBdCA6IFwidXBkYXRlZEF0XCI7XG4gICAgICAgIHRoaXMuX3JlYWRPbmx5QXR0cmlidXRlcy5hZGQodGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXJhbm9pZCAmJiB0aGlzLm9wdGlvbnMuZGVsZXRlZEF0ICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdCA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuZGVsZXRlZEF0ID09PSBcInN0cmluZ1wiID8gdGhpcy5vcHRpb25zLmRlbGV0ZWRBdCA6IFwiZGVsZXRlZEF0XCI7XG4gICAgICAgIHRoaXMuX3JlYWRPbmx5QXR0cmlidXRlcy5hZGQodGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnZlcnNpb24pIHtcbiAgICAgIHRoaXMuX3ZlcnNpb25BdHRyaWJ1dGUgPSB0eXBlb2YgdGhpcy5vcHRpb25zLnZlcnNpb24gPT09IFwic3RyaW5nXCIgPyB0aGlzLm9wdGlvbnMudmVyc2lvbiA6IFwidmVyc2lvblwiO1xuICAgICAgdGhpcy5fcmVhZE9ubHlBdHRyaWJ1dGVzLmFkZCh0aGlzLl92ZXJzaW9uQXR0cmlidXRlKTtcbiAgICB9XG4gICAgdGhpcy5faGFzUmVhZE9ubHlBdHRyaWJ1dGVzID0gdGhpcy5fcmVhZE9ubHlBdHRyaWJ1dGVzLnNpemUgPiAwO1xuICAgIHRoaXMuX2FkZERlZmF1bHRBdHRyaWJ1dGVzKCk7XG4gICAgdGhpcy5yZWZyZXNoQXR0cmlidXRlcygpO1xuICAgIHRoaXMuX2ZpbmRBdXRvSW5jcmVtZW50QXR0cmlidXRlKCk7XG4gICAgdGhpcy5fc2NvcGUgPSB0aGlzLm9wdGlvbnMuZGVmYXVsdFNjb3BlO1xuICAgIHRoaXMuX3Njb3BlTmFtZXMgPSBbXCJkZWZhdWx0U2NvcGVcIl07XG4gICAgdGhpcy5zZXF1ZWxpemUubW9kZWxNYW5hZ2VyLmFkZE1vZGVsKHRoaXMpO1xuICAgIHRoaXMuc2VxdWVsaXplLnJ1bkhvb2tzKFwiYWZ0ZXJEZWZpbmVcIiwgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RhdGljIHJlZnJlc2hBdHRyaWJ1dGVzKCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZU1hbmlwdWxhdGlvbiA9IHt9O1xuICAgIHRoaXMucHJvdG90eXBlLl9jdXN0b21HZXR0ZXJzID0ge307XG4gICAgdGhpcy5wcm90b3R5cGUuX2N1c3RvbVNldHRlcnMgPSB7fTtcbiAgICBbXCJnZXRcIiwgXCJzZXRcIl0uZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgY29uc3Qgb3B0ID0gYCR7dHlwZX10ZXJNZXRob2RzYDtcbiAgICAgIGNvbnN0IGZ1bmNzID0gX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMub3B0aW9uc1tvcHRdKTtcbiAgICAgIGNvbnN0IF9jdXN0b20gPSB0eXBlID09PSBcImdldFwiID8gdGhpcy5wcm90b3R5cGUuX2N1c3RvbUdldHRlcnMgOiB0aGlzLnByb3RvdHlwZS5fY3VzdG9tU2V0dGVycztcbiAgICAgIF8uZWFjaChmdW5jcywgKG1ldGhvZCwgYXR0cmlidXRlKSA9PiB7XG4gICAgICAgIF9jdXN0b21bYXR0cmlidXRlXSA9IG1ldGhvZDtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZ2V0XCIpIHtcbiAgICAgICAgICBmdW5jc1thdHRyaWJ1dGVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoYXR0cmlidXRlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcInNldFwiKSB7XG4gICAgICAgICAgZnVuY3NbYXR0cmlidXRlXSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXQoYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBfLmVhY2godGhpcy5yYXdBdHRyaWJ1dGVzLCAob3B0aW9ucywgYXR0cmlidXRlKSA9PiB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgdHlwZSkpIHtcbiAgICAgICAgICBfY3VzdG9tW2F0dHJpYnV0ZV0gPSBvcHRpb25zW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcImdldFwiKSB7XG4gICAgICAgICAgZnVuY3NbYXR0cmlidXRlXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGF0dHJpYnV0ZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJzZXRcIikge1xuICAgICAgICAgIGZ1bmNzW2F0dHJpYnV0ZV0gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXy5lYWNoKGZ1bmNzLCAoZmN0LCBuYW1lKSA9PiB7XG4gICAgICAgIGlmICghYXR0cmlidXRlTWFuaXB1bGF0aW9uW25hbWVdKSB7XG4gICAgICAgICAgYXR0cmlidXRlTWFuaXB1bGF0aW9uW25hbWVdID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBhdHRyaWJ1dGVNYW5pcHVsYXRpb25bbmFtZV1bdHlwZV0gPSBmY3Q7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLl9kYXRhVHlwZUNoYW5nZXMgPSB7fTtcbiAgICB0aGlzLl9kYXRhVHlwZVNhbml0aXplcnMgPSB7fTtcbiAgICB0aGlzLl9oYXNCb29sZWFuQXR0cmlidXRlcyA9IGZhbHNlO1xuICAgIHRoaXMuX2hhc0RhdGVBdHRyaWJ1dGVzID0gZmFsc2U7XG4gICAgdGhpcy5fanNvbkF0dHJpYnV0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuX3ZpcnR1YWxBdHRyaWJ1dGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLl9kZWZhdWx0VmFsdWVzID0ge307XG4gICAgdGhpcy5wcm90b3R5cGUudmFsaWRhdG9ycyA9IHt9O1xuICAgIHRoaXMuZmllbGRSYXdBdHRyaWJ1dGVzTWFwID0ge307XG4gICAgdGhpcy5wcmltYXJ5S2V5cyA9IHt9O1xuICAgIHRoaXMudW5pcXVlS2V5cyA9IHt9O1xuICAgIF8uZWFjaCh0aGlzLnJhd0F0dHJpYnV0ZXMsIChkZWZpbml0aW9uLCBuYW1lKSA9PiB7XG4gICAgICBkZWZpbml0aW9uLnR5cGUgPSB0aGlzLnNlcXVlbGl6ZS5ub3JtYWxpemVEYXRhVHlwZShkZWZpbml0aW9uLnR5cGUpO1xuICAgICAgZGVmaW5pdGlvbi5Nb2RlbCA9IHRoaXM7XG4gICAgICBkZWZpbml0aW9uLmZpZWxkTmFtZSA9IG5hbWU7XG4gICAgICBkZWZpbml0aW9uLl9tb2RlbEF0dHJpYnV0ZSA9IHRydWU7XG4gICAgICBpZiAoZGVmaW5pdGlvbi5maWVsZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlZmluaXRpb24uZmllbGQgPSBVdGlscy51bmRlcnNjb3JlZElmKG5hbWUsIHRoaXMudW5kZXJzY29yZWQpO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmluaXRpb24ucHJpbWFyeUtleSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnByaW1hcnlLZXlzW25hbWVdID0gZGVmaW5pdGlvbjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmllbGRSYXdBdHRyaWJ1dGVzTWFwW2RlZmluaXRpb24uZmllbGRdID0gZGVmaW5pdGlvbjtcbiAgICAgIGlmIChkZWZpbml0aW9uLnR5cGUuX3Nhbml0aXplKSB7XG4gICAgICAgIHRoaXMuX2RhdGFUeXBlU2FuaXRpemVyc1tuYW1lXSA9IGRlZmluaXRpb24udHlwZS5fc2FuaXRpemU7XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5pdGlvbi50eXBlLl9pc0NoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5fZGF0YVR5cGVDaGFuZ2VzW25hbWVdID0gZGVmaW5pdGlvbi50eXBlLl9pc0NoYW5nZWQ7XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5pdGlvbi50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkJPT0xFQU4pIHtcbiAgICAgICAgdGhpcy5faGFzQm9vbGVhbkF0dHJpYnV0ZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkZWZpbml0aW9uLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuREFURSB8fCBkZWZpbml0aW9uLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuREFURU9OTFkpIHtcbiAgICAgICAgdGhpcy5faGFzRGF0ZUF0dHJpYnV0ZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkZWZpbml0aW9uLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuSlNPTikge1xuICAgICAgICB0aGlzLl9qc29uQXR0cmlidXRlcy5hZGQobmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKGRlZmluaXRpb24udHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5WSVJUVUFMKSB7XG4gICAgICAgIHRoaXMuX3ZpcnR1YWxBdHRyaWJ1dGVzLmFkZChuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVmaW5pdGlvbiwgXCJkZWZhdWx0VmFsdWVcIikpIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdFZhbHVlc1tuYW1lXSA9ICgpID0+IFV0aWxzLnRvRGVmYXVsdFZhbHVlKGRlZmluaXRpb24uZGVmYXVsdFZhbHVlLCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWZpbml0aW9uLCBcInVuaXF1ZVwiKSAmJiBkZWZpbml0aW9uLnVuaXF1ZSkge1xuICAgICAgICBsZXQgaWR4TmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWZpbml0aW9uLnVuaXF1ZSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVmaW5pdGlvbi51bmlxdWUsIFwibmFtZVwiKSkge1xuICAgICAgICAgIGlkeE5hbWUgPSBkZWZpbml0aW9uLnVuaXF1ZS5uYW1lO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbml0aW9uLnVuaXF1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlkeE5hbWUgPSBkZWZpbml0aW9uLnVuaXF1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZHhOYW1lID0gYCR7dGhpcy50YWJsZU5hbWV9XyR7bmFtZX1fdW5pcXVlYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLnVuaXF1ZUtleXNbaWR4TmFtZV0gfHwgeyBmaWVsZHM6IFtdIH07XG4gICAgICAgIGlkeC5maWVsZHMucHVzaChkZWZpbml0aW9uLmZpZWxkKTtcbiAgICAgICAgaWR4Lm1zZyA9IGlkeC5tc2cgfHwgZGVmaW5pdGlvbi51bmlxdWUubXNnIHx8IG51bGw7XG4gICAgICAgIGlkeC5uYW1lID0gaWR4TmFtZSB8fCBmYWxzZTtcbiAgICAgICAgaWR4LmNvbHVtbiA9IG5hbWU7XG4gICAgICAgIGlkeC5jdXN0b21JbmRleCA9IGRlZmluaXRpb24udW5pcXVlICE9PSB0cnVlO1xuICAgICAgICB0aGlzLnVuaXF1ZUtleXNbaWR4TmFtZV0gPSBpZHg7XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmluaXRpb24sIFwidmFsaWRhdGVcIikpIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUudmFsaWRhdG9yc1tuYW1lXSA9IGRlZmluaXRpb24udmFsaWRhdGU7XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5pdGlvbi5pbmRleCA9PT0gdHJ1ZSAmJiBkZWZpbml0aW9uLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuSlNPTkIpIHtcbiAgICAgICAgdGhpcy5faW5kZXhlcy5wdXNoKFV0aWxzLm5hbWVJbmRleCh0aGlzLl9jb25mb3JtSW5kZXgoe1xuICAgICAgICAgIGZpZWxkczogW2RlZmluaXRpb24uZmllbGQgfHwgbmFtZV0sXG4gICAgICAgICAgdXNpbmc6IFwiZ2luXCJcbiAgICAgICAgfSksIHRoaXMuZ2V0VGFibGVOYW1lKCkpKTtcbiAgICAgICAgZGVsZXRlIGRlZmluaXRpb24uaW5kZXg7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5maWVsZEF0dHJpYnV0ZU1hcCA9IF8ucmVkdWNlKHRoaXMuZmllbGRSYXdBdHRyaWJ1dGVzTWFwLCAobWFwLCB2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBpZiAoa2V5ICE9PSB2YWx1ZS5maWVsZE5hbWUpIHtcbiAgICAgICAgbWFwW2tleV0gPSB2YWx1ZS5maWVsZE5hbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0sIHt9KTtcbiAgICB0aGlzLl9oYXNKc29uQXR0cmlidXRlcyA9ICEhdGhpcy5fanNvbkF0dHJpYnV0ZXMuc2l6ZTtcbiAgICB0aGlzLl9oYXNWaXJ0dWFsQXR0cmlidXRlcyA9ICEhdGhpcy5fdmlydHVhbEF0dHJpYnV0ZXMuc2l6ZTtcbiAgICB0aGlzLl9oYXNEZWZhdWx0VmFsdWVzID0gIV8uaXNFbXB0eSh0aGlzLl9kZWZhdWx0VmFsdWVzKTtcbiAgICB0aGlzLnRhYmxlQXR0cmlidXRlcyA9IF8ub21pdEJ5KHRoaXMucmF3QXR0cmlidXRlcywgKF9hLCBrZXkpID0+IHRoaXMuX3ZpcnR1YWxBdHRyaWJ1dGVzLmhhcyhrZXkpKTtcbiAgICB0aGlzLnByb3RvdHlwZS5faGFzQ3VzdG9tR2V0dGVycyA9IE9iamVjdC5rZXlzKHRoaXMucHJvdG90eXBlLl9jdXN0b21HZXR0ZXJzKS5sZW5ndGg7XG4gICAgdGhpcy5wcm90b3R5cGUuX2hhc0N1c3RvbVNldHRlcnMgPSBPYmplY3Qua2V5cyh0aGlzLnByb3RvdHlwZS5fY3VzdG9tU2V0dGVycykubGVuZ3RoO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGF0dHJpYnV0ZU1hbmlwdWxhdGlvbikpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoTW9kZWwucHJvdG90eXBlLCBrZXkpKSB7XG4gICAgICAgIHRoaXMuc2VxdWVsaXplLmxvZyhgTm90IG92ZXJyaWRpbmcgYnVpbHQtaW4gbWV0aG9kIGZyb20gbW9kZWwgYXR0cmlidXRlOiAke2tleX1gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5wcm90b3R5cGUsIGtleSwgYXR0cmlidXRlTWFuaXB1bGF0aW9uW2tleV0pO1xuICAgIH1cbiAgICB0aGlzLnByb3RvdHlwZS5yYXdBdHRyaWJ1dGVzID0gdGhpcy5yYXdBdHRyaWJ1dGVzO1xuICAgIHRoaXMucHJvdG90eXBlLl9pc0F0dHJpYnV0ZSA9IChrZXkpID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnByb3RvdHlwZS5yYXdBdHRyaWJ1dGVzLCBrZXkpO1xuICAgIHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyh0aGlzLnByaW1hcnlLZXlzKTtcbiAgICB0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGUgPSB0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGVzWzBdO1xuICAgIGlmICh0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGUpIHtcbiAgICAgIHRoaXMucHJpbWFyeUtleUZpZWxkID0gdGhpcy5yYXdBdHRyaWJ1dGVzW3RoaXMucHJpbWFyeUtleUF0dHJpYnV0ZV0uZmllbGQgfHwgdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgIH1cbiAgICB0aGlzLl9oYXNQcmltYXJ5S2V5cyA9IHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZXMubGVuZ3RoID4gMDtcbiAgICB0aGlzLl9pc1ByaW1hcnlLZXkgPSAoa2V5KSA9PiB0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGVzLmluY2x1ZGVzKGtleSk7XG4gICAgdGhpcy5fYXR0cmlidXRlTWFuaXB1bGF0aW9uID0gYXR0cmlidXRlTWFuaXB1bGF0aW9uO1xuICB9XG4gIHN0YXRpYyByZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG4gICAgZGVsZXRlIHRoaXMucmF3QXR0cmlidXRlc1thdHRyaWJ1dGVdO1xuICAgIHRoaXMucmVmcmVzaEF0dHJpYnV0ZXMoKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgc3luYyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLm9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICBvcHRpb25zLmhvb2tzID0gb3B0aW9ucy5ob29rcyA9PT0gdm9pZCAwID8gdHJ1ZSA6ICEhb3B0aW9ucy5ob29rcztcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy50YWJsZUF0dHJpYnV0ZXM7XG4gICAgY29uc3QgcmF3QXR0cmlidXRlcyA9IHRoaXMuZmllbGRSYXdBdHRyaWJ1dGVzTWFwO1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKFwiYmVmb3JlU3luY1wiLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGhpcy5nZXRUYWJsZU5hbWUob3B0aW9ucyk7XG4gICAgbGV0IHRhYmxlRXhpc3RzO1xuICAgIGlmIChvcHRpb25zLmZvcmNlKSB7XG4gICAgICBhd2FpdCB0aGlzLmRyb3Aob3B0aW9ucyk7XG4gICAgICB0YWJsZUV4aXN0cyA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWJsZUV4aXN0cyA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UudGFibGVFeGlzdHModGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKCF0YWJsZUV4aXN0cykge1xuICAgICAgYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5jcmVhdGVUYWJsZSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmVuc3VyZUVudW1zKHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucywgdGhpcyk7XG4gICAgfVxuICAgIGlmICh0YWJsZUV4aXN0cyAmJiBvcHRpb25zLmFsdGVyKSB7XG4gICAgICBjb25zdCB0YWJsZUluZm9zID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmRlc2NyaWJlVGFibGUodGFibGVOYW1lLCBvcHRpb25zKSxcbiAgICAgICAgdGhpcy5xdWVyeUludGVyZmFjZS5nZXRGb3JlaWduS2V5UmVmZXJlbmNlc0ZvclRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucylcbiAgICAgIF0pO1xuICAgICAgY29uc3QgY29sdW1ucyA9IHRhYmxlSW5mb3NbMF07XG4gICAgICBjb25zdCBmb3JlaWduS2V5UmVmZXJlbmNlcyA9IHRhYmxlSW5mb3NbMV07XG4gICAgICBjb25zdCByZW1vdmVkQ29uc3RyYWludHMgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgY29sdW1uTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZXMsIGNvbHVtbk5hbWUpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWNvbHVtbnNbY29sdW1uTmFtZV0gJiYgIWNvbHVtbnNbYXR0cmlidXRlc1tjb2x1bW5OYW1lXS5maWVsZF0pIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmFkZENvbHVtbih0YWJsZU5hbWUsIGF0dHJpYnV0ZXNbY29sdW1uTmFtZV0uZmllbGQgfHwgY29sdW1uTmFtZSwgYXR0cmlidXRlc1tjb2x1bW5OYW1lXSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmFsdGVyID09PSB0cnVlIHx8IHR5cGVvZiBvcHRpb25zLmFsdGVyID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuYWx0ZXIuZHJvcCAhPT0gZmFsc2UpIHtcbiAgICAgICAgZm9yIChjb25zdCBjb2x1bW5OYW1lIGluIGNvbHVtbnMpIHtcbiAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb2x1bW5zLCBjb2x1bW5OYW1lKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRBdHRyaWJ1dGUgPSByYXdBdHRyaWJ1dGVzW2NvbHVtbk5hbWVdO1xuICAgICAgICAgIGlmICghY3VycmVudEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5yZW1vdmVDb2x1bW4odGFibGVOYW1lLCBjb2x1bW5OYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3VycmVudEF0dHJpYnV0ZS5wcmltYXJ5S2V5KVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY29uc3QgcmVmZXJlbmNlcyA9IGN1cnJlbnRBdHRyaWJ1dGUucmVmZXJlbmNlcztcbiAgICAgICAgICBpZiAoY3VycmVudEF0dHJpYnV0ZS5yZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhYmFzZSA9IHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kYXRhYmFzZTtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuc2VxdWVsaXplLmNvbmZpZy5zY2hlbWE7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZvcmVpZ25LZXlSZWZlcmVuY2Ugb2YgZm9yZWlnbktleVJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgY29uc3RyYWludE5hbWUgPSBmb3JlaWduS2V5UmVmZXJlbmNlLmNvbnN0cmFpbnROYW1lO1xuICAgICAgICAgICAgICBpZiAoISFjb25zdHJhaW50TmFtZSAmJiBmb3JlaWduS2V5UmVmZXJlbmNlLnRhYmxlQ2F0YWxvZyA9PT0gZGF0YWJhc2UgJiYgKHNjaGVtYSA/IGZvcmVpZ25LZXlSZWZlcmVuY2UudGFibGVTY2hlbWEgPT09IHNjaGVtYSA6IHRydWUpICYmIGZvcmVpZ25LZXlSZWZlcmVuY2UucmVmZXJlbmNlZFRhYmxlTmFtZSA9PT0gcmVmZXJlbmNlcy5tb2RlbCAmJiBmb3JlaWduS2V5UmVmZXJlbmNlLnJlZmVyZW5jZWRDb2x1bW5OYW1lID09PSByZWZlcmVuY2VzLmtleSAmJiAoc2NoZW1hID8gZm9yZWlnbktleVJlZmVyZW5jZS5yZWZlcmVuY2VkVGFibGVTY2hlbWEgPT09IHNjaGVtYSA6IHRydWUpICYmICFyZW1vdmVkQ29uc3RyYWludHNbY29uc3RyYWludE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5yZW1vdmVDb25zdHJhaW50KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJlbW92ZWRDb25zdHJhaW50c1tjb25zdHJhaW50TmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuY2hhbmdlQ29sdW1uKHRhYmxlTmFtZSwgY29sdW1uTmFtZSwgY3VycmVudEF0dHJpYnV0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdJbmRleGVzID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5zaG93SW5kZXgodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICBjb25zdCBtaXNzaW5nSW5kZXhlcyA9IHRoaXMuX2luZGV4ZXMuZmlsdGVyKChpdGVtMSkgPT4gIWV4aXN0aW5nSW5kZXhlcy5zb21lKChpdGVtMikgPT4gaXRlbTEubmFtZSA9PT0gaXRlbTIubmFtZSkpLnNvcnQoKGluZGV4MSwgaW5kZXgyKSA9PiB7XG4gICAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0ID09PSBcInBvc3RncmVzXCIpIHtcbiAgICAgICAgaWYgKGluZGV4MS5jb25jdXJyZW50bHkgPT09IHRydWUpXG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmIChpbmRleDIuY29uY3VycmVudGx5ID09PSB0cnVlKVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuICAgIGZvciAoY29uc3QgaW5kZXggb2YgbWlzc2luZ0luZGV4ZXMpIHtcbiAgICAgIGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuYWRkSW5kZXgodGFibGVOYW1lLCBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIGluZGV4KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKFwiYWZ0ZXJTeW5jXCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdGF0aWMgYXN5bmMgZHJvcChvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuZHJvcFRhYmxlKHRoaXMuZ2V0VGFibGVOYW1lKG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZHJvcFNjaGVtYShzY2hlbWEpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5kcm9wU2NoZW1hKHNjaGVtYSk7XG4gIH1cbiAgc3RhdGljIHNjaGVtYShzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjbG9uZSA9IGNsYXNzIGV4dGVuZHMgdGhpcyB7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xvbmUsIFwibmFtZVwiLCB7IHZhbHVlOiB0aGlzLm5hbWUgfSk7XG4gICAgY2xvbmUuX3NjaGVtYSA9IHNjaGVtYTtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNsb25lLl9zY2hlbWFEZWxpbWl0ZXIgPSBvcHRpb25zO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnNjaGVtYURlbGltaXRlcikge1xuICAgICAgICBjbG9uZS5fc2NoZW1hRGVsaW1pdGVyID0gb3B0aW9ucy5zY2hlbWFEZWxpbWl0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuICBzdGF0aWMgZ2V0VGFibGVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmFkZFNjaGVtYSh0aGlzKTtcbiAgfVxuICBzdGF0aWMgdW5zY29wZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NvcGUoKTtcbiAgfVxuICBzdGF0aWMgYWRkU2NvcGUobmFtZSwgc2NvcGUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoeyBvdmVycmlkZTogZmFsc2UgfSwgb3B0aW9ucyk7XG4gICAgaWYgKChuYW1lID09PSBcImRlZmF1bHRTY29wZVwiICYmIE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5kZWZhdWx0U2NvcGUpLmxlbmd0aCA+IDAgfHwgbmFtZSBpbiB0aGlzLm9wdGlvbnMuc2NvcGVzKSAmJiBvcHRpb25zLm92ZXJyaWRlID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc2NvcGUgJHtuYW1lfSBhbHJlYWR5IGV4aXN0cy4gUGFzcyB7IG92ZXJyaWRlOiB0cnVlIH0gYXMgb3B0aW9ucyB0byBzaWxlbmNlIHRoaXMgZXJyb3JgKTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IFwiZGVmYXVsdFNjb3BlXCIpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5kZWZhdWx0U2NvcGUgPSB0aGlzLl9zY29wZSA9IHNjb3BlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wdGlvbnMuc2NvcGVzW25hbWVdID0gc2NvcGU7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBzY29wZShvcHRpb24pIHtcbiAgICBjb25zdCBzZWxmID0gY2xhc3MgZXh0ZW5kcyB0aGlzIHtcbiAgICB9O1xuICAgIGxldCBzY29wZTtcbiAgICBsZXQgc2NvcGVOYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBcIm5hbWVcIiwgeyB2YWx1ZTogdGhpcy5uYW1lIH0pO1xuICAgIHNlbGYuX3Njb3BlID0ge307XG4gICAgc2VsZi5fc2NvcGVOYW1lcyA9IFtdO1xuICAgIHNlbGYuc2NvcGVkID0gdHJ1ZTtcbiAgICBpZiAoIW9wdGlvbikge1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSBfLmZsYXR0ZW4oYXJndW1lbnRzKTtcbiAgICBmb3IgKGNvbnN0IG9wdGlvbjIgb2Ygb3B0aW9ucykge1xuICAgICAgc2NvcGUgPSBudWxsO1xuICAgICAgc2NvcGVOYW1lID0gbnVsbDtcbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3Qob3B0aW9uMikpIHtcbiAgICAgICAgaWYgKG9wdGlvbjIubWV0aG9kKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9uMi5tZXRob2QpICYmICEhc2VsZi5vcHRpb25zLnNjb3Blc1tvcHRpb24yLm1ldGhvZFswXV0pIHtcbiAgICAgICAgICAgIHNjb3BlTmFtZSA9IG9wdGlvbjIubWV0aG9kWzBdO1xuICAgICAgICAgICAgc2NvcGUgPSBzZWxmLm9wdGlvbnMuc2NvcGVzW3Njb3BlTmFtZV0uYXBwbHkoc2VsZiwgb3B0aW9uMi5tZXRob2Quc2xpY2UoMSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5vcHRpb25zLnNjb3Blc1tvcHRpb24yLm1ldGhvZF0pIHtcbiAgICAgICAgICAgIHNjb3BlTmFtZSA9IG9wdGlvbjIubWV0aG9kO1xuICAgICAgICAgICAgc2NvcGUgPSBzZWxmLm9wdGlvbnMuc2NvcGVzW3Njb3BlTmFtZV0uYXBwbHkoc2VsZik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjb3BlID0gb3B0aW9uMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvcHRpb24yID09PSBcImRlZmF1bHRTY29wZVwiICYmIF8uaXNQbGFpbk9iamVjdChzZWxmLm9wdGlvbnMuZGVmYXVsdFNjb3BlKSkge1xuICAgICAgICBzY29wZSA9IHNlbGYub3B0aW9ucy5kZWZhdWx0U2NvcGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY29wZU5hbWUgPSBvcHRpb24yO1xuICAgICAgICBzY29wZSA9IHNlbGYub3B0aW9ucy5zY29wZXNbc2NvcGVOYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY29wZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgc2NvcGUgPSBzY29wZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2NvcGUpIHtcbiAgICAgICAgdGhpcy5fY29uZm9ybUluY2x1ZGVzKHNjb3BlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fYXNzaWduT3B0aW9ucyhzZWxmLl9zY29wZSwgVXRpbHMuY2xvbmVEZWVwKHNjb3BlKSk7XG4gICAgICAgIHNlbGYuX3Njb3BlTmFtZXMucHVzaChzY29wZU5hbWUgPyBzY29wZU5hbWUgOiBcImRlZmF1bHRTY29wZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuU2VxdWVsaXplU2NvcGVFcnJvcihgSW52YWxpZCBzY29wZSAke3Njb3BlTmFtZX0gY2FsbGVkLmApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZmluZEFsbChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgIT09IHZvaWQgMCAmJiAhXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlF1ZXJ5RXJyb3IoXCJUaGUgYXJndW1lbnQgcGFzc2VkIHRvIGZpbmRBbGwgbXVzdCBiZSBhbiBvcHRpb25zIG9iamVjdCwgdXNlIGZpbmRCeVBrIGlmIHlvdSB3aXNoIHRvIHBhc3MgYSBzaW5nbGUgcHJpbWFyeSBrZXkgdmFsdWVcIik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5hdHRyaWJ1dGVzKSAmJiAhXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMuYXR0cmlidXRlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5RdWVyeUVycm9yKFwiVGhlIGF0dHJpYnV0ZXMgb3B0aW9uIG11c3QgYmUgYW4gYXJyYXkgb2YgY29sdW1uIG5hbWVzIG9yIGFuIG9iamVjdFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy53YXJuT25JbnZhbGlkT3B0aW9ucyhvcHRpb25zLCBPYmplY3Qua2V5cyh0aGlzLnJhd0F0dHJpYnV0ZXMpKTtcbiAgICBjb25zdCB0YWJsZU5hbWVzID0ge307XG4gICAgdGFibGVOYW1lc1t0aGlzLmdldFRhYmxlTmFtZShvcHRpb25zKV0gPSB0cnVlO1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gPT09IHZvaWQgMCAmJiB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscy5nZXQoXCJ0cmFuc2FjdGlvblwiKTtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24gPSB0O1xuICAgICAgfVxuICAgIH1cbiAgICBfLmRlZmF1bHRzKG9wdGlvbnMsIHsgaG9va3M6IHRydWUgfSk7XG4gICAgb3B0aW9ucy5yZWplY3RPbkVtcHR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwicmVqZWN0T25FbXB0eVwiKSA/IG9wdGlvbnMucmVqZWN0T25FbXB0eSA6IHRoaXMub3B0aW9ucy5yZWplY3RPbkVtcHR5O1xuICAgIHRoaXMuX2luamVjdFNjb3BlKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKFwiYmVmb3JlRmluZFwiLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdGhpcy5fY29uZm9ybUluY2x1ZGVzKG9wdGlvbnMsIHRoaXMpO1xuICAgIHRoaXMuX2V4cGFuZEF0dHJpYnV0ZXMob3B0aW9ucyk7XG4gICAgdGhpcy5fZXhwYW5kSW5jbHVkZUFsbChvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcyhcImJlZm9yZUZpbmRBZnRlckV4cGFuZEluY2x1ZGVBbGxcIiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIG9wdGlvbnMub3JpZ2luYWxBdHRyaWJ1dGVzID0gdGhpcy5faW5qZWN0RGVwZW5kZW50VmlydHVhbEF0dHJpYnV0ZXMob3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICBvcHRpb25zLmhhc0pvaW4gPSB0cnVlO1xuICAgICAgdGhpcy5fdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnRzKG9wdGlvbnMsIHRhYmxlTmFtZXMpO1xuICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcyAmJiAhb3B0aW9ucy5yYXcgJiYgdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlICYmICFvcHRpb25zLmF0dHJpYnV0ZXMuaW5jbHVkZXModGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlKSAmJiAoIW9wdGlvbnMuZ3JvdXAgfHwgIW9wdGlvbnMuaGFzU2luZ2xlQXNzb2NpYXRpb24gfHwgb3B0aW9ucy5oYXNNdWx0aUFzc29jaWF0aW9uKSkge1xuICAgICAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBbdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlXS5jb25jYXQob3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmF0dHJpYnV0ZXMpIHtcbiAgICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKHRoaXMucmF3QXR0cmlidXRlcyk7XG4gICAgICBvcHRpb25zLm9yaWdpbmFsQXR0cmlidXRlcyA9IHRoaXMuX2luamVjdERlcGVuZGVudFZpcnR1YWxBdHRyaWJ1dGVzKG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucy53aGVyZUNvbGxlY3Rpb24gPSBvcHRpb25zLndoZXJlIHx8IG51bGw7XG4gICAgVXRpbHMubWFwRmluZGVyT3B0aW9ucyhvcHRpb25zLCB0aGlzKTtcbiAgICBvcHRpb25zID0gdGhpcy5fcGFyYW5vaWRDbGF1c2UodGhpcywgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoXCJiZWZvcmVGaW5kQWZ0ZXJPcHRpb25zXCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RPcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgdGFibGVOYW1lczogT2JqZWN0LmtleXModGFibGVOYW1lcykgfSk7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2Uuc2VsZWN0KHRoaXMsIHRoaXMuZ2V0VGFibGVOYW1lKHNlbGVjdE9wdGlvbnMpLCBzZWxlY3RPcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcyhcImFmdGVyRmluZFwiLCByZXN1bHRzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKF8uaXNFbXB0eShyZXN1bHRzKSAmJiBvcHRpb25zLnJlamVjdE9uRW1wdHkpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWplY3RPbkVtcHR5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IG9wdGlvbnMucmVqZWN0T25FbXB0eSgpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlamVjdE9uRW1wdHkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgb3B0aW9ucy5yZWplY3RPbkVtcHR5O1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5FbXB0eVJlc3VsdEVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBNb2RlbC5fZmluZFNlcGFyYXRlKHJlc3VsdHMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyB3YXJuT25JbnZhbGlkT3B0aW9ucyhvcHRpb25zLCB2YWxpZENvbHVtbk5hbWVzKSB7XG4gICAgaWYgKCFfLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdW5yZWNvZ25pemVkT3B0aW9ucyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpLmZpbHRlcigoaykgPT4gIXZhbGlkUXVlcnlLZXl3b3Jkcy5oYXMoaykpO1xuICAgIGNvbnN0IHVuZXhwZWN0ZWRNb2RlbEF0dHJpYnV0ZXMgPSBfLmludGVyc2VjdGlvbih1bnJlY29nbml6ZWRPcHRpb25zLCB2YWxpZENvbHVtbk5hbWVzKTtcbiAgICBpZiAoIW9wdGlvbnMud2hlcmUgJiYgdW5leHBlY3RlZE1vZGVsQXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICBsb2dnZXIud2FybihgTW9kZWwgYXR0cmlidXRlcyAoJHt1bmV4cGVjdGVkTW9kZWxBdHRyaWJ1dGVzLmpvaW4oXCIsIFwiKX0pIHBhc3NlZCBpbnRvIGZpbmRlciBtZXRob2Qgb3B0aW9ucyBvZiBtb2RlbCAke3RoaXMubmFtZX0sIGJ1dCB0aGUgb3B0aW9ucy53aGVyZSBvYmplY3QgaXMgZW1wdHkuIERpZCB5b3UgZm9yZ2V0IHRvIHVzZSBvcHRpb25zLndoZXJlP2ApO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgX2luamVjdERlcGVuZGVudFZpcnR1YWxBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoIXRoaXMuX2hhc1ZpcnR1YWxBdHRyaWJ1dGVzKVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgaWYgKCFhdHRyaWJ1dGVzIHx8ICFBcnJheS5pc0FycmF5KGF0dHJpYnV0ZXMpKVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xuICAgICAgaWYgKHRoaXMuX3ZpcnR1YWxBdHRyaWJ1dGVzLmhhcyhhdHRyaWJ1dGUpICYmIHRoaXMucmF3QXR0cmlidXRlc1thdHRyaWJ1dGVdLnR5cGUuZmllbGRzKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmNvbmNhdCh0aGlzLnJhd0F0dHJpYnV0ZXNbYXR0cmlidXRlXS50eXBlLmZpZWxkcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGF0dHJpYnV0ZXMgPSBfLnVuaXEoYXR0cmlidXRlcyk7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gIH1cbiAgc3RhdGljIGFzeW5jIF9maW5kU2VwYXJhdGUocmVzdWx0cywgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlIHx8IG9wdGlvbnMucmF3IHx8ICFyZXN1bHRzKVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgY29uc3Qgb3JpZ2luYWwgPSByZXN1bHRzO1xuICAgIGlmIChvcHRpb25zLnBsYWluKVxuICAgICAgcmVzdWx0cyA9IFtyZXN1bHRzXTtcbiAgICBpZiAoIXJlc3VsdHMubGVuZ3RoKVxuICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKG9wdGlvbnMuaW5jbHVkZS5tYXAoYXN5bmMgKGluY2x1ZGUpID0+IHtcbiAgICAgIGlmICghaW5jbHVkZS5zZXBhcmF0ZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgTW9kZWwuX2ZpbmRTZXBhcmF0ZShyZXN1bHRzLnJlZHVjZSgobWVtbywgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgbGV0IGFzc29jaWF0aW9ucyA9IHJlc3VsdC5nZXQoaW5jbHVkZS5hc3NvY2lhdGlvbi5hcyk7XG4gICAgICAgICAgaWYgKCFhc3NvY2lhdGlvbnMpXG4gICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXNzb2NpYXRpb25zKSlcbiAgICAgICAgICAgIGFzc29jaWF0aW9ucyA9IFthc3NvY2lhdGlvbnNdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhc3NvY2lhdGlvbnMubGVuZ3RoOyBpICE9PSBsZW47ICsraSkge1xuICAgICAgICAgICAgbWVtby5wdXNoKGFzc29jaWF0aW9uc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICB9LCBbXSksIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIF8ub21pdChvcHRpb25zLCBcImluY2x1ZGVcIiwgXCJhdHRyaWJ1dGVzXCIsIFwib3JkZXJcIiwgXCJ3aGVyZVwiLCBcImxpbWl0XCIsIFwib2Zmc2V0XCIsIFwicGxhaW5cIiwgXCJzY29wZVwiKSksIHtcbiAgICAgICAgICBpbmNsdWRlOiBpbmNsdWRlLmluY2x1ZGUgfHwgW11cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWFwID0gYXdhaXQgaW5jbHVkZS5hc3NvY2lhdGlvbi5nZXQocmVzdWx0cywgX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIF8ub21pdChvcHRpb25zLCBub25DYXNjYWRpbmdPcHRpb25zKSksIF8ub21pdChpbmNsdWRlLCBbXCJwYXJlbnRcIiwgXCJhc3NvY2lhdGlvblwiLCBcImFzXCIsIFwib3JpZ2luYWxBdHRyaWJ1dGVzXCJdKSkpO1xuICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICByZXN1bHQuc2V0KGluY2x1ZGUuYXNzb2NpYXRpb24uYXMsIG1hcFtyZXN1bHQuZ2V0KGluY2x1ZGUuYXNzb2NpYXRpb24uc291cmNlS2V5KV0sIHsgcmF3OiB0cnVlIH0pO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICByZXR1cm4gb3JpZ2luYWw7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZpbmRCeVBrKHBhcmFtLCBvcHRpb25zKSB7XG4gICAgaWYgKFtudWxsLCB2b2lkIDBdLmluY2x1ZGVzKHBhcmFtKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucykgfHwge307XG4gICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgcGFyYW0gPT09IFwiYmlnaW50XCIgfHwgdHlwZW9mIHBhcmFtID09PSBcInN0cmluZ1wiIHx8IEJ1ZmZlci5pc0J1ZmZlcihwYXJhbSkpIHtcbiAgICAgIG9wdGlvbnMud2hlcmUgPSB7XG4gICAgICAgIFt0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGVdOiBwYXJhbVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcmd1bWVudCBwYXNzZWQgdG8gZmluZEJ5UGsgaXMgaW52YWxpZDogJHtwYXJhbX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZmluZE9uZShvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZmluZE9uZShvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgIT09IHZvaWQgMCAmJiAhXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYXJndW1lbnQgcGFzc2VkIHRvIGZpbmRPbmUgbXVzdCBiZSBhbiBvcHRpb25zIG9iamVjdCwgdXNlIGZpbmRCeVBrIGlmIHlvdSB3aXNoIHRvIHBhc3MgYSBzaW5nbGUgcHJpbWFyeSBrZXkgdmFsdWVcIik7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gPT09IHZvaWQgMCAmJiB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscy5nZXQoXCJ0cmFuc2FjdGlvblwiKTtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24gPSB0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5saW1pdCA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCB1bmlxdWVTaW5nbGVDb2x1bW5zID0gXy5jaGFpbih0aGlzLnVuaXF1ZUtleXMpLnZhbHVlcygpLmZpbHRlcigoYykgPT4gYy5maWVsZHMubGVuZ3RoID09PSAxKS5tYXAoXCJjb2x1bW5cIikudmFsdWUoKTtcbiAgICAgIGlmICghb3B0aW9ucy53aGVyZSB8fCAhXy5zb21lKG9wdGlvbnMud2hlcmUsICh2YWx1ZSwga2V5KSA9PiAoa2V5ID09PSB0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGUgfHwgdW5pcXVlU2luZ2xlQ29sdW1ucy5pbmNsdWRlcyhrZXkpKSAmJiAoVXRpbHMuaXNQcmltaXRpdmUodmFsdWUpIHx8IEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpKSkge1xuICAgICAgICBvcHRpb25zLmxpbWl0ID0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZmluZEFsbChfLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgIHBsYWluOiB0cnVlXG4gICAgfSkpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBhZ2dyZWdhdGUoYXR0cmlidXRlLCBhZ2dyZWdhdGVGdW5jdGlvbiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgY29uc3QgcHJldkF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXM7XG4gICAgdGhpcy5faW5qZWN0U2NvcGUob3B0aW9ucyk7XG4gICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gcHJldkF0dHJpYnV0ZXM7XG4gICAgdGhpcy5fY29uZm9ybUluY2x1ZGVzKG9wdGlvbnMsIHRoaXMpO1xuICAgIGlmIChvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgIHRoaXMuX2V4cGFuZEluY2x1ZGVBbGwob3B0aW9ucyk7XG4gICAgICB0aGlzLl92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHMob3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IGF0dHJPcHRpb25zID0gdGhpcy5yYXdBdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XG4gICAgY29uc3QgZmllbGQgPSBhdHRyT3B0aW9ucyAmJiBhdHRyT3B0aW9ucy5maWVsZCB8fCBhdHRyaWJ1dGU7XG4gICAgbGV0IGFnZ3JlZ2F0ZUNvbHVtbiA9IHRoaXMuc2VxdWVsaXplLmNvbChmaWVsZCk7XG4gICAgaWYgKG9wdGlvbnMuZGlzdGluY3QpIHtcbiAgICAgIGFnZ3JlZ2F0ZUNvbHVtbiA9IHRoaXMuc2VxdWVsaXplLmZuKFwiRElTVElOQ1RcIiwgYWdncmVnYXRlQ29sdW1uKTtcbiAgICB9XG4gICAgbGV0IHsgZ3JvdXAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZ3JvdXApICYmIEFycmF5LmlzQXJyYXkoZ3JvdXBbMF0pKSB7XG4gICAgICBub0RvdWJsZU5lc3RlZEdyb3VwKCk7XG4gICAgICBncm91cCA9IF8uZmxhdHRlbihncm91cCk7XG4gICAgfVxuICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IF8udW5pb25CeShvcHRpb25zLmF0dHJpYnV0ZXMsIGdyb3VwLCBbW3RoaXMuc2VxdWVsaXplLmZuKGFnZ3JlZ2F0ZUZ1bmN0aW9uLCBhZ2dyZWdhdGVDb2x1bW4pLCBhZ2dyZWdhdGVGdW5jdGlvbl1dLCAoYSkgPT4gQXJyYXkuaXNBcnJheShhKSA/IGFbMV0gOiBhKTtcbiAgICBpZiAoIW9wdGlvbnMuZGF0YVR5cGUpIHtcbiAgICAgIGlmIChhdHRyT3B0aW9ucykge1xuICAgICAgICBvcHRpb25zLmRhdGFUeXBlID0gYXR0ck9wdGlvbnMudHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuZGF0YVR5cGUgPSBuZXcgRGF0YVR5cGVzLkZMT0FUKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuZGF0YVR5cGUgPSB0aGlzLnNlcXVlbGl6ZS5ub3JtYWxpemVEYXRhVHlwZShvcHRpb25zLmRhdGFUeXBlKTtcbiAgICB9XG4gICAgVXRpbHMubWFwT3B0aW9uRmllbGROYW1lcyhvcHRpb25zLCB0aGlzKTtcbiAgICBvcHRpb25zID0gdGhpcy5fcGFyYW5vaWRDbGF1c2UodGhpcywgb3B0aW9ucyk7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLnJhd1NlbGVjdCh0aGlzLmdldFRhYmxlTmFtZShvcHRpb25zKSwgb3B0aW9ucywgYWdncmVnYXRlRnVuY3Rpb24sIHRoaXMpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgY291bnQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucywgeyBob29rczogdHJ1ZSB9KTtcbiAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiA9PT0gdm9pZCAwICYmIHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzLmdldChcInRyYW5zYWN0aW9uXCIpO1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbiA9IHQ7XG4gICAgICB9XG4gICAgfVxuICAgIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcyhcImJlZm9yZUNvdW50XCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBsZXQgY29sID0gb3B0aW9ucy5jb2wgfHwgXCIqXCI7XG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgY29sID0gYCR7dGhpcy5uYW1lfS4ke29wdGlvbnMuY29sIHx8IHRoaXMucHJpbWFyeUtleUZpZWxkfWA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRpc3RpbmN0ICYmIGNvbCA9PT0gXCIqXCIpIHtcbiAgICAgIGNvbCA9IHRoaXMucHJpbWFyeUtleUZpZWxkO1xuICAgIH1cbiAgICBvcHRpb25zLnBsYWluID0gIW9wdGlvbnMuZ3JvdXA7XG4gICAgb3B0aW9ucy5kYXRhVHlwZSA9IG5ldyBEYXRhVHlwZXMuSU5URUdFUigpO1xuICAgIG9wdGlvbnMuaW5jbHVkZUlnbm9yZUF0dHJpYnV0ZXMgPSBmYWxzZTtcbiAgICBvcHRpb25zLmxpbWl0ID0gbnVsbDtcbiAgICBvcHRpb25zLm9mZnNldCA9IG51bGw7XG4gICAgb3B0aW9ucy5vcmRlciA9IG51bGw7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5hZ2dyZWdhdGUoY29sLCBcImNvdW50XCIsIG9wdGlvbnMpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQubWFwKChpdGVtKSA9PiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBpdGVtKSwge1xuICAgICAgICBjb3VudDogTnVtYmVyKGl0ZW0uY291bnQpXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZpbmRBbmRDb3VudEFsbChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgIT09IHZvaWQgMCAmJiAhXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYXJndW1lbnQgcGFzc2VkIHRvIGZpbmRBbmRDb3VudEFsbCBtdXN0IGJlIGFuIG9wdGlvbnMgb2JqZWN0LCB1c2UgZmluZEJ5UGsgaWYgeW91IHdpc2ggdG8gcGFzcyBhIHNpbmdsZSBwcmltYXJ5IGtleSB2YWx1ZVwiKTtcbiAgICB9XG4gICAgY29uc3QgY291bnRPcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIGlmIChjb3VudE9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgICAgY291bnRPcHRpb25zLmF0dHJpYnV0ZXMgPSB2b2lkIDA7XG4gICAgfVxuICAgIGNvbnN0IFtjb3VudCwgcm93c10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLmNvdW50KGNvdW50T3B0aW9ucyksXG4gICAgICB0aGlzLmZpbmRBbGwob3B0aW9ucylcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgY291bnQsXG4gICAgICByb3dzOiBjb3VudCA9PT0gMCA/IFtdIDogcm93c1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGFzeW5jIG1heChmaWVsZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFnZ3JlZ2F0ZShmaWVsZCwgXCJtYXhcIiwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIG1pbihmaWVsZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFnZ3JlZ2F0ZShmaWVsZCwgXCJtaW5cIiwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIHN1bShmaWVsZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFnZ3JlZ2F0ZShmaWVsZCwgXCJzdW1cIiwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGJ1aWxkKHZhbHVlcywgb3B0aW9ucykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ1bGtCdWlsZCh2YWx1ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHRoaXModmFsdWVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgYnVsa0J1aWxkKHZhbHVlU2V0cywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7IGlzTmV3UmVjb3JkOiB0cnVlIH0sIG9wdGlvbnMpO1xuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlVmFsaWRhdGVkKSB7XG4gICAgICB0aGlzLl9jb25mb3JtSW5jbHVkZXMob3B0aW9ucywgdGhpcyk7XG4gICAgICBpZiAob3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICAgIHRoaXMuX2V4cGFuZEluY2x1ZGVBbGwob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzLm1hcCgoYXR0cmlidXRlKSA9PiBBcnJheS5pc0FycmF5KGF0dHJpYnV0ZSkgPyBhdHRyaWJ1dGVbMV0gOiBhdHRyaWJ1dGUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVTZXRzLm1hcCgodmFsdWVzKSA9PiB0aGlzLmJ1aWxkKHZhbHVlcywgb3B0aW9ucykpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBjcmVhdGUodmFsdWVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zIHx8IHt9KTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5idWlsZCh2YWx1ZXMsIHtcbiAgICAgIGlzTmV3UmVjb3JkOiB0cnVlLFxuICAgICAgYXR0cmlidXRlczogb3B0aW9ucy5maWVsZHMsXG4gICAgICBpbmNsdWRlOiBvcHRpb25zLmluY2x1ZGUsXG4gICAgICByYXc6IG9wdGlvbnMucmF3LFxuICAgICAgc2lsZW50OiBvcHRpb25zLnNpbGVudFxuICAgIH0pLnNhdmUob3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZpbmRPckJ1aWxkKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMud2hlcmUgfHwgYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgd2hlcmUgYXR0cmlidXRlIGluIHRoZSBvcHRpb25zIHBhcmFtZXRlciBwYXNzZWQgdG8gZmluZE9yQnVpbGQuIFBsZWFzZSBub3RlIHRoYXQgdGhlIEFQSSBoYXMgY2hhbmdlZCwgYW5kIGlzIG5vdyBvcHRpb25zIG9ubHkgKGFuIG9iamVjdCB3aXRoIHdoZXJlLCBkZWZhdWx0cyBrZXlzLCB0cmFuc2FjdGlvbiBldGMuKVwiKTtcbiAgICB9XG4gICAgbGV0IHZhbHVlcztcbiAgICBsZXQgaW5zdGFuY2UgPSBhd2FpdCB0aGlzLmZpbmRPbmUob3B0aW9ucyk7XG4gICAgaWYgKGluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICB2YWx1ZXMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucy5kZWZhdWx0cyk7XG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMud2hlcmUpKSB7XG4gICAgICAgIHZhbHVlcyA9IFV0aWxzLmRlZmF1bHRzKHZhbHVlcywgb3B0aW9ucy53aGVyZSk7XG4gICAgICB9XG4gICAgICBpbnN0YW5jZSA9IHRoaXMuYnVpbGQodmFsdWVzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBbaW5zdGFuY2UsIHRydWVdO1xuICAgIH1cbiAgICByZXR1cm4gW2luc3RhbmNlLCBmYWxzZV07XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZpbmRPckNyZWF0ZShvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLndoZXJlIHx8IGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHdoZXJlIGF0dHJpYnV0ZSBpbiB0aGUgb3B0aW9ucyBwYXJhbWV0ZXIgcGFzc2VkIHRvIGZpbmRPckNyZWF0ZS4gUGxlYXNlIG5vdGUgdGhhdCB0aGUgQVBJIGhhcyBjaGFuZ2VkLCBhbmQgaXMgbm93IG9wdGlvbnMgb25seSAoYW4gb2JqZWN0IHdpdGggd2hlcmUsIGRlZmF1bHRzIGtleXMsIHRyYW5zYWN0aW9uIGV0Yy4pXCIpO1xuICAgIH1cbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICBjb25zdCBkZWZhdWx0cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMuZGVmYXVsdHMpO1xuICAgICAgY29uc3QgdW5rbm93bkRlZmF1bHRzID0gZGVmYXVsdHMuZmlsdGVyKChuYW1lKSA9PiAhdGhpcy5yYXdBdHRyaWJ1dGVzW25hbWVdKTtcbiAgICAgIGlmICh1bmtub3duRGVmYXVsdHMubGVuZ3RoKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBVbmtub3duIGF0dHJpYnV0ZXMgKCR7dW5rbm93bkRlZmF1bHRzfSkgcGFzc2VkIHRvIGRlZmF1bHRzIG9wdGlvbiBvZiBmaW5kT3JDcmVhdGVgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gPT09IHZvaWQgMCAmJiB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscy5nZXQoXCJ0cmFuc2FjdGlvblwiKTtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24gPSB0O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbnRlcm5hbFRyYW5zYWN0aW9uID0gIW9wdGlvbnMudHJhbnNhY3Rpb247XG4gICAgbGV0IHZhbHVlcztcbiAgICBsZXQgdHJhbnNhY3Rpb247XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHQgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS50cmFuc2FjdGlvbihvcHRpb25zKTtcbiAgICAgIHRyYW5zYWN0aW9uID0gdDtcbiAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24gPSB0O1xuICAgICAgY29uc3QgZm91bmQgPSBhd2FpdCB0aGlzLmZpbmRPbmUoVXRpbHMuZGVmYXVsdHMoeyB0cmFuc2FjdGlvbiB9LCBvcHRpb25zKSk7XG4gICAgICBpZiAoZm91bmQgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtmb3VuZCwgZmFsc2VdO1xuICAgICAgfVxuICAgICAgdmFsdWVzID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMuZGVmYXVsdHMpO1xuICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChvcHRpb25zLndoZXJlKSkge1xuICAgICAgICB2YWx1ZXMgPSBVdGlscy5kZWZhdWx0cyh2YWx1ZXMsIG9wdGlvbnMud2hlcmUpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5leGNlcHRpb24gPSB0cnVlO1xuICAgICAgb3B0aW9ucy5yZXR1cm5pbmcgPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY3JlYXRlZCA9IGF3YWl0IHRoaXMuY3JlYXRlKHZhbHVlcywgb3B0aW9ucyk7XG4gICAgICAgIGlmIChjcmVhdGVkLmdldCh0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5VbmlxdWVDb25zdHJhaW50RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2NyZWF0ZWQsIHRydWVdO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIHNlcXVlbGl6ZUVycm9ycy5VbmlxdWVDb25zdHJhaW50RXJyb3IpKVxuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgY29uc3QgZmxhdHRlbmVkV2hlcmUgPSBVdGlscy5mbGF0dGVuT2JqZWN0RGVlcChvcHRpb25zLndoZXJlKTtcbiAgICAgICAgY29uc3QgZmxhdHRlbmVkV2hlcmVLZXlzID0gT2JqZWN0LmtleXMoZmxhdHRlbmVkV2hlcmUpLm1hcCgobmFtZSkgPT4gXy5sYXN0KG5hbWUuc3BsaXQoXCIuXCIpKSk7XG4gICAgICAgIGNvbnN0IHdoZXJlRmllbGRzID0gZmxhdHRlbmVkV2hlcmVLZXlzLm1hcCgobmFtZSkgPT4gXy5nZXQodGhpcy5yYXdBdHRyaWJ1dGVzLCBgJHtuYW1lfS5maWVsZGAsIG5hbWUpKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdEZpZWxkcyA9IG9wdGlvbnMuZGVmYXVsdHMgJiYgT2JqZWN0LmtleXMob3B0aW9ucy5kZWZhdWx0cykuZmlsdGVyKChuYW1lKSA9PiB0aGlzLnJhd0F0dHJpYnV0ZXNbbmFtZV0pLm1hcCgobmFtZSkgPT4gdGhpcy5yYXdBdHRyaWJ1dGVzW25hbWVdLmZpZWxkIHx8IG5hbWUpO1xuICAgICAgICBjb25zdCBlcnJGaWVsZEtleXMgPSBPYmplY3Qua2V5cyhlcnIuZmllbGRzKTtcbiAgICAgICAgY29uc3QgZXJyRmllbGRzV2hlcmVJbnRlcnNlY3RzID0gVXRpbHMuaW50ZXJzZWN0cyhlcnJGaWVsZEtleXMsIHdoZXJlRmllbGRzKTtcbiAgICAgICAgaWYgKGRlZmF1bHRGaWVsZHMgJiYgIWVyckZpZWxkc1doZXJlSW50ZXJzZWN0cyAmJiBVdGlscy5pbnRlcnNlY3RzKGVyckZpZWxkS2V5cywgZGVmYXVsdEZpZWxkcykpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyckZpZWxkc1doZXJlSW50ZXJzZWN0cykge1xuICAgICAgICAgIF8uZWFjaChlcnIuZmllbGRzLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZmllbGRSYXdBdHRyaWJ1dGVzTWFwW2tleV0uZmllbGROYW1lO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnRvU3RyaW5nKCkgIT09IG9wdGlvbnMud2hlcmVbbmFtZV0udG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5uYW1lfSNmaW5kT3JDcmVhdGU6IHZhbHVlIHVzZWQgZm9yICR7bmFtZX0gd2FzIG5vdCBlcXVhbCBmb3IgYm90aCB0aGUgZmluZCBhbmQgdGhlIGNyZWF0ZSBjYWxscywgJyR7b3B0aW9ucy53aGVyZVtuYW1lXX0nIHZzICcke3ZhbHVlfSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdGhlckNyZWF0ZWQgPSBhd2FpdCB0aGlzLmZpbmRPbmUoVXRpbHMuZGVmYXVsdHMoe1xuICAgICAgICAgIHRyYW5zYWN0aW9uOiBpbnRlcm5hbFRyYW5zYWN0aW9uID8gbnVsbCA6IHRyYW5zYWN0aW9uXG4gICAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgaWYgKG90aGVyQ3JlYXRlZCA9PT0gbnVsbClcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIHJldHVybiBbb3RoZXJDcmVhdGVkLCBmYWxzZV07XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChpbnRlcm5hbFRyYW5zYWN0aW9uICYmIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGF3YWl0IHRyYW5zYWN0aW9uLmNvbW1pdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgYXN5bmMgZmluZENyZWF0ZUZpbmQob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy53aGVyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB3aGVyZSBhdHRyaWJ1dGUgaW4gdGhlIG9wdGlvbnMgcGFyYW1ldGVyIHBhc3NlZCB0byBmaW5kQ3JlYXRlRmluZC5cIik7XG4gICAgfVxuICAgIGxldCB2YWx1ZXMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucy5kZWZhdWx0cyk7XG4gICAgaWYgKF8uaXNQbGFpbk9iamVjdChvcHRpb25zLndoZXJlKSkge1xuICAgICAgdmFsdWVzID0gVXRpbHMuZGVmYXVsdHModmFsdWVzLCBvcHRpb25zLndoZXJlKTtcbiAgICB9XG4gICAgY29uc3QgZm91bmQgPSBhd2FpdCB0aGlzLmZpbmRPbmUob3B0aW9ucyk7XG4gICAgaWYgKGZvdW5kKVxuICAgICAgcmV0dXJuIFtmb3VuZCwgZmFsc2VdO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjcmVhdGVPcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xuICAgICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCA9PT0gXCJwb3N0Z3Jlc1wiICYmIG9wdGlvbnMudHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY3JlYXRlT3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNyZWF0ZWQgPSBhd2FpdCB0aGlzLmNyZWF0ZSh2YWx1ZXMsIGNyZWF0ZU9wdGlvbnMpO1xuICAgICAgcmV0dXJuIFtjcmVhdGVkLCB0cnVlXTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIHNlcXVlbGl6ZUVycm9ycy5VbmlxdWVDb25zdHJhaW50RXJyb3IgfHwgZXJyIGluc3RhbmNlb2Ygc2VxdWVsaXplRXJyb3JzLkVtcHR5UmVzdWx0RXJyb3IpKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZvdW5kQWdhaW4gPSBhd2FpdCB0aGlzLmZpbmRPbmUob3B0aW9ucyk7XG4gICAgICByZXR1cm4gW2ZvdW5kQWdhaW4sIGZhbHNlXTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGFzeW5jIHVwc2VydCh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgaG9va3M6IHRydWUsXG4gICAgICByZXR1cm5pbmc6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogdHJ1ZVxuICAgIH0sIFV0aWxzLmNsb25lRGVlcChvcHRpb25zKSk7XG4gICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gPT09IHZvaWQgMCAmJiB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscy5nZXQoXCJ0cmFuc2FjdGlvblwiKTtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24gPSB0O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjcmVhdGVkQXRBdHRyID0gdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXQ7XG4gICAgY29uc3QgdXBkYXRlZEF0QXR0ciA9IHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0O1xuICAgIGNvbnN0IGhhc1ByaW1hcnkgPSB0aGlzLnByaW1hcnlLZXlGaWVsZCBpbiB2YWx1ZXMgfHwgdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlIGluIHZhbHVlcztcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuYnVpbGQodmFsdWVzKTtcbiAgICBvcHRpb25zLm1vZGVsID0gdGhpcztcbiAgICBvcHRpb25zLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgY29uc3QgY2hhbmdlZCA9IEFycmF5LmZyb20oaW5zdGFuY2UuX2NoYW5nZWQpO1xuICAgIGlmICghb3B0aW9ucy5maWVsZHMpIHtcbiAgICAgIG9wdGlvbnMuZmllbGRzID0gY2hhbmdlZDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudmFsaWRhdGUpIHtcbiAgICAgIGF3YWl0IGluc3RhbmNlLnZhbGlkYXRlKG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVkRGF0YVZhbHVlcyA9IF8ucGljayhpbnN0YW5jZS5kYXRhVmFsdWVzLCBjaGFuZ2VkKTtcbiAgICBjb25zdCBpbnNlcnRWYWx1ZXMgPSBVdGlscy5tYXBWYWx1ZUZpZWxkTmFtZXMoaW5zdGFuY2UuZGF0YVZhbHVlcywgT2JqZWN0LmtleXMoaW5zdGFuY2UucmF3QXR0cmlidXRlcyksIHRoaXMpO1xuICAgIGNvbnN0IHVwZGF0ZVZhbHVlcyA9IFV0aWxzLm1hcFZhbHVlRmllbGROYW1lcyh1cGRhdGVkRGF0YVZhbHVlcywgb3B0aW9ucy5maWVsZHMsIHRoaXMpO1xuICAgIGNvbnN0IG5vdyA9IFV0aWxzLm5vdyh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuICAgIGlmIChjcmVhdGVkQXRBdHRyICYmICFpbnNlcnRWYWx1ZXNbY3JlYXRlZEF0QXR0cl0pIHtcbiAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5yYXdBdHRyaWJ1dGVzW2NyZWF0ZWRBdEF0dHJdLmZpZWxkIHx8IGNyZWF0ZWRBdEF0dHI7XG4gICAgICBpbnNlcnRWYWx1ZXNbZmllbGRdID0gdGhpcy5fZ2V0RGVmYXVsdFRpbWVzdGFtcChjcmVhdGVkQXRBdHRyKSB8fCBub3c7XG4gICAgfVxuICAgIGlmICh1cGRhdGVkQXRBdHRyICYmICFpbnNlcnRWYWx1ZXNbdXBkYXRlZEF0QXR0cl0pIHtcbiAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5yYXdBdHRyaWJ1dGVzW3VwZGF0ZWRBdEF0dHJdLmZpZWxkIHx8IHVwZGF0ZWRBdEF0dHI7XG4gICAgICBpbnNlcnRWYWx1ZXNbZmllbGRdID0gdXBkYXRlVmFsdWVzW2ZpZWxkXSA9IHRoaXMuX2dldERlZmF1bHRUaW1lc3RhbXAodXBkYXRlZEF0QXR0cikgfHwgbm93O1xuICAgIH1cbiAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0ID09PSBcImRiMlwiKSB7XG4gICAgICB0aGlzLnVuaXFubyA9IHRoaXMuc2VxdWVsaXplLmRpYWxlY3QucXVlcnlHZW5lcmF0b3IuYWRkVW5pcXVlRmllbGRzKGluc2VydFZhbHVlcywgdGhpcy5yYXdBdHRyaWJ1dGVzLCB0aGlzLnVuaXFubyk7XG4gICAgfVxuICAgIGlmICghaGFzUHJpbWFyeSAmJiB0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGUgJiYgIXRoaXMucmF3QXR0cmlidXRlc1t0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGVdLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgZGVsZXRlIGluc2VydFZhbHVlc1t0aGlzLnByaW1hcnlLZXlGaWVsZF07XG4gICAgICBkZWxldGUgdXBkYXRlVmFsdWVzW3RoaXMucHJpbWFyeUtleUZpZWxkXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoXCJiZWZvcmVVcHNlcnRcIiwgdmFsdWVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS51cHNlcnQodGhpcy5nZXRUYWJsZU5hbWUob3B0aW9ucyksIGluc2VydFZhbHVlcywgdXBkYXRlVmFsdWVzLCBpbnN0YW5jZS53aGVyZSgpLCBvcHRpb25zKTtcbiAgICBjb25zdCBbcmVjb3JkXSA9IHJlc3VsdDtcbiAgICByZWNvcmQuaXNOZXdSZWNvcmQgPSBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcyhcImFmdGVyVXBzZXJ0XCIsIHJlc3VsdCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyBhc3luYyBidWxrQ3JlYXRlKHJlY29yZHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghcmVjb3Jkcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgZGlhbGVjdCA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdDtcbiAgICBjb25zdCBub3cgPSBVdGlscy5ub3codGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uID09PSB2b2lkIDAgJiYgdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscykge1xuICAgICAgY29uc3QgdCA9IHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMuZ2V0KFwidHJhbnNhY3Rpb25cIik7XG4gICAgICBpZiAodCkge1xuICAgICAgICBvcHRpb25zLnRyYW5zYWN0aW9uID0gdDtcbiAgICAgIH1cbiAgICB9XG4gICAgb3B0aW9ucy5tb2RlbCA9IHRoaXM7XG4gICAgaWYgKCFvcHRpb25zLmluY2x1ZGVWYWxpZGF0ZWQpIHtcbiAgICAgIHRoaXMuX2NvbmZvcm1JbmNsdWRlcyhvcHRpb25zLCB0aGlzKTtcbiAgICAgIGlmIChvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgICAgdGhpcy5fZXhwYW5kSW5jbHVkZUFsbChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnRzKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbnN0YW5jZXMgPSByZWNvcmRzLm1hcCgodmFsdWVzKSA9PiB0aGlzLmJ1aWxkKHZhbHVlcywgeyBpc05ld1JlY29yZDogdHJ1ZSwgaW5jbHVkZTogb3B0aW9ucy5pbmNsdWRlIH0pKTtcbiAgICBjb25zdCByZWN1cnNpdmVCdWxrQ3JlYXRlID0gYXN5bmMgKGluc3RhbmNlczIsIG9wdGlvbnMyKSA9PiB7XG4gICAgICBvcHRpb25zMiA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgdmFsaWRhdGU6IGZhbHNlLFxuICAgICAgICBob29rczogdHJ1ZSxcbiAgICAgICAgaW5kaXZpZHVhbEhvb2tzOiBmYWxzZSxcbiAgICAgICAgaWdub3JlRHVwbGljYXRlczogZmFsc2VcbiAgICAgIH0sIG9wdGlvbnMyKTtcbiAgICAgIGlmIChvcHRpb25zMi5yZXR1cm5pbmcgPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAob3B0aW9uczIuYXNzb2NpYXRpb24pIHtcbiAgICAgICAgICBvcHRpb25zMi5yZXR1cm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zMi5yZXR1cm5pbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9uczIuaWdub3JlRHVwbGljYXRlcyAmJiAhdGhpcy5zZXF1ZWxpemUuZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLmlnbm9yZUR1cGxpY2F0ZXMgJiYgIXRoaXMuc2VxdWVsaXplLmRpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy5vbkNvbmZsaWN0RG9Ob3RoaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtkaWFsZWN0fSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBpZ25vcmVEdXBsaWNhdGVzIG9wdGlvbi5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zMi51cGRhdGVPbkR1cGxpY2F0ZSAmJiAoZGlhbGVjdCAhPT0gXCJteXNxbFwiICYmIGRpYWxlY3QgIT09IFwibWFyaWFkYlwiICYmIGRpYWxlY3QgIT09IFwic3FsaXRlXCIgJiYgZGlhbGVjdCAhPT0gXCJwb3N0Z3Jlc1wiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZGlhbGVjdH0gZG9lcyBub3Qgc3VwcG9ydCB0aGUgdXBkYXRlT25EdXBsaWNhdGUgb3B0aW9uLmApO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZWwgPSBvcHRpb25zMi5tb2RlbDtcbiAgICAgIG9wdGlvbnMyLmZpZWxkcyA9IG9wdGlvbnMyLmZpZWxkcyB8fCBPYmplY3Qua2V5cyhtb2RlbC5yYXdBdHRyaWJ1dGVzKTtcbiAgICAgIGNvbnN0IGNyZWF0ZWRBdEF0dHIgPSBtb2RlbC5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXQ7XG4gICAgICBjb25zdCB1cGRhdGVkQXRBdHRyID0gbW9kZWwuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0O1xuICAgICAgaWYgKG9wdGlvbnMyLnVwZGF0ZU9uRHVwbGljYXRlICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9uczIudXBkYXRlT25EdXBsaWNhdGUpICYmIG9wdGlvbnMyLnVwZGF0ZU9uRHVwbGljYXRlLmxlbmd0aCkge1xuICAgICAgICAgIG9wdGlvbnMyLnVwZGF0ZU9uRHVwbGljYXRlID0gXy5pbnRlcnNlY3Rpb24oXy53aXRob3V0KE9iamVjdC5rZXlzKG1vZGVsLnRhYmxlQXR0cmlidXRlcyksIGNyZWF0ZWRBdEF0dHIpLCBvcHRpb25zMi51cGRhdGVPbkR1cGxpY2F0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidXBkYXRlT25EdXBsaWNhdGUgb3B0aW9uIG9ubHkgc3VwcG9ydHMgbm9uLWVtcHR5IGFycmF5LlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMyLmhvb2tzKSB7XG4gICAgICAgIGF3YWl0IG1vZGVsLnJ1bkhvb2tzKFwiYmVmb3JlQnVsa0NyZWF0ZVwiLCBpbnN0YW5jZXMyLCBvcHRpb25zMik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9uczIudmFsaWRhdGUpIHtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlT3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zMik7XG4gICAgICAgIHZhbGlkYXRlT3B0aW9ucy5ob29rcyA9IG9wdGlvbnMyLmluZGl2aWR1YWxIb29rcztcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5zdGFuY2VzMi5tYXAoYXN5bmMgKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGluc3RhbmNlLnZhbGlkYXRlKHZhbGlkYXRlT3B0aW9ucyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgc2VxdWVsaXplRXJyb3JzLkJ1bGtSZWNvcmRFcnJvcihlcnIsIGluc3RhbmNlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zMi5za2lwO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuQWdncmVnYXRlRXJyb3IoZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMyLmluZGl2aWR1YWxIb29rcykge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChpbnN0YW5jZXMyLm1hcChhc3luYyAoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICBjb25zdCBpbmRpdmlkdWFsT3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMyKSwge1xuICAgICAgICAgICAgdmFsaWRhdGU6IGZhbHNlLFxuICAgICAgICAgICAgaG9va3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWxldGUgaW5kaXZpZHVhbE9wdGlvbnMuZmllbGRzO1xuICAgICAgICAgIGRlbGV0ZSBpbmRpdmlkdWFsT3B0aW9ucy5pbmRpdmlkdWFsSG9va3M7XG4gICAgICAgICAgZGVsZXRlIGluZGl2aWR1YWxPcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXM7XG4gICAgICAgICAgYXdhaXQgaW5zdGFuY2Uuc2F2ZShpbmRpdmlkdWFsT3B0aW9ucyk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcHRpb25zMi5pbmNsdWRlICYmIG9wdGlvbnMyLmluY2x1ZGUubGVuZ3RoKSB7XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob3B0aW9uczIuaW5jbHVkZS5maWx0ZXIoKGluY2x1ZGUpID0+IGluY2x1ZGUuYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG8pLm1hcChhc3luYyAoaW5jbHVkZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXNzb2NpYXRpb25JbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGFzc29jaWF0aW9uSW5zdGFuY2VJbmRleFRvSW5zdGFuY2VNYXAgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgaW5zdGFuY2VzMikge1xuICAgICAgICAgICAgICBjb25zdCBhc3NvY2lhdGlvbkluc3RhbmNlID0gaW5zdGFuY2UuZ2V0KGluY2x1ZGUuYXMpO1xuICAgICAgICAgICAgICBpZiAoYXNzb2NpYXRpb25JbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uSW5zdGFuY2VzLnB1c2goYXNzb2NpYXRpb25JbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgYXNzb2NpYXRpb25JbnN0YW5jZUluZGV4VG9JbnN0YW5jZU1hcC5wdXNoKGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhc3NvY2lhdGlvbkluc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSBfKFV0aWxzLmNsb25lRGVlcChpbmNsdWRlKSkub21pdChbXCJhc3NvY2lhdGlvblwiXSkuZGVmYXVsdHMoe1xuICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogb3B0aW9uczIudHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgIGxvZ2dpbmc6IG9wdGlvbnMyLmxvZ2dpbmdcbiAgICAgICAgICAgIH0pLnZhbHVlKCk7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVkQXNzb2NpYXRpb25JbnN0YW5jZXMgPSBhd2FpdCByZWN1cnNpdmVCdWxrQ3JlYXRlKGFzc29jaWF0aW9uSW5zdGFuY2VzLCBpbmNsdWRlT3B0aW9ucyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkeCBpbiBjcmVhdGVkQXNzb2NpYXRpb25JbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgYXNzb2NpYXRpb25JbnN0YW5jZSA9IGNyZWF0ZWRBc3NvY2lhdGlvbkluc3RhbmNlc1tpZHhdO1xuICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGFzc29jaWF0aW9uSW5zdGFuY2VJbmRleFRvSW5zdGFuY2VNYXBbaWR4XTtcbiAgICAgICAgICAgICAgYXdhaXQgaW5jbHVkZS5hc3NvY2lhdGlvbi5zZXQoaW5zdGFuY2UsIGFzc29jaWF0aW9uSW5zdGFuY2UsIHsgc2F2ZTogZmFsc2UsIGxvZ2dpbmc6IG9wdGlvbnMyLmxvZ2dpbmcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJlY29yZHMgPSBpbnN0YW5jZXMyLm1hcCgoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBpbnN0YW5jZS5kYXRhVmFsdWVzO1xuICAgICAgICAgIGlmIChjcmVhdGVkQXRBdHRyICYmICF2YWx1ZXNbY3JlYXRlZEF0QXR0cl0pIHtcbiAgICAgICAgICAgIHZhbHVlc1tjcmVhdGVkQXRBdHRyXSA9IG5vdztcbiAgICAgICAgICAgIGlmICghb3B0aW9uczIuZmllbGRzLmluY2x1ZGVzKGNyZWF0ZWRBdEF0dHIpKSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMyLmZpZWxkcy5wdXNoKGNyZWF0ZWRBdEF0dHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodXBkYXRlZEF0QXR0ciAmJiAhdmFsdWVzW3VwZGF0ZWRBdEF0dHJdKSB7XG4gICAgICAgICAgICB2YWx1ZXNbdXBkYXRlZEF0QXR0cl0gPSBub3c7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMyLmZpZWxkcy5pbmNsdWRlcyh1cGRhdGVkQXRBdHRyKSkge1xuICAgICAgICAgICAgICBvcHRpb25zMi5maWVsZHMucHVzaCh1cGRhdGVkQXRBdHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgb3V0ID0gVXRpbHMubWFwVmFsdWVGaWVsZE5hbWVzKHZhbHVlcywgb3B0aW9uczIuZmllbGRzLCBtb2RlbCk7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgbW9kZWwuX3ZpcnR1YWxBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBkZWxldGUgb3V0W2tleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmaWVsZE1hcHBlZEF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBhdHRyIGluIG1vZGVsLnRhYmxlQXR0cmlidXRlcykge1xuICAgICAgICAgIGZpZWxkTWFwcGVkQXR0cmlidXRlc1ttb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkIHx8IGF0dHJdID0gbW9kZWwucmF3QXR0cmlidXRlc1thdHRyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9uczIudXBkYXRlT25EdXBsaWNhdGUpIHtcbiAgICAgICAgICBvcHRpb25zMi51cGRhdGVPbkR1cGxpY2F0ZSA9IG9wdGlvbnMyLnVwZGF0ZU9uRHVwbGljYXRlLm1hcCgoYXR0cikgPT4gbW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZCB8fCBhdHRyKTtcbiAgICAgICAgICBpZiAob3B0aW9uczIuY29uZmxpY3RBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBvcHRpb25zMi51cHNlcnRLZXlzID0gb3B0aW9uczIuY29uZmxpY3RBdHRyaWJ1dGVzLm1hcCgoYXR0ck5hbWUpID0+IG1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0ck5hbWVdLmZpZWxkIHx8IGF0dHJOYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdXBzZXJ0S2V5cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpIG9mIG1vZGVsLl9pbmRleGVzKSB7XG4gICAgICAgICAgICAgIGlmIChpLnVuaXF1ZSAmJiAhaS53aGVyZSkge1xuICAgICAgICAgICAgICAgIHVwc2VydEtleXMucHVzaCguLi5pLmZpZWxkcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpcnN0VW5pcXVlS2V5ID0gT2JqZWN0LnZhbHVlcyhtb2RlbC51bmlxdWVLZXlzKS5maW5kKChjKSA9PiBjLmZpZWxkcy5sZW5ndGggPiAwKTtcbiAgICAgICAgICAgIGlmIChmaXJzdFVuaXF1ZUtleSAmJiBmaXJzdFVuaXF1ZUtleS5maWVsZHMpIHtcbiAgICAgICAgICAgICAgdXBzZXJ0S2V5cy5wdXNoKC4uLmZpcnN0VW5pcXVlS2V5LmZpZWxkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zMi51cHNlcnRLZXlzID0gdXBzZXJ0S2V5cy5sZW5ndGggPiAwID8gdXBzZXJ0S2V5cyA6IE9iamVjdC52YWx1ZXMobW9kZWwucHJpbWFyeUtleXMpLm1hcCgoeCkgPT4geC5maWVsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zMi5yZXR1cm5pbmcgJiYgQXJyYXkuaXNBcnJheShvcHRpb25zMi5yZXR1cm5pbmcpKSB7XG4gICAgICAgICAgb3B0aW9uczIucmV0dXJuaW5nID0gb3B0aW9uczIucmV0dXJuaW5nLm1hcCgoYXR0cikgPT4gXy5nZXQobW9kZWwucmF3QXR0cmlidXRlc1thdHRyXSwgXCJmaWVsZFwiLCBhdHRyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IG1vZGVsLnF1ZXJ5SW50ZXJmYWNlLmJ1bGtJbnNlcnQobW9kZWwuZ2V0VGFibGVOYW1lKG9wdGlvbnMyKSwgcmVjb3Jkcywgb3B0aW9uczIsIGZpZWxkTWFwcGVkQXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdHMpKSB7XG4gICAgICAgICAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzMltpXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICBpZiAoIWluc3RhbmNlIHx8IGtleSA9PT0gbW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZSAmJiBpbnN0YW5jZS5nZXQobW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZSkgJiYgW1wibXlzcWxcIiwgXCJtYXJpYWRiXCIsIFwic3FsaXRlXCJdLmluY2x1ZGVzKGRpYWxlY3QpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWNvcmQgPSByZXN1bHRba2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRyID0gXy5maW5kKG1vZGVsLnJhd0F0dHJpYnV0ZXMsIChhdHRyaWJ1dGUpID0+IGF0dHJpYnV0ZS5maWVsZE5hbWUgPT09IGtleSB8fCBhdHRyaWJ1dGUuZmllbGQgPT09IGtleSk7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZGF0YVZhbHVlc1thdHRyICYmIGF0dHIuZmllbGROYW1lIHx8IGtleV0gPSByZWNvcmQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMyLmluY2x1ZGUgJiYgb3B0aW9uczIuaW5jbHVkZS5sZW5ndGgpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob3B0aW9uczIuaW5jbHVkZS5maWx0ZXIoKGluY2x1ZGUpID0+ICEoaW5jbHVkZS5hc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUbyB8fCBpbmNsdWRlLnBhcmVudCAmJiBpbmNsdWRlLnBhcmVudC5hc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUb01hbnkpKS5tYXAoYXN5bmMgKGluY2x1ZGUpID0+IHtcbiAgICAgICAgICBjb25zdCBhc3NvY2lhdGlvbkluc3RhbmNlcyA9IFtdO1xuICAgICAgICAgIGNvbnN0IGFzc29jaWF0aW9uSW5zdGFuY2VJbmRleFRvSW5zdGFuY2VNYXAgPSBbXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlczIpIHtcbiAgICAgICAgICAgIGxldCBhc3NvY2lhdGVkID0gaW5zdGFuY2UuZ2V0KGluY2x1ZGUuYXMpO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFzc29jaWF0ZWQpKVxuICAgICAgICAgICAgICBhc3NvY2lhdGVkID0gW2Fzc29jaWF0ZWRdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhc3NvY2lhdGlvbkluc3RhbmNlIG9mIGFzc29jaWF0ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGFzc29jaWF0aW9uSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShpbmNsdWRlLmFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvTWFueSkpIHtcbiAgICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uSW5zdGFuY2Uuc2V0KGluY2x1ZGUuYXNzb2NpYXRpb24uZm9yZWlnbktleSwgaW5zdGFuY2UuZ2V0KGluY2x1ZGUuYXNzb2NpYXRpb24uc291cmNlS2V5IHx8IGluc3RhbmNlLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pLCB7IHJhdzogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oYXNzb2NpYXRpb25JbnN0YW5jZSwgaW5jbHVkZS5hc3NvY2lhdGlvbi5zY29wZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uSW5zdGFuY2VzLnB1c2goYXNzb2NpYXRpb25JbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgYXNzb2NpYXRpb25JbnN0YW5jZUluZGV4VG9JbnN0YW5jZU1hcC5wdXNoKGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWFzc29jaWF0aW9uSW5zdGFuY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IF8oVXRpbHMuY2xvbmVEZWVwKGluY2x1ZGUpKS5vbWl0KFtcImFzc29jaWF0aW9uXCJdKS5kZWZhdWx0cyh7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogb3B0aW9uczIudHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBsb2dnaW5nOiBvcHRpb25zMi5sb2dnaW5nXG4gICAgICAgICAgfSkudmFsdWUoKTtcbiAgICAgICAgICBjb25zdCBjcmVhdGVkQXNzb2NpYXRpb25JbnN0YW5jZXMgPSBhd2FpdCByZWN1cnNpdmVCdWxrQ3JlYXRlKGFzc29jaWF0aW9uSW5zdGFuY2VzLCBpbmNsdWRlT3B0aW9ucyk7XG4gICAgICAgICAgaWYgKGluY2x1ZGUuYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG9NYW55KSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZVNldHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWR4IGluIGNyZWF0ZWRBc3NvY2lhdGlvbkluc3RhbmNlcykge1xuICAgICAgICAgICAgICBjb25zdCBhc3NvY2lhdGlvbkluc3RhbmNlID0gY3JlYXRlZEFzc29jaWF0aW9uSW5zdGFuY2VzW2lkeF07XG4gICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gYXNzb2NpYXRpb25JbnN0YW5jZUluZGV4VG9JbnN0YW5jZU1hcFtpZHhdO1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgICAgICAgICAgW2luY2x1ZGUuYXNzb2NpYXRpb24uZm9yZWlnbktleV06IGluc3RhbmNlLmdldChpbnN0YW5jZS5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICBbaW5jbHVkZS5hc3NvY2lhdGlvbi5vdGhlcktleV06IGFzc29jaWF0aW9uSW5zdGFuY2UuZ2V0KGFzc29jaWF0aW9uSW5zdGFuY2UuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSlcbiAgICAgICAgICAgICAgfSwgaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLnNjb3BlKTtcbiAgICAgICAgICAgICAgaWYgKGFzc29jaWF0aW9uSW5zdGFuY2VbaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhdHRyIG9mIE9iamVjdC5rZXlzKGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLl9hdXRvR2VuZXJhdGVkIHx8IGF0dHIgPT09IGluY2x1ZGUuYXNzb2NpYXRpb24uZm9yZWlnbktleSB8fCBhdHRyID09PSBpbmNsdWRlLmFzc29jaWF0aW9uLm90aGVyS2V5IHx8IHR5cGVvZiBhc3NvY2lhdGlvbkluc3RhbmNlW2luY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5uYW1lXVthdHRyXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhbHVlc1thdHRyXSA9IGFzc29jaWF0aW9uSW5zdGFuY2VbaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLm5hbWVdW2F0dHJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YWx1ZVNldHMucHVzaCh2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGhyb3VnaE9wdGlvbnMgPSBfKFV0aWxzLmNsb25lRGVlcChpbmNsdWRlKSkub21pdChbXCJhc3NvY2lhdGlvblwiLCBcImF0dHJpYnV0ZXNcIl0pLmRlZmF1bHRzKHtcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IG9wdGlvbnMyLnRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICBsb2dnaW5nOiBvcHRpb25zMi5sb2dnaW5nXG4gICAgICAgICAgICB9KS52YWx1ZSgpO1xuICAgICAgICAgICAgdGhyb3VnaE9wdGlvbnMubW9kZWwgPSBpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2hNb2RlbDtcbiAgICAgICAgICAgIGNvbnN0IHRocm91Z2hJbnN0YW5jZXMgPSBpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2hNb2RlbC5idWxrQnVpbGQodmFsdWVTZXRzLCB0aHJvdWdoT3B0aW9ucyk7XG4gICAgICAgICAgICBhd2FpdCByZWN1cnNpdmVCdWxrQ3JlYXRlKHRocm91Z2hJbnN0YW5jZXMsIHRocm91Z2hPcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGluc3RhbmNlczIuZm9yRWFjaCgoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBhdHRyIGluIG1vZGVsLnJhd0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBpZiAobW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZCAmJiBpbnN0YW5jZS5kYXRhVmFsdWVzW21vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGRdICE9PSB2b2lkIDAgJiYgbW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZCAhPT0gYXR0cikge1xuICAgICAgICAgICAgaW5zdGFuY2UuZGF0YVZhbHVlc1thdHRyXSA9IGluc3RhbmNlLmRhdGFWYWx1ZXNbbW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZF07XG4gICAgICAgICAgICBkZWxldGUgaW5zdGFuY2UuZGF0YVZhbHVlc1ttb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5zdGFuY2UuX3ByZXZpb3VzRGF0YVZhbHVlc1thdHRyXSA9IGluc3RhbmNlLmRhdGFWYWx1ZXNbYXR0cl07XG4gICAgICAgICAgaW5zdGFuY2UuY2hhbmdlZChhdHRyLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UuaXNOZXdSZWNvcmQgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKG9wdGlvbnMyLmhvb2tzKSB7XG4gICAgICAgIGF3YWl0IG1vZGVsLnJ1bkhvb2tzKFwiYWZ0ZXJCdWxrQ3JlYXRlXCIsIGluc3RhbmNlczIsIG9wdGlvbnMyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnN0YW5jZXMyO1xuICAgIH07XG4gICAgcmV0dXJuIGF3YWl0IHJlY3Vyc2l2ZUJ1bGtDcmVhdGUoaW5zdGFuY2VzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgdHJ1bmNhdGUob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucykgfHwge307XG4gICAgb3B0aW9ucy50cnVuY2F0ZSA9IHRydWU7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGVzdHJveShvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzdHJveShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiA9PT0gdm9pZCAwICYmIHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzLmdldChcInRyYW5zYWN0aW9uXCIpO1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbiA9IHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2luamVjdFNjb3BlKG9wdGlvbnMpO1xuICAgIGlmICghb3B0aW9ucyB8fCAhKG9wdGlvbnMud2hlcmUgfHwgb3B0aW9ucy50cnVuY2F0ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgd2hlcmUgb3IgdHJ1bmNhdGUgYXR0cmlidXRlIGluIHRoZSBvcHRpb25zIHBhcmFtZXRlciBvZiBtb2RlbC5kZXN0cm95LlwiKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLnRydW5jYXRlICYmICFfLmlzUGxhaW5PYmplY3Qob3B0aW9ucy53aGVyZSkgJiYgIUFycmF5LmlzQXJyYXkob3B0aW9ucy53aGVyZSkgJiYgIShvcHRpb25zLndoZXJlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgcGxhaW4gb2JqZWN0LCBhcnJheSBvciBzZXF1ZWxpemUgbWV0aG9kIGluIHRoZSBvcHRpb25zLndoZXJlIHBhcmFtZXRlciBvZiBtb2RlbC5kZXN0cm95LlwiKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgaG9va3M6IHRydWUsXG4gICAgICBpbmRpdmlkdWFsSG9va3M6IGZhbHNlLFxuICAgICAgZm9yY2U6IGZhbHNlLFxuICAgICAgY2FzY2FkZTogZmFsc2UsXG4gICAgICByZXN0YXJ0SWRlbnRpdHk6IGZhbHNlXG4gICAgfSk7XG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5CVUxLREVMRVRFO1xuICAgIFV0aWxzLm1hcE9wdGlvbkZpZWxkTmFtZXMob3B0aW9ucywgdGhpcyk7XG4gICAgb3B0aW9ucy5tb2RlbCA9IHRoaXM7XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoXCJiZWZvcmVCdWxrRGVzdHJveVwiLCBvcHRpb25zKTtcbiAgICB9XG4gICAgbGV0IGluc3RhbmNlcztcbiAgICBpZiAob3B0aW9ucy5pbmRpdmlkdWFsSG9va3MpIHtcbiAgICAgIGluc3RhbmNlcyA9IGF3YWl0IHRoaXMuZmluZEFsbCh7IHdoZXJlOiBvcHRpb25zLndoZXJlLCB0cmFuc2FjdGlvbjogb3B0aW9ucy50cmFuc2FjdGlvbiwgbG9nZ2luZzogb3B0aW9ucy5sb2dnaW5nLCBiZW5jaG1hcms6IG9wdGlvbnMuYmVuY2htYXJrIH0pO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5zdGFuY2VzLm1hcCgoaW5zdGFuY2UpID0+IHRoaXMucnVuSG9va3MoXCJiZWZvcmVEZXN0cm95XCIsIGluc3RhbmNlLCBvcHRpb25zKSkpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICh0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdCAmJiAhb3B0aW9ucy5mb3JjZSkge1xuICAgICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5CVUxLVVBEQVRFO1xuICAgICAgY29uc3QgYXR0clZhbHVlSGFzaCA9IHt9O1xuICAgICAgY29uc3QgZGVsZXRlZEF0QXR0cmlidXRlID0gdGhpcy5yYXdBdHRyaWJ1dGVzW3RoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0XTtcbiAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5yYXdBdHRyaWJ1dGVzW3RoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0XS5maWVsZDtcbiAgICAgIGNvbnN0IHdoZXJlID0ge1xuICAgICAgICBbZmllbGRdOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVsZXRlZEF0QXR0cmlidXRlLCBcImRlZmF1bHRWYWx1ZVwiKSA/IGRlbGV0ZWRBdEF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUgOiBudWxsXG4gICAgICB9O1xuICAgICAgYXR0clZhbHVlSGFzaFtmaWVsZF0gPSBVdGlscy5ub3codGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuYnVsa1VwZGF0ZSh0aGlzLmdldFRhYmxlTmFtZShvcHRpb25zKSwgYXR0clZhbHVlSGFzaCwgT2JqZWN0LmFzc2lnbih3aGVyZSwgb3B0aW9ucy53aGVyZSksIG9wdGlvbnMsIHRoaXMucmF3QXR0cmlidXRlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuYnVsa0RlbGV0ZSh0aGlzLmdldFRhYmxlTmFtZShvcHRpb25zKSwgb3B0aW9ucy53aGVyZSwgb3B0aW9ucywgdGhpcyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmluZGl2aWR1YWxIb29rcykge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5zdGFuY2VzLm1hcCgoaW5zdGFuY2UpID0+IHRoaXMucnVuSG9va3MoXCJhZnRlckRlc3Ryb3lcIiwgaW5zdGFuY2UsIG9wdGlvbnMpKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKFwiYWZ0ZXJCdWxrRGVzdHJveVwiLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgYXN5bmMgcmVzdG9yZShvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGVsIGlzIG5vdCBwYXJhbm9pZFwiKTtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgaG9va3M6IHRydWUsXG4gICAgICBpbmRpdmlkdWFsSG9va3M6IGZhbHNlXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gPT09IHZvaWQgMCAmJiB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscy5nZXQoXCJ0cmFuc2FjdGlvblwiKTtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24gPSB0O1xuICAgICAgfVxuICAgIH1cbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLlJBVztcbiAgICBvcHRpb25zLm1vZGVsID0gdGhpcztcbiAgICBVdGlscy5tYXBPcHRpb25GaWVsZE5hbWVzKG9wdGlvbnMsIHRoaXMpO1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKFwiYmVmb3JlQnVsa1Jlc3RvcmVcIiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGxldCBpbnN0YW5jZXM7XG4gICAgaWYgKG9wdGlvbnMuaW5kaXZpZHVhbEhvb2tzKSB7XG4gICAgICBpbnN0YW5jZXMgPSBhd2FpdCB0aGlzLmZpbmRBbGwoeyB3aGVyZTogb3B0aW9ucy53aGVyZSwgdHJhbnNhY3Rpb246IG9wdGlvbnMudHJhbnNhY3Rpb24sIGxvZ2dpbmc6IG9wdGlvbnMubG9nZ2luZywgYmVuY2htYXJrOiBvcHRpb25zLmJlbmNobWFyaywgcGFyYW5vaWQ6IGZhbHNlIH0pO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5zdGFuY2VzLm1hcCgoaW5zdGFuY2UpID0+IHRoaXMucnVuSG9va3MoXCJiZWZvcmVSZXN0b3JlXCIsIGluc3RhbmNlLCBvcHRpb25zKSkpO1xuICAgIH1cbiAgICBjb25zdCBhdHRyVmFsdWVIYXNoID0ge307XG4gICAgY29uc3QgZGVsZXRlZEF0Q29sID0gdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQ7XG4gICAgY29uc3QgZGVsZXRlZEF0QXR0cmlidXRlID0gdGhpcy5yYXdBdHRyaWJ1dGVzW2RlbGV0ZWRBdENvbF07XG4gICAgY29uc3QgZGVsZXRlZEF0RGVmYXVsdFZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlbGV0ZWRBdEF0dHJpYnV0ZSwgXCJkZWZhdWx0VmFsdWVcIikgPyBkZWxldGVkQXRBdHRyaWJ1dGUuZGVmYXVsdFZhbHVlIDogbnVsbDtcbiAgICBhdHRyVmFsdWVIYXNoW2RlbGV0ZWRBdEF0dHJpYnV0ZS5maWVsZCB8fCBkZWxldGVkQXRDb2xdID0gZGVsZXRlZEF0RGVmYXVsdFZhbHVlO1xuICAgIG9wdGlvbnMub21pdE51bGwgPSBmYWxzZTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmJ1bGtVcGRhdGUodGhpcy5nZXRUYWJsZU5hbWUob3B0aW9ucyksIGF0dHJWYWx1ZUhhc2gsIG9wdGlvbnMud2hlcmUsIG9wdGlvbnMsIHRoaXMucmF3QXR0cmlidXRlcyk7XG4gICAgaWYgKG9wdGlvbnMuaW5kaXZpZHVhbEhvb2tzKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChpbnN0YW5jZXMubWFwKChpbnN0YW5jZSkgPT4gdGhpcy5ydW5Ib29rcyhcImFmdGVyUmVzdG9yZVwiLCBpbnN0YW5jZSwgb3B0aW9ucykpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoXCJhZnRlckJ1bGtSZXN0b3JlXCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyBhc3luYyB1cGRhdGUodmFsdWVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiA9PT0gdm9pZCAwICYmIHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzLmdldChcInRyYW5zYWN0aW9uXCIpO1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbiA9IHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2luamVjdFNjb3BlKG9wdGlvbnMpO1xuICAgIHRoaXMuX29wdGlvbnNNdXN0Q29udGFpbldoZXJlKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMgPSB0aGlzLl9wYXJhbm9pZENsYXVzZSh0aGlzLCBfLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgIHZhbGlkYXRlOiB0cnVlLFxuICAgICAgaG9va3M6IHRydWUsXG4gICAgICBpbmRpdmlkdWFsSG9va3M6IGZhbHNlLFxuICAgICAgcmV0dXJuaW5nOiBmYWxzZSxcbiAgICAgIGZvcmNlOiBmYWxzZSxcbiAgICAgIHNpZGVFZmZlY3RzOiB0cnVlXG4gICAgfSkpO1xuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuQlVMS1VQREFURTtcbiAgICB2YWx1ZXMgPSBfLm9taXRCeSh2YWx1ZXMsICh2YWx1ZSkgPT4gdmFsdWUgPT09IHZvaWQgMCk7XG4gICAgaWYgKG9wdGlvbnMuZmllbGRzICYmIG9wdGlvbnMuZmllbGRzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbHVlcykpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmZpZWxkcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgZGVsZXRlIHZhbHVlc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRBdEF0dHIgPSB0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdDtcbiAgICAgIG9wdGlvbnMuZmllbGRzID0gXy5pbnRlcnNlY3Rpb24oT2JqZWN0LmtleXModmFsdWVzKSwgT2JqZWN0LmtleXModGhpcy50YWJsZUF0dHJpYnV0ZXMpKTtcbiAgICAgIGlmICh1cGRhdGVkQXRBdHRyICYmICFvcHRpb25zLmZpZWxkcy5pbmNsdWRlcyh1cGRhdGVkQXRBdHRyKSkge1xuICAgICAgICBvcHRpb25zLmZpZWxkcy5wdXNoKHVwZGF0ZWRBdEF0dHIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQgJiYgIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICB2YWx1ZXNbdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXRdID0gdGhpcy5fZ2V0RGVmYXVsdFRpbWVzdGFtcCh0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdCkgfHwgVXRpbHMubm93KHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgfVxuICAgIG9wdGlvbnMubW9kZWwgPSB0aGlzO1xuICAgIGxldCB2YWx1ZXNVc2U7XG4gICAgaWYgKG9wdGlvbnMudmFsaWRhdGUpIHtcbiAgICAgIGNvbnN0IGJ1aWxkID0gdGhpcy5idWlsZCh2YWx1ZXMpO1xuICAgICAgYnVpbGQuc2V0KHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0LCB2YWx1ZXNbdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXRdLCB7IHJhdzogdHJ1ZSB9KTtcbiAgICAgIGlmIChvcHRpb25zLnNpZGVFZmZlY3RzKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odmFsdWVzLCBfLnBpY2soYnVpbGQuZ2V0KCksIGJ1aWxkLmNoYW5nZWQoKSkpO1xuICAgICAgICBvcHRpb25zLmZpZWxkcyA9IF8udW5pb24ob3B0aW9ucy5maWVsZHMsIE9iamVjdC5rZXlzKHZhbHVlcykpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5za2lwID0gXy5kaWZmZXJlbmNlKE9iamVjdC5rZXlzKHRoaXMucmF3QXR0cmlidXRlcyksIE9iamVjdC5rZXlzKHZhbHVlcykpO1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGF3YWl0IGJ1aWxkLnZhbGlkYXRlKG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5za2lwID0gdm9pZCAwO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMgJiYgYXR0cmlidXRlcy5kYXRhVmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcyA9IF8ucGljayhhdHRyaWJ1dGVzLmRhdGFWYWx1ZXMsIE9iamVjdC5rZXlzKHZhbHVlcykpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gdmFsdWVzO1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcyhcImJlZm9yZUJ1bGtVcGRhdGVcIiwgb3B0aW9ucyk7XG4gICAgICB2YWx1ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXM7XG4gICAgICBkZWxldGUgb3B0aW9ucy5hdHRyaWJ1dGVzO1xuICAgIH1cbiAgICB2YWx1ZXNVc2UgPSB2YWx1ZXM7XG4gICAgbGV0IGluc3RhbmNlcztcbiAgICBsZXQgdXBkYXRlRG9uZVJvd0J5Um93ID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMuaW5kaXZpZHVhbEhvb2tzKSB7XG4gICAgICBpbnN0YW5jZXMgPSBhd2FpdCB0aGlzLmZpbmRBbGwoe1xuICAgICAgICB3aGVyZTogb3B0aW9ucy53aGVyZSxcbiAgICAgICAgdHJhbnNhY3Rpb246IG9wdGlvbnMudHJhbnNhY3Rpb24sXG4gICAgICAgIGxvZ2dpbmc6IG9wdGlvbnMubG9nZ2luZyxcbiAgICAgICAgYmVuY2htYXJrOiBvcHRpb25zLmJlbmNobWFyayxcbiAgICAgICAgcGFyYW5vaWQ6IG9wdGlvbnMucGFyYW5vaWRcbiAgICAgIH0pO1xuICAgICAgaWYgKGluc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGNoYW5nZWRWYWx1ZXM7XG4gICAgICAgIGxldCBkaWZmZXJlbnQgPSBmYWxzZTtcbiAgICAgICAgaW5zdGFuY2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoaW5zdGFuY2VzLm1hcChhc3luYyAoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGluc3RhbmNlLmRhdGFWYWx1ZXMsIHZhbHVlcyk7XG4gICAgICAgICAgXy5mb3JJbih2YWx1ZXNVc2UsIChuZXdWYWx1ZSwgYXR0cikgPT4ge1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBpbnN0YW5jZS5fcHJldmlvdXNEYXRhVmFsdWVzW2F0dHJdKSB7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnNldERhdGFWYWx1ZShhdHRyLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcyhcImJlZm9yZVVwZGF0ZVwiLCBpbnN0YW5jZSwgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKCFkaWZmZXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRoaXNDaGFuZ2VkVmFsdWVzID0ge307XG4gICAgICAgICAgICBfLmZvckluKGluc3RhbmNlLmRhdGFWYWx1ZXMsIChuZXdWYWx1ZSwgYXR0cikgPT4ge1xuICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IGluc3RhbmNlLl9wcmV2aW91c0RhdGFWYWx1ZXNbYXR0cl0pIHtcbiAgICAgICAgICAgICAgICB0aGlzQ2hhbmdlZFZhbHVlc1thdHRyXSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghY2hhbmdlZFZhbHVlcykge1xuICAgICAgICAgICAgICBjaGFuZ2VkVmFsdWVzID0gdGhpc0NoYW5nZWRWYWx1ZXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkaWZmZXJlbnQgPSAhXy5pc0VxdWFsKGNoYW5nZWRWYWx1ZXMsIHRoaXNDaGFuZ2VkVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9KSk7XG4gICAgICAgIGlmICghZGlmZmVyZW50KSB7XG4gICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGNoYW5nZWRWYWx1ZXMpO1xuICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFsdWVzVXNlID0gY2hhbmdlZFZhbHVlcztcbiAgICAgICAgICAgIG9wdGlvbnMuZmllbGRzID0gXy51bmlvbihvcHRpb25zLmZpZWxkcywga2V5cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc3RhbmNlcyA9IGF3YWl0IFByb21pc2UuYWxsKGluc3RhbmNlcy5tYXAoYXN5bmMgKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRpdmlkdWFsT3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICAgICAgICAgIGhvb2tzOiBmYWxzZSxcbiAgICAgICAgICAgICAgdmFsaWRhdGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlbGV0ZSBpbmRpdmlkdWFsT3B0aW9ucy5pbmRpdmlkdWFsSG9va3M7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2Uuc2F2ZShpbmRpdmlkdWFsT3B0aW9ucyk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHVwZGF0ZURvbmVSb3dCeVJvdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAodXBkYXRlRG9uZVJvd0J5Um93KSB7XG4gICAgICByZXN1bHQgPSBbaW5zdGFuY2VzLmxlbmd0aCwgaW5zdGFuY2VzXTtcbiAgICB9IGVsc2UgaWYgKF8uaXNFbXB0eSh2YWx1ZXNVc2UpIHx8IE9iamVjdC5rZXlzKHZhbHVlc1VzZSkubGVuZ3RoID09PSAxICYmIHZhbHVlc1VzZVt0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdF0pIHtcbiAgICAgIHJlc3VsdCA9IFswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzVXNlID0gVXRpbHMubWFwVmFsdWVGaWVsZE5hbWVzKHZhbHVlc1VzZSwgb3B0aW9ucy5maWVsZHMsIHRoaXMpO1xuICAgICAgb3B0aW9ucyA9IFV0aWxzLm1hcE9wdGlvbkZpZWxkTmFtZXMob3B0aW9ucywgdGhpcyk7XG4gICAgICBvcHRpb25zLmhhc1RyaWdnZXIgPSB0aGlzLm9wdGlvbnMgPyB0aGlzLm9wdGlvbnMuaGFzVHJpZ2dlciA6IGZhbHNlO1xuICAgICAgY29uc3QgYWZmZWN0ZWRSb3dzID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5idWxrVXBkYXRlKHRoaXMuZ2V0VGFibGVOYW1lKG9wdGlvbnMpLCB2YWx1ZXNVc2UsIG9wdGlvbnMud2hlcmUsIG9wdGlvbnMsIHRoaXMudGFibGVBdHRyaWJ1dGVzKTtcbiAgICAgIGlmIChvcHRpb25zLnJldHVybmluZykge1xuICAgICAgICByZXN1bHQgPSBbYWZmZWN0ZWRSb3dzLmxlbmd0aCwgYWZmZWN0ZWRSb3dzXTtcbiAgICAgICAgaW5zdGFuY2VzID0gYWZmZWN0ZWRSb3dzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gW2FmZmVjdGVkUm93c107XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmluZGl2aWR1YWxIb29rcykge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5zdGFuY2VzLm1hcCgoaW5zdGFuY2UpID0+IHRoaXMucnVuSG9va3MoXCJhZnRlclVwZGF0ZVwiLCBpbnN0YW5jZSwgb3B0aW9ucykpKTtcbiAgICAgIHJlc3VsdFsxXSA9IGluc3RhbmNlcztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IHZhbHVlcztcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoXCJhZnRlckJ1bGtVcGRhdGVcIiwgb3B0aW9ucyk7XG4gICAgICBkZWxldGUgb3B0aW9ucy5hdHRyaWJ1dGVzO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNjcmliZShzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5kZXNjcmliZVRhYmxlKHRoaXMudGFibGVOYW1lLCBfX3NwcmVhZFZhbHVlcyh7IHNjaGVtYTogc2NoZW1hIHx8IHRoaXMuX3NjaGVtYSB8fCB2b2lkIDAgfSwgb3B0aW9ucykpO1xuICB9XG4gIHN0YXRpYyBfZ2V0RGVmYXVsdFRpbWVzdGFtcChhdHRyKSB7XG4gICAgaWYgKCEhdGhpcy5yYXdBdHRyaWJ1dGVzW2F0dHJdICYmICEhdGhpcy5yYXdBdHRyaWJ1dGVzW2F0dHJdLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuIFV0aWxzLnRvRGVmYXVsdFZhbHVlKHRoaXMucmF3QXR0cmlidXRlc1thdHRyXS5kZWZhdWx0VmFsdWUsIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgc3RhdGljIF9leHBhbmRBdHRyaWJ1dGVzKG9wdGlvbnMpIHtcbiAgICBpZiAoIV8uaXNQbGFpbk9iamVjdChvcHRpb25zLmF0dHJpYnV0ZXMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXModGhpcy5yYXdBdHRyaWJ1dGVzKTtcbiAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzLmV4Y2x1ZGUpIHtcbiAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmZpbHRlcigoZWxlbSkgPT4gIW9wdGlvbnMuYXR0cmlidXRlcy5leGNsdWRlLmluY2x1ZGVzKGVsZW0pKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcy5pbmNsdWRlKSB7XG4gICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5jb25jYXQob3B0aW9ucy5hdHRyaWJ1dGVzLmluY2x1ZGUpO1xuICAgIH1cbiAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICB9XG4gIHN0YXRpYyBfaW5qZWN0U2NvcGUob3B0aW9ucykge1xuICAgIGNvbnN0IHNjb3BlID0gVXRpbHMuY2xvbmVEZWVwKHRoaXMuX3Njb3BlKTtcbiAgICB0aGlzLl9kZWZhdWx0c09wdGlvbnMob3B0aW9ucywgc2NvcGUpO1xuICB9XG4gIHN0YXRpYyBbU3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpXSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG4gIHN0YXRpYyBoYXNBbGlhcyhhbGlhcykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hc3NvY2lhdGlvbnMsIGFsaWFzKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgaW5jcmVtZW50KGZpZWxkcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiKVxuICAgICAgZmllbGRzID0gW2ZpZWxkc107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRzKSkge1xuICAgICAgZmllbGRzID0gZmllbGRzLm1hcCgoZikgPT4ge1xuICAgICAgICBpZiAodGhpcy5yYXdBdHRyaWJ1dGVzW2ZdICYmIHRoaXMucmF3QXR0cmlidXRlc1tmXS5maWVsZCAmJiB0aGlzLnJhd0F0dHJpYnV0ZXNbZl0uZmllbGQgIT09IGYpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yYXdBdHRyaWJ1dGVzW2ZdLmZpZWxkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChmaWVsZHMgJiYgdHlwZW9mIGZpZWxkcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZmllbGRzID0gT2JqZWN0LmtleXMoZmllbGRzKS5yZWR1Y2UoKHJhd0ZpZWxkcywgZikgPT4ge1xuICAgICAgICBpZiAodGhpcy5yYXdBdHRyaWJ1dGVzW2ZdICYmIHRoaXMucmF3QXR0cmlidXRlc1tmXS5maWVsZCAmJiB0aGlzLnJhd0F0dHJpYnV0ZXNbZl0uZmllbGQgIT09IGYpIHtcbiAgICAgICAgICByYXdGaWVsZHNbdGhpcy5yYXdBdHRyaWJ1dGVzW2ZdLmZpZWxkXSA9IGZpZWxkc1tmXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByYXdGaWVsZHNbZl0gPSBmaWVsZHNbZl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhd0ZpZWxkcztcbiAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgdGhpcy5faW5qZWN0U2NvcGUob3B0aW9ucyk7XG4gICAgdGhpcy5fb3B0aW9uc011c3RDb250YWluV2hlcmUob3B0aW9ucyk7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBieTogMSxcbiAgICAgIHdoZXJlOiB7fSxcbiAgICAgIGluY3JlbWVudDogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IGlzU3VidHJhY3Rpb24gPSAhb3B0aW9ucy5pbmNyZW1lbnQ7XG4gICAgVXRpbHMubWFwT3B0aW9uRmllbGROYW1lcyhvcHRpb25zLCB0aGlzKTtcbiAgICBjb25zdCB3aGVyZSA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zLndoZXJlKTtcbiAgICBsZXQgaW5jcmVtZW50QW1vdW50c0J5RmllbGQgPSB7fTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZHMpKSB7XG4gICAgICBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgaW5jcmVtZW50QW1vdW50c0J5RmllbGRbZmllbGRdID0gb3B0aW9ucy5ieTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5jcmVtZW50QW1vdW50c0J5RmllbGQgPSBmaWVsZHM7XG4gICAgfVxuICAgIGlmICh0aGlzLl92ZXJzaW9uQXR0cmlidXRlKSB7XG4gICAgICBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZFt0aGlzLl92ZXJzaW9uQXR0cmlidXRlXSA9IGlzU3VidHJhY3Rpb24gPyAtMSA6IDE7XG4gICAgfVxuICAgIGNvbnN0IGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkID0ge307XG4gICAgY29uc3QgdXBkYXRlZEF0QXR0ciA9IHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0O1xuICAgIGlmICghb3B0aW9ucy5zaWxlbnQgJiYgdXBkYXRlZEF0QXR0ciAmJiAhaW5jcmVtZW50QW1vdW50c0J5RmllbGRbdXBkYXRlZEF0QXR0cl0pIHtcbiAgICAgIGNvbnN0IGF0dHJOYW1lID0gdGhpcy5yYXdBdHRyaWJ1dGVzW3VwZGF0ZWRBdEF0dHJdLmZpZWxkIHx8IHVwZGF0ZWRBdEF0dHI7XG4gICAgICBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZFthdHRyTmFtZV0gPSB0aGlzLl9nZXREZWZhdWx0VGltZXN0YW1wKHVwZGF0ZWRBdEF0dHIpIHx8IFV0aWxzLm5vdyh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuICAgIH1cbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0aGlzLmdldFRhYmxlTmFtZShvcHRpb25zKTtcbiAgICBsZXQgYWZmZWN0ZWRSb3dzO1xuICAgIGlmIChpc1N1YnRyYWN0aW9uKSB7XG4gICAgICBhZmZlY3RlZFJvd3MgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmRlY3JlbWVudCh0aGlzLCB0YWJsZU5hbWUsIHdoZXJlLCBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCwgZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZmZlY3RlZFJvd3MgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmluY3JlbWVudCh0aGlzLCB0YWJsZU5hbWUsIHdoZXJlLCBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCwgZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgIHJldHVybiBbYWZmZWN0ZWRSb3dzLCBhZmZlY3RlZFJvd3MubGVuZ3RoXTtcbiAgICB9XG4gICAgcmV0dXJuIFthZmZlY3RlZFJvd3NdO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZWNyZW1lbnQoZmllbGRzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5jcmVtZW50KGZpZWxkcywgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBieTogMVxuICAgIH0sIG9wdGlvbnMpLCB7XG4gICAgICBpbmNyZW1lbnQ6IGZhbHNlXG4gICAgfSkpO1xuICB9XG4gIHN0YXRpYyBfb3B0aW9uc011c3RDb250YWluV2hlcmUob3B0aW9ucykge1xuICAgIGFzc2VydChvcHRpb25zICYmIG9wdGlvbnMud2hlcmUsIFwiTWlzc2luZyB3aGVyZSBhdHRyaWJ1dGUgaW4gdGhlIG9wdGlvbnMgcGFyYW1ldGVyXCIpO1xuICAgIGFzc2VydChfLmlzUGxhaW5PYmplY3Qob3B0aW9ucy53aGVyZSkgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zLndoZXJlKSB8fCBvcHRpb25zLndoZXJlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kLCBcIkV4cGVjdGVkIHBsYWluIG9iamVjdCwgYXJyYXkgb3Igc2VxdWVsaXplIG1ldGhvZCBpbiB0aGUgb3B0aW9ucy53aGVyZSBwYXJhbWV0ZXJcIik7XG4gIH1cbiAgd2hlcmUoY2hlY2tWZXJzaW9uKSB7XG4gICAgY29uc3Qgd2hlcmUgPSB0aGlzLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGVzLnJlZHVjZSgocmVzdWx0LCBhdHRyaWJ1dGUpID0+IHtcbiAgICAgIHJlc3VsdFthdHRyaWJ1dGVdID0gdGhpcy5nZXQoYXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pO1xuICAgIGlmIChfLnNpemUod2hlcmUpID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5vcHRpb25zLndoZXJlQ29sbGVjdGlvbjtcbiAgICB9XG4gICAgY29uc3QgdmVyc2lvbkF0dHIgPSB0aGlzLmNvbnN0cnVjdG9yLl92ZXJzaW9uQXR0cmlidXRlO1xuICAgIGlmIChjaGVja1ZlcnNpb24gJiYgdmVyc2lvbkF0dHIpIHtcbiAgICAgIHdoZXJlW3ZlcnNpb25BdHRyXSA9IHRoaXMuZ2V0KHZlcnNpb25BdHRyLCB7IHJhdzogdHJ1ZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFV0aWxzLm1hcFdoZXJlRmllbGROYW1lcyh3aGVyZSwgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbb2JqZWN0IFNlcXVlbGl6ZUluc3RhbmNlOiR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfV1gO1xuICB9XG4gIGdldERhdGFWYWx1ZShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhVmFsdWVzW2tleV07XG4gIH1cbiAgc2V0RGF0YVZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBvcmlnaW5hbFZhbHVlID0gdGhpcy5fcHJldmlvdXNEYXRhVmFsdWVzW2tleV07XG4gICAgaWYgKCFfLmlzRXF1YWwodmFsdWUsIG9yaWdpbmFsVmFsdWUpKSB7XG4gICAgICB0aGlzLmNoYW5nZWQoa2V5LCB0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5kYXRhVmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgfVxuICBnZXQoa2V5LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCAmJiB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBvcHRpb25zID0ga2V5O1xuICAgICAga2V5ID0gdm9pZCAwO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX2N1c3RvbUdldHRlcnMsIGtleSkgJiYgIW9wdGlvbnMucmF3KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXN0b21HZXR0ZXJzW2tleV0uY2FsbCh0aGlzLCBrZXksIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMucGxhaW4gJiYgdGhpcy5fb3B0aW9ucy5pbmNsdWRlICYmIHRoaXMuX29wdGlvbnMuaW5jbHVkZU5hbWVzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5kYXRhVmFsdWVzW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVZhbHVlc1trZXldLm1hcCgoaW5zdGFuY2UpID0+IGluc3RhbmNlLmdldChvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGF0YVZhbHVlc1trZXldIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhVmFsdWVzW2tleV0uZ2V0KG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFWYWx1ZXNba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmRhdGFWYWx1ZXNba2V5XTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2hhc0N1c3RvbUdldHRlcnMgfHwgb3B0aW9ucy5wbGFpbiAmJiB0aGlzLl9vcHRpb25zLmluY2x1ZGUgfHwgb3B0aW9ucy5jbG9uZSkge1xuICAgICAgY29uc3QgdmFsdWVzID0ge307XG4gICAgICBsZXQgX2tleTtcbiAgICAgIGlmICh0aGlzLl9oYXNDdXN0b21HZXR0ZXJzKSB7XG4gICAgICAgIGZvciAoX2tleSBpbiB0aGlzLl9jdXN0b21HZXR0ZXJzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuYXR0cmlidXRlcyAmJiAhdGhpcy5fb3B0aW9ucy5hdHRyaWJ1dGVzLmluY2x1ZGVzKF9rZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9jdXN0b21HZXR0ZXJzLCBfa2V5KSkge1xuICAgICAgICAgICAgdmFsdWVzW19rZXldID0gdGhpcy5nZXQoX2tleSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKF9rZXkgaW4gdGhpcy5kYXRhVmFsdWVzKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlcywgX2tleSkgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuZGF0YVZhbHVlcywgX2tleSkpIHtcbiAgICAgICAgICB2YWx1ZXNbX2tleV0gPSB0aGlzLmdldChfa2V5LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGF0YVZhbHVlcztcbiAgfVxuICBzZXQoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGxldCB2YWx1ZXM7XG4gICAgbGV0IG9yaWdpbmFsVmFsdWU7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICB2YWx1ZXMgPSBrZXk7XG4gICAgICBvcHRpb25zID0gdmFsdWUgfHwge307XG4gICAgICBpZiAob3B0aW9ucy5yZXNldCkge1xuICAgICAgICB0aGlzLmRhdGFWYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkyIGluIHZhbHVlcykge1xuICAgICAgICAgIHRoaXMuY2hhbmdlZChrZXkyLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnJhdyAmJiAhKHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5pbmNsdWRlKSAmJiAhKG9wdGlvbnMgJiYgb3B0aW9ucy5hdHRyaWJ1dGVzKSAmJiAhdGhpcy5jb25zdHJ1Y3Rvci5faGFzRGF0ZUF0dHJpYnV0ZXMgJiYgIXRoaXMuY29uc3RydWN0b3IuX2hhc0Jvb2xlYW5BdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmRhdGFWYWx1ZXMpLmxlbmd0aCkge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5kYXRhVmFsdWVzLCB2YWx1ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGF0YVZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcmV2aW91c0RhdGFWYWx1ZXMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5kYXRhVmFsdWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBjb25zdCBzZXRLZXlzID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBkYXRhKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZXNba10gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuc2V0KGssIHZhbHVlc1trXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBzZXRLZXlzKG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gICAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuX2hhc1ZpcnR1YWxBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBzZXRLZXlzKHRoaXMuY29uc3RydWN0b3IuX3ZpcnR1YWxBdHRyaWJ1dGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuaW5jbHVkZU5hbWVzKSB7XG4gICAgICAgICAgICBzZXRLZXlzKHRoaXMuX29wdGlvbnMuaW5jbHVkZU5hbWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkyIGluIHZhbHVlcykge1xuICAgICAgICAgICAgdGhpcy5zZXQoa2V5MiwgdmFsdWVzW2tleTJdLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucmF3KSB7XG4gICAgICAgICAgdGhpcy5fcHJldmlvdXNEYXRhVmFsdWVzID0gX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuZGF0YVZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMpXG4gICAgICBvcHRpb25zID0ge307XG4gICAgaWYgKCFvcHRpb25zLnJhdykge1xuICAgICAgb3JpZ2luYWxWYWx1ZSA9IHRoaXMuZGF0YVZhbHVlc1trZXldO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMucmF3ICYmIHRoaXMuX2N1c3RvbVNldHRlcnNba2V5XSkge1xuICAgICAgdGhpcy5fY3VzdG9tU2V0dGVyc1trZXldLmNhbGwodGhpcywgdmFsdWUsIGtleSk7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMuZGF0YVZhbHVlc1trZXldO1xuICAgICAgaWYgKCFfLmlzRXF1YWwobmV3VmFsdWUsIG9yaWdpbmFsVmFsdWUpKSB7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzRGF0YVZhbHVlc1trZXldID0gb3JpZ2luYWxWYWx1ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKGtleSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMuaW5jbHVkZSAmJiB0aGlzLl9vcHRpb25zLmluY2x1ZGVOYW1lcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIHRoaXMuX3NldEluY2x1ZGUoa2V5LCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKCFvcHRpb25zLnJhdykge1xuICAgICAgICBpZiAoIXRoaXMuX2lzQXR0cmlidXRlKGtleSkpIHtcbiAgICAgICAgICBpZiAoa2V5LmluY2x1ZGVzKFwiLlwiKSAmJiB0aGlzLmNvbnN0cnVjdG9yLl9qc29uQXR0cmlidXRlcy5oYXMoa2V5LnNwbGl0KFwiLlwiKVswXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzTmVzdGVkVmFsdWUgPSBEb3R0aWUuZ2V0KHRoaXMuZGF0YVZhbHVlcywga2V5KTtcbiAgICAgICAgICAgIGlmICghXy5pc0VxdWFsKHByZXZpb3VzTmVzdGVkVmFsdWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgICBEb3R0aWUuc2V0KHRoaXMuZGF0YVZhbHVlcywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgIHRoaXMuY2hhbmdlZChrZXkuc3BsaXQoXCIuXCIpWzBdLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuX2hhc1ByaW1hcnlLZXlzICYmIG9yaWdpbmFsVmFsdWUgJiYgdGhpcy5jb25zdHJ1Y3Rvci5faXNQcmltYXJ5S2V5KGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNOZXdSZWNvcmQgJiYgdGhpcy5jb25zdHJ1Y3Rvci5faGFzUmVhZE9ubHlBdHRyaWJ1dGVzICYmIHRoaXMuY29uc3RydWN0b3IuX3JlYWRPbmx5QXR0cmlidXRlcy5oYXMoa2V5KSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29uc3RydWN0b3IuX2RhdGFUeXBlU2FuaXRpemVycywga2V5KSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuY29uc3RydWN0b3IuX2RhdGFUeXBlU2FuaXRpemVyc1trZXldLmNhbGwodGhpcywgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKCFvcHRpb25zLnJhdyAmJiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QgfHwgISh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkgJiYgdGhpcy5jb25zdHJ1Y3Rvci5fZGF0YVR5cGVDaGFuZ2VzW2tleV0gJiYgdGhpcy5jb25zdHJ1Y3Rvci5fZGF0YVR5cGVDaGFuZ2VzW2tleV0uY2FsbCh0aGlzLCB2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgb3B0aW9ucykgfHwgIXRoaXMuY29uc3RydWN0b3IuX2RhdGFUeXBlQ2hhbmdlc1trZXldICYmICFfLmlzRXF1YWwodmFsdWUsIG9yaWdpbmFsVmFsdWUpKSkge1xuICAgICAgICB0aGlzLl9wcmV2aW91c0RhdGFWYWx1ZXNba2V5XSA9IG9yaWdpbmFsVmFsdWU7XG4gICAgICAgIHRoaXMuY2hhbmdlZChrZXksIHRydWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5kYXRhVmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0QXR0cmlidXRlcyh1cGRhdGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KHVwZGF0ZXMpO1xuICB9XG4gIGNoYW5nZWQoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKHRoaXMuX2NoYW5nZWQuc2l6ZSA+IDApIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fY2hhbmdlZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fY2hhbmdlZC5hZGQoa2V5KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl9jaGFuZ2VkLmRlbGV0ZShrZXkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jaGFuZ2VkLmhhcyhrZXkpO1xuICB9XG4gIHByZXZpb3VzKGtleSkge1xuICAgIGlmIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0RhdGFWYWx1ZXNba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIF8ucGlja0J5KHRoaXMuX3ByZXZpb3VzRGF0YVZhbHVlcywgKHZhbHVlLCBrZXkyKSA9PiB0aGlzLmNoYW5nZWQoa2V5MikpO1xuICB9XG4gIF9zZXRJbmNsdWRlKGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgIGlmICh2YWx1ZVswXSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLm1hcCgoaW5zdGFuY2UpID0+IGluc3RhbmNlLmRhdGFWYWx1ZXMpO1xuICAgIH1cbiAgICBjb25zdCBpbmNsdWRlID0gdGhpcy5fb3B0aW9ucy5pbmNsdWRlTWFwW2tleV07XG4gICAgY29uc3QgYXNzb2NpYXRpb24gPSBpbmNsdWRlLmFzc29jaWF0aW9uO1xuICAgIGNvbnN0IGFjY2Vzc29yID0ga2V5O1xuICAgIGNvbnN0IHByaW1hcnlLZXlBdHRyaWJ1dGUgPSBpbmNsdWRlLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgY29uc3QgY2hpbGRPcHRpb25zID0ge1xuICAgICAgaXNOZXdSZWNvcmQ6IHRoaXMuaXNOZXdSZWNvcmQsXG4gICAgICBpbmNsdWRlOiBpbmNsdWRlLmluY2x1ZGUsXG4gICAgICBpbmNsdWRlTmFtZXM6IGluY2x1ZGUuaW5jbHVkZU5hbWVzLFxuICAgICAgaW5jbHVkZU1hcDogaW5jbHVkZS5pbmNsdWRlTWFwLFxuICAgICAgaW5jbHVkZVZhbGlkYXRlZDogdHJ1ZSxcbiAgICAgIHJhdzogb3B0aW9ucy5yYXcsXG4gICAgICBhdHRyaWJ1dGVzOiBpbmNsdWRlLm9yaWdpbmFsQXR0cmlidXRlc1xuICAgIH07XG4gICAgbGV0IGlzRW1wdHk7XG4gICAgaWYgKGluY2x1ZGUub3JpZ2luYWxBdHRyaWJ1dGVzID09PSB2b2lkIDAgfHwgaW5jbHVkZS5vcmlnaW5hbEF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICBpZiAoYXNzb2NpYXRpb24uaXNTaW5nbGVBc3NvY2lhdGlvbikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlzRW1wdHkgPSB2YWx1ZSAmJiB2YWx1ZVtwcmltYXJ5S2V5QXR0cmlidXRlXSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gbnVsbDtcbiAgICAgICAgdGhpc1thY2Nlc3Nvcl0gPSB0aGlzLmRhdGFWYWx1ZXNbYWNjZXNzb3JdID0gaXNFbXB0eSA/IG51bGwgOiBpbmNsdWRlLm1vZGVsLmJ1aWxkKHZhbHVlLCBjaGlsZE9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNFbXB0eSA9IHZhbHVlWzBdICYmIHZhbHVlWzBdW3ByaW1hcnlLZXlBdHRyaWJ1dGVdID09PSBudWxsO1xuICAgICAgICB0aGlzW2FjY2Vzc29yXSA9IHRoaXMuZGF0YVZhbHVlc1thY2Nlc3Nvcl0gPSBpc0VtcHR5ID8gW10gOiBpbmNsdWRlLm1vZGVsLmJ1bGtCdWlsZCh2YWx1ZSwgY2hpbGRPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgc2F2ZShvcHRpb25zKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2Vjb25kIGFyZ3VtZW50IHdhcyByZW1vdmVkIGluIGZhdm9yIG9mIHRoZSBvcHRpb25zIG9iamVjdC5cIik7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gPT09IHZvaWQgMCAmJiB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscy5nZXQoXCJ0cmFuc2FjdGlvblwiKTtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24gPSB0O1xuICAgICAgfVxuICAgIH1cbiAgICBvcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICBob29rczogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKCFvcHRpb25zLmZpZWxkcykge1xuICAgICAgaWYgKHRoaXMuaXNOZXdSZWNvcmQpIHtcbiAgICAgICAgb3B0aW9ucy5maWVsZHMgPSBPYmplY3Qua2V5cyh0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5maWVsZHMgPSBfLmludGVyc2VjdGlvbih0aGlzLmNoYW5nZWQoKSwgT2JqZWN0LmtleXModGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzKSk7XG4gICAgICB9XG4gICAgICBvcHRpb25zLmRlZmF1bHRGaWVsZHMgPSBvcHRpb25zLmZpZWxkcztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmV0dXJuaW5nID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChvcHRpb25zLmFzc29jaWF0aW9uKSB7XG4gICAgICAgIG9wdGlvbnMucmV0dXJuaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNOZXdSZWNvcmQpIHtcbiAgICAgICAgb3B0aW9ucy5yZXR1cm5pbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcmltYXJ5S2V5TmFtZSA9IHRoaXMuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZTtcbiAgICBjb25zdCBwcmltYXJ5S2V5QXR0cmlidXRlID0gcHJpbWFyeUtleU5hbWUgJiYgdGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzW3ByaW1hcnlLZXlOYW1lXTtcbiAgICBjb25zdCBjcmVhdGVkQXRBdHRyID0gdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXQ7XG4gICAgY29uc3QgdmVyc2lvbkF0dHIgPSB0aGlzLmNvbnN0cnVjdG9yLl92ZXJzaW9uQXR0cmlidXRlO1xuICAgIGNvbnN0IGhvb2sgPSB0aGlzLmlzTmV3UmVjb3JkID8gXCJDcmVhdGVcIiA6IFwiVXBkYXRlXCI7XG4gICAgY29uc3Qgd2FzTmV3UmVjb3JkID0gdGhpcy5pc05ld1JlY29yZDtcbiAgICBjb25zdCBub3cgPSBVdGlscy5ub3codGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcbiAgICBsZXQgdXBkYXRlZEF0QXR0ciA9IHRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0O1xuICAgIGlmICh1cGRhdGVkQXRBdHRyICYmIG9wdGlvbnMuZmllbGRzLmxlbmd0aCA+IDAgJiYgIW9wdGlvbnMuZmllbGRzLmluY2x1ZGVzKHVwZGF0ZWRBdEF0dHIpKSB7XG4gICAgICBvcHRpb25zLmZpZWxkcy5wdXNoKHVwZGF0ZWRBdEF0dHIpO1xuICAgIH1cbiAgICBpZiAodmVyc2lvbkF0dHIgJiYgb3B0aW9ucy5maWVsZHMubGVuZ3RoID4gMCAmJiAhb3B0aW9ucy5maWVsZHMuaW5jbHVkZXModmVyc2lvbkF0dHIpKSB7XG4gICAgICBvcHRpb25zLmZpZWxkcy5wdXNoKHZlcnNpb25BdHRyKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc2lsZW50ID09PSB0cnVlICYmICEodGhpcy5pc05ld1JlY29yZCAmJiB0aGlzLmdldCh1cGRhdGVkQXRBdHRyLCB7IHJhdzogdHJ1ZSB9KSkpIHtcbiAgICAgIF8ucmVtb3ZlKG9wdGlvbnMuZmllbGRzLCAodmFsKSA9PiB2YWwgPT09IHVwZGF0ZWRBdEF0dHIpO1xuICAgICAgdXBkYXRlZEF0QXR0ciA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc05ld1JlY29yZCA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKGNyZWF0ZWRBdEF0dHIgJiYgIW9wdGlvbnMuZmllbGRzLmluY2x1ZGVzKGNyZWF0ZWRBdEF0dHIpKSB7XG4gICAgICAgIG9wdGlvbnMuZmllbGRzLnB1c2goY3JlYXRlZEF0QXR0cik7XG4gICAgICB9XG4gICAgICBpZiAocHJpbWFyeUtleUF0dHJpYnV0ZSAmJiBwcmltYXJ5S2V5QXR0cmlidXRlLmRlZmF1bHRWYWx1ZSAmJiAhb3B0aW9ucy5maWVsZHMuaW5jbHVkZXMocHJpbWFyeUtleU5hbWUpKSB7XG4gICAgICAgIG9wdGlvbnMuZmllbGRzLnVuc2hpZnQocHJpbWFyeUtleU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5pc05ld1JlY29yZCA9PT0gZmFsc2UpIHtcbiAgICAgIGlmIChwcmltYXJ5S2V5TmFtZSAmJiB0aGlzLmdldChwcmltYXJ5S2V5TmFtZSwgeyByYXc6IHRydWUgfSkgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgYXR0ZW1wdGVkIHRvIHNhdmUgYW4gaW5zdGFuY2Ugd2l0aCBubyBwcmltYXJ5IGtleSwgdGhpcyBpcyBub3QgYWxsb3dlZCBzaW5jZSBpdCB3b3VsZCByZXN1bHQgaW4gYSBnbG9iYWwgdXBkYXRlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXBkYXRlZEF0QXR0ciAmJiAhb3B0aW9ucy5zaWxlbnQgJiYgb3B0aW9ucy5maWVsZHMuaW5jbHVkZXModXBkYXRlZEF0QXR0cikpIHtcbiAgICAgIHRoaXMuZGF0YVZhbHVlc1t1cGRhdGVkQXRBdHRyXSA9IHRoaXMuY29uc3RydWN0b3IuX2dldERlZmF1bHRUaW1lc3RhbXAodXBkYXRlZEF0QXR0cikgfHwgbm93O1xuICAgIH1cbiAgICBpZiAodGhpcy5pc05ld1JlY29yZCAmJiBjcmVhdGVkQXRBdHRyICYmICF0aGlzLmRhdGFWYWx1ZXNbY3JlYXRlZEF0QXR0cl0pIHtcbiAgICAgIHRoaXMuZGF0YVZhbHVlc1tjcmVhdGVkQXRBdHRyXSA9IHRoaXMuY29uc3RydWN0b3IuX2dldERlZmF1bHRUaW1lc3RhbXAoY3JlYXRlZEF0QXR0cikgfHwgbm93O1xuICAgIH1cbiAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0ID09PSBcImRiMlwiICYmIHRoaXMuaXNOZXdSZWNvcmQpIHtcbiAgICAgIHRoaXMudW5pcW5vID0gdGhpcy5zZXF1ZWxpemUuZGlhbGVjdC5xdWVyeUdlbmVyYXRvci5hZGRVbmlxdWVGaWVsZHModGhpcy5kYXRhVmFsdWVzLCB0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXMsIHRoaXMudW5pcW5vKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudmFsaWRhdGUpIHtcbiAgICAgIGF3YWl0IHRoaXMudmFsaWRhdGUob3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBjb25zdCBiZWZvcmVIb29rVmFsdWVzID0gXy5waWNrKHRoaXMuZGF0YVZhbHVlcywgb3B0aW9ucy5maWVsZHMpO1xuICAgICAgbGV0IGlnbm9yZUNoYW5nZWQgPSBfLmRpZmZlcmVuY2UodGhpcy5jaGFuZ2VkKCksIG9wdGlvbnMuZmllbGRzKTtcbiAgICAgIGxldCBob29rQ2hhbmdlZDtcbiAgICAgIGxldCBhZnRlckhvb2tWYWx1ZXM7XG4gICAgICBpZiAodXBkYXRlZEF0QXR0ciAmJiBvcHRpb25zLmZpZWxkcy5pbmNsdWRlcyh1cGRhdGVkQXRBdHRyKSkge1xuICAgICAgICBpZ25vcmVDaGFuZ2VkID0gXy53aXRob3V0KGlnbm9yZUNoYW5nZWQsIHVwZGF0ZWRBdEF0dHIpO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5jb25zdHJ1Y3Rvci5ydW5Ib29rcyhgYmVmb3JlJHtob29rfWAsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdEZpZWxkcyAmJiAhdGhpcy5pc05ld1JlY29yZCkge1xuICAgICAgICBhZnRlckhvb2tWYWx1ZXMgPSBfLnBpY2sodGhpcy5kYXRhVmFsdWVzLCBfLmRpZmZlcmVuY2UodGhpcy5jaGFuZ2VkKCksIGlnbm9yZUNoYW5nZWQpKTtcbiAgICAgICAgaG9va0NoYW5nZWQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoYWZ0ZXJIb29rVmFsdWVzKSkge1xuICAgICAgICAgIGlmIChhZnRlckhvb2tWYWx1ZXNba2V5XSAhPT0gYmVmb3JlSG9va1ZhbHVlc1trZXldKSB7XG4gICAgICAgICAgICBob29rQ2hhbmdlZC5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuZmllbGRzID0gXy51bmlxKG9wdGlvbnMuZmllbGRzLmNvbmNhdChob29rQ2hhbmdlZCkpO1xuICAgICAgfVxuICAgICAgaWYgKGhvb2tDaGFuZ2VkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnZhbGlkYXRlKSB7XG4gICAgICAgICAgb3B0aW9ucy5za2lwID0gXy5kaWZmZXJlbmNlKE9iamVjdC5rZXlzKHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlcyksIGhvb2tDaGFuZ2VkKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlKG9wdGlvbnMpO1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnNraXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZmllbGRzLmxlbmd0aCAmJiB0aGlzLmlzTmV3UmVjb3JkICYmIHRoaXMuX29wdGlvbnMuaW5jbHVkZSAmJiB0aGlzLl9vcHRpb25zLmluY2x1ZGUubGVuZ3RoKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLl9vcHRpb25zLmluY2x1ZGUuZmlsdGVyKChpbmNsdWRlKSA9PiBpbmNsdWRlLmFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvKS5tYXAoYXN5bmMgKGluY2x1ZGUpID0+IHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmdldChpbmNsdWRlLmFzKTtcbiAgICAgICAgaWYgKCFpbnN0YW5jZSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gXyhVdGlscy5jbG9uZURlZXAoaW5jbHVkZSkpLm9taXQoW1wiYXNzb2NpYXRpb25cIl0pLmRlZmF1bHRzKHtcbiAgICAgICAgICB0cmFuc2FjdGlvbjogb3B0aW9ucy50cmFuc2FjdGlvbixcbiAgICAgICAgICBsb2dnaW5nOiBvcHRpb25zLmxvZ2dpbmcsXG4gICAgICAgICAgcGFyZW50UmVjb3JkOiB0aGlzXG4gICAgICAgIH0pLnZhbHVlKCk7XG4gICAgICAgIGF3YWl0IGluc3RhbmNlLnNhdmUoaW5jbHVkZU9wdGlvbnMpO1xuICAgICAgICBhd2FpdCB0aGlzW2luY2x1ZGUuYXNzb2NpYXRpb24uYWNjZXNzb3JzLnNldF0oaW5zdGFuY2UsIHsgc2F2ZTogZmFsc2UsIGxvZ2dpbmc6IG9wdGlvbnMubG9nZ2luZyB9KTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgY29uc3QgcmVhbEZpZWxkcyA9IG9wdGlvbnMuZmllbGRzLmZpbHRlcigoZmllbGQpID0+ICF0aGlzLmNvbnN0cnVjdG9yLl92aXJ0dWFsQXR0cmlidXRlcy5oYXMoZmllbGQpKTtcbiAgICBpZiAoIXJlYWxGaWVsZHMubGVuZ3RoKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCF0aGlzLmNoYW5nZWQoKSAmJiAhdGhpcy5pc05ld1JlY29yZClcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHZlcnNpb25GaWVsZE5hbWUgPSBfLmdldCh0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXNbdmVyc2lvbkF0dHJdLCBcImZpZWxkXCIpIHx8IHZlcnNpb25BdHRyO1xuICAgIGNvbnN0IHZhbHVlcyA9IFV0aWxzLm1hcFZhbHVlRmllbGROYW1lcyh0aGlzLmRhdGFWYWx1ZXMsIG9wdGlvbnMuZmllbGRzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICBsZXQgcXVlcnkgPSBudWxsO1xuICAgIGxldCBhcmdzID0gW107XG4gICAgbGV0IHdoZXJlO1xuICAgIGlmICh0aGlzLmlzTmV3UmVjb3JkKSB7XG4gICAgICBxdWVyeSA9IFwiaW5zZXJ0XCI7XG4gICAgICBhcmdzID0gW3RoaXMsIHRoaXMuY29uc3RydWN0b3IuZ2V0VGFibGVOYW1lKG9wdGlvbnMpLCB2YWx1ZXMsIG9wdGlvbnNdO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGVyZSA9IHRoaXMud2hlcmUodHJ1ZSk7XG4gICAgICBpZiAodmVyc2lvbkF0dHIpIHtcbiAgICAgICAgdmFsdWVzW3ZlcnNpb25GaWVsZE5hbWVdID0gcGFyc2VJbnQodmFsdWVzW3ZlcnNpb25GaWVsZE5hbWVdLCAxMCkgKyAxO1xuICAgICAgfVxuICAgICAgcXVlcnkgPSBcInVwZGF0ZVwiO1xuICAgICAgYXJncyA9IFt0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLmdldFRhYmxlTmFtZShvcHRpb25zKSwgdmFsdWVzLCB3aGVyZSwgb3B0aW9uc107XG4gICAgfVxuICAgIGNvbnN0IFtyZXN1bHQsIHJvd3NVcGRhdGVkXSA9IGF3YWl0IHRoaXMuY29uc3RydWN0b3IucXVlcnlJbnRlcmZhY2VbcXVlcnldKC4uLmFyZ3MpO1xuICAgIGlmICh2ZXJzaW9uQXR0cikge1xuICAgICAgaWYgKHJvd3NVcGRhdGVkIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLk9wdGltaXN0aWNMb2NrRXJyb3Ioe1xuICAgICAgICAgIG1vZGVsTmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAgIHZhbHVlcyxcbiAgICAgICAgICB3aGVyZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5kYXRhVmFsdWVzW3ZlcnNpb25BdHRyXSA9IHZhbHVlc1t2ZXJzaW9uRmllbGROYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBhdHRyIG9mIE9iamVjdC5rZXlzKHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlcykpIHtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGQgJiYgdmFsdWVzW3RoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZF0gIT09IHZvaWQgMCAmJiB0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGQgIT09IGF0dHIpIHtcbiAgICAgICAgdmFsdWVzW2F0dHJdID0gdmFsdWVzW3RoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZF07XG4gICAgICAgIGRlbGV0ZSB2YWx1ZXNbdGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkXTtcbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih2YWx1ZXMsIHJlc3VsdC5kYXRhVmFsdWVzKTtcbiAgICBPYmplY3QuYXNzaWduKHJlc3VsdC5kYXRhVmFsdWVzLCB2YWx1ZXMpO1xuICAgIGlmICh3YXNOZXdSZWNvcmQgJiYgdGhpcy5fb3B0aW9ucy5pbmNsdWRlICYmIHRoaXMuX29wdGlvbnMuaW5jbHVkZS5sZW5ndGgpIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuX29wdGlvbnMuaW5jbHVkZS5maWx0ZXIoKGluY2x1ZGUpID0+ICEoaW5jbHVkZS5hc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUbyB8fCBpbmNsdWRlLnBhcmVudCAmJiBpbmNsdWRlLnBhcmVudC5hc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUb01hbnkpKS5tYXAoYXN5bmMgKGluY2x1ZGUpID0+IHtcbiAgICAgICAgbGV0IGluc3RhbmNlcyA9IHRoaXMuZ2V0KGluY2x1ZGUuYXMpO1xuICAgICAgICBpZiAoIWluc3RhbmNlcylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnN0YW5jZXMpKVxuICAgICAgICAgIGluc3RhbmNlcyA9IFtpbnN0YW5jZXNdO1xuICAgICAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IF8oVXRpbHMuY2xvbmVEZWVwKGluY2x1ZGUpKS5vbWl0KFtcImFzc29jaWF0aW9uXCJdKS5kZWZhdWx0cyh7XG4gICAgICAgICAgdHJhbnNhY3Rpb246IG9wdGlvbnMudHJhbnNhY3Rpb24sXG4gICAgICAgICAgbG9nZ2luZzogb3B0aW9ucy5sb2dnaW5nLFxuICAgICAgICAgIHBhcmVudFJlY29yZDogdGhpc1xuICAgICAgICB9KS52YWx1ZSgpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChpbnN0YW5jZXMubWFwKGFzeW5jIChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgIGlmIChpbmNsdWRlLmFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvTWFueSkge1xuICAgICAgICAgICAgYXdhaXQgaW5zdGFuY2Uuc2F2ZShpbmNsdWRlT3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMwID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICAgICAgICBbaW5jbHVkZS5hc3NvY2lhdGlvbi5mb3JlaWduS2V5XTogdGhpcy5nZXQodGhpcy5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgW2luY2x1ZGUuYXNzb2NpYXRpb24ub3RoZXJLZXldOiBpbnN0YW5jZS5nZXQoaW5zdGFuY2UuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSlcbiAgICAgICAgICAgIH0sIGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5zY29wZSk7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VbaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLm5hbWVdKSB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBPYmplY3Qua2V5cyhpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uX2F1dG9HZW5lcmF0ZWQgfHwgYXR0ciA9PT0gaW5jbHVkZS5hc3NvY2lhdGlvbi5mb3JlaWduS2V5IHx8IGF0dHIgPT09IGluY2x1ZGUuYXNzb2NpYXRpb24ub3RoZXJLZXkgfHwgdHlwZW9mIGluc3RhbmNlW2luY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5uYW1lXVthdHRyXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlczBbYXR0cl0gPSBpbnN0YW5jZVtpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwubmFtZV1bYXR0cl07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaE1vZGVsLmNyZWF0ZSh2YWx1ZXMwLCBpbmNsdWRlT3B0aW9ucyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldChpbmNsdWRlLmFzc29jaWF0aW9uLmZvcmVpZ25LZXksIHRoaXMuZ2V0KGluY2x1ZGUuYXNzb2NpYXRpb24uc291cmNlS2V5IHx8IHRoaXMuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSksIHsgcmF3OiB0cnVlIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwgaW5jbHVkZS5hc3NvY2lhdGlvbi5zY29wZSk7XG4gICAgICAgICAgICBhd2FpdCBpbnN0YW5jZS5zYXZlKGluY2x1ZGVPcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMuY29uc3RydWN0b3IucnVuSG9va3MoYGFmdGVyJHtob29rfWAsIHJlc3VsdCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmllbGQgb2Ygb3B0aW9ucy5maWVsZHMpIHtcbiAgICAgIHJlc3VsdC5fcHJldmlvdXNEYXRhVmFsdWVzW2ZpZWxkXSA9IHJlc3VsdC5kYXRhVmFsdWVzW2ZpZWxkXTtcbiAgICAgIHRoaXMuY2hhbmdlZChmaWVsZCwgZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLmlzTmV3UmVjb3JkID0gZmFsc2U7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyByZWxvYWQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyh7XG4gICAgICB3aGVyZTogdGhpcy53aGVyZSgpXG4gICAgfSwgb3B0aW9ucywge1xuICAgICAgaW5jbHVkZTogdGhpcy5fb3B0aW9ucy5pbmNsdWRlIHx8IHZvaWQgMFxuICAgIH0pO1xuICAgIGNvbnN0IHJlbG9hZGVkID0gYXdhaXQgdGhpcy5jb25zdHJ1Y3Rvci5maW5kT25lKG9wdGlvbnMpO1xuICAgIGlmICghcmVsb2FkZWQpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuSW5zdGFuY2VFcnJvcihcIkluc3RhbmNlIGNvdWxkIG5vdCBiZSByZWxvYWRlZCBiZWNhdXNlIGl0IGRvZXMgbm90IGV4aXN0IGFueW1vcmUgKGZpbmQgY2FsbCByZXR1cm5lZCBudWxsKVwiKTtcbiAgICB9XG4gICAgdGhpcy5fb3B0aW9ucyA9IHJlbG9hZGVkLl9vcHRpb25zO1xuICAgIHRoaXMuc2V0KHJlbG9hZGVkLmRhdGFWYWx1ZXMsIHtcbiAgICAgIHJhdzogdHJ1ZSxcbiAgICAgIHJlc2V0OiAhb3B0aW9ucy5hdHRyaWJ1dGVzXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXN5bmMgdmFsaWRhdGUob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgSW5zdGFuY2VWYWxpZGF0b3IodGhpcywgb3B0aW9ucykudmFsaWRhdGUoKTtcbiAgfVxuICBhc3luYyB1cGRhdGUodmFsdWVzLCBvcHRpb25zKSB7XG4gICAgdmFsdWVzID0gXy5vbWl0QnkodmFsdWVzLCAodmFsdWUpID0+IHZhbHVlID09PSB2b2lkIDApO1xuICAgIGNvbnN0IGNoYW5nZWRCZWZvcmUgPSB0aGlzLmNoYW5nZWQoKSB8fCBbXTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSlcbiAgICAgIG9wdGlvbnMgPSB7IGZpZWxkczogb3B0aW9ucyB9O1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gPT09IHZvaWQgMCAmJiB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscy5nZXQoXCJ0cmFuc2FjdGlvblwiKTtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24gPSB0O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzZXRPcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIHNldE9wdGlvbnMuYXR0cmlidXRlcyA9IG9wdGlvbnMuZmllbGRzO1xuICAgIHRoaXMuc2V0KHZhbHVlcywgc2V0T3B0aW9ucyk7XG4gICAgY29uc3Qgc2lkZUVmZmVjdHMgPSBfLndpdGhvdXQodGhpcy5jaGFuZ2VkKCksIC4uLmNoYW5nZWRCZWZvcmUpO1xuICAgIGNvbnN0IGZpZWxkcyA9IF8udW5pb24oT2JqZWN0LmtleXModmFsdWVzKSwgc2lkZUVmZmVjdHMpO1xuICAgIGlmICghb3B0aW9ucy5maWVsZHMpIHtcbiAgICAgIG9wdGlvbnMuZmllbGRzID0gXy5pbnRlcnNlY3Rpb24oZmllbGRzLCB0aGlzLmNoYW5nZWQoKSk7XG4gICAgICBvcHRpb25zLmRlZmF1bHRGaWVsZHMgPSBvcHRpb25zLmZpZWxkcztcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2F2ZShvcHRpb25zKTtcbiAgfVxuICBhc3luYyBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgaG9va3M6IHRydWUsXG4gICAgICBmb3JjZTogZmFsc2VcbiAgICB9LCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiA9PT0gdm9pZCAwICYmIHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzLmdldChcInRyYW5zYWN0aW9uXCIpO1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbiA9IHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLmNvbnN0cnVjdG9yLnJ1bkhvb2tzKFwiYmVmb3JlRGVzdHJveVwiLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3Qgd2hlcmUgPSB0aGlzLndoZXJlKHRydWUpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0ICYmIG9wdGlvbnMuZm9yY2UgPT09IGZhbHNlKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQ7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSB0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlLCBcImRlZmF1bHRWYWx1ZVwiKSA/IGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUgOiBudWxsO1xuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5nZXREYXRhVmFsdWUoYXR0cmlidXRlTmFtZSk7XG4gICAgICBjb25zdCB1bmRlZmluZWRPck51bGwgPSBjdXJyZW50VmFsdWUgPT0gbnVsbCAmJiBkZWZhdWx0VmFsdWUgPT0gbnVsbDtcbiAgICAgIGlmICh1bmRlZmluZWRPck51bGwgfHwgXy5pc0VxdWFsKGN1cnJlbnRWYWx1ZSwgZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICB0aGlzLnNldERhdGFWYWx1ZShhdHRyaWJ1dGVOYW1lLCBuZXcgRGF0ZSgpKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuc2F2ZShfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyBob29rczogZmFsc2UgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLmNvbnN0cnVjdG9yLnF1ZXJ5SW50ZXJmYWNlLmRlbGV0ZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLmdldFRhYmxlTmFtZShvcHRpb25zKSwgd2hlcmUsIF9fc3ByZWFkVmFsdWVzKHsgdHlwZTogUXVlcnlUeXBlcy5ERUxFVEUsIGxpbWl0OiBudWxsIH0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMuY29uc3RydWN0b3IucnVuSG9va3MoXCJhZnRlckRlc3Ryb3lcIiwgdGhpcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaXNTb2Z0RGVsZXRlZCgpIHtcbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlbCBpcyBub3QgcGFyYW5vaWRcIik7XG4gICAgfVxuICAgIGNvbnN0IGRlbGV0ZWRBdEF0dHJpYnV0ZSA9IHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlc1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdF07XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlbGV0ZWRBdEF0dHJpYnV0ZSwgXCJkZWZhdWx0VmFsdWVcIikgPyBkZWxldGVkQXRBdHRyaWJ1dGUuZGVmYXVsdFZhbHVlIDogbnVsbDtcbiAgICBjb25zdCBkZWxldGVkQXQgPSB0aGlzLmdldCh0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdCkgfHwgbnVsbDtcbiAgICBjb25zdCBpc1NldCA9IGRlbGV0ZWRBdCAhPT0gZGVmYXVsdFZhbHVlO1xuICAgIHJldHVybiBpc1NldDtcbiAgfVxuICBhc3luYyByZXN0b3JlKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kZWwgaXMgbm90IHBhcmFub2lkXCIpO1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBob29rczogdHJ1ZSxcbiAgICAgIGZvcmNlOiBmYWxzZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uID09PSB2b2lkIDAgJiYgdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscykge1xuICAgICAgY29uc3QgdCA9IHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMuZ2V0KFwidHJhbnNhY3Rpb25cIik7XG4gICAgICBpZiAodCkge1xuICAgICAgICBvcHRpb25zLnRyYW5zYWN0aW9uID0gdDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMuY29uc3RydWN0b3IucnVuSG9va3MoXCJiZWZvcmVSZXN0b3JlXCIsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBkZWxldGVkQXRDb2wgPSB0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdDtcbiAgICBjb25zdCBkZWxldGVkQXRBdHRyaWJ1dGUgPSB0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXNbZGVsZXRlZEF0Q29sXTtcbiAgICBjb25zdCBkZWxldGVkQXREZWZhdWx0VmFsdWUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVsZXRlZEF0QXR0cmlidXRlLCBcImRlZmF1bHRWYWx1ZVwiKSA/IGRlbGV0ZWRBdEF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUgOiBudWxsO1xuICAgIHRoaXMuc2V0RGF0YVZhbHVlKGRlbGV0ZWRBdENvbCwgZGVsZXRlZEF0RGVmYXVsdFZhbHVlKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNhdmUoX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgaG9va3M6IGZhbHNlLCBvbWl0TnVsbDogZmFsc2UgfSkpO1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLmNvbnN0cnVjdG9yLnJ1bkhvb2tzKFwiYWZ0ZXJSZXN0b3JlXCIsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyBpbmNyZW1lbnQoZmllbGRzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaWRlbnRpZmllciA9IHRoaXMud2hlcmUoKTtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMud2hlcmUgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucy53aGVyZSksIGlkZW50aWZpZXIpO1xuICAgIG9wdGlvbnMuaW5zdGFuY2UgPSB0aGlzO1xuICAgIGF3YWl0IHRoaXMuY29uc3RydWN0b3IuaW5jcmVtZW50KGZpZWxkcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXN5bmMgZGVjcmVtZW50KGZpZWxkcywgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmluY3JlbWVudChmaWVsZHMsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgYnk6IDFcbiAgICB9LCBvcHRpb25zKSwge1xuICAgICAgaW5jcmVtZW50OiBmYWxzZVxuICAgIH0pKTtcbiAgfVxuICBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAoIW90aGVyIHx8ICFvdGhlci5jb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGVzLmV2ZXJ5KChhdHRyaWJ1dGUpID0+IHRoaXMuZ2V0KGF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSkgPT09IG90aGVyLmdldChhdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pKTtcbiAgfVxuICBlcXVhbHNPbmVPZihvdGhlcnMpIHtcbiAgICByZXR1cm4gb3RoZXJzLnNvbWUoKG90aGVyKSA9PiB0aGlzLmVxdWFscyhvdGhlcikpO1xuICB9XG4gIHNldFZhbGlkYXRvcnMoYXR0cmlidXRlLCB2YWxpZGF0b3JzKSB7XG4gICAgdGhpcy52YWxpZGF0b3JzW2F0dHJpYnV0ZV0gPSB2YWxpZGF0b3JzO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gXy5jbG9uZURlZXAodGhpcy5nZXQoe1xuICAgICAgcGxhaW46IHRydWVcbiAgICB9KSk7XG4gIH1cbiAgc3RhdGljIGhhc01hbnkodGFyZ2V0LCBvcHRpb25zKSB7XG4gIH1cbiAgc3RhdGljIGJlbG9uZ3NUb01hbnkodGFyZ2V0LCBvcHRpb25zKSB7XG4gIH1cbiAgc3RhdGljIGhhc09uZSh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgfVxuICBzdGF0aWMgYmVsb25nc1RvKHRhcmdldCwgb3B0aW9ucykge1xuICB9XG59XG5mdW5jdGlvbiB1bnBhY2tBbmQod2hlcmUpIHtcbiAgaWYgKCFfLmlzT2JqZWN0KHdoZXJlKSkge1xuICAgIHJldHVybiB3aGVyZTtcbiAgfVxuICBjb25zdCBrZXlzID0gVXRpbHMuZ2V0Q29tcGxleEtleXMod2hlcmUpO1xuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGtleXMubGVuZ3RoICE9PSAxIHx8IGtleXNbMF0gIT09IE9wLmFuZCkge1xuICAgIHJldHVybiB3aGVyZTtcbiAgfVxuICBjb25zdCBhbmRQYXJ0cyA9IHdoZXJlW09wLmFuZF07XG4gIHJldHVybiBhbmRQYXJ0cztcbn1cbmZ1bmN0aW9uIGNvbWJpbmVXaGVyZXNXaXRoQW5kKHdoZXJlQSwgd2hlcmVCKSB7XG4gIGNvbnN0IHVucGFja2VkQSA9IHVucGFja0FuZCh3aGVyZUEpO1xuICBpZiAodW5wYWNrZWRBID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gd2hlcmVCO1xuICB9XG4gIGNvbnN0IHVucGFja2VkQiA9IHVucGFja0FuZCh3aGVyZUIpO1xuICBpZiAodW5wYWNrZWRCID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gd2hlcmVBO1xuICB9XG4gIHJldHVybiB7XG4gICAgW09wLmFuZF06IF8uZmxhdHRlbihbdW5wYWNrZWRBLCB1bnBhY2tlZEJdKVxuICB9O1xufVxuT2JqZWN0LmFzc2lnbihNb2RlbCwgYXNzb2NpYXRpb25zTWl4aW4pO1xuSG9va3MuYXBwbHlUbyhNb2RlbCwgdHJ1ZSk7XG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZWwuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/model.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/operators.js":
/*!**************************************************!*\
  !*** ../node_modules/sequelize/lib/operators.js ***!
  \**************************************************/
/***/ ((module, exports) => {

eval("var __defProp = Object.defineProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  Op: () => Op,\n  default: () => operators_default\n});\nconst Op = {\n  eq: Symbol.for(\"eq\"),\n  ne: Symbol.for(\"ne\"),\n  gte: Symbol.for(\"gte\"),\n  gt: Symbol.for(\"gt\"),\n  lte: Symbol.for(\"lte\"),\n  lt: Symbol.for(\"lt\"),\n  not: Symbol.for(\"not\"),\n  is: Symbol.for(\"is\"),\n  in: Symbol.for(\"in\"),\n  notIn: Symbol.for(\"notIn\"),\n  like: Symbol.for(\"like\"),\n  notLike: Symbol.for(\"notLike\"),\n  iLike: Symbol.for(\"iLike\"),\n  notILike: Symbol.for(\"notILike\"),\n  startsWith: Symbol.for(\"startsWith\"),\n  endsWith: Symbol.for(\"endsWith\"),\n  substring: Symbol.for(\"substring\"),\n  regexp: Symbol.for(\"regexp\"),\n  notRegexp: Symbol.for(\"notRegexp\"),\n  iRegexp: Symbol.for(\"iRegexp\"),\n  notIRegexp: Symbol.for(\"notIRegexp\"),\n  between: Symbol.for(\"between\"),\n  notBetween: Symbol.for(\"notBetween\"),\n  overlap: Symbol.for(\"overlap\"),\n  contains: Symbol.for(\"contains\"),\n  contained: Symbol.for(\"contained\"),\n  adjacent: Symbol.for(\"adjacent\"),\n  strictLeft: Symbol.for(\"strictLeft\"),\n  strictRight: Symbol.for(\"strictRight\"),\n  noExtendRight: Symbol.for(\"noExtendRight\"),\n  noExtendLeft: Symbol.for(\"noExtendLeft\"),\n  and: Symbol.for(\"and\"),\n  or: Symbol.for(\"or\"),\n  any: Symbol.for(\"any\"),\n  all: Symbol.for(\"all\"),\n  values: Symbol.for(\"values\"),\n  col: Symbol.for(\"col\"),\n  placeholder: Symbol.for(\"placeholder\"),\n  join: Symbol.for(\"join\"),\n  match: Symbol.for(\"match\")\n};\nvar operators_default = Op;\nmodule.exports = Op;\n//# sourceMappingURL=operators.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9vcGVyYXRvcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9vcGVyYXRvcnMuanM/NWQ0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIE9wOiAoKSA9PiBPcCxcbiAgZGVmYXVsdDogKCkgPT4gb3BlcmF0b3JzX2RlZmF1bHRcbn0pO1xuY29uc3QgT3AgPSB7XG4gIGVxOiBTeW1ib2wuZm9yKFwiZXFcIiksXG4gIG5lOiBTeW1ib2wuZm9yKFwibmVcIiksXG4gIGd0ZTogU3ltYm9sLmZvcihcImd0ZVwiKSxcbiAgZ3Q6IFN5bWJvbC5mb3IoXCJndFwiKSxcbiAgbHRlOiBTeW1ib2wuZm9yKFwibHRlXCIpLFxuICBsdDogU3ltYm9sLmZvcihcImx0XCIpLFxuICBub3Q6IFN5bWJvbC5mb3IoXCJub3RcIiksXG4gIGlzOiBTeW1ib2wuZm9yKFwiaXNcIiksXG4gIGluOiBTeW1ib2wuZm9yKFwiaW5cIiksXG4gIG5vdEluOiBTeW1ib2wuZm9yKFwibm90SW5cIiksXG4gIGxpa2U6IFN5bWJvbC5mb3IoXCJsaWtlXCIpLFxuICBub3RMaWtlOiBTeW1ib2wuZm9yKFwibm90TGlrZVwiKSxcbiAgaUxpa2U6IFN5bWJvbC5mb3IoXCJpTGlrZVwiKSxcbiAgbm90SUxpa2U6IFN5bWJvbC5mb3IoXCJub3RJTGlrZVwiKSxcbiAgc3RhcnRzV2l0aDogU3ltYm9sLmZvcihcInN0YXJ0c1dpdGhcIiksXG4gIGVuZHNXaXRoOiBTeW1ib2wuZm9yKFwiZW5kc1dpdGhcIiksXG4gIHN1YnN0cmluZzogU3ltYm9sLmZvcihcInN1YnN0cmluZ1wiKSxcbiAgcmVnZXhwOiBTeW1ib2wuZm9yKFwicmVnZXhwXCIpLFxuICBub3RSZWdleHA6IFN5bWJvbC5mb3IoXCJub3RSZWdleHBcIiksXG4gIGlSZWdleHA6IFN5bWJvbC5mb3IoXCJpUmVnZXhwXCIpLFxuICBub3RJUmVnZXhwOiBTeW1ib2wuZm9yKFwibm90SVJlZ2V4cFwiKSxcbiAgYmV0d2VlbjogU3ltYm9sLmZvcihcImJldHdlZW5cIiksXG4gIG5vdEJldHdlZW46IFN5bWJvbC5mb3IoXCJub3RCZXR3ZWVuXCIpLFxuICBvdmVybGFwOiBTeW1ib2wuZm9yKFwib3ZlcmxhcFwiKSxcbiAgY29udGFpbnM6IFN5bWJvbC5mb3IoXCJjb250YWluc1wiKSxcbiAgY29udGFpbmVkOiBTeW1ib2wuZm9yKFwiY29udGFpbmVkXCIpLFxuICBhZGphY2VudDogU3ltYm9sLmZvcihcImFkamFjZW50XCIpLFxuICBzdHJpY3RMZWZ0OiBTeW1ib2wuZm9yKFwic3RyaWN0TGVmdFwiKSxcbiAgc3RyaWN0UmlnaHQ6IFN5bWJvbC5mb3IoXCJzdHJpY3RSaWdodFwiKSxcbiAgbm9FeHRlbmRSaWdodDogU3ltYm9sLmZvcihcIm5vRXh0ZW5kUmlnaHRcIiksXG4gIG5vRXh0ZW5kTGVmdDogU3ltYm9sLmZvcihcIm5vRXh0ZW5kTGVmdFwiKSxcbiAgYW5kOiBTeW1ib2wuZm9yKFwiYW5kXCIpLFxuICBvcjogU3ltYm9sLmZvcihcIm9yXCIpLFxuICBhbnk6IFN5bWJvbC5mb3IoXCJhbnlcIiksXG4gIGFsbDogU3ltYm9sLmZvcihcImFsbFwiKSxcbiAgdmFsdWVzOiBTeW1ib2wuZm9yKFwidmFsdWVzXCIpLFxuICBjb2w6IFN5bWJvbC5mb3IoXCJjb2xcIiksXG4gIHBsYWNlaG9sZGVyOiBTeW1ib2wuZm9yKFwicGxhY2Vob2xkZXJcIiksXG4gIGpvaW46IFN5bWJvbC5mb3IoXCJqb2luXCIpLFxuICBtYXRjaDogU3ltYm9sLmZvcihcIm1hdGNoXCIpXG59O1xudmFyIG9wZXJhdG9yc19kZWZhdWx0ID0gT3A7XG5tb2R1bGUuZXhwb3J0cyA9IE9wO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3BlcmF0b3JzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/operators.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/query-types.js":
/*!****************************************************!*\
  !*** ../node_modules/sequelize/lib/query-types.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\nconst QueryTypes = module.exports = {\n  SELECT: \"SELECT\",\n  INSERT: \"INSERT\",\n  UPDATE: \"UPDATE\",\n  BULKUPDATE: \"BULKUPDATE\",\n  BULKDELETE: \"BULKDELETE\",\n  DELETE: \"DELETE\",\n  UPSERT: \"UPSERT\",\n  VERSION: \"VERSION\",\n  SHOWTABLES: \"SHOWTABLES\",\n  SHOWINDEXES: \"SHOWINDEXES\",\n  DESCRIBE: \"DESCRIBE\",\n  RAW: \"RAW\",\n  FOREIGNKEYS: \"FOREIGNKEYS\",\n  SHOWCONSTRAINTS: \"SHOWCONSTRAINTS\"\n};\n//# sourceMappingURL=query-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9xdWVyeS10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvcXVlcnktdHlwZXMuanM/MmIzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgU0VMRUNUOiBcIlNFTEVDVFwiLFxuICBJTlNFUlQ6IFwiSU5TRVJUXCIsXG4gIFVQREFURTogXCJVUERBVEVcIixcbiAgQlVMS1VQREFURTogXCJCVUxLVVBEQVRFXCIsXG4gIEJVTEtERUxFVEU6IFwiQlVMS0RFTEVURVwiLFxuICBERUxFVEU6IFwiREVMRVRFXCIsXG4gIFVQU0VSVDogXCJVUFNFUlRcIixcbiAgVkVSU0lPTjogXCJWRVJTSU9OXCIsXG4gIFNIT1dUQUJMRVM6IFwiU0hPV1RBQkxFU1wiLFxuICBTSE9XSU5ERVhFUzogXCJTSE9XSU5ERVhFU1wiLFxuICBERVNDUklCRTogXCJERVNDUklCRVwiLFxuICBSQVc6IFwiUkFXXCIsXG4gIEZPUkVJR05LRVlTOiBcIkZPUkVJR05LRVlTXCIsXG4gIFNIT1dDT05TVFJBSU5UUzogXCJTSE9XQ09OU1RSQUlOVFNcIlxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LXR5cGVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/query-types.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/sequelize.js":
/*!**************************************************!*\
  !*** ../node_modules/sequelize/lib/sequelize.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst url = __webpack_require__(/*! url */ \"url\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst pgConnectionString = __webpack_require__(/*! pg-connection-string */ \"(action-browser)/../node_modules/pg-connection-string/index.js\");\nconst retry = (__webpack_require__(/*! retry-as-promised */ \"(action-browser)/../node_modules/retry-as-promised/dist/index.js\")[\"default\"]);\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ./utils */ \"(action-browser)/../node_modules/sequelize/lib/utils.js\");\nconst Model = __webpack_require__(/*! ./model */ \"(action-browser)/../node_modules/sequelize/lib/model.js\");\nconst DataTypes = __webpack_require__(/*! ./data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\");\nconst Deferrable = __webpack_require__(/*! ./deferrable */ \"(action-browser)/../node_modules/sequelize/lib/deferrable.js\");\nconst ModelManager = __webpack_require__(/*! ./model-manager */ \"(action-browser)/../node_modules/sequelize/lib/model-manager.js\");\nconst Transaction = __webpack_require__(/*! ./transaction */ \"(action-browser)/../node_modules/sequelize/lib/transaction.js\");\nconst QueryTypes = __webpack_require__(/*! ./query-types */ \"(action-browser)/../node_modules/sequelize/lib/query-types.js\");\nconst TableHints = __webpack_require__(/*! ./table-hints */ \"(action-browser)/../node_modules/sequelize/lib/table-hints.js\");\nconst IndexHints = __webpack_require__(/*! ./index-hints */ \"(action-browser)/../node_modules/sequelize/lib/index-hints.js\");\nconst sequelizeErrors = __webpack_require__(/*! ./errors */ \"(action-browser)/../node_modules/sequelize/lib/errors/index.js\");\nconst Hooks = __webpack_require__(/*! ./hooks */ \"(action-browser)/../node_modules/sequelize/lib/hooks.js\");\nconst Association = __webpack_require__(/*! ./associations/index */ \"(action-browser)/../node_modules/sequelize/lib/associations/index.js\");\nconst Validator = (__webpack_require__(/*! ./utils/validator-extras */ \"(action-browser)/../node_modules/sequelize/lib/utils/validator-extras.js\").validator);\nconst Op = __webpack_require__(/*! ./operators */ \"(action-browser)/../node_modules/sequelize/lib/operators.js\");\nconst deprecations = __webpack_require__(/*! ./utils/deprecations */ \"(action-browser)/../node_modules/sequelize/lib/utils/deprecations.js\");\nconst { QueryInterface } = __webpack_require__(/*! ./dialects/abstract/query-interface */ \"(action-browser)/../node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nconst { BelongsTo } = __webpack_require__(/*! ./associations/belongs-to */ \"(action-browser)/../node_modules/sequelize/lib/associations/belongs-to.js\");\nconst HasOne = __webpack_require__(/*! ./associations/has-one */ \"(action-browser)/../node_modules/sequelize/lib/associations/has-one.js\");\nconst { BelongsToMany } = __webpack_require__(/*! ./associations/belongs-to-many */ \"(action-browser)/../node_modules/sequelize/lib/associations/belongs-to-many.js\");\nconst { HasMany } = __webpack_require__(/*! ./associations/has-many */ \"(action-browser)/../node_modules/sequelize/lib/associations/has-many.js\");\nconst { withSqliteForeignKeysOff } = __webpack_require__(/*! ./dialects/sqlite/sqlite-utils */ \"(action-browser)/../node_modules/sequelize/lib/dialects/sqlite/sqlite-utils.js\");\nconst { injectReplacements } = __webpack_require__(/*! ./utils/sql */ \"(action-browser)/../node_modules/sequelize/lib/utils/sql.js\");\nclass Sequelize {\n  constructor(database, username, password, options) {\n    let config;\n    if (arguments.length === 1 && typeof database === \"object\") {\n      options = database;\n      config = _.pick(options, \"host\", \"port\", \"database\", \"username\", \"password\");\n    } else if (arguments.length === 1 && typeof database === \"string\" || arguments.length === 2 && typeof username === \"object\") {\n      config = {};\n      options = username || {};\n      const urlParts = url.parse(arguments[0], true);\n      options.dialect = urlParts.protocol.replace(/:$/, \"\");\n      options.host = urlParts.hostname;\n      if (options.dialect === \"sqlite\" && urlParts.pathname && !urlParts.pathname.startsWith(\"/:memory\")) {\n        const storagePath = path.join(options.host, urlParts.pathname);\n        options.storage = path.resolve(options.storage || storagePath);\n      }\n      if (urlParts.pathname) {\n        config.database = urlParts.pathname.replace(/^\\//, \"\");\n      }\n      if (urlParts.port) {\n        options.port = urlParts.port;\n      }\n      if (urlParts.auth) {\n        const authParts = urlParts.auth.split(\":\");\n        config.username = authParts[0];\n        if (authParts.length > 1)\n          config.password = authParts.slice(1).join(\":\");\n      }\n      if (urlParts.query) {\n        if (urlParts.query.host) {\n          options.host = urlParts.query.host;\n        }\n        if (options.dialectOptions) {\n          Object.assign(options.dialectOptions, urlParts.query);\n        } else {\n          options.dialectOptions = urlParts.query;\n          if (urlParts.query.options) {\n            try {\n              const o = JSON.parse(urlParts.query.options);\n              options.dialectOptions.options = o;\n            } catch (e) {\n            }\n          }\n        }\n      }\n      if ([\"postgres\", \"postgresql\"].includes(options.dialect)) {\n        Object.assign(options.dialectOptions, pgConnectionString.parse(arguments[0]));\n      }\n    } else {\n      options = options || {};\n      config = { database, username, password };\n    }\n    Sequelize.runHooks(\"beforeInit\", config, options);\n    this.options = __spreadValues({\n      dialect: null,\n      dialectModule: null,\n      dialectModulePath: null,\n      host: \"localhost\",\n      protocol: \"tcp\",\n      define: {},\n      query: {},\n      sync: {},\n      timezone: \"+00:00\",\n      standardConformingStrings: true,\n      logging: console.log,\n      omitNull: false,\n      native: false,\n      replication: false,\n      ssl: void 0,\n      pool: {},\n      quoteIdentifiers: true,\n      hooks: {},\n      retry: {\n        max: 5,\n        match: [\n          \"SQLITE_BUSY: database is locked\"\n        ]\n      },\n      transactionType: Transaction.TYPES.DEFERRED,\n      isolationLevel: null,\n      databaseVersion: 0,\n      typeValidation: false,\n      benchmark: false,\n      minifyAliases: false,\n      logQueryParameters: false,\n      attributeBehavior: \"throw\"\n    }, options);\n    if (!this.options.dialect) {\n      throw new Error(\"Dialect needs to be explicitly supplied as of v4.0.0\");\n    }\n    if (this.options.dialect === \"postgresql\") {\n      this.options.dialect = \"postgres\";\n    }\n    if (this.options.dialect === \"sqlite\" && this.options.timezone !== \"+00:00\") {\n      throw new Error(\"Setting a custom timezone is not supported by SQLite, dates are always returned as UTC. Please remove the custom timezone parameter.\");\n    }\n    if (this.options.logging === true) {\n      deprecations.noTrueLogging();\n      this.options.logging = console.log;\n    }\n    this._setupHooks(options.hooks);\n    this.config = {\n      database: config.database || this.options.database,\n      username: config.username || this.options.username,\n      password: config.password || this.options.password || null,\n      host: config.host || this.options.host,\n      port: config.port || this.options.port,\n      pool: this.options.pool,\n      protocol: this.options.protocol,\n      native: this.options.native,\n      ssl: this.options.ssl,\n      replication: this.options.replication,\n      dialectModule: this.options.dialectModule,\n      dialectModulePath: this.options.dialectModulePath,\n      keepDefaultTimezone: this.options.keepDefaultTimezone,\n      dialectOptions: this.options.dialectOptions\n    };\n    let Dialect;\n    switch (this.getDialect()) {\n      case \"mariadb\":\n        Dialect = __webpack_require__(/*! ./dialects/mariadb */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mariadb/index.js\");\n        break;\n      case \"mssql\":\n        Dialect = __webpack_require__(/*! ./dialects/mssql */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mssql/index.js\");\n        break;\n      case \"mysql\":\n        Dialect = __webpack_require__(/*! ./dialects/mysql */ \"(action-browser)/../node_modules/sequelize/lib/dialects/mysql/index.js\");\n        break;\n      case \"oracle\":\n        Dialect = __webpack_require__(/*! ./dialects/oracle */ \"(action-browser)/../node_modules/sequelize/lib/dialects/oracle/index.js\");\n        break;\n      case \"postgres\":\n        Dialect = __webpack_require__(/*! ./dialects/postgres */ \"(action-browser)/../node_modules/sequelize/lib/dialects/postgres/index.js\");\n        break;\n      case \"sqlite\":\n        Dialect = __webpack_require__(/*! ./dialects/sqlite */ \"(action-browser)/../node_modules/sequelize/lib/dialects/sqlite/index.js\");\n        break;\n      case \"db2\":\n        Dialect = __webpack_require__(/*! ./dialects/db2 */ \"(action-browser)/../node_modules/sequelize/lib/dialects/db2/index.js\");\n        break;\n      case \"snowflake\":\n        Dialect = __webpack_require__(/*! ./dialects/snowflake */ \"(action-browser)/../node_modules/sequelize/lib/dialects/snowflake/index.js\");\n        break;\n      default:\n        throw new Error(`The dialect ${this.getDialect()} is not supported. Supported dialects: mssql, mariadb, mysql, oracle, postgres, db2 and sqlite.`);\n    }\n    this.dialect = new Dialect(this);\n    this.dialect.queryGenerator.typeValidation = options.typeValidation;\n    if (_.isPlainObject(this.options.operatorsAliases)) {\n      deprecations.noStringOperators();\n      this.dialect.queryGenerator.setOperatorsAliases(this.options.operatorsAliases);\n    } else if (typeof this.options.operatorsAliases === \"boolean\") {\n      deprecations.noBoolOperatorAliases();\n    }\n    this.queryInterface = this.dialect.queryInterface;\n    this.models = {};\n    this.modelManager = new ModelManager(this);\n    this.connectionManager = this.dialect.connectionManager;\n    Sequelize.runHooks(\"afterInit\", this);\n  }\n  refreshTypes() {\n    this.connectionManager.refreshTypeParser(DataTypes);\n  }\n  getDialect() {\n    return this.options.dialect;\n  }\n  getDatabaseName() {\n    return this.config.database;\n  }\n  getQueryInterface() {\n    return this.queryInterface;\n  }\n  define(modelName, attributes, options = {}) {\n    options.modelName = modelName;\n    options.sequelize = this;\n    const model = class extends Model {\n    };\n    model.init(attributes, options);\n    return model;\n  }\n  model(modelName) {\n    if (!this.isDefined(modelName)) {\n      throw new Error(`${modelName} has not been defined`);\n    }\n    return this.modelManager.getModel(modelName);\n  }\n  isDefined(modelName) {\n    return !!this.modelManager.models.find((model) => model.name === modelName);\n  }\n  async query(sql, options) {\n    options = __spreadValues(__spreadValues({}, this.options.query), options);\n    if (options.instance && !options.model) {\n      options.model = options.instance.constructor;\n    }\n    if (!options.instance && !options.model) {\n      options.raw = true;\n    }\n    if (options.mapToModel) {\n      options.fieldMap = _.get(options, \"model.fieldAttributeMap\", {});\n    }\n    options = _.defaults(options, {\n      logging: Object.prototype.hasOwnProperty.call(this.options, \"logging\") ? this.options.logging : console.log,\n      searchPath: Object.prototype.hasOwnProperty.call(this.options, \"searchPath\") ? this.options.searchPath : \"DEFAULT\"\n    });\n    if (!options.type) {\n      if (options.model || options.nest || options.plain) {\n        options.type = QueryTypes.SELECT;\n      } else {\n        options.type = QueryTypes.RAW;\n      }\n    }\n    if (!this.dialect.supports.searchPath || !this.options.dialectOptions || !this.options.dialectOptions.prependSearchPath || options.supportsSearchPath === false) {\n      delete options.searchPath;\n    } else if (!options.searchPath) {\n      options.searchPath = \"DEFAULT\";\n    }\n    if (typeof sql === \"object\") {\n      if (sql.values !== void 0) {\n        if (options.replacements !== void 0) {\n          throw new Error(\"Both `sql.values` and `options.replacements` cannot be set at the same time\");\n        }\n        options.replacements = sql.values;\n      }\n      if (sql.bind !== void 0) {\n        if (options.bind !== void 0) {\n          throw new Error(\"Both `sql.bind` and `options.bind` cannot be set at the same time\");\n        }\n        options.bind = sql.bind;\n      }\n      if (sql.query !== void 0) {\n        sql = sql.query;\n      }\n    }\n    sql = sql.trim();\n    if (options.replacements && options.bind) {\n      throw new Error(\"Both `replacements` and `bind` cannot be set at the same time\");\n    }\n    if (options.replacements) {\n      sql = injectReplacements(sql, this.dialect, options.replacements);\n    }\n    let bindParameters;\n    if (options.bind) {\n      [sql, bindParameters] = this.dialect.Query.formatBindParameters(sql, options.bind, this.options.dialect);\n    }\n    const checkTransaction = () => {\n      if (options.transaction && options.transaction.finished && !options.completesTransaction) {\n        const error = new Error(`${options.transaction.finished} has been called on this transaction(${options.transaction.id}), you can no longer use it. (The rejected query is attached as the 'sql' property of this error)`);\n        error.sql = sql;\n        throw error;\n      }\n    };\n    const retryOptions = __spreadValues(__spreadValues({}, this.options.retry), options.retry);\n    return retry(async () => {\n      if (options.transaction === void 0 && Sequelize._cls) {\n        options.transaction = Sequelize._cls.get(\"transaction\");\n      }\n      checkTransaction();\n      const connection = await (options.transaction ? options.transaction.connection : this.connectionManager.getConnection(options));\n      if (this.options.dialect === \"db2\" && options.alter) {\n        if (options.alter.drop === false) {\n          connection.dropTable = false;\n        }\n      }\n      const query = new this.dialect.Query(connection, this, options);\n      try {\n        await this.runHooks(\"beforeQuery\", options, query);\n        checkTransaction();\n        return await query.run(sql, bindParameters);\n      } finally {\n        await this.runHooks(\"afterQuery\", options, query);\n        if (!options.transaction) {\n          this.connectionManager.releaseConnection(connection);\n        }\n      }\n    }, retryOptions);\n  }\n  async set(variables, options) {\n    options = __spreadValues(__spreadValues({}, this.options.set), typeof options === \"object\" && options);\n    if (![\"mysql\", \"mariadb\"].includes(this.options.dialect)) {\n      throw new Error(\"sequelize.set is only supported for mysql or mariadb\");\n    }\n    if (!options.transaction || !(options.transaction instanceof Transaction)) {\n      throw new TypeError(\"options.transaction is required\");\n    }\n    options.raw = true;\n    options.plain = true;\n    options.type = \"SET\";\n    const query = `SET ${_.map(variables, (v, k) => `@${k} := ${typeof v === \"string\" ? `\"${v}\"` : v}`).join(\", \")}`;\n    return await this.query(query, options);\n  }\n  escape(value) {\n    return this.dialect.queryGenerator.escape(value);\n  }\n  async createSchema(schema, options) {\n    return await this.getQueryInterface().createSchema(schema, options);\n  }\n  async showAllSchemas(options) {\n    return await this.getQueryInterface().showAllSchemas(options);\n  }\n  async dropSchema(schema, options) {\n    return await this.getQueryInterface().dropSchema(schema, options);\n  }\n  async dropAllSchemas(options) {\n    return await this.getQueryInterface().dropAllSchemas(options);\n  }\n  async sync(options) {\n    options = __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, this.options), this.options.sync), options), {\n      hooks: options ? options.hooks !== false : true\n    });\n    if (options.match) {\n      if (!options.match.test(this.config.database)) {\n        throw new Error(`Database \"${this.config.database}\" does not match sync match parameter \"${options.match}\"`);\n      }\n    }\n    if (options.hooks) {\n      await this.runHooks(\"beforeBulkSync\", options);\n    }\n    if (options.force) {\n      await this.drop(options);\n    }\n    if (this.modelManager.models.length === 0) {\n      await this.authenticate(options);\n    } else {\n      const models = this.modelManager.getModelsTopoSortedByForeignKey();\n      if (models == null) {\n        return this._syncModelsWithCyclicReferences(options);\n      }\n      models.reverse();\n      for (const model of models) {\n        await model.sync(options);\n      }\n    }\n    if (options.hooks) {\n      await this.runHooks(\"afterBulkSync\", options);\n    }\n    return this;\n  }\n  async _syncModelsWithCyclicReferences(options) {\n    if (this.dialect.name === \"sqlite\") {\n      await withSqliteForeignKeysOff(this, options, async () => {\n        for (const model of this.modelManager.models) {\n          await model.sync(options);\n        }\n      });\n      return;\n    }\n    for (const model of this.modelManager.models) {\n      await model.sync(__spreadProps(__spreadValues({}, options), { withoutForeignKeyConstraints: true }));\n    }\n    for (const model of this.modelManager.models) {\n      await model.sync(__spreadProps(__spreadValues({}, options), { force: false, alter: true }));\n    }\n  }\n  async truncate(options) {\n    const sortedModels = this.modelManager.getModelsTopoSortedByForeignKey();\n    const models = sortedModels || this.modelManager.models;\n    const hasCyclicDependencies = sortedModels == null;\n    if (hasCyclicDependencies && (!options || !options.cascade)) {\n      throw new Error('Sequelize#truncate: Some of your models have cyclic references (foreign keys). You need to use the \"cascade\" option to be able to delete rows from models that have cyclic references.');\n    }\n    if (hasCyclicDependencies && this.dialect.name === \"sqlite\") {\n      return withSqliteForeignKeysOff(this, options, async () => {\n        await Promise.all(models.map((model) => model.truncate(options)));\n      });\n    }\n    if (options && options.cascade) {\n      for (const model of models)\n        await model.truncate(options);\n    } else {\n      await Promise.all(models.map((model) => model.truncate(options)));\n    }\n  }\n  async drop(options) {\n    if (options && options.cascade) {\n      for (const model of this.modelManager.models) {\n        await model.drop(options);\n      }\n    }\n    const sortedModels = this.modelManager.getModelsTopoSortedByForeignKey();\n    if (sortedModels) {\n      for (const model of sortedModels) {\n        await model.drop(options);\n      }\n    }\n    if (this.dialect.name === \"sqlite\") {\n      await withSqliteForeignKeysOff(this, options, async () => {\n        for (const model of this.modelManager.models) {\n          await model.drop(options);\n        }\n      });\n      return;\n    }\n    for (const model of this.modelManager.models) {\n      const tableName = model.getTableName();\n      const foreignKeys = await this.queryInterface.getForeignKeyReferencesForTable(tableName, options);\n      await Promise.all(foreignKeys.map((foreignKey) => {\n        return this.queryInterface.removeConstraint(tableName, foreignKey.constraintName, options);\n      }));\n    }\n    for (const model of this.modelManager.models) {\n      await model.drop(options);\n    }\n  }\n  async authenticate(options) {\n    options = __spreadValues({\n      raw: true,\n      plain: true,\n      type: QueryTypes.SELECT\n    }, options);\n    await this.query(this.dialect.queryGenerator.authTestQuery(), options);\n    return;\n  }\n  async databaseVersion(options) {\n    return await this.getQueryInterface().databaseVersion(options);\n  }\n  random() {\n    if ([\"postgres\", \"sqlite\", \"snowflake\"].includes(this.getDialect())) {\n      return this.fn(\"RANDOM\");\n    }\n    return this.fn(\"RAND\");\n  }\n  static fn(fn, ...args) {\n    return new Utils.Fn(fn, args);\n  }\n  static col(col) {\n    return new Utils.Col(col);\n  }\n  static cast(val, type) {\n    return new Utils.Cast(val, type);\n  }\n  static literal(val) {\n    return new Utils.Literal(val);\n  }\n  static and(...args) {\n    return { [Op.and]: args };\n  }\n  static or(...args) {\n    return { [Op.or]: args };\n  }\n  static json(conditionsOrPath, value) {\n    return new Utils.Json(conditionsOrPath, value);\n  }\n  static where(attr, comparator, logic) {\n    return new Utils.Where(attr, comparator, logic);\n  }\n  async transaction(options, autoCallback) {\n    if (typeof options === \"function\") {\n      autoCallback = options;\n      options = void 0;\n    }\n    const transaction = new Transaction(this, options);\n    if (!autoCallback) {\n      await transaction.prepareEnvironment(false);\n      return transaction;\n    }\n    return Sequelize._clsRun(async () => {\n      await transaction.prepareEnvironment(true);\n      let result;\n      try {\n        result = await autoCallback(transaction);\n      } catch (err) {\n        try {\n          await transaction.rollback();\n        } catch (ignore) {\n        }\n        throw err;\n      }\n      await transaction.commit();\n      return result;\n    });\n  }\n  static useCLS(ns) {\n    if (!ns || typeof ns !== \"object\" || typeof ns.bind !== \"function\" || typeof ns.run !== \"function\")\n      throw new Error(\"Must provide CLS namespace\");\n    Sequelize._cls = ns;\n    return this;\n  }\n  static _clsRun(fn) {\n    const ns = Sequelize._cls;\n    if (!ns)\n      return fn();\n    let res;\n    ns.run((context) => res = fn(context));\n    return res;\n  }\n  log(...args) {\n    let options;\n    const last = _.last(args);\n    if (last && _.isPlainObject(last) && Object.prototype.hasOwnProperty.call(last, \"logging\")) {\n      options = last;\n      if (options.logging === console.log) {\n        args.splice(args.length - 1, 1);\n      }\n    } else {\n      options = this.options;\n    }\n    if (options.logging) {\n      if (options.logging === true) {\n        deprecations.noTrueLogging();\n        options.logging = console.log;\n      }\n      if ((this.options.benchmark || options.benchmark) && options.logging === console.log) {\n        args = [`${args[0]} Elapsed time: ${args[1]}ms`];\n      }\n      options.logging(...args);\n    }\n  }\n  close() {\n    return this.connectionManager.close();\n  }\n  normalizeDataType(Type) {\n    let type = typeof Type === \"function\" ? new Type() : Type;\n    const dialectTypes = this.dialect.DataTypes || {};\n    if (dialectTypes[type.key]) {\n      type = dialectTypes[type.key].extend(type);\n    }\n    if (type instanceof DataTypes.ARRAY) {\n      if (!type.type) {\n        throw new Error(\"ARRAY is missing type definition for its values.\");\n      }\n      if (dialectTypes[type.type.key]) {\n        type.type = dialectTypes[type.type.key].extend(type.type);\n      }\n    }\n    return type;\n  }\n  normalizeAttribute(attribute) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = { type: attribute };\n    }\n    if (!attribute.type)\n      return attribute;\n    attribute.type = this.normalizeDataType(attribute.type);\n    if (Object.prototype.hasOwnProperty.call(attribute, \"defaultValue\")) {\n      if (typeof attribute.defaultValue === \"function\" && [DataTypes.NOW, DataTypes.UUIDV1, DataTypes.UUIDV4].includes(attribute.defaultValue)) {\n        attribute.defaultValue = new attribute.defaultValue();\n      }\n    }\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.values) {\n        attribute.type.values = attribute.type.options.values = attribute.values;\n      } else {\n        attribute.values = attribute.type.values;\n      }\n      if (!attribute.values.length) {\n        throw new Error(\"Values for ENUM have not been defined.\");\n      }\n    }\n    return attribute;\n  }\n}\nSequelize.prototype.fn = Sequelize.fn;\nSequelize.prototype.col = Sequelize.col;\nSequelize.prototype.cast = Sequelize.cast;\nSequelize.prototype.literal = Sequelize.literal;\nSequelize.prototype.and = Sequelize.and;\nSequelize.prototype.or = Sequelize.or;\nSequelize.prototype.json = Sequelize.json;\nSequelize.prototype.where = Sequelize.where;\nSequelize.prototype.validate = Sequelize.prototype.authenticate;\nObject.defineProperty(Sequelize, \"version\", {\n  enumerable: true,\n  get() {\n    return (__webpack_require__(/*! ../package.json */ \"(action-browser)/../node_modules/sequelize/package.json\").version);\n  }\n});\nSequelize.options = { hooks: {} };\nSequelize.Utils = Utils;\nSequelize.Op = Op;\nSequelize.TableHints = TableHints;\nSequelize.IndexHints = IndexHints;\nSequelize.Transaction = Transaction;\nSequelize.prototype.Sequelize = Sequelize;\nSequelize.prototype.QueryTypes = Sequelize.QueryTypes = QueryTypes;\nSequelize.prototype.Validator = Sequelize.Validator = Validator;\nSequelize.Model = Model;\nSequelize.QueryInterface = QueryInterface;\nSequelize.BelongsTo = BelongsTo;\nSequelize.HasOne = HasOne;\nSequelize.HasMany = HasMany;\nSequelize.BelongsToMany = BelongsToMany;\nSequelize.DataTypes = DataTypes;\nfor (const dataType in DataTypes) {\n  Sequelize[dataType] = DataTypes[dataType];\n}\nSequelize.Deferrable = Deferrable;\nSequelize.prototype.Association = Sequelize.Association = Association;\nSequelize.useInflection = Utils.useInflection;\nHooks.applyTo(Sequelize);\nHooks.applyTo(Sequelize.prototype);\nSequelize.Error = sequelizeErrors.BaseError;\nfor (const error of Object.keys(sequelizeErrors)) {\n  Sequelize[error] = sequelizeErrors[error];\n}\nmodule.exports = Sequelize;\nmodule.exports.Sequelize = Sequelize;\nmodule.exports[\"default\"] = Sequelize;\n//# sourceMappingURL=sequelize.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9zZXF1ZWxpemUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQiwyQkFBMkIsbUJBQU8sQ0FBQyw0RkFBc0I7QUFDekQsY0FBYyw2SEFBb0M7QUFDbEQsVUFBVSxtQkFBTyxDQUFDLGlFQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyx3RUFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsd0VBQVM7QUFDL0Isa0JBQWtCLG1CQUFPLENBQUMsa0ZBQWM7QUFDeEMsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQWM7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsd0ZBQWlCO0FBQzlDLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFlO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLG9GQUFlO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLG9GQUFlO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLG9GQUFlO0FBQzFDLHdCQUF3QixtQkFBTyxDQUFDLGdGQUFVO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyx3RUFBUztBQUMvQixvQkFBb0IsbUJBQU8sQ0FBQyxrR0FBc0I7QUFDbEQsa0JBQWtCLDJJQUE2QztBQUMvRCxXQUFXLG1CQUFPLENBQUMsZ0ZBQWE7QUFDaEMscUJBQXFCLG1CQUFPLENBQUMsa0dBQXNCO0FBQ25ELFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyxnSUFBcUM7QUFDeEUsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyw0R0FBMkI7QUFDekQsZUFBZSxtQkFBTyxDQUFDLHNHQUF3QjtBQUMvQyxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsc0hBQWdDO0FBQ2xFLFFBQVEsVUFBVSxFQUFFLG1CQUFPLENBQUMsd0dBQXlCO0FBQ3JELFFBQVEsMkJBQTJCLEVBQUUsbUJBQU8sQ0FBQyxzSEFBZ0M7QUFDN0UsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLGdGQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLG9HQUFvQjtBQUM5QztBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsZ0dBQWtCO0FBQzVDO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxnR0FBa0I7QUFDNUM7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLGtHQUFtQjtBQUM3QztBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsc0dBQXFCO0FBQy9DO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxrR0FBbUI7QUFDN0M7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDRGQUFnQjtBQUMxQztBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsd0dBQXNCO0FBQ2hEO0FBQ0E7QUFDQSx1Q0FBdUMsbUJBQW1CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOEJBQThCLHNDQUFzQyx1QkFBdUI7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwrQkFBK0IsR0FBRyxLQUFLLDRCQUE0QixFQUFFLE9BQU8sY0FBYztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUIseUNBQXlDLGNBQWM7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsY0FBYyxvQ0FBb0M7QUFDeEc7QUFDQTtBQUNBLHNEQUFzRCxjQUFjLDJCQUEyQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUyxnQkFBZ0IsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrR0FBa0M7QUFDN0M7QUFDQSxDQUFDO0FBQ0Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9zZXF1ZWxpemUuanM/YjkzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xuY29uc3QgdXJsID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IHBnQ29ubmVjdGlvblN0cmluZyA9IHJlcXVpcmUoXCJwZy1jb25uZWN0aW9uLXN0cmluZ1wiKTtcbmNvbnN0IHJldHJ5ID0gcmVxdWlyZShcInJldHJ5LWFzLXByb21pc2VkXCIpLmRlZmF1bHQ7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBNb2RlbCA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4vZGF0YS10eXBlc1wiKTtcbmNvbnN0IERlZmVycmFibGUgPSByZXF1aXJlKFwiLi9kZWZlcnJhYmxlXCIpO1xuY29uc3QgTW9kZWxNYW5hZ2VyID0gcmVxdWlyZShcIi4vbW9kZWwtbWFuYWdlclwiKTtcbmNvbnN0IFRyYW5zYWN0aW9uID0gcmVxdWlyZShcIi4vdHJhbnNhY3Rpb25cIik7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZShcIi4vcXVlcnktdHlwZXNcIik7XG5jb25zdCBUYWJsZUhpbnRzID0gcmVxdWlyZShcIi4vdGFibGUtaGludHNcIik7XG5jb25zdCBJbmRleEhpbnRzID0gcmVxdWlyZShcIi4vaW5kZXgtaGludHNcIik7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBIb29rcyA9IHJlcXVpcmUoXCIuL2hvb2tzXCIpO1xuY29uc3QgQXNzb2NpYXRpb24gPSByZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvaW5kZXhcIik7XG5jb25zdCBWYWxpZGF0b3IgPSByZXF1aXJlKFwiLi91dGlscy92YWxpZGF0b3ItZXh0cmFzXCIpLnZhbGlkYXRvcjtcbmNvbnN0IE9wID0gcmVxdWlyZShcIi4vb3BlcmF0b3JzXCIpO1xuY29uc3QgZGVwcmVjYXRpb25zID0gcmVxdWlyZShcIi4vdXRpbHMvZGVwcmVjYXRpb25zXCIpO1xuY29uc3QgeyBRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZShcIi4vZGlhbGVjdHMvYWJzdHJhY3QvcXVlcnktaW50ZXJmYWNlXCIpO1xuY29uc3QgeyBCZWxvbmdzVG8gfSA9IHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvXCIpO1xuY29uc3QgSGFzT25lID0gcmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL2hhcy1vbmVcIik7XG5jb25zdCB7IEJlbG9uZ3NUb01hbnkgfSA9IHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvLW1hbnlcIik7XG5jb25zdCB7IEhhc01hbnkgfSA9IHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9oYXMtbWFueVwiKTtcbmNvbnN0IHsgd2l0aFNxbGl0ZUZvcmVpZ25LZXlzT2ZmIH0gPSByZXF1aXJlKFwiLi9kaWFsZWN0cy9zcWxpdGUvc3FsaXRlLXV0aWxzXCIpO1xuY29uc3QgeyBpbmplY3RSZXBsYWNlbWVudHMgfSA9IHJlcXVpcmUoXCIuL3V0aWxzL3NxbFwiKTtcbmNsYXNzIFNlcXVlbGl6ZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGFiYXNlLCB1c2VybmFtZSwgcGFzc3dvcmQsIG9wdGlvbnMpIHtcbiAgICBsZXQgY29uZmlnO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBkYXRhYmFzZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgb3B0aW9ucyA9IGRhdGFiYXNlO1xuICAgICAgY29uZmlnID0gXy5waWNrKG9wdGlvbnMsIFwiaG9zdFwiLCBcInBvcnRcIiwgXCJkYXRhYmFzZVwiLCBcInVzZXJuYW1lXCIsIFwicGFzc3dvcmRcIik7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBkYXRhYmFzZSA9PT0gXCJzdHJpbmdcIiB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiB1c2VybmFtZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uZmlnID0ge307XG4gICAgICBvcHRpb25zID0gdXNlcm5hbWUgfHwge307XG4gICAgICBjb25zdCB1cmxQYXJ0cyA9IHVybC5wYXJzZShhcmd1bWVudHNbMF0sIHRydWUpO1xuICAgICAgb3B0aW9ucy5kaWFsZWN0ID0gdXJsUGFydHMucHJvdG9jb2wucmVwbGFjZSgvOiQvLCBcIlwiKTtcbiAgICAgIG9wdGlvbnMuaG9zdCA9IHVybFBhcnRzLmhvc3RuYW1lO1xuICAgICAgaWYgKG9wdGlvbnMuZGlhbGVjdCA9PT0gXCJzcWxpdGVcIiAmJiB1cmxQYXJ0cy5wYXRobmFtZSAmJiAhdXJsUGFydHMucGF0aG5hbWUuc3RhcnRzV2l0aChcIi86bWVtb3J5XCIpKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VQYXRoID0gcGF0aC5qb2luKG9wdGlvbnMuaG9zdCwgdXJsUGFydHMucGF0aG5hbWUpO1xuICAgICAgICBvcHRpb25zLnN0b3JhZ2UgPSBwYXRoLnJlc29sdmUob3B0aW9ucy5zdG9yYWdlIHx8IHN0b3JhZ2VQYXRoKTtcbiAgICAgIH1cbiAgICAgIGlmICh1cmxQYXJ0cy5wYXRobmFtZSkge1xuICAgICAgICBjb25maWcuZGF0YWJhc2UgPSB1cmxQYXJ0cy5wYXRobmFtZS5yZXBsYWNlKC9eXFwvLywgXCJcIik7XG4gICAgICB9XG4gICAgICBpZiAodXJsUGFydHMucG9ydCkge1xuICAgICAgICBvcHRpb25zLnBvcnQgPSB1cmxQYXJ0cy5wb3J0O1xuICAgICAgfVxuICAgICAgaWYgKHVybFBhcnRzLmF1dGgpIHtcbiAgICAgICAgY29uc3QgYXV0aFBhcnRzID0gdXJsUGFydHMuYXV0aC5zcGxpdChcIjpcIik7XG4gICAgICAgIGNvbmZpZy51c2VybmFtZSA9IGF1dGhQYXJ0c1swXTtcbiAgICAgICAgaWYgKGF1dGhQYXJ0cy5sZW5ndGggPiAxKVxuICAgICAgICAgIGNvbmZpZy5wYXNzd29yZCA9IGF1dGhQYXJ0cy5zbGljZSgxKS5qb2luKFwiOlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh1cmxQYXJ0cy5xdWVyeSkge1xuICAgICAgICBpZiAodXJsUGFydHMucXVlcnkuaG9zdCkge1xuICAgICAgICAgIG9wdGlvbnMuaG9zdCA9IHVybFBhcnRzLnF1ZXJ5Lmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZGlhbGVjdE9wdGlvbnMpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMuZGlhbGVjdE9wdGlvbnMsIHVybFBhcnRzLnF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLmRpYWxlY3RPcHRpb25zID0gdXJsUGFydHMucXVlcnk7XG4gICAgICAgICAgaWYgKHVybFBhcnRzLnF1ZXJ5Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IG8gPSBKU09OLnBhcnNlKHVybFBhcnRzLnF1ZXJ5Lm9wdGlvbnMpO1xuICAgICAgICAgICAgICBvcHRpb25zLmRpYWxlY3RPcHRpb25zLm9wdGlvbnMgPSBvO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKFtcInBvc3RncmVzXCIsIFwicG9zdGdyZXNxbFwiXS5pbmNsdWRlcyhvcHRpb25zLmRpYWxlY3QpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucy5kaWFsZWN0T3B0aW9ucywgcGdDb25uZWN0aW9uU3RyaW5nLnBhcnNlKGFyZ3VtZW50c1swXSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIGNvbmZpZyA9IHsgZGF0YWJhc2UsIHVzZXJuYW1lLCBwYXNzd29yZCB9O1xuICAgIH1cbiAgICBTZXF1ZWxpemUucnVuSG9va3MoXCJiZWZvcmVJbml0XCIsIGNvbmZpZywgb3B0aW9ucyk7XG4gICAgdGhpcy5vcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgZGlhbGVjdDogbnVsbCxcbiAgICAgIGRpYWxlY3RNb2R1bGU6IG51bGwsXG4gICAgICBkaWFsZWN0TW9kdWxlUGF0aDogbnVsbCxcbiAgICAgIGhvc3Q6IFwibG9jYWxob3N0XCIsXG4gICAgICBwcm90b2NvbDogXCJ0Y3BcIixcbiAgICAgIGRlZmluZToge30sXG4gICAgICBxdWVyeToge30sXG4gICAgICBzeW5jOiB7fSxcbiAgICAgIHRpbWV6b25lOiBcIiswMDowMFwiLFxuICAgICAgc3RhbmRhcmRDb25mb3JtaW5nU3RyaW5nczogdHJ1ZSxcbiAgICAgIGxvZ2dpbmc6IGNvbnNvbGUubG9nLFxuICAgICAgb21pdE51bGw6IGZhbHNlLFxuICAgICAgbmF0aXZlOiBmYWxzZSxcbiAgICAgIHJlcGxpY2F0aW9uOiBmYWxzZSxcbiAgICAgIHNzbDogdm9pZCAwLFxuICAgICAgcG9vbDoge30sXG4gICAgICBxdW90ZUlkZW50aWZpZXJzOiB0cnVlLFxuICAgICAgaG9va3M6IHt9LFxuICAgICAgcmV0cnk6IHtcbiAgICAgICAgbWF4OiA1LFxuICAgICAgICBtYXRjaDogW1xuICAgICAgICAgIFwiU1FMSVRFX0JVU1k6IGRhdGFiYXNlIGlzIGxvY2tlZFwiXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB0cmFuc2FjdGlvblR5cGU6IFRyYW5zYWN0aW9uLlRZUEVTLkRFRkVSUkVELFxuICAgICAgaXNvbGF0aW9uTGV2ZWw6IG51bGwsXG4gICAgICBkYXRhYmFzZVZlcnNpb246IDAsXG4gICAgICB0eXBlVmFsaWRhdGlvbjogZmFsc2UsXG4gICAgICBiZW5jaG1hcms6IGZhbHNlLFxuICAgICAgbWluaWZ5QWxpYXNlczogZmFsc2UsXG4gICAgICBsb2dRdWVyeVBhcmFtZXRlcnM6IGZhbHNlLFxuICAgICAgYXR0cmlidXRlQmVoYXZpb3I6IFwidGhyb3dcIlxuICAgIH0sIG9wdGlvbnMpO1xuICAgIGlmICghdGhpcy5vcHRpb25zLmRpYWxlY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpYWxlY3QgbmVlZHMgdG8gYmUgZXhwbGljaXRseSBzdXBwbGllZCBhcyBvZiB2NC4wLjBcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlhbGVjdCA9PT0gXCJwb3N0Z3Jlc3FsXCIpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5kaWFsZWN0ID0gXCJwb3N0Z3Jlc1wiO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmRpYWxlY3QgPT09IFwic3FsaXRlXCIgJiYgdGhpcy5vcHRpb25zLnRpbWV6b25lICE9PSBcIiswMDowMFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXR0aW5nIGEgY3VzdG9tIHRpbWV6b25lIGlzIG5vdCBzdXBwb3J0ZWQgYnkgU1FMaXRlLCBkYXRlcyBhcmUgYWx3YXlzIHJldHVybmVkIGFzIFVUQy4gUGxlYXNlIHJlbW92ZSB0aGUgY3VzdG9tIHRpbWV6b25lIHBhcmFtZXRlci5cIik7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMubG9nZ2luZyA9PT0gdHJ1ZSkge1xuICAgICAgZGVwcmVjYXRpb25zLm5vVHJ1ZUxvZ2dpbmcoKTtcbiAgICAgIHRoaXMub3B0aW9ucy5sb2dnaW5nID0gY29uc29sZS5sb2c7XG4gICAgfVxuICAgIHRoaXMuX3NldHVwSG9va3Mob3B0aW9ucy5ob29rcyk7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICBkYXRhYmFzZTogY29uZmlnLmRhdGFiYXNlIHx8IHRoaXMub3B0aW9ucy5kYXRhYmFzZSxcbiAgICAgIHVzZXJuYW1lOiBjb25maWcudXNlcm5hbWUgfHwgdGhpcy5vcHRpb25zLnVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmQ6IGNvbmZpZy5wYXNzd29yZCB8fCB0aGlzLm9wdGlvbnMucGFzc3dvcmQgfHwgbnVsbCxcbiAgICAgIGhvc3Q6IGNvbmZpZy5ob3N0IHx8IHRoaXMub3B0aW9ucy5ob3N0LFxuICAgICAgcG9ydDogY29uZmlnLnBvcnQgfHwgdGhpcy5vcHRpb25zLnBvcnQsXG4gICAgICBwb29sOiB0aGlzLm9wdGlvbnMucG9vbCxcbiAgICAgIHByb3RvY29sOiB0aGlzLm9wdGlvbnMucHJvdG9jb2wsXG4gICAgICBuYXRpdmU6IHRoaXMub3B0aW9ucy5uYXRpdmUsXG4gICAgICBzc2w6IHRoaXMub3B0aW9ucy5zc2wsXG4gICAgICByZXBsaWNhdGlvbjogdGhpcy5vcHRpb25zLnJlcGxpY2F0aW9uLFxuICAgICAgZGlhbGVjdE1vZHVsZTogdGhpcy5vcHRpb25zLmRpYWxlY3RNb2R1bGUsXG4gICAgICBkaWFsZWN0TW9kdWxlUGF0aDogdGhpcy5vcHRpb25zLmRpYWxlY3RNb2R1bGVQYXRoLFxuICAgICAga2VlcERlZmF1bHRUaW1lem9uZTogdGhpcy5vcHRpb25zLmtlZXBEZWZhdWx0VGltZXpvbmUsXG4gICAgICBkaWFsZWN0T3B0aW9uczogdGhpcy5vcHRpb25zLmRpYWxlY3RPcHRpb25zXG4gICAgfTtcbiAgICBsZXQgRGlhbGVjdDtcbiAgICBzd2l0Y2ggKHRoaXMuZ2V0RGlhbGVjdCgpKSB7XG4gICAgICBjYXNlIFwibWFyaWFkYlwiOlxuICAgICAgICBEaWFsZWN0ID0gcmVxdWlyZShcIi4vZGlhbGVjdHMvbWFyaWFkYlwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibXNzcWxcIjpcbiAgICAgICAgRGlhbGVjdCA9IHJlcXVpcmUoXCIuL2RpYWxlY3RzL21zc3FsXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJteXNxbFwiOlxuICAgICAgICBEaWFsZWN0ID0gcmVxdWlyZShcIi4vZGlhbGVjdHMvbXlzcWxcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm9yYWNsZVwiOlxuICAgICAgICBEaWFsZWN0ID0gcmVxdWlyZShcIi4vZGlhbGVjdHMvb3JhY2xlXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwb3N0Z3Jlc1wiOlxuICAgICAgICBEaWFsZWN0ID0gcmVxdWlyZShcIi4vZGlhbGVjdHMvcG9zdGdyZXNcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNxbGl0ZVwiOlxuICAgICAgICBEaWFsZWN0ID0gcmVxdWlyZShcIi4vZGlhbGVjdHMvc3FsaXRlXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkYjJcIjpcbiAgICAgICAgRGlhbGVjdCA9IHJlcXVpcmUoXCIuL2RpYWxlY3RzL2RiMlwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic25vd2ZsYWtlXCI6XG4gICAgICAgIERpYWxlY3QgPSByZXF1aXJlKFwiLi9kaWFsZWN0cy9zbm93Zmxha2VcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZGlhbGVjdCAke3RoaXMuZ2V0RGlhbGVjdCgpfSBpcyBub3Qgc3VwcG9ydGVkLiBTdXBwb3J0ZWQgZGlhbGVjdHM6IG1zc3FsLCBtYXJpYWRiLCBteXNxbCwgb3JhY2xlLCBwb3N0Z3JlcywgZGIyIGFuZCBzcWxpdGUuYCk7XG4gICAgfVxuICAgIHRoaXMuZGlhbGVjdCA9IG5ldyBEaWFsZWN0KHRoaXMpO1xuICAgIHRoaXMuZGlhbGVjdC5xdWVyeUdlbmVyYXRvci50eXBlVmFsaWRhdGlvbiA9IG9wdGlvbnMudHlwZVZhbGlkYXRpb247XG4gICAgaWYgKF8uaXNQbGFpbk9iamVjdCh0aGlzLm9wdGlvbnMub3BlcmF0b3JzQWxpYXNlcykpIHtcbiAgICAgIGRlcHJlY2F0aW9ucy5ub1N0cmluZ09wZXJhdG9ycygpO1xuICAgICAgdGhpcy5kaWFsZWN0LnF1ZXJ5R2VuZXJhdG9yLnNldE9wZXJhdG9yc0FsaWFzZXModGhpcy5vcHRpb25zLm9wZXJhdG9yc0FsaWFzZXMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vcGVyYXRvcnNBbGlhc2VzID09PSBcImJvb2xlYW5cIikge1xuICAgICAgZGVwcmVjYXRpb25zLm5vQm9vbE9wZXJhdG9yQWxpYXNlcygpO1xuICAgIH1cbiAgICB0aGlzLnF1ZXJ5SW50ZXJmYWNlID0gdGhpcy5kaWFsZWN0LnF1ZXJ5SW50ZXJmYWNlO1xuICAgIHRoaXMubW9kZWxzID0ge307XG4gICAgdGhpcy5tb2RlbE1hbmFnZXIgPSBuZXcgTW9kZWxNYW5hZ2VyKHRoaXMpO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSB0aGlzLmRpYWxlY3QuY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgU2VxdWVsaXplLnJ1bkhvb2tzKFwiYWZ0ZXJJbml0XCIsIHRoaXMpO1xuICB9XG4gIHJlZnJlc2hUeXBlcygpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hUeXBlUGFyc2VyKERhdGFUeXBlcyk7XG4gIH1cbiAgZ2V0RGlhbGVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmRpYWxlY3Q7XG4gIH1cbiAgZ2V0RGF0YWJhc2VOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5kYXRhYmFzZTtcbiAgfVxuICBnZXRRdWVyeUludGVyZmFjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeUludGVyZmFjZTtcbiAgfVxuICBkZWZpbmUobW9kZWxOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zLm1vZGVsTmFtZSA9IG1vZGVsTmFtZTtcbiAgICBvcHRpb25zLnNlcXVlbGl6ZSA9IHRoaXM7XG4gICAgY29uc3QgbW9kZWwgPSBjbGFzcyBleHRlbmRzIE1vZGVsIHtcbiAgICB9O1xuICAgIG1vZGVsLmluaXQoYXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIG1vZGVsKG1vZGVsTmFtZSkge1xuICAgIGlmICghdGhpcy5pc0RlZmluZWQobW9kZWxOYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke21vZGVsTmFtZX0gaGFzIG5vdCBiZWVuIGRlZmluZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubW9kZWxNYW5hZ2VyLmdldE1vZGVsKG1vZGVsTmFtZSk7XG4gIH1cbiAgaXNEZWZpbmVkKG1vZGVsTmFtZSkge1xuICAgIHJldHVybiAhIXRoaXMubW9kZWxNYW5hZ2VyLm1vZGVscy5maW5kKChtb2RlbCkgPT4gbW9kZWwubmFtZSA9PT0gbW9kZWxOYW1lKTtcbiAgfVxuICBhc3luYyBxdWVyeShzcWwsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMub3B0aW9ucy5xdWVyeSksIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmluc3RhbmNlICYmICFvcHRpb25zLm1vZGVsKSB7XG4gICAgICBvcHRpb25zLm1vZGVsID0gb3B0aW9ucy5pbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmluc3RhbmNlICYmICFvcHRpb25zLm1vZGVsKSB7XG4gICAgICBvcHRpb25zLnJhdyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm1hcFRvTW9kZWwpIHtcbiAgICAgIG9wdGlvbnMuZmllbGRNYXAgPSBfLmdldChvcHRpb25zLCBcIm1vZGVsLmZpZWxkQXR0cmlidXRlTWFwXCIsIHt9KTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgbG9nZ2luZzogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMub3B0aW9ucywgXCJsb2dnaW5nXCIpID8gdGhpcy5vcHRpb25zLmxvZ2dpbmcgOiBjb25zb2xlLmxvZyxcbiAgICAgIHNlYXJjaFBhdGg6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm9wdGlvbnMsIFwic2VhcmNoUGF0aFwiKSA/IHRoaXMub3B0aW9ucy5zZWFyY2hQYXRoIDogXCJERUZBVUxUXCJcbiAgICB9KTtcbiAgICBpZiAoIW9wdGlvbnMudHlwZSkge1xuICAgICAgaWYgKG9wdGlvbnMubW9kZWwgfHwgb3B0aW9ucy5uZXN0IHx8IG9wdGlvbnMucGxhaW4pIHtcbiAgICAgICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5TRUxFQ1Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLlJBVztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLmRpYWxlY3Quc3VwcG9ydHMuc2VhcmNoUGF0aCB8fCAhdGhpcy5vcHRpb25zLmRpYWxlY3RPcHRpb25zIHx8ICF0aGlzLm9wdGlvbnMuZGlhbGVjdE9wdGlvbnMucHJlcGVuZFNlYXJjaFBhdGggfHwgb3B0aW9ucy5zdXBwb3J0c1NlYXJjaFBhdGggPT09IGZhbHNlKSB7XG4gICAgICBkZWxldGUgb3B0aW9ucy5zZWFyY2hQYXRoO1xuICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuc2VhcmNoUGF0aCkge1xuICAgICAgb3B0aW9ucy5zZWFyY2hQYXRoID0gXCJERUZBVUxUXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3FsID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAoc3FsLnZhbHVlcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnJlcGxhY2VtZW50cyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm90aCBgc3FsLnZhbHVlc2AgYW5kIGBvcHRpb25zLnJlcGxhY2VtZW50c2AgY2Fubm90IGJlIHNldCBhdCB0aGUgc2FtZSB0aW1lXCIpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMucmVwbGFjZW1lbnRzID0gc3FsLnZhbHVlcztcbiAgICAgIH1cbiAgICAgIGlmIChzcWwuYmluZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmJpbmQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJvdGggYHNxbC5iaW5kYCBhbmQgYG9wdGlvbnMuYmluZGAgY2Fubm90IGJlIHNldCBhdCB0aGUgc2FtZSB0aW1lXCIpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuYmluZCA9IHNxbC5iaW5kO1xuICAgICAgfVxuICAgICAgaWYgKHNxbC5xdWVyeSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHNxbCA9IHNxbC5xdWVyeTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3FsID0gc3FsLnRyaW0oKTtcbiAgICBpZiAob3B0aW9ucy5yZXBsYWNlbWVudHMgJiYgb3B0aW9ucy5iaW5kKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb3RoIGByZXBsYWNlbWVudHNgIGFuZCBgYmluZGAgY2Fubm90IGJlIHNldCBhdCB0aGUgc2FtZSB0aW1lXCIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZXBsYWNlbWVudHMpIHtcbiAgICAgIHNxbCA9IGluamVjdFJlcGxhY2VtZW50cyhzcWwsIHRoaXMuZGlhbGVjdCwgb3B0aW9ucy5yZXBsYWNlbWVudHMpO1xuICAgIH1cbiAgICBsZXQgYmluZFBhcmFtZXRlcnM7XG4gICAgaWYgKG9wdGlvbnMuYmluZCkge1xuICAgICAgW3NxbCwgYmluZFBhcmFtZXRlcnNdID0gdGhpcy5kaWFsZWN0LlF1ZXJ5LmZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgb3B0aW9ucy5iaW5kLCB0aGlzLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGNoZWNrVHJhbnNhY3Rpb24gPSAoKSA9PiB7XG4gICAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiAmJiBvcHRpb25zLnRyYW5zYWN0aW9uLmZpbmlzaGVkICYmICFvcHRpb25zLmNvbXBsZXRlc1RyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGAke29wdGlvbnMudHJhbnNhY3Rpb24uZmluaXNoZWR9IGhhcyBiZWVuIGNhbGxlZCBvbiB0aGlzIHRyYW5zYWN0aW9uKCR7b3B0aW9ucy50cmFuc2FjdGlvbi5pZH0pLCB5b3UgY2FuIG5vIGxvbmdlciB1c2UgaXQuIChUaGUgcmVqZWN0ZWQgcXVlcnkgaXMgYXR0YWNoZWQgYXMgdGhlICdzcWwnIHByb3BlcnR5IG9mIHRoaXMgZXJyb3IpYCk7XG4gICAgICAgIGVycm9yLnNxbCA9IHNxbDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZXRyeU9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5vcHRpb25zLnJldHJ5KSwgb3B0aW9ucy5yZXRyeSk7XG4gICAgcmV0dXJuIHJldHJ5KGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uID09PSB2b2lkIDAgJiYgU2VxdWVsaXplLl9jbHMpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbiA9IFNlcXVlbGl6ZS5fY2xzLmdldChcInRyYW5zYWN0aW9uXCIpO1xuICAgICAgfVxuICAgICAgY2hlY2tUcmFuc2FjdGlvbigpO1xuICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IChvcHRpb25zLnRyYW5zYWN0aW9uID8gb3B0aW9ucy50cmFuc2FjdGlvbi5jb25uZWN0aW9uIDogdGhpcy5jb25uZWN0aW9uTWFuYWdlci5nZXRDb25uZWN0aW9uKG9wdGlvbnMpKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlhbGVjdCA9PT0gXCJkYjJcIiAmJiBvcHRpb25zLmFsdGVyKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFsdGVyLmRyb3AgPT09IGZhbHNlKSB7XG4gICAgICAgICAgY29ubmVjdGlvbi5kcm9wVGFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcXVlcnkgPSBuZXcgdGhpcy5kaWFsZWN0LlF1ZXJ5KGNvbm5lY3Rpb24sIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcyhcImJlZm9yZVF1ZXJ5XCIsIG9wdGlvbnMsIHF1ZXJ5KTtcbiAgICAgICAgY2hlY2tUcmFuc2FjdGlvbigpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcXVlcnkucnVuKHNxbCwgYmluZFBhcmFtZXRlcnMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcyhcImFmdGVyUXVlcnlcIiwgb3B0aW9ucywgcXVlcnkpO1xuICAgICAgICBpZiAoIW9wdGlvbnMudHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlbGVhc2VDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgcmV0cnlPcHRpb25zKTtcbiAgfVxuICBhc3luYyBzZXQodmFyaWFibGVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLm9wdGlvbnMuc2V0KSwgdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucyk7XG4gICAgaWYgKCFbXCJteXNxbFwiLCBcIm1hcmlhZGJcIl0uaW5jbHVkZXModGhpcy5vcHRpb25zLmRpYWxlY3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXF1ZWxpemUuc2V0IGlzIG9ubHkgc3VwcG9ydGVkIGZvciBteXNxbCBvciBtYXJpYWRiXCIpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMudHJhbnNhY3Rpb24gfHwgIShvcHRpb25zLnRyYW5zYWN0aW9uIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwib3B0aW9ucy50cmFuc2FjdGlvbiBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICAgIG9wdGlvbnMucGxhaW4gPSB0cnVlO1xuICAgIG9wdGlvbnMudHlwZSA9IFwiU0VUXCI7XG4gICAgY29uc3QgcXVlcnkgPSBgU0VUICR7Xy5tYXAodmFyaWFibGVzLCAodiwgaykgPT4gYEAke2t9IDo9ICR7dHlwZW9mIHYgPT09IFwic3RyaW5nXCIgPyBgXCIke3Z9XCJgIDogdn1gKS5qb2luKFwiLCBcIil9YDtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5xdWVyeShxdWVyeSwgb3B0aW9ucyk7XG4gIH1cbiAgZXNjYXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlhbGVjdC5xdWVyeUdlbmVyYXRvci5lc2NhcGUodmFsdWUpO1xuICB9XG4gIGFzeW5jIGNyZWF0ZVNjaGVtYShzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRRdWVyeUludGVyZmFjZSgpLmNyZWF0ZVNjaGVtYShzY2hlbWEsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIHNob3dBbGxTY2hlbWFzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRRdWVyeUludGVyZmFjZSgpLnNob3dBbGxTY2hlbWFzKG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGRyb3BTY2hlbWEoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UXVlcnlJbnRlcmZhY2UoKS5kcm9wU2NoZW1hKHNjaGVtYSwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgZHJvcEFsbFNjaGVtYXMob3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFF1ZXJ5SW50ZXJmYWNlKCkuZHJvcEFsbFNjaGVtYXMob3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgc3luYyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMub3B0aW9ucyksIHRoaXMub3B0aW9ucy5zeW5jKSwgb3B0aW9ucyksIHtcbiAgICAgIGhvb2tzOiBvcHRpb25zID8gb3B0aW9ucy5ob29rcyAhPT0gZmFsc2UgOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMubWF0Y2gpIHtcbiAgICAgIGlmICghb3B0aW9ucy5tYXRjaC50ZXN0KHRoaXMuY29uZmlnLmRhdGFiYXNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFiYXNlIFwiJHt0aGlzLmNvbmZpZy5kYXRhYmFzZX1cIiBkb2VzIG5vdCBtYXRjaCBzeW5jIG1hdGNoIHBhcmFtZXRlciBcIiR7b3B0aW9ucy5tYXRjaH1cImApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcyhcImJlZm9yZUJ1bGtTeW5jXCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5mb3JjZSkge1xuICAgICAgYXdhaXQgdGhpcy5kcm9wKG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb2RlbE1hbmFnZXIubW9kZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXdhaXQgdGhpcy5hdXRoZW50aWNhdGUob3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1vZGVscyA9IHRoaXMubW9kZWxNYW5hZ2VyLmdldE1vZGVsc1RvcG9Tb3J0ZWRCeUZvcmVpZ25LZXkoKTtcbiAgICAgIGlmIChtb2RlbHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3luY01vZGVsc1dpdGhDeWNsaWNSZWZlcmVuY2VzKG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgbW9kZWxzLnJldmVyc2UoKTtcbiAgICAgIGZvciAoY29uc3QgbW9kZWwgb2YgbW9kZWxzKSB7XG4gICAgICAgIGF3YWl0IG1vZGVsLnN5bmMob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKFwiYWZ0ZXJCdWxrU3luY1wiLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXN5bmMgX3N5bmNNb2RlbHNXaXRoQ3ljbGljUmVmZXJlbmNlcyhvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuZGlhbGVjdC5uYW1lID09PSBcInNxbGl0ZVwiKSB7XG4gICAgICBhd2FpdCB3aXRoU3FsaXRlRm9yZWlnbktleXNPZmYodGhpcywgb3B0aW9ucywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHRoaXMubW9kZWxNYW5hZ2VyLm1vZGVscykge1xuICAgICAgICAgIGF3YWl0IG1vZGVsLnN5bmMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHRoaXMubW9kZWxNYW5hZ2VyLm1vZGVscykge1xuICAgICAgYXdhaXQgbW9kZWwuc3luYyhfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyB3aXRob3V0Rm9yZWlnbktleUNvbnN0cmFpbnRzOiB0cnVlIH0pKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiB0aGlzLm1vZGVsTWFuYWdlci5tb2RlbHMpIHtcbiAgICAgIGF3YWl0IG1vZGVsLnN5bmMoX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgZm9yY2U6IGZhbHNlLCBhbHRlcjogdHJ1ZSB9KSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHRydW5jYXRlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBzb3J0ZWRNb2RlbHMgPSB0aGlzLm1vZGVsTWFuYWdlci5nZXRNb2RlbHNUb3BvU29ydGVkQnlGb3JlaWduS2V5KCk7XG4gICAgY29uc3QgbW9kZWxzID0gc29ydGVkTW9kZWxzIHx8IHRoaXMubW9kZWxNYW5hZ2VyLm1vZGVscztcbiAgICBjb25zdCBoYXNDeWNsaWNEZXBlbmRlbmNpZXMgPSBzb3J0ZWRNb2RlbHMgPT0gbnVsbDtcbiAgICBpZiAoaGFzQ3ljbGljRGVwZW5kZW5jaWVzICYmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5jYXNjYWRlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXF1ZWxpemUjdHJ1bmNhdGU6IFNvbWUgb2YgeW91ciBtb2RlbHMgaGF2ZSBjeWNsaWMgcmVmZXJlbmNlcyAoZm9yZWlnbiBrZXlzKS4gWW91IG5lZWQgdG8gdXNlIHRoZSBcImNhc2NhZGVcIiBvcHRpb24gdG8gYmUgYWJsZSB0byBkZWxldGUgcm93cyBmcm9tIG1vZGVscyB0aGF0IGhhdmUgY3ljbGljIHJlZmVyZW5jZXMuJyk7XG4gICAgfVxuICAgIGlmIChoYXNDeWNsaWNEZXBlbmRlbmNpZXMgJiYgdGhpcy5kaWFsZWN0Lm5hbWUgPT09IFwic3FsaXRlXCIpIHtcbiAgICAgIHJldHVybiB3aXRoU3FsaXRlRm9yZWlnbktleXNPZmYodGhpcywgb3B0aW9ucywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChtb2RlbHMubWFwKChtb2RlbCkgPT4gbW9kZWwudHJ1bmNhdGUob3B0aW9ucykpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNhc2NhZGUpIHtcbiAgICAgIGZvciAoY29uc3QgbW9kZWwgb2YgbW9kZWxzKVxuICAgICAgICBhd2FpdCBtb2RlbC50cnVuY2F0ZShvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwobW9kZWxzLm1hcCgobW9kZWwpID0+IG1vZGVsLnRydW5jYXRlKG9wdGlvbnMpKSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGRyb3Aob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY2FzY2FkZSkge1xuICAgICAgZm9yIChjb25zdCBtb2RlbCBvZiB0aGlzLm1vZGVsTWFuYWdlci5tb2RlbHMpIHtcbiAgICAgICAgYXdhaXQgbW9kZWwuZHJvcChvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc29ydGVkTW9kZWxzID0gdGhpcy5tb2RlbE1hbmFnZXIuZ2V0TW9kZWxzVG9wb1NvcnRlZEJ5Rm9yZWlnbktleSgpO1xuICAgIGlmIChzb3J0ZWRNb2RlbHMpIHtcbiAgICAgIGZvciAoY29uc3QgbW9kZWwgb2Ygc29ydGVkTW9kZWxzKSB7XG4gICAgICAgIGF3YWl0IG1vZGVsLmRyb3Aob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmRpYWxlY3QubmFtZSA9PT0gXCJzcWxpdGVcIikge1xuICAgICAgYXdhaXQgd2l0aFNxbGl0ZUZvcmVpZ25LZXlzT2ZmKHRoaXMsIG9wdGlvbnMsIGFzeW5jICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBtb2RlbCBvZiB0aGlzLm1vZGVsTWFuYWdlci5tb2RlbHMpIHtcbiAgICAgICAgICBhd2FpdCBtb2RlbC5kcm9wKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiB0aGlzLm1vZGVsTWFuYWdlci5tb2RlbHMpIHtcbiAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IG1vZGVsLmdldFRhYmxlTmFtZSgpO1xuICAgICAgY29uc3QgZm9yZWlnbktleXMgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmdldEZvcmVpZ25LZXlSZWZlcmVuY2VzRm9yVGFibGUodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGZvcmVpZ25LZXlzLm1hcCgoZm9yZWlnbktleSkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeUludGVyZmFjZS5yZW1vdmVDb25zdHJhaW50KHRhYmxlTmFtZSwgZm9yZWlnbktleS5jb25zdHJhaW50TmFtZSwgb3B0aW9ucyk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbW9kZWwgb2YgdGhpcy5tb2RlbE1hbmFnZXIubW9kZWxzKSB7XG4gICAgICBhd2FpdCBtb2RlbC5kcm9wKG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBhc3luYyBhdXRoZW50aWNhdGUob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICByYXc6IHRydWUsXG4gICAgICBwbGFpbjogdHJ1ZSxcbiAgICAgIHR5cGU6IFF1ZXJ5VHlwZXMuU0VMRUNUXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgYXdhaXQgdGhpcy5xdWVyeSh0aGlzLmRpYWxlY3QucXVlcnlHZW5lcmF0b3IuYXV0aFRlc3RRdWVyeSgpLCBvcHRpb25zKTtcbiAgICByZXR1cm47XG4gIH1cbiAgYXN5bmMgZGF0YWJhc2VWZXJzaW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRRdWVyeUludGVyZmFjZSgpLmRhdGFiYXNlVmVyc2lvbihvcHRpb25zKTtcbiAgfVxuICByYW5kb20oKSB7XG4gICAgaWYgKFtcInBvc3RncmVzXCIsIFwic3FsaXRlXCIsIFwic25vd2ZsYWtlXCJdLmluY2x1ZGVzKHRoaXMuZ2V0RGlhbGVjdCgpKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZm4oXCJSQU5ET01cIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZuKFwiUkFORFwiKTtcbiAgfVxuICBzdGF0aWMgZm4oZm4sIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFV0aWxzLkZuKGZuLCBhcmdzKTtcbiAgfVxuICBzdGF0aWMgY29sKGNvbCkge1xuICAgIHJldHVybiBuZXcgVXRpbHMuQ29sKGNvbCk7XG4gIH1cbiAgc3RhdGljIGNhc3QodmFsLCB0eXBlKSB7XG4gICAgcmV0dXJuIG5ldyBVdGlscy5DYXN0KHZhbCwgdHlwZSk7XG4gIH1cbiAgc3RhdGljIGxpdGVyYWwodmFsKSB7XG4gICAgcmV0dXJuIG5ldyBVdGlscy5MaXRlcmFsKHZhbCk7XG4gIH1cbiAgc3RhdGljIGFuZCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHsgW09wLmFuZF06IGFyZ3MgfTtcbiAgfVxuICBzdGF0aWMgb3IoLi4uYXJncykge1xuICAgIHJldHVybiB7IFtPcC5vcl06IGFyZ3MgfTtcbiAgfVxuICBzdGF0aWMganNvbihjb25kaXRpb25zT3JQYXRoLCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgVXRpbHMuSnNvbihjb25kaXRpb25zT3JQYXRoLCB2YWx1ZSk7XG4gIH1cbiAgc3RhdGljIHdoZXJlKGF0dHIsIGNvbXBhcmF0b3IsIGxvZ2ljKSB7XG4gICAgcmV0dXJuIG5ldyBVdGlscy5XaGVyZShhdHRyLCBjb21wYXJhdG9yLCBsb2dpYyk7XG4gIH1cbiAgYXN5bmMgdHJhbnNhY3Rpb24ob3B0aW9ucywgYXV0b0NhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGF1dG9DYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbih0aGlzLCBvcHRpb25zKTtcbiAgICBpZiAoIWF1dG9DYWxsYmFjaykge1xuICAgICAgYXdhaXQgdHJhbnNhY3Rpb24ucHJlcGFyZUVudmlyb25tZW50KGZhbHNlKTtcbiAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIFNlcXVlbGl6ZS5fY2xzUnVuKGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHRyYW5zYWN0aW9uLnByZXBhcmVFbnZpcm9ubWVudCh0cnVlKTtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCBhdXRvQ2FsbGJhY2sodHJhbnNhY3Rpb24pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdHJhbnNhY3Rpb24ucm9sbGJhY2soKTtcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgYXdhaXQgdHJhbnNhY3Rpb24uY29tbWl0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyB1c2VDTFMobnMpIHtcbiAgICBpZiAoIW5zIHx8IHR5cGVvZiBucyAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbnMuYmluZCAhPT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBucy5ydW4gIT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBDTFMgbmFtZXNwYWNlXCIpO1xuICAgIFNlcXVlbGl6ZS5fY2xzID0gbnM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RhdGljIF9jbHNSdW4oZm4pIHtcbiAgICBjb25zdCBucyA9IFNlcXVlbGl6ZS5fY2xzO1xuICAgIGlmICghbnMpXG4gICAgICByZXR1cm4gZm4oKTtcbiAgICBsZXQgcmVzO1xuICAgIG5zLnJ1bigoY29udGV4dCkgPT4gcmVzID0gZm4oY29udGV4dCkpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgbG9nKC4uLmFyZ3MpIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICBjb25zdCBsYXN0ID0gXy5sYXN0KGFyZ3MpO1xuICAgIGlmIChsYXN0ICYmIF8uaXNQbGFpbk9iamVjdChsYXN0KSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGFzdCwgXCJsb2dnaW5nXCIpKSB7XG4gICAgICBvcHRpb25zID0gbGFzdDtcbiAgICAgIGlmIChvcHRpb25zLmxvZ2dpbmcgPT09IGNvbnNvbGUubG9nKSB7XG4gICAgICAgIGFyZ3Muc3BsaWNlKGFyZ3MubGVuZ3RoIC0gMSwgMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxvZ2dpbmcpIHtcbiAgICAgIGlmIChvcHRpb25zLmxvZ2dpbmcgPT09IHRydWUpIHtcbiAgICAgICAgZGVwcmVjYXRpb25zLm5vVHJ1ZUxvZ2dpbmcoKTtcbiAgICAgICAgb3B0aW9ucy5sb2dnaW5nID0gY29uc29sZS5sb2c7XG4gICAgICB9XG4gICAgICBpZiAoKHRoaXMub3B0aW9ucy5iZW5jaG1hcmsgfHwgb3B0aW9ucy5iZW5jaG1hcmspICYmIG9wdGlvbnMubG9nZ2luZyA9PT0gY29uc29sZS5sb2cpIHtcbiAgICAgICAgYXJncyA9IFtgJHthcmdzWzBdfSBFbGFwc2VkIHRpbWU6ICR7YXJnc1sxXX1tc2BdO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5sb2dnaW5nKC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuICBjbG9zZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jbG9zZSgpO1xuICB9XG4gIG5vcm1hbGl6ZURhdGFUeXBlKFR5cGUpIHtcbiAgICBsZXQgdHlwZSA9IHR5cGVvZiBUeXBlID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgVHlwZSgpIDogVHlwZTtcbiAgICBjb25zdCBkaWFsZWN0VHlwZXMgPSB0aGlzLmRpYWxlY3QuRGF0YVR5cGVzIHx8IHt9O1xuICAgIGlmIChkaWFsZWN0VHlwZXNbdHlwZS5rZXldKSB7XG4gICAgICB0eXBlID0gZGlhbGVjdFR5cGVzW3R5cGUua2V5XS5leHRlbmQodHlwZSk7XG4gICAgfVxuICAgIGlmICh0eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkFSUkFZKSB7XG4gICAgICBpZiAoIXR5cGUudHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBUlJBWSBpcyBtaXNzaW5nIHR5cGUgZGVmaW5pdGlvbiBmb3IgaXRzIHZhbHVlcy5cIik7XG4gICAgICB9XG4gICAgICBpZiAoZGlhbGVjdFR5cGVzW3R5cGUudHlwZS5rZXldKSB7XG4gICAgICAgIHR5cGUudHlwZSA9IGRpYWxlY3RUeXBlc1t0eXBlLnR5cGUua2V5XS5leHRlbmQodHlwZS50eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgbm9ybWFsaXplQXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KGF0dHJpYnV0ZSkpIHtcbiAgICAgIGF0dHJpYnV0ZSA9IHsgdHlwZTogYXR0cmlidXRlIH07XG4gICAgfVxuICAgIGlmICghYXR0cmlidXRlLnR5cGUpXG4gICAgICByZXR1cm4gYXR0cmlidXRlO1xuICAgIGF0dHJpYnV0ZS50eXBlID0gdGhpcy5ub3JtYWxpemVEYXRhVHlwZShhdHRyaWJ1dGUudHlwZSk7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGUsIFwiZGVmYXVsdFZhbHVlXCIpKSB7XG4gICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJiBbRGF0YVR5cGVzLk5PVywgRGF0YVR5cGVzLlVVSURWMSwgRGF0YVR5cGVzLlVVSURWNF0uaW5jbHVkZXMoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSA9IG5ldyBhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNKSB7XG4gICAgICBpZiAoYXR0cmlidXRlLnZhbHVlcykge1xuICAgICAgICBhdHRyaWJ1dGUudHlwZS52YWx1ZXMgPSBhdHRyaWJ1dGUudHlwZS5vcHRpb25zLnZhbHVlcyA9IGF0dHJpYnV0ZS52YWx1ZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGUudmFsdWVzID0gYXR0cmlidXRlLnR5cGUudmFsdWVzO1xuICAgICAgfVxuICAgICAgaWYgKCFhdHRyaWJ1dGUudmFsdWVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZXMgZm9yIEVOVU0gaGF2ZSBub3QgYmVlbiBkZWZpbmVkLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZTtcbiAgfVxufVxuU2VxdWVsaXplLnByb3RvdHlwZS5mbiA9IFNlcXVlbGl6ZS5mbjtcblNlcXVlbGl6ZS5wcm90b3R5cGUuY29sID0gU2VxdWVsaXplLmNvbDtcblNlcXVlbGl6ZS5wcm90b3R5cGUuY2FzdCA9IFNlcXVlbGl6ZS5jYXN0O1xuU2VxdWVsaXplLnByb3RvdHlwZS5saXRlcmFsID0gU2VxdWVsaXplLmxpdGVyYWw7XG5TZXF1ZWxpemUucHJvdG90eXBlLmFuZCA9IFNlcXVlbGl6ZS5hbmQ7XG5TZXF1ZWxpemUucHJvdG90eXBlLm9yID0gU2VxdWVsaXplLm9yO1xuU2VxdWVsaXplLnByb3RvdHlwZS5qc29uID0gU2VxdWVsaXplLmpzb247XG5TZXF1ZWxpemUucHJvdG90eXBlLndoZXJlID0gU2VxdWVsaXplLndoZXJlO1xuU2VxdWVsaXplLnByb3RvdHlwZS52YWxpZGF0ZSA9IFNlcXVlbGl6ZS5wcm90b3R5cGUuYXV0aGVudGljYXRlO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcXVlbGl6ZSwgXCJ2ZXJzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0KCkge1xuICAgIHJldHVybiByZXF1aXJlKFwiLi4vcGFja2FnZS5qc29uXCIpLnZlcnNpb247XG4gIH1cbn0pO1xuU2VxdWVsaXplLm9wdGlvbnMgPSB7IGhvb2tzOiB7fSB9O1xuU2VxdWVsaXplLlV0aWxzID0gVXRpbHM7XG5TZXF1ZWxpemUuT3AgPSBPcDtcblNlcXVlbGl6ZS5UYWJsZUhpbnRzID0gVGFibGVIaW50cztcblNlcXVlbGl6ZS5JbmRleEhpbnRzID0gSW5kZXhIaW50cztcblNlcXVlbGl6ZS5UcmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uO1xuU2VxdWVsaXplLnByb3RvdHlwZS5TZXF1ZWxpemUgPSBTZXF1ZWxpemU7XG5TZXF1ZWxpemUucHJvdG90eXBlLlF1ZXJ5VHlwZXMgPSBTZXF1ZWxpemUuUXVlcnlUeXBlcyA9IFF1ZXJ5VHlwZXM7XG5TZXF1ZWxpemUucHJvdG90eXBlLlZhbGlkYXRvciA9IFNlcXVlbGl6ZS5WYWxpZGF0b3IgPSBWYWxpZGF0b3I7XG5TZXF1ZWxpemUuTW9kZWwgPSBNb2RlbDtcblNlcXVlbGl6ZS5RdWVyeUludGVyZmFjZSA9IFF1ZXJ5SW50ZXJmYWNlO1xuU2VxdWVsaXplLkJlbG9uZ3NUbyA9IEJlbG9uZ3NUbztcblNlcXVlbGl6ZS5IYXNPbmUgPSBIYXNPbmU7XG5TZXF1ZWxpemUuSGFzTWFueSA9IEhhc01hbnk7XG5TZXF1ZWxpemUuQmVsb25nc1RvTWFueSA9IEJlbG9uZ3NUb01hbnk7XG5TZXF1ZWxpemUuRGF0YVR5cGVzID0gRGF0YVR5cGVzO1xuZm9yIChjb25zdCBkYXRhVHlwZSBpbiBEYXRhVHlwZXMpIHtcbiAgU2VxdWVsaXplW2RhdGFUeXBlXSA9IERhdGFUeXBlc1tkYXRhVHlwZV07XG59XG5TZXF1ZWxpemUuRGVmZXJyYWJsZSA9IERlZmVycmFibGU7XG5TZXF1ZWxpemUucHJvdG90eXBlLkFzc29jaWF0aW9uID0gU2VxdWVsaXplLkFzc29jaWF0aW9uID0gQXNzb2NpYXRpb247XG5TZXF1ZWxpemUudXNlSW5mbGVjdGlvbiA9IFV0aWxzLnVzZUluZmxlY3Rpb247XG5Ib29rcy5hcHBseVRvKFNlcXVlbGl6ZSk7XG5Ib29rcy5hcHBseVRvKFNlcXVlbGl6ZS5wcm90b3R5cGUpO1xuU2VxdWVsaXplLkVycm9yID0gc2VxdWVsaXplRXJyb3JzLkJhc2VFcnJvcjtcbmZvciAoY29uc3QgZXJyb3Igb2YgT2JqZWN0LmtleXMoc2VxdWVsaXplRXJyb3JzKSkge1xuICBTZXF1ZWxpemVbZXJyb3JdID0gc2VxdWVsaXplRXJyb3JzW2Vycm9yXTtcbn1cbm1vZHVsZS5leHBvcnRzID0gU2VxdWVsaXplO1xubW9kdWxlLmV4cG9ydHMuU2VxdWVsaXplID0gU2VxdWVsaXplO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IFNlcXVlbGl6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcXVlbGl6ZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/sequelize.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/sql-string.js":
/*!***************************************************!*\
  !*** ../node_modules/sequelize/lib/sql-string.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst moment = __webpack_require__(/*! moment */ \"(action-browser)/../node_modules/moment/moment.js\");\nconst dataTypes = __webpack_require__(/*! ./data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\");\nconst { logger } = __webpack_require__(/*! ./utils/logger */ \"(action-browser)/../node_modules/sequelize/lib/utils/logger.js\");\nfunction arrayToList(array, timeZone, dialect, format2) {\n  return array.reduce((sql, val, i) => {\n    if (i !== 0) {\n      sql += \", \";\n    }\n    if (Array.isArray(val)) {\n      sql += `(${arrayToList(val, timeZone, dialect, format2)})`;\n    } else {\n      sql += escape(val, timeZone, dialect, format2);\n    }\n    return sql;\n  }, \"\");\n}\nexports.arrayToList = arrayToList;\nfunction escape(val, timeZone, dialect, format2) {\n  let prependN = false;\n  if (val === void 0 || val === null) {\n    return \"NULL\";\n  }\n  switch (typeof val) {\n    case \"boolean\":\n      if ([\"sqlite\", \"mssql\", \"oracle\"].includes(dialect)) {\n        return +!!val;\n      }\n      return (!!val).toString();\n    case \"number\":\n    case \"bigint\":\n      return val.toString();\n    case \"string\":\n      prependN = dialect === \"mssql\";\n      break;\n  }\n  if (val instanceof Date) {\n    val = dataTypes[dialect].DATE.prototype.stringify(val, { timezone: timeZone });\n  }\n  if (Buffer.isBuffer(val)) {\n    if (dataTypes[dialect].BLOB) {\n      return dataTypes[dialect].BLOB.prototype.stringify(val);\n    }\n    return dataTypes.BLOB.prototype.stringify(val);\n  }\n  if (Array.isArray(val)) {\n    const partialEscape = (escVal) => escape(escVal, timeZone, dialect, format2);\n    if (dialect === \"postgres\" && !format2) {\n      return dataTypes.ARRAY.prototype.stringify(val, { escape: partialEscape });\n    }\n    return arrayToList(val, timeZone, dialect, format2);\n  }\n  if (!val.replace) {\n    throw new Error(`Invalid value ${logger.inspect(val)}`);\n  }\n  if ([\"postgres\", \"sqlite\", \"mssql\", \"snowflake\", \"db2\"].includes(dialect)) {\n    val = val.replace(/'/g, \"''\");\n    if (dialect === \"postgres\") {\n      val = val.replace(/\\0/g, \"\\\\0\");\n    }\n  } else if (dialect === \"oracle\" && typeof val === \"string\") {\n    if (val.startsWith(\"TO_TIMESTAMP_TZ\") || val.startsWith(\"TO_DATE\")) {\n      const splitVal = val.split(/\\(|\\)/);\n      if (splitVal.length !== 3 || splitVal[2] !== \"\") {\n        throw new Error(\"Invalid SQL function call.\");\n      }\n      const functionName = splitVal[0].trim();\n      const insideParens = splitVal[1].trim();\n      if (functionName !== \"TO_TIMESTAMP_TZ\" && functionName !== \"TO_DATE\") {\n        throw new Error(\"Invalid SQL function call. Expected TO_TIMESTAMP_TZ or TO_DATE.\");\n      }\n      const params = insideParens.split(\",\");\n      if (params.length !== 2) {\n        throw new Error(\"Unexpected input received.\\nSequelize supports TO_TIMESTAMP_TZ or TO_DATE exclusively with a combination of value and format.\");\n      }\n      const dateValue = params[0].trim().replace(/'/g, \"\");\n      const formatValue = params[1].trim();\n      if (functionName === \"TO_TIMESTAMP_TZ\") {\n        const expectedFormat = \"'YYYY-MM-DD HH24:MI:SS.FFTZH:TZM'\";\n        if (formatValue !== expectedFormat) {\n          throw new Error(`Invalid format string for TO_TIMESTAMP_TZ. Expected format: ${expectedFormat}`);\n        }\n        const formattedDate = moment(dateValue).format(\"YYYY-MM-DD HH:mm:ss.SSS Z\");\n        if (formattedDate !== dateValue) {\n          throw new Error(\"Invalid date value for TO_TIMESTAMP_TZ. Expected format: 'YYYY-MM-DD HH:mm:ss.SSS Z'\");\n        }\n      } else if (functionName === \"TO_DATE\") {\n        const expectedFormat = \"'YYYY/MM/DD'\";\n        if (formatValue !== expectedFormat) {\n          throw new Error(`Invalid format string for TO_DATE. Expected format: ${expectedFormat}`);\n        }\n        const formattedDate = moment(dateValue).format(\"YYYY-MM-DD\");\n        if (formattedDate !== dateValue) {\n          throw new Error(\"Invalid date value for TO_DATE. Expected format: 'YYYY-MM-DD'\");\n        }\n      }\n      return val;\n    }\n    val = val.replace(/'/g, \"''\");\n  } else {\n    val = val.replace(/[\\0\\n\\r\\b\\t\\\\'\"\\x1a]/g, (s) => {\n      switch (s) {\n        case \"\\0\":\n          return \"\\\\0\";\n        case \"\\n\":\n          return \"\\\\n\";\n        case \"\\r\":\n          return \"\\\\r\";\n        case \"\\b\":\n          return \"\\\\b\";\n        case \"\t\":\n          return \"\\\\t\";\n        case \"\u001a\":\n          return \"\\\\Z\";\n        default:\n          return `\\\\${s}`;\n      }\n    });\n  }\n  return `${(prependN ? \"N'\" : \"'\") + val}'`;\n}\nexports.escape = escape;\nfunction format(sql, values, timeZone, dialect) {\n  values = [].concat(values);\n  if (typeof sql !== \"string\") {\n    throw new Error(`Invalid SQL string provided: ${sql}`);\n  }\n  return sql.replace(/\\?/g, (match) => {\n    if (!values.length) {\n      return match;\n    }\n    return escape(values.shift(), timeZone, dialect, true);\n  });\n}\nexports.format = format;\nfunction formatNamedParameters(sql, values, timeZone, dialect) {\n  return sql.replace(/:+(?!\\d)(\\w+)/g, (value, key) => {\n    if (dialect === \"postgres\" && value.slice(0, 2) === \"::\") {\n      return value;\n    }\n    if (values[key] !== void 0) {\n      return escape(values[key], timeZone, dialect, true);\n    }\n    throw new Error(`Named parameter \"${value}\" has no value in the given object.`);\n  });\n}\nexports.formatNamedParameters = formatNamedParameters;\n//# sourceMappingURL=sql-string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9zcWwtc3RyaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsZUFBZSxtQkFBTyxDQUFDLGlFQUFRO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLGtGQUFjO0FBQ3hDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0ZBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBNkM7QUFDOUQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxvQkFBb0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsdUJBQXVCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG9CQUFvQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsZUFBZTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxpRkFBaUYsZUFBZTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEVBQUU7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZLDhCQUE4QjtBQUMxQztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDLEdBQUc7QUFDSDtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9zcWwtc3RyaW5nLmpzPzRkMmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBtb21lbnQgPSByZXF1aXJlKFwibW9tZW50XCIpO1xuY29uc3QgZGF0YVR5cGVzID0gcmVxdWlyZShcIi4vZGF0YS10eXBlc1wiKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKFwiLi91dGlscy9sb2dnZXJcIik7XG5mdW5jdGlvbiBhcnJheVRvTGlzdChhcnJheSwgdGltZVpvbmUsIGRpYWxlY3QsIGZvcm1hdDIpIHtcbiAgcmV0dXJuIGFycmF5LnJlZHVjZSgoc3FsLCB2YWwsIGkpID0+IHtcbiAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgc3FsICs9IFwiLCBcIjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgc3FsICs9IGAoJHthcnJheVRvTGlzdCh2YWwsIHRpbWVab25lLCBkaWFsZWN0LCBmb3JtYXQyKX0pYDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3FsICs9IGVzY2FwZSh2YWwsIHRpbWVab25lLCBkaWFsZWN0LCBmb3JtYXQyKTtcbiAgICB9XG4gICAgcmV0dXJuIHNxbDtcbiAgfSwgXCJcIik7XG59XG5leHBvcnRzLmFycmF5VG9MaXN0ID0gYXJyYXlUb0xpc3Q7XG5mdW5jdGlvbiBlc2NhcGUodmFsLCB0aW1lWm9uZSwgZGlhbGVjdCwgZm9ybWF0Mikge1xuICBsZXQgcHJlcGVuZE4gPSBmYWxzZTtcbiAgaWYgKHZhbCA9PT0gdm9pZCAwIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBcIk5VTExcIjtcbiAgfVxuICBzd2l0Y2ggKHR5cGVvZiB2YWwpIHtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgaWYgKFtcInNxbGl0ZVwiLCBcIm1zc3FsXCIsIFwib3JhY2xlXCJdLmluY2x1ZGVzKGRpYWxlY3QpKSB7XG4gICAgICAgIHJldHVybiArISF2YWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCEhdmFsKS50b1N0cmluZygpO1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICByZXR1cm4gdmFsLnRvU3RyaW5nKCk7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcHJlcGVuZE4gPSBkaWFsZWN0ID09PSBcIm1zc3FsXCI7XG4gICAgICBicmVhaztcbiAgfVxuICBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHZhbCA9IGRhdGFUeXBlc1tkaWFsZWN0XS5EQVRFLnByb3RvdHlwZS5zdHJpbmdpZnkodmFsLCB7IHRpbWV6b25lOiB0aW1lWm9uZSB9KTtcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICBpZiAoZGF0YVR5cGVzW2RpYWxlY3RdLkJMT0IpIHtcbiAgICAgIHJldHVybiBkYXRhVHlwZXNbZGlhbGVjdF0uQkxPQi5wcm90b3R5cGUuc3RyaW5naWZ5KHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhVHlwZXMuQkxPQi5wcm90b3R5cGUuc3RyaW5naWZ5KHZhbCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIGNvbnN0IHBhcnRpYWxFc2NhcGUgPSAoZXNjVmFsKSA9PiBlc2NhcGUoZXNjVmFsLCB0aW1lWm9uZSwgZGlhbGVjdCwgZm9ybWF0Mik7XG4gICAgaWYgKGRpYWxlY3QgPT09IFwicG9zdGdyZXNcIiAmJiAhZm9ybWF0Mikge1xuICAgICAgcmV0dXJuIGRhdGFUeXBlcy5BUlJBWS5wcm90b3R5cGUuc3RyaW5naWZ5KHZhbCwgeyBlc2NhcGU6IHBhcnRpYWxFc2NhcGUgfSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheVRvTGlzdCh2YWwsIHRpbWVab25lLCBkaWFsZWN0LCBmb3JtYXQyKTtcbiAgfVxuICBpZiAoIXZhbC5yZXBsYWNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbHVlICR7bG9nZ2VyLmluc3BlY3QodmFsKX1gKTtcbiAgfVxuICBpZiAoW1wicG9zdGdyZXNcIiwgXCJzcWxpdGVcIiwgXCJtc3NxbFwiLCBcInNub3dmbGFrZVwiLCBcImRiMlwiXS5pbmNsdWRlcyhkaWFsZWN0KSkge1xuICAgIHZhbCA9IHZhbC5yZXBsYWNlKC8nL2csIFwiJydcIik7XG4gICAgaWYgKGRpYWxlY3QgPT09IFwicG9zdGdyZXNcIikge1xuICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1xcMC9nLCBcIlxcXFwwXCIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkaWFsZWN0ID09PSBcIm9yYWNsZVwiICYmIHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAodmFsLnN0YXJ0c1dpdGgoXCJUT19USU1FU1RBTVBfVFpcIikgfHwgdmFsLnN0YXJ0c1dpdGgoXCJUT19EQVRFXCIpKSB7XG4gICAgICBjb25zdCBzcGxpdFZhbCA9IHZhbC5zcGxpdCgvXFwofFxcKS8pO1xuICAgICAgaWYgKHNwbGl0VmFsLmxlbmd0aCAhPT0gMyB8fCBzcGxpdFZhbFsyXSAhPT0gXCJcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFNRTCBmdW5jdGlvbiBjYWxsLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IHNwbGl0VmFsWzBdLnRyaW0oKTtcbiAgICAgIGNvbnN0IGluc2lkZVBhcmVucyA9IHNwbGl0VmFsWzFdLnRyaW0oKTtcbiAgICAgIGlmIChmdW5jdGlvbk5hbWUgIT09IFwiVE9fVElNRVNUQU1QX1RaXCIgJiYgZnVuY3Rpb25OYW1lICE9PSBcIlRPX0RBVEVcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFNRTCBmdW5jdGlvbiBjYWxsLiBFeHBlY3RlZCBUT19USU1FU1RBTVBfVFogb3IgVE9fREFURS5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJhbXMgPSBpbnNpZGVQYXJlbnMuc3BsaXQoXCIsXCIpO1xuICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBpbnB1dCByZWNlaXZlZC5cXG5TZXF1ZWxpemUgc3VwcG9ydHMgVE9fVElNRVNUQU1QX1RaIG9yIFRPX0RBVEUgZXhjbHVzaXZlbHkgd2l0aCBhIGNvbWJpbmF0aW9uIG9mIHZhbHVlIGFuZCBmb3JtYXQuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0ZVZhbHVlID0gcGFyYW1zWzBdLnRyaW0oKS5yZXBsYWNlKC8nL2csIFwiXCIpO1xuICAgICAgY29uc3QgZm9ybWF0VmFsdWUgPSBwYXJhbXNbMV0udHJpbSgpO1xuICAgICAgaWYgKGZ1bmN0aW9uTmFtZSA9PT0gXCJUT19USU1FU1RBTVBfVFpcIikge1xuICAgICAgICBjb25zdCBleHBlY3RlZEZvcm1hdCA9IFwiJ1lZWVktTU0tREQgSEgyNDpNSTpTUy5GRlRaSDpUWk0nXCI7XG4gICAgICAgIGlmIChmb3JtYXRWYWx1ZSAhPT0gZXhwZWN0ZWRGb3JtYXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZm9ybWF0IHN0cmluZyBmb3IgVE9fVElNRVNUQU1QX1RaLiBFeHBlY3RlZCBmb3JtYXQ6ICR7ZXhwZWN0ZWRGb3JtYXR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybWF0dGVkRGF0ZSA9IG1vbWVudChkYXRlVmFsdWUpLmZvcm1hdChcIllZWVktTU0tREQgSEg6bW06c3MuU1NTIFpcIik7XG4gICAgICAgIGlmIChmb3JtYXR0ZWREYXRlICE9PSBkYXRlVmFsdWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGUgdmFsdWUgZm9yIFRPX1RJTUVTVEFNUF9UWi4gRXhwZWN0ZWQgZm9ybWF0OiAnWVlZWS1NTS1ERCBISDptbTpzcy5TU1MgWidcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZnVuY3Rpb25OYW1lID09PSBcIlRPX0RBVEVcIikge1xuICAgICAgICBjb25zdCBleHBlY3RlZEZvcm1hdCA9IFwiJ1lZWVkvTU0vREQnXCI7XG4gICAgICAgIGlmIChmb3JtYXRWYWx1ZSAhPT0gZXhwZWN0ZWRGb3JtYXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZm9ybWF0IHN0cmluZyBmb3IgVE9fREFURS4gRXhwZWN0ZWQgZm9ybWF0OiAke2V4cGVjdGVkRm9ybWF0fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZERhdGUgPSBtb21lbnQoZGF0ZVZhbHVlKS5mb3JtYXQoXCJZWVlZLU1NLUREXCIpO1xuICAgICAgICBpZiAoZm9ybWF0dGVkRGF0ZSAhPT0gZGF0ZVZhbHVlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRlIHZhbHVlIGZvciBUT19EQVRFLiBFeHBlY3RlZCBmb3JtYXQ6ICdZWVlZLU1NLUREJ1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgdmFsID0gdmFsLnJlcGxhY2UoLycvZywgXCInJ1wiKTtcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSB2YWwucmVwbGFjZSgvW1xcMFxcblxcclxcYlxcdFxcXFwnXCJcXHgxYV0vZywgKHMpID0+IHtcbiAgICAgIHN3aXRjaCAocykge1xuICAgICAgICBjYXNlIFwiXFwwXCI6XG4gICAgICAgICAgcmV0dXJuIFwiXFxcXDBcIjtcbiAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgIHJldHVybiBcIlxcXFxuXCI7XG4gICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICByZXR1cm4gXCJcXFxcclwiO1xuICAgICAgICBjYXNlIFwiXFxiXCI6XG4gICAgICAgICAgcmV0dXJuIFwiXFxcXGJcIjtcbiAgICAgICAgY2FzZSBcIlx0XCI6XG4gICAgICAgICAgcmV0dXJuIFwiXFxcXHRcIjtcbiAgICAgICAgY2FzZSBcIlx1MDAxYVwiOlxuICAgICAgICAgIHJldHVybiBcIlxcXFxaXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGBcXFxcJHtzfWA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGAkeyhwcmVwZW5kTiA/IFwiTidcIiA6IFwiJ1wiKSArIHZhbH0nYDtcbn1cbmV4cG9ydHMuZXNjYXBlID0gZXNjYXBlO1xuZnVuY3Rpb24gZm9ybWF0KHNxbCwgdmFsdWVzLCB0aW1lWm9uZSwgZGlhbGVjdCkge1xuICB2YWx1ZXMgPSBbXS5jb25jYXQodmFsdWVzKTtcbiAgaWYgKHR5cGVvZiBzcWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgU1FMIHN0cmluZyBwcm92aWRlZDogJHtzcWx9YCk7XG4gIH1cbiAgcmV0dXJuIHNxbC5yZXBsYWNlKC9cXD8vZywgKG1hdGNoKSA9PiB7XG4gICAgaWYgKCF2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICAgIHJldHVybiBlc2NhcGUodmFsdWVzLnNoaWZ0KCksIHRpbWVab25lLCBkaWFsZWN0LCB0cnVlKTtcbiAgfSk7XG59XG5leHBvcnRzLmZvcm1hdCA9IGZvcm1hdDtcbmZ1bmN0aW9uIGZvcm1hdE5hbWVkUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgdGltZVpvbmUsIGRpYWxlY3QpIHtcbiAgcmV0dXJuIHNxbC5yZXBsYWNlKC86Kyg/IVxcZCkoXFx3KykvZywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAoZGlhbGVjdCA9PT0gXCJwb3N0Z3Jlc1wiICYmIHZhbHVlLnNsaWNlKDAsIDIpID09PSBcIjo6XCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlc1trZXldICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBlc2NhcGUodmFsdWVzW2tleV0sIHRpbWVab25lLCBkaWFsZWN0LCB0cnVlKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOYW1lZCBwYXJhbWV0ZXIgXCIke3ZhbHVlfVwiIGhhcyBubyB2YWx1ZSBpbiB0aGUgZ2l2ZW4gb2JqZWN0LmApO1xuICB9KTtcbn1cbmV4cG9ydHMuZm9ybWF0TmFtZWRQYXJhbWV0ZXJzID0gZm9ybWF0TmFtZWRQYXJhbWV0ZXJzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3FsLXN0cmluZy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/sql-string.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/table-hints.js":
/*!****************************************************!*\
  !*** ../node_modules/sequelize/lib/table-hints.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\nconst TableHints = module.exports = {\n  NOLOCK: \"NOLOCK\",\n  READUNCOMMITTED: \"READUNCOMMITTED\",\n  UPDLOCK: \"UPDLOCK\",\n  REPEATABLEREAD: \"REPEATABLEREAD\",\n  SERIALIZABLE: \"SERIALIZABLE\",\n  READCOMMITTED: \"READCOMMITTED\",\n  TABLOCK: \"TABLOCK\",\n  TABLOCKX: \"TABLOCKX\",\n  PAGLOCK: \"PAGLOCK\",\n  ROWLOCK: \"ROWLOCK\",\n  NOWAIT: \"NOWAIT\",\n  READPAST: \"READPAST\",\n  XLOCK: \"XLOCK\",\n  SNAPSHOT: \"SNAPSHOT\",\n  NOEXPAND: \"NOEXPAND\"\n};\n//# sourceMappingURL=table-hints.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi90YWJsZS1oaW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi90YWJsZS1oaW50cy5qcz82NmYyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgVGFibGVIaW50cyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBOT0xPQ0s6IFwiTk9MT0NLXCIsXG4gIFJFQURVTkNPTU1JVFRFRDogXCJSRUFEVU5DT01NSVRURURcIixcbiAgVVBETE9DSzogXCJVUERMT0NLXCIsXG4gIFJFUEVBVEFCTEVSRUFEOiBcIlJFUEVBVEFCTEVSRUFEXCIsXG4gIFNFUklBTElaQUJMRTogXCJTRVJJQUxJWkFCTEVcIixcbiAgUkVBRENPTU1JVFRFRDogXCJSRUFEQ09NTUlUVEVEXCIsXG4gIFRBQkxPQ0s6IFwiVEFCTE9DS1wiLFxuICBUQUJMT0NLWDogXCJUQUJMT0NLWFwiLFxuICBQQUdMT0NLOiBcIlBBR0xPQ0tcIixcbiAgUk9XTE9DSzogXCJST1dMT0NLXCIsXG4gIE5PV0FJVDogXCJOT1dBSVRcIixcbiAgUkVBRFBBU1Q6IFwiUkVBRFBBU1RcIixcbiAgWExPQ0s6IFwiWExPQ0tcIixcbiAgU05BUFNIT1Q6IFwiU05BUFNIT1RcIixcbiAgTk9FWFBBTkQ6IFwiTk9FWFBBTkRcIlxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYmxlLWhpbnRzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/table-hints.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/transaction.js":
/*!****************************************************!*\
  !*** ../node_modules/sequelize/lib/transaction.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nclass Transaction {\n  constructor(sequelize, options) {\n    this.sequelize = sequelize;\n    this.savepoints = [];\n    this._afterCommitHooks = [];\n    const generateTransactionId = this.sequelize.dialect.queryGenerator.generateTransactionId;\n    this.options = __spreadValues({\n      type: sequelize.options.transactionType,\n      isolationLevel: sequelize.options.isolationLevel,\n      readOnly: false\n    }, options);\n    this.parent = this.options.transaction;\n    if (this.parent) {\n      this.id = this.parent.id;\n      this.parent.savepoints.push(this);\n      this.name = `${this.id}-sp-${this.parent.savepoints.length}`;\n    } else {\n      this.id = this.name = generateTransactionId();\n    }\n    delete this.options.transaction;\n  }\n  async commit() {\n    if (this.finished) {\n      throw new Error(`Transaction cannot be committed because it has been finished with state: ${this.finished}`);\n    }\n    try {\n      await this.sequelize.getQueryInterface().commitTransaction(this, this.options);\n      this.cleanup();\n    } catch (e) {\n      console.warn(`Committing transaction ${this.id} failed with error ${JSON.stringify(e.message)}. We are killing its connection as it is now in an undetermined state.`);\n      await this.forceCleanup();\n      throw e;\n    } finally {\n      this.finished = \"commit\";\n      for (const hook of this._afterCommitHooks) {\n        await hook.apply(this, [this]);\n      }\n    }\n  }\n  async rollback() {\n    if (this.finished) {\n      throw new Error(`Transaction cannot be rolled back because it has been finished with state: ${this.finished}`);\n    }\n    if (!this.connection) {\n      throw new Error(\"Transaction cannot be rolled back because it never started\");\n    }\n    try {\n      await this.sequelize.getQueryInterface().rollbackTransaction(this, this.options);\n      this.cleanup();\n    } catch (e) {\n      console.warn(`Rolling back transaction ${this.id} failed with error ${JSON.stringify(e.message)}. We are killing its connection as it is now in an undetermined state.`);\n      await this.forceCleanup();\n      throw e;\n    }\n  }\n  async prepareEnvironment(useCLS = true) {\n    let connectionPromise;\n    if (this.parent) {\n      connectionPromise = Promise.resolve(this.parent.connection);\n    } else {\n      const acquireOptions = { uuid: this.id };\n      if (this.options.readOnly) {\n        acquireOptions.type = \"SELECT\";\n      }\n      connectionPromise = this.sequelize.connectionManager.getConnection(acquireOptions);\n    }\n    let result;\n    const connection = await connectionPromise;\n    this.connection = connection;\n    this.connection.uuid = this.id;\n    try {\n      await this.begin();\n      result = await this.setDeferrable();\n    } catch (setupErr) {\n      try {\n        result = await this.rollback();\n      } finally {\n        throw setupErr;\n      }\n    }\n    if (useCLS && this.sequelize.constructor._cls) {\n      this.sequelize.constructor._cls.set(\"transaction\", this);\n    }\n    return result;\n  }\n  async setDeferrable() {\n    if (this.options.deferrable) {\n      return await this.sequelize.getQueryInterface().deferConstraints(this, this.options);\n    }\n  }\n  async begin() {\n    const queryInterface = this.sequelize.getQueryInterface();\n    if (this.sequelize.dialect.supports.settingIsolationLevelDuringTransaction) {\n      await queryInterface.startTransaction(this, this.options);\n      return queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\n    }\n    await queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\n    return queryInterface.startTransaction(this, this.options);\n  }\n  cleanup() {\n    if (this.parent || this.connection.uuid === void 0) {\n      return;\n    }\n    this._clearCls();\n    this.sequelize.connectionManager.releaseConnection(this.connection);\n    this.connection.uuid = void 0;\n  }\n  async forceCleanup() {\n    if (this.parent || this.connection.uuid === void 0) {\n      return;\n    }\n    this._clearCls();\n    await this.sequelize.connectionManager.destroyConnection(this.connection);\n    this.connection.uuid = void 0;\n  }\n  _clearCls() {\n    const cls = this.sequelize.constructor._cls;\n    if (cls) {\n      if (cls.get(\"transaction\") === this) {\n        cls.set(\"transaction\", null);\n      }\n    }\n  }\n  afterCommit(fn) {\n    if (!fn || typeof fn !== \"function\") {\n      throw new Error('\"fn\" must be a function');\n    }\n    this._afterCommitHooks.push(fn);\n  }\n  static get TYPES() {\n    return {\n      DEFERRED: \"DEFERRED\",\n      IMMEDIATE: \"IMMEDIATE\",\n      EXCLUSIVE: \"EXCLUSIVE\"\n    };\n  }\n  static get ISOLATION_LEVELS() {\n    return {\n      READ_UNCOMMITTED: \"READ UNCOMMITTED\",\n      READ_COMMITTED: \"READ COMMITTED\",\n      REPEATABLE_READ: \"REPEATABLE READ\",\n      SERIALIZABLE: \"SERIALIZABLE\"\n    };\n  }\n  static get LOCK() {\n    return {\n      UPDATE: \"UPDATE\",\n      SHARE: \"SHARE\",\n      KEY_SHARE: \"KEY SHARE\",\n      NO_KEY_UPDATE: \"NO KEY UPDATE\"\n    };\n  }\n  get LOCK() {\n    return Transaction.LOCK;\n  }\n}\nmodule.exports = Transaction;\nmodule.exports.Transaction = Transaction;\nmodule.exports[\"default\"] = Transaction;\n//# sourceMappingURL=transaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi90cmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRLE1BQU0sOEJBQThCO0FBQ2pFLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csY0FBYztBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw2Q0FBNkMsU0FBUyxvQkFBb0IsMEJBQTBCO0FBQ3BHO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyxjQUFjO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLCtDQUErQyxTQUFTLG9CQUFvQiwwQkFBMEI7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQix5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvdHJhbnNhY3Rpb24uanM/MmU2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbmNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgY29uc3RydWN0b3Ioc2VxdWVsaXplLCBvcHRpb25zKSB7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5zYXZlcG9pbnRzID0gW107XG4gICAgdGhpcy5fYWZ0ZXJDb21taXRIb29rcyA9IFtdO1xuICAgIGNvbnN0IGdlbmVyYXRlVHJhbnNhY3Rpb25JZCA9IHRoaXMuc2VxdWVsaXplLmRpYWxlY3QucXVlcnlHZW5lcmF0b3IuZ2VuZXJhdGVUcmFuc2FjdGlvbklkO1xuICAgIHRoaXMub3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIHR5cGU6IHNlcXVlbGl6ZS5vcHRpb25zLnRyYW5zYWN0aW9uVHlwZSxcbiAgICAgIGlzb2xhdGlvbkxldmVsOiBzZXF1ZWxpemUub3B0aW9ucy5pc29sYXRpb25MZXZlbCxcbiAgICAgIHJlYWRPbmx5OiBmYWxzZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHRoaXMucGFyZW50ID0gdGhpcy5vcHRpb25zLnRyYW5zYWN0aW9uO1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5pZCA9IHRoaXMucGFyZW50LmlkO1xuICAgICAgdGhpcy5wYXJlbnQuc2F2ZXBvaW50cy5wdXNoKHRoaXMpO1xuICAgICAgdGhpcy5uYW1lID0gYCR7dGhpcy5pZH0tc3AtJHt0aGlzLnBhcmVudC5zYXZlcG9pbnRzLmxlbmd0aH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlkID0gdGhpcy5uYW1lID0gZ2VuZXJhdGVUcmFuc2FjdGlvbklkKCk7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMudHJhbnNhY3Rpb247XG4gIH1cbiAgYXN5bmMgY29tbWl0KCkge1xuICAgIGlmICh0aGlzLmZpbmlzaGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIGNhbm5vdCBiZSBjb21taXR0ZWQgYmVjYXVzZSBpdCBoYXMgYmVlbiBmaW5pc2hlZCB3aXRoIHN0YXRlOiAke3RoaXMuZmluaXNoZWR9YCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5nZXRRdWVyeUludGVyZmFjZSgpLmNvbW1pdFRyYW5zYWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENvbW1pdHRpbmcgdHJhbnNhY3Rpb24gJHt0aGlzLmlkfSBmYWlsZWQgd2l0aCBlcnJvciAke0pTT04uc3RyaW5naWZ5KGUubWVzc2FnZSl9LiBXZSBhcmUga2lsbGluZyBpdHMgY29ubmVjdGlvbiBhcyBpdCBpcyBub3cgaW4gYW4gdW5kZXRlcm1pbmVkIHN0YXRlLmApO1xuICAgICAgYXdhaXQgdGhpcy5mb3JjZUNsZWFudXAoKTtcbiAgICAgIHRocm93IGU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZmluaXNoZWQgPSBcImNvbW1pdFwiO1xuICAgICAgZm9yIChjb25zdCBob29rIG9mIHRoaXMuX2FmdGVyQ29tbWl0SG9va3MpIHtcbiAgICAgICAgYXdhaXQgaG9vay5hcHBseSh0aGlzLCBbdGhpc10pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyByb2xsYmFjaygpIHtcbiAgICBpZiAodGhpcy5maW5pc2hlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBjYW5ub3QgYmUgcm9sbGVkIGJhY2sgYmVjYXVzZSBpdCBoYXMgYmVlbiBmaW5pc2hlZCB3aXRoIHN0YXRlOiAke3RoaXMuZmluaXNoZWR9YCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb25uZWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2FjdGlvbiBjYW5ub3QgYmUgcm9sbGVkIGJhY2sgYmVjYXVzZSBpdCBuZXZlciBzdGFydGVkXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUuZ2V0UXVlcnlJbnRlcmZhY2UoKS5yb2xsYmFja1RyYW5zYWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFJvbGxpbmcgYmFjayB0cmFuc2FjdGlvbiAke3RoaXMuaWR9IGZhaWxlZCB3aXRoIGVycm9yICR7SlNPTi5zdHJpbmdpZnkoZS5tZXNzYWdlKX0uIFdlIGFyZSBraWxsaW5nIGl0cyBjb25uZWN0aW9uIGFzIGl0IGlzIG5vdyBpbiBhbiB1bmRldGVybWluZWQgc3RhdGUuYCk7XG4gICAgICBhd2FpdCB0aGlzLmZvcmNlQ2xlYW51cCgpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcHJlcGFyZUVudmlyb25tZW50KHVzZUNMUyA9IHRydWUpIHtcbiAgICBsZXQgY29ubmVjdGlvblByb21pc2U7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICBjb25uZWN0aW9uUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh0aGlzLnBhcmVudC5jb25uZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYWNxdWlyZU9wdGlvbnMgPSB7IHV1aWQ6IHRoaXMuaWQgfTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVhZE9ubHkpIHtcbiAgICAgICAgYWNxdWlyZU9wdGlvbnMudHlwZSA9IFwiU0VMRUNUXCI7XG4gICAgICB9XG4gICAgICBjb25uZWN0aW9uUHJvbWlzZSA9IHRoaXMuc2VxdWVsaXplLmNvbm5lY3Rpb25NYW5hZ2VyLmdldENvbm5lY3Rpb24oYWNxdWlyZU9wdGlvbnMpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBjb25uZWN0aW9uUHJvbWlzZTtcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgIHRoaXMuY29ubmVjdGlvbi51dWlkID0gdGhpcy5pZDtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5iZWdpbigpO1xuICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5zZXREZWZlcnJhYmxlKCk7XG4gICAgfSBjYXRjaCAoc2V0dXBFcnIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMucm9sbGJhY2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRocm93IHNldHVwRXJyO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXNlQ0xTICYmIHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMpIHtcbiAgICAgIHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMuc2V0KFwidHJhbnNhY3Rpb25cIiwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgc2V0RGVmZXJyYWJsZSgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmRlZmVycmFibGUpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5nZXRRdWVyeUludGVyZmFjZSgpLmRlZmVyQ29uc3RyYWludHModGhpcywgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYmVnaW4oKSB7XG4gICAgY29uc3QgcXVlcnlJbnRlcmZhY2UgPSB0aGlzLnNlcXVlbGl6ZS5nZXRRdWVyeUludGVyZmFjZSgpO1xuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5kaWFsZWN0LnN1cHBvcnRzLnNldHRpbmdJc29sYXRpb25MZXZlbER1cmluZ1RyYW5zYWN0aW9uKSB7XG4gICAgICBhd2FpdCBxdWVyeUludGVyZmFjZS5zdGFydFRyYW5zYWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucyk7XG4gICAgICByZXR1cm4gcXVlcnlJbnRlcmZhY2Uuc2V0SXNvbGF0aW9uTGV2ZWwodGhpcywgdGhpcy5vcHRpb25zLmlzb2xhdGlvbkxldmVsLCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICBhd2FpdCBxdWVyeUludGVyZmFjZS5zZXRJc29sYXRpb25MZXZlbCh0aGlzLCB0aGlzLm9wdGlvbnMuaXNvbGF0aW9uTGV2ZWwsIHRoaXMub3B0aW9ucyk7XG4gICAgcmV0dXJuIHF1ZXJ5SW50ZXJmYWNlLnN0YXJ0VHJhbnNhY3Rpb24odGhpcywgdGhpcy5vcHRpb25zKTtcbiAgfVxuICBjbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLnBhcmVudCB8fCB0aGlzLmNvbm5lY3Rpb24udXVpZCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NsZWFyQ2xzKCk7XG4gICAgdGhpcy5zZXF1ZWxpemUuY29ubmVjdGlvbk1hbmFnZXIucmVsZWFzZUNvbm5lY3Rpb24odGhpcy5jb25uZWN0aW9uKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24udXVpZCA9IHZvaWQgMDtcbiAgfVxuICBhc3luYyBmb3JjZUNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50IHx8IHRoaXMuY29ubmVjdGlvbi51dWlkID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY2xlYXJDbHMoKTtcbiAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5jb25uZWN0aW9uTWFuYWdlci5kZXN0cm95Q29ubmVjdGlvbih0aGlzLmNvbm5lY3Rpb24pO1xuICAgIHRoaXMuY29ubmVjdGlvbi51dWlkID0gdm9pZCAwO1xuICB9XG4gIF9jbGVhckNscygpIHtcbiAgICBjb25zdCBjbHMgPSB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzO1xuICAgIGlmIChjbHMpIHtcbiAgICAgIGlmIChjbHMuZ2V0KFwidHJhbnNhY3Rpb25cIikgPT09IHRoaXMpIHtcbiAgICAgICAgY2xzLnNldChcInRyYW5zYWN0aW9uXCIsIG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhZnRlckNvbW1pdChmbikge1xuICAgIGlmICghZm4gfHwgdHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJmblwiIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgICB0aGlzLl9hZnRlckNvbW1pdEhvb2tzLnB1c2goZm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgVFlQRVMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIERFRkVSUkVEOiBcIkRFRkVSUkVEXCIsXG4gICAgICBJTU1FRElBVEU6IFwiSU1NRURJQVRFXCIsXG4gICAgICBFWENMVVNJVkU6IFwiRVhDTFVTSVZFXCJcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBnZXQgSVNPTEFUSU9OX0xFVkVMUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgUkVBRF9VTkNPTU1JVFRFRDogXCJSRUFEIFVOQ09NTUlUVEVEXCIsXG4gICAgICBSRUFEX0NPTU1JVFRFRDogXCJSRUFEIENPTU1JVFRFRFwiLFxuICAgICAgUkVQRUFUQUJMRV9SRUFEOiBcIlJFUEVBVEFCTEUgUkVBRFwiLFxuICAgICAgU0VSSUFMSVpBQkxFOiBcIlNFUklBTElaQUJMRVwiXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZ2V0IExPQ0soKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFVQREFURTogXCJVUERBVEVcIixcbiAgICAgIFNIQVJFOiBcIlNIQVJFXCIsXG4gICAgICBLRVlfU0hBUkU6IFwiS0VZIFNIQVJFXCIsXG4gICAgICBOT19LRVlfVVBEQVRFOiBcIk5PIEtFWSBVUERBVEVcIlxuICAgIH07XG4gIH1cbiAgZ2V0IExPQ0soKSB7XG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uLkxPQ0s7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb247XG5tb2R1bGUuZXhwb3J0cy5UcmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IFRyYW5zYWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNhY3Rpb24uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/transaction.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/utils.js":
/*!**********************************************!*\
  !*** ../node_modules/sequelize/lib/utils.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst DataTypes = __webpack_require__(/*! ./data-types */ \"(action-browser)/../node_modules/sequelize/lib/data-types.js\");\nconst SqlString = __webpack_require__(/*! ./sql-string */ \"(action-browser)/../node_modules/sequelize/lib/sql-string.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst baseIsNative = __webpack_require__(/*! lodash/_baseIsNative */ \"(action-browser)/../node_modules/lodash/_baseIsNative.js\");\nconst uuidv1 = (__webpack_require__(/*! uuid */ \"(action-browser)/../node_modules/uuid/dist/esm-node/index.js\").v1);\nconst uuidv4 = (__webpack_require__(/*! uuid */ \"(action-browser)/../node_modules/uuid/dist/esm-node/index.js\").v4);\nconst operators = __webpack_require__(/*! ./operators */ \"(action-browser)/../node_modules/sequelize/lib/operators.js\");\nconst operatorsSet = new Set(Object.values(operators));\nlet inflection = __webpack_require__(/*! inflection */ \"(action-browser)/../node_modules/inflection/lib/inflection.js\");\nexports.classToInvokable = __webpack_require__(/*! ./utils/class-to-invokable */ \"(action-browser)/../node_modules/sequelize/lib/utils/class-to-invokable.js\").classToInvokable;\nexports.joinSQLFragments = __webpack_require__(/*! ./utils/join-sql-fragments */ \"(action-browser)/../node_modules/sequelize/lib/utils/join-sql-fragments.js\").joinSQLFragments;\nfunction useInflection(_inflection) {\n  inflection = _inflection;\n}\nexports.useInflection = useInflection;\nfunction camelizeIf(str, condition) {\n  let result = str;\n  if (condition) {\n    result = camelize(str);\n  }\n  return result;\n}\nexports.camelizeIf = camelizeIf;\nfunction underscoredIf(str, condition) {\n  let result = str;\n  if (condition) {\n    result = underscore(str);\n  }\n  return result;\n}\nexports.underscoredIf = underscoredIf;\nfunction isPrimitive(val) {\n  const type = typeof val;\n  return [\"string\", \"number\", \"boolean\"].includes(type);\n}\nexports.isPrimitive = isPrimitive;\nfunction mergeDefaults(a, b) {\n  return _.mergeWith(a, b, (objectValue, sourceValue) => {\n    if (!_.isPlainObject(objectValue) && objectValue !== void 0) {\n      if (_.isFunction(objectValue) && baseIsNative(objectValue)) {\n        return sourceValue || objectValue;\n      }\n      return objectValue;\n    }\n  });\n}\nexports.mergeDefaults = mergeDefaults;\nfunction merge() {\n  const result = {};\n  for (const obj of arguments) {\n    _.forOwn(obj, (value, key) => {\n      if (value !== void 0) {\n        if (!result[key]) {\n          result[key] = value;\n        } else if (_.isPlainObject(value) && _.isPlainObject(result[key])) {\n          result[key] = merge(result[key], value);\n        } else if (Array.isArray(value) && Array.isArray(result[key])) {\n          result[key] = value.concat(result[key]);\n        } else {\n          result[key] = value;\n        }\n      }\n    });\n  }\n  return result;\n}\nexports.merge = merge;\nfunction spliceStr(str, index, count, add) {\n  return str.slice(0, index) + add + str.slice(index + count);\n}\nexports.spliceStr = spliceStr;\nfunction camelize(str) {\n  return str.trim().replace(/[-_\\s]+(.)?/g, (match, c) => c.toUpperCase());\n}\nexports.camelize = camelize;\nfunction underscore(str) {\n  return inflection.underscore(str);\n}\nexports.underscore = underscore;\nfunction singularize(str) {\n  return inflection.singularize(str);\n}\nexports.singularize = singularize;\nfunction pluralize(str) {\n  return inflection.pluralize(str);\n}\nexports.pluralize = pluralize;\nfunction format(arr, dialect) {\n  const timeZone = null;\n  return SqlString.format(arr[0], arr.slice(1), timeZone, dialect);\n}\nexports.format = format;\nfunction formatNamedParameters(sql, parameters, dialect) {\n  const timeZone = null;\n  return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);\n}\nexports.formatNamedParameters = formatNamedParameters;\nfunction cloneDeep(obj, onlyPlain) {\n  obj = obj || {};\n  return _.cloneDeepWith(obj, (elem) => {\n    if (Array.isArray(elem) || _.isPlainObject(elem)) {\n      return void 0;\n    }\n    if (onlyPlain || typeof elem === \"object\") {\n      return elem;\n    }\n    if (elem && typeof elem.clone === \"function\") {\n      return elem.clone();\n    }\n  });\n}\nexports.cloneDeep = cloneDeep;\nfunction mapFinderOptions(options, Model) {\n  if (options.attributes && Array.isArray(options.attributes)) {\n    options.attributes = Model._injectDependentVirtualAttributes(options.attributes);\n    options.attributes = options.attributes.filter((v) => !Model._virtualAttributes.has(v));\n  }\n  mapOptionFieldNames(options, Model);\n  return options;\n}\nexports.mapFinderOptions = mapFinderOptions;\nfunction mapOptionFieldNames(options, Model) {\n  if (Array.isArray(options.attributes)) {\n    options.attributes = options.attributes.map((attr) => {\n      if (typeof attr !== \"string\")\n        return attr;\n      if (Model.rawAttributes[attr] && attr !== Model.rawAttributes[attr].field) {\n        return [Model.rawAttributes[attr].field, attr];\n      }\n      return attr;\n    });\n  }\n  if (options.where && _.isPlainObject(options.where)) {\n    options.where = mapWhereFieldNames(options.where, Model);\n  }\n  return options;\n}\nexports.mapOptionFieldNames = mapOptionFieldNames;\nfunction mapWhereFieldNames(attributes, Model) {\n  if (attributes) {\n    attributes = cloneDeep(attributes);\n    getComplexKeys(attributes).forEach((attribute) => {\n      const rawAttribute = Model.rawAttributes[attribute];\n      if (rawAttribute && rawAttribute.field !== rawAttribute.fieldName) {\n        attributes[rawAttribute.field] = attributes[attribute];\n        delete attributes[attribute];\n      }\n      if (_.isPlainObject(attributes[attribute]) && !(rawAttribute && (rawAttribute.type instanceof DataTypes.HSTORE || rawAttribute.type instanceof DataTypes.JSON))) {\n        attributes[attribute] = mapOptionFieldNames({\n          where: attributes[attribute]\n        }, Model).where;\n      }\n      if (Array.isArray(attributes[attribute])) {\n        attributes[attribute].forEach((where, index) => {\n          if (_.isPlainObject(where)) {\n            attributes[attribute][index] = mapWhereFieldNames(where, Model);\n          }\n        });\n      }\n    });\n  }\n  return attributes;\n}\nexports.mapWhereFieldNames = mapWhereFieldNames;\nfunction mapValueFieldNames(dataValues, fields, Model) {\n  const values = {};\n  for (const attr of fields) {\n    if (dataValues[attr] !== void 0 && !Model._virtualAttributes.has(attr)) {\n      if (Model.rawAttributes[attr] && Model.rawAttributes[attr].field && Model.rawAttributes[attr].field !== attr) {\n        values[Model.rawAttributes[attr].field] = dataValues[attr];\n      } else {\n        values[attr] = dataValues[attr];\n      }\n    }\n  }\n  return values;\n}\nexports.mapValueFieldNames = mapValueFieldNames;\nfunction isColString(value) {\n  return typeof value === \"string\" && value[0] === \"$\" && value[value.length - 1] === \"$\";\n}\nexports.isColString = isColString;\nfunction canTreatArrayAsAnd(arr) {\n  return arr.some((arg) => _.isPlainObject(arg) || arg instanceof Where);\n}\nexports.canTreatArrayAsAnd = canTreatArrayAsAnd;\nfunction combineTableNames(tableName1, tableName2) {\n  return tableName1.toLowerCase() < tableName2.toLowerCase() ? tableName1 + tableName2 : tableName2 + tableName1;\n}\nexports.combineTableNames = combineTableNames;\nfunction toDefaultValue(value, dialect) {\n  if (typeof value === \"function\") {\n    const tmp = value();\n    if (tmp instanceof DataTypes.ABSTRACT) {\n      return tmp.toSql();\n    }\n    return tmp;\n  }\n  if (value instanceof DataTypes.UUIDV1) {\n    return uuidv1();\n  }\n  if (value instanceof DataTypes.UUIDV4) {\n    return uuidv4();\n  }\n  if (value instanceof DataTypes.NOW) {\n    return now(dialect);\n  }\n  if (Array.isArray(value)) {\n    return value.slice();\n  }\n  if (_.isPlainObject(value)) {\n    return __spreadValues({}, value);\n  }\n  return value;\n}\nexports.toDefaultValue = toDefaultValue;\nfunction defaultValueSchemable(value) {\n  if (value === void 0) {\n    return false;\n  }\n  if (value instanceof DataTypes.NOW) {\n    return false;\n  }\n  if (value instanceof DataTypes.UUIDV1 || value instanceof DataTypes.UUIDV4) {\n    return false;\n  }\n  return typeof value !== \"function\";\n}\nexports.defaultValueSchemable = defaultValueSchemable;\nfunction removeNullValuesFromHash(hash, omitNull, options) {\n  let result = hash;\n  options = options || {};\n  options.allowNull = options.allowNull || [];\n  if (omitNull) {\n    const _hash = {};\n    _.forIn(hash, (val, key) => {\n      if (options.allowNull.includes(key) || key.endsWith(\"Id\") || val !== null && val !== void 0) {\n        _hash[key] = val;\n      }\n    });\n    result = _hash;\n  }\n  return result;\n}\nexports.removeNullValuesFromHash = removeNullValuesFromHash;\nconst dialects = /* @__PURE__ */ new Set([\"mariadb\", \"mysql\", \"postgres\", \"sqlite\", \"mssql\", \"db2\", \"oracle\"]);\nfunction now(dialect) {\n  const d = new Date();\n  if (!dialects.has(dialect)) {\n    d.setMilliseconds(0);\n  }\n  return d;\n}\nexports.now = now;\nconst TICK_CHAR = \"`\";\nexports.TICK_CHAR = TICK_CHAR;\nfunction addTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return tickChar + removeTicks(s, tickChar) + tickChar;\n}\nexports.addTicks = addTicks;\nfunction removeTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return s.replace(new RegExp(tickChar, \"g\"), \"\");\n}\nexports.removeTicks = removeTicks;\nfunction flattenObjectDeep(value) {\n  if (!_.isPlainObject(value))\n    return value;\n  const flattenedObj = {};\n  function flattenObject(obj, subPath) {\n    Object.keys(obj).forEach((key) => {\n      const pathToProperty = subPath ? `${subPath}.${key}` : key;\n      if (typeof obj[key] === \"object\" && obj[key] !== null) {\n        flattenObject(obj[key], pathToProperty);\n      } else {\n        flattenedObj[pathToProperty] = _.get(obj, key);\n      }\n    });\n    return flattenedObj;\n  }\n  return flattenObject(value, void 0);\n}\nexports.flattenObjectDeep = flattenObjectDeep;\nclass SequelizeMethod {\n}\nexports.SequelizeMethod = SequelizeMethod;\nclass Fn extends SequelizeMethod {\n  constructor(fn, args) {\n    super();\n    this.fn = fn;\n    this.args = args;\n  }\n  clone() {\n    return new Fn(this.fn, this.args);\n  }\n}\nexports.Fn = Fn;\nclass Col extends SequelizeMethod {\n  constructor(col, ...args) {\n    super();\n    if (args.length > 0) {\n      col = args;\n    }\n    this.col = col;\n  }\n}\nexports.Col = Col;\nclass Cast extends SequelizeMethod {\n  constructor(val, type, json) {\n    super();\n    this.val = val;\n    this.type = (type || \"\").trim();\n    this.json = json || false;\n  }\n}\nexports.Cast = Cast;\nclass Literal extends SequelizeMethod {\n  constructor(val) {\n    super();\n    this.val = val;\n  }\n}\nexports.Literal = Literal;\nclass Json extends SequelizeMethod {\n  constructor(conditionsOrPath, value) {\n    super();\n    if (_.isObject(conditionsOrPath)) {\n      this.conditions = conditionsOrPath;\n    } else {\n      this.path = conditionsOrPath;\n      if (value) {\n        this.value = value;\n      }\n    }\n  }\n}\nexports.Json = Json;\nclass Where extends SequelizeMethod {\n  constructor(attribute, comparator, logic) {\n    super();\n    if (logic === void 0) {\n      logic = comparator;\n      comparator = \"=\";\n    }\n    this.attribute = attribute;\n    this.comparator = comparator;\n    this.logic = logic;\n  }\n}\nexports.Where = Where;\nfunction getOperators(obj) {\n  return Object.getOwnPropertySymbols(obj).filter((s) => operatorsSet.has(s));\n}\nexports.getOperators = getOperators;\nfunction getComplexKeys(obj) {\n  return getOperators(obj).concat(Object.keys(obj));\n}\nexports.getComplexKeys = getComplexKeys;\nfunction getComplexSize(obj) {\n  return Array.isArray(obj) ? obj.length : getComplexKeys(obj).length;\n}\nexports.getComplexSize = getComplexSize;\nfunction isWhereEmpty(obj) {\n  return !!obj && _.isEmpty(obj) && getOperators(obj).length === 0;\n}\nexports.isWhereEmpty = isWhereEmpty;\nfunction generateEnumName(tableName, columnName) {\n  return `enum_${tableName}_${columnName}`;\n}\nexports.generateEnumName = generateEnumName;\nfunction camelizeObjectKeys(obj) {\n  const newObj = new Object();\n  Object.keys(obj).forEach((key) => {\n    newObj[camelize(key)] = obj[key];\n  });\n  return newObj;\n}\nexports.camelizeObjectKeys = camelizeObjectKeys;\nfunction defaults(object, ...sources) {\n  object = Object(object);\n  sources.forEach((source) => {\n    if (source) {\n      source = Object(source);\n      getComplexKeys(source).forEach((key) => {\n        const value = object[key];\n        if (value === void 0 || _.eq(value, Object.prototype[key]) && !Object.prototype.hasOwnProperty.call(object, key)) {\n          object[key] = source[key];\n        }\n      });\n    }\n  });\n  return object;\n}\nexports.defaults = defaults;\nfunction nameIndex(index, tableName) {\n  if (tableName.tableName)\n    tableName = tableName.tableName;\n  if (!Object.prototype.hasOwnProperty.call(index, \"name\")) {\n    const fields = index.fields.map((field) => typeof field === \"string\" ? field : field.name || field.attribute);\n    index.name = underscore(`${tableName}_${fields.join(\"_\")}`);\n  }\n  return index;\n}\nexports.nameIndex = nameIndex;\nfunction intersects(arr1, arr2) {\n  return arr1.some((v) => arr2.includes(v));\n}\nexports.intersects = intersects;\nfunction safeStringifyJson(value) {\n  return JSON.stringify(value, (key, value2) => {\n    if (typeof value2 === \"bigint\") {\n      return String(value2);\n    }\n    return value2;\n  });\n}\nexports.safeStringifyJson = safeStringifyJson;\n//# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxrRkFBYztBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQyxrRkFBYztBQUN4QyxVQUFVLG1CQUFPLENBQUMsaUVBQVE7QUFDMUIscUJBQXFCLG1CQUFPLENBQUMsc0ZBQXNCO0FBQ25ELGVBQWUsb0dBQWtCO0FBQ2pDLGVBQWUsb0dBQWtCO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLGdGQUFhO0FBQ3ZDO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsaUZBQVk7QUFDckMsK0tBQWlGO0FBQ2pGLCtLQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVEsR0FBRyxJQUFJO0FBQ3pEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxpQkFBaUIsVUFBVSxHQUFHLFdBQVc7QUFDekM7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVSxHQUFHLGlCQUFpQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy5qcz9hOGY3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4vZGF0YS10eXBlc1wiKTtcbmNvbnN0IFNxbFN0cmluZyA9IHJlcXVpcmUoXCIuL3NxbC1zdHJpbmdcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IGJhc2VJc05hdGl2ZSA9IHJlcXVpcmUoXCJsb2Rhc2gvX2Jhc2VJc05hdGl2ZVwiKTtcbmNvbnN0IHV1aWR2MSA9IHJlcXVpcmUoXCJ1dWlkXCIpLnYxO1xuY29uc3QgdXVpZHY0ID0gcmVxdWlyZShcInV1aWRcIikudjQ7XG5jb25zdCBvcGVyYXRvcnMgPSByZXF1aXJlKFwiLi9vcGVyYXRvcnNcIik7XG5jb25zdCBvcGVyYXRvcnNTZXQgPSBuZXcgU2V0KE9iamVjdC52YWx1ZXMob3BlcmF0b3JzKSk7XG5sZXQgaW5mbGVjdGlvbiA9IHJlcXVpcmUoXCJpbmZsZWN0aW9uXCIpO1xuZXhwb3J0cy5jbGFzc1RvSW52b2thYmxlID0gcmVxdWlyZShcIi4vdXRpbHMvY2xhc3MtdG8taW52b2thYmxlXCIpLmNsYXNzVG9JbnZva2FibGU7XG5leHBvcnRzLmpvaW5TUUxGcmFnbWVudHMgPSByZXF1aXJlKFwiLi91dGlscy9qb2luLXNxbC1mcmFnbWVudHNcIikuam9pblNRTEZyYWdtZW50cztcbmZ1bmN0aW9uIHVzZUluZmxlY3Rpb24oX2luZmxlY3Rpb24pIHtcbiAgaW5mbGVjdGlvbiA9IF9pbmZsZWN0aW9uO1xufVxuZXhwb3J0cy51c2VJbmZsZWN0aW9uID0gdXNlSW5mbGVjdGlvbjtcbmZ1bmN0aW9uIGNhbWVsaXplSWYoc3RyLCBjb25kaXRpb24pIHtcbiAgbGV0IHJlc3VsdCA9IHN0cjtcbiAgaWYgKGNvbmRpdGlvbikge1xuICAgIHJlc3VsdCA9IGNhbWVsaXplKHN0cik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuY2FtZWxpemVJZiA9IGNhbWVsaXplSWY7XG5mdW5jdGlvbiB1bmRlcnNjb3JlZElmKHN0ciwgY29uZGl0aW9uKSB7XG4gIGxldCByZXN1bHQgPSBzdHI7XG4gIGlmIChjb25kaXRpb24pIHtcbiAgICByZXN1bHQgPSB1bmRlcnNjb3JlKHN0cik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMudW5kZXJzY29yZWRJZiA9IHVuZGVyc2NvcmVkSWY7XG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWwpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIHJldHVybiBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJib29sZWFuXCJdLmluY2x1ZGVzKHR5cGUpO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuZnVuY3Rpb24gbWVyZ2VEZWZhdWx0cyhhLCBiKSB7XG4gIHJldHVybiBfLm1lcmdlV2l0aChhLCBiLCAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlKSA9PiB7XG4gICAgaWYgKCFfLmlzUGxhaW5PYmplY3Qob2JqZWN0VmFsdWUpICYmIG9iamVjdFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqZWN0VmFsdWUpICYmIGJhc2VJc05hdGl2ZShvYmplY3RWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZVZhbHVlIHx8IG9iamVjdFZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdFZhbHVlO1xuICAgIH1cbiAgfSk7XG59XG5leHBvcnRzLm1lcmdlRGVmYXVsdHMgPSBtZXJnZURlZmF1bHRzO1xuZnVuY3Rpb24gbWVyZ2UoKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IG9iaiBvZiBhcmd1bWVudHMpIHtcbiAgICBfLmZvck93bihvYmosICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoIXJlc3VsdFtrZXldKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChfLmlzUGxhaW5PYmplY3QodmFsdWUpICYmIF8uaXNQbGFpbk9iamVjdChyZXN1bHRba2V5XSkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgQXJyYXkuaXNBcnJheShyZXN1bHRba2V5XSkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlLmNvbmNhdChyZXN1bHRba2V5XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLm1lcmdlID0gbWVyZ2U7XG5mdW5jdGlvbiBzcGxpY2VTdHIoc3RyLCBpbmRleCwgY291bnQsIGFkZCkge1xuICByZXR1cm4gc3RyLnNsaWNlKDAsIGluZGV4KSArIGFkZCArIHN0ci5zbGljZShpbmRleCArIGNvdW50KTtcbn1cbmV4cG9ydHMuc3BsaWNlU3RyID0gc3BsaWNlU3RyO1xuZnVuY3Rpb24gY2FtZWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHIudHJpbSgpLnJlcGxhY2UoL1stX1xcc10rKC4pPy9nLCAobWF0Y2gsIGMpID0+IGMudG9VcHBlckNhc2UoKSk7XG59XG5leHBvcnRzLmNhbWVsaXplID0gY2FtZWxpemU7XG5mdW5jdGlvbiB1bmRlcnNjb3JlKHN0cikge1xuICByZXR1cm4gaW5mbGVjdGlvbi51bmRlcnNjb3JlKHN0cik7XG59XG5leHBvcnRzLnVuZGVyc2NvcmUgPSB1bmRlcnNjb3JlO1xuZnVuY3Rpb24gc2luZ3VsYXJpemUoc3RyKSB7XG4gIHJldHVybiBpbmZsZWN0aW9uLnNpbmd1bGFyaXplKHN0cik7XG59XG5leHBvcnRzLnNpbmd1bGFyaXplID0gc2luZ3VsYXJpemU7XG5mdW5jdGlvbiBwbHVyYWxpemUoc3RyKSB7XG4gIHJldHVybiBpbmZsZWN0aW9uLnBsdXJhbGl6ZShzdHIpO1xufVxuZXhwb3J0cy5wbHVyYWxpemUgPSBwbHVyYWxpemU7XG5mdW5jdGlvbiBmb3JtYXQoYXJyLCBkaWFsZWN0KSB7XG4gIGNvbnN0IHRpbWVab25lID0gbnVsbDtcbiAgcmV0dXJuIFNxbFN0cmluZy5mb3JtYXQoYXJyWzBdLCBhcnIuc2xpY2UoMSksIHRpbWVab25lLCBkaWFsZWN0KTtcbn1cbmV4cG9ydHMuZm9ybWF0ID0gZm9ybWF0O1xuZnVuY3Rpb24gZm9ybWF0TmFtZWRQYXJhbWV0ZXJzKHNxbCwgcGFyYW1ldGVycywgZGlhbGVjdCkge1xuICBjb25zdCB0aW1lWm9uZSA9IG51bGw7XG4gIHJldHVybiBTcWxTdHJpbmcuZm9ybWF0TmFtZWRQYXJhbWV0ZXJzKHNxbCwgcGFyYW1ldGVycywgdGltZVpvbmUsIGRpYWxlY3QpO1xufVxuZXhwb3J0cy5mb3JtYXROYW1lZFBhcmFtZXRlcnMgPSBmb3JtYXROYW1lZFBhcmFtZXRlcnM7XG5mdW5jdGlvbiBjbG9uZURlZXAob2JqLCBvbmx5UGxhaW4pIHtcbiAgb2JqID0gb2JqIHx8IHt9O1xuICByZXR1cm4gXy5jbG9uZURlZXBXaXRoKG9iaiwgKGVsZW0pID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtKSB8fCBfLmlzUGxhaW5PYmplY3QoZWxlbSkpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChvbmx5UGxhaW4gfHwgdHlwZW9mIGVsZW0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBlbGVtO1xuICAgIH1cbiAgICBpZiAoZWxlbSAmJiB0eXBlb2YgZWxlbS5jbG9uZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gZWxlbS5jbG9uZSgpO1xuICAgIH1cbiAgfSk7XG59XG5leHBvcnRzLmNsb25lRGVlcCA9IGNsb25lRGVlcDtcbmZ1bmN0aW9uIG1hcEZpbmRlck9wdGlvbnMob3B0aW9ucywgTW9kZWwpIHtcbiAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcyAmJiBBcnJheS5pc0FycmF5KG9wdGlvbnMuYXR0cmlidXRlcykpIHtcbiAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBNb2RlbC5faW5qZWN0RGVwZW5kZW50VmlydHVhbEF0dHJpYnV0ZXMob3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMuZmlsdGVyKCh2KSA9PiAhTW9kZWwuX3ZpcnR1YWxBdHRyaWJ1dGVzLmhhcyh2KSk7XG4gIH1cbiAgbWFwT3B0aW9uRmllbGROYW1lcyhvcHRpb25zLCBNb2RlbCk7XG4gIHJldHVybiBvcHRpb25zO1xufVxuZXhwb3J0cy5tYXBGaW5kZXJPcHRpb25zID0gbWFwRmluZGVyT3B0aW9ucztcbmZ1bmN0aW9uIG1hcE9wdGlvbkZpZWxkTmFtZXMob3B0aW9ucywgTW9kZWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5hdHRyaWJ1dGVzKSkge1xuICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcy5tYXAoKGF0dHIpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgYXR0ciAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgICBpZiAoTW9kZWwucmF3QXR0cmlidXRlc1thdHRyXSAmJiBhdHRyICE9PSBNb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkKSB7XG4gICAgICAgIHJldHVybiBbTW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZCwgYXR0cl07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cjtcbiAgICB9KTtcbiAgfVxuICBpZiAob3B0aW9ucy53aGVyZSAmJiBfLmlzUGxhaW5PYmplY3Qob3B0aW9ucy53aGVyZSkpIHtcbiAgICBvcHRpb25zLndoZXJlID0gbWFwV2hlcmVGaWVsZE5hbWVzKG9wdGlvbnMud2hlcmUsIE1vZGVsKTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cbmV4cG9ydHMubWFwT3B0aW9uRmllbGROYW1lcyA9IG1hcE9wdGlvbkZpZWxkTmFtZXM7XG5mdW5jdGlvbiBtYXBXaGVyZUZpZWxkTmFtZXMoYXR0cmlidXRlcywgTW9kZWwpIHtcbiAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICBhdHRyaWJ1dGVzID0gY2xvbmVEZWVwKGF0dHJpYnV0ZXMpO1xuICAgIGdldENvbXBsZXhLZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goKGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgY29uc3QgcmF3QXR0cmlidXRlID0gTW9kZWwucmF3QXR0cmlidXRlc1thdHRyaWJ1dGVdO1xuICAgICAgaWYgKHJhd0F0dHJpYnV0ZSAmJiByYXdBdHRyaWJ1dGUuZmllbGQgIT09IHJhd0F0dHJpYnV0ZS5maWVsZE5hbWUpIHtcbiAgICAgICAgYXR0cmlidXRlc1tyYXdBdHRyaWJ1dGUuZmllbGRdID0gYXR0cmlidXRlc1thdHRyaWJ1dGVdO1xuICAgICAgICBkZWxldGUgYXR0cmlidXRlc1thdHRyaWJ1dGVdO1xuICAgICAgfVxuICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0pICYmICEocmF3QXR0cmlidXRlICYmIChyYXdBdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5IU1RPUkUgfHwgcmF3QXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuSlNPTikpKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IG1hcE9wdGlvbkZpZWxkTmFtZXMoe1xuICAgICAgICAgIHdoZXJlOiBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV1cbiAgICAgICAgfSwgTW9kZWwpLndoZXJlO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cmlidXRlc1thdHRyaWJ1dGVdKSkge1xuICAgICAgICBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0uZm9yRWFjaCgod2hlcmUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdCh3aGVyZSkpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbYXR0cmlidXRlXVtpbmRleF0gPSBtYXBXaGVyZUZpZWxkTmFtZXMod2hlcmUsIE1vZGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufVxuZXhwb3J0cy5tYXBXaGVyZUZpZWxkTmFtZXMgPSBtYXBXaGVyZUZpZWxkTmFtZXM7XG5mdW5jdGlvbiBtYXBWYWx1ZUZpZWxkTmFtZXMoZGF0YVZhbHVlcywgZmllbGRzLCBNb2RlbCkge1xuICBjb25zdCB2YWx1ZXMgPSB7fTtcbiAgZm9yIChjb25zdCBhdHRyIG9mIGZpZWxkcykge1xuICAgIGlmIChkYXRhVmFsdWVzW2F0dHJdICE9PSB2b2lkIDAgJiYgIU1vZGVsLl92aXJ0dWFsQXR0cmlidXRlcy5oYXMoYXR0cikpIHtcbiAgICAgIGlmIChNb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdICYmIE1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGQgJiYgTW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZCAhPT0gYXR0cikge1xuICAgICAgICB2YWx1ZXNbTW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZF0gPSBkYXRhVmFsdWVzW2F0dHJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzW2F0dHJdID0gZGF0YVZhbHVlc1thdHRyXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cbmV4cG9ydHMubWFwVmFsdWVGaWVsZE5hbWVzID0gbWFwVmFsdWVGaWVsZE5hbWVzO1xuZnVuY3Rpb24gaXNDb2xTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZVswXSA9PT0gXCIkXCIgJiYgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09IFwiJFwiO1xufVxuZXhwb3J0cy5pc0NvbFN0cmluZyA9IGlzQ29sU3RyaW5nO1xuZnVuY3Rpb24gY2FuVHJlYXRBcnJheUFzQW5kKGFycikge1xuICByZXR1cm4gYXJyLnNvbWUoKGFyZykgPT4gXy5pc1BsYWluT2JqZWN0KGFyZykgfHwgYXJnIGluc3RhbmNlb2YgV2hlcmUpO1xufVxuZXhwb3J0cy5jYW5UcmVhdEFycmF5QXNBbmQgPSBjYW5UcmVhdEFycmF5QXNBbmQ7XG5mdW5jdGlvbiBjb21iaW5lVGFibGVOYW1lcyh0YWJsZU5hbWUxLCB0YWJsZU5hbWUyKSB7XG4gIHJldHVybiB0YWJsZU5hbWUxLnRvTG93ZXJDYXNlKCkgPCB0YWJsZU5hbWUyLnRvTG93ZXJDYXNlKCkgPyB0YWJsZU5hbWUxICsgdGFibGVOYW1lMiA6IHRhYmxlTmFtZTIgKyB0YWJsZU5hbWUxO1xufVxuZXhwb3J0cy5jb21iaW5lVGFibGVOYW1lcyA9IGNvbWJpbmVUYWJsZU5hbWVzO1xuZnVuY3Rpb24gdG9EZWZhdWx0VmFsdWUodmFsdWUsIGRpYWxlY3QpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3QgdG1wID0gdmFsdWUoKTtcbiAgICBpZiAodG1wIGluc3RhbmNlb2YgRGF0YVR5cGVzLkFCU1RSQUNUKSB7XG4gICAgICByZXR1cm4gdG1wLnRvU3FsKCk7XG4gICAgfVxuICAgIHJldHVybiB0bXA7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0YVR5cGVzLlVVSURWMSkge1xuICAgIHJldHVybiB1dWlkdjEoKTtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuVVVJRFY0KSB7XG4gICAgcmV0dXJuIHV1aWR2NCgpO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5OT1cpIHtcbiAgICByZXR1cm4gbm93KGRpYWxlY3QpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5zbGljZSgpO1xuICB9XG4gIGlmIChfLmlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKHt9LCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0cy50b0RlZmF1bHRWYWx1ZSA9IHRvRGVmYXVsdFZhbHVlO1xuZnVuY3Rpb24gZGVmYXVsdFZhbHVlU2NoZW1hYmxlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5OT1cpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0YVR5cGVzLlVVSURWMSB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5VVUlEVjQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiO1xufVxuZXhwb3J0cy5kZWZhdWx0VmFsdWVTY2hlbWFibGUgPSBkZWZhdWx0VmFsdWVTY2hlbWFibGU7XG5mdW5jdGlvbiByZW1vdmVOdWxsVmFsdWVzRnJvbUhhc2goaGFzaCwgb21pdE51bGwsIG9wdGlvbnMpIHtcbiAgbGV0IHJlc3VsdCA9IGhhc2g7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmFsbG93TnVsbCA9IG9wdGlvbnMuYWxsb3dOdWxsIHx8IFtdO1xuICBpZiAob21pdE51bGwpIHtcbiAgICBjb25zdCBfaGFzaCA9IHt9O1xuICAgIF8uZm9ySW4oaGFzaCwgKHZhbCwga2V5KSA9PiB7XG4gICAgICBpZiAob3B0aW9ucy5hbGxvd051bGwuaW5jbHVkZXMoa2V5KSB8fCBrZXkuZW5kc1dpdGgoXCJJZFwiKSB8fCB2YWwgIT09IG51bGwgJiYgdmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgX2hhc2hba2V5XSA9IHZhbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXN1bHQgPSBfaGFzaDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5yZW1vdmVOdWxsVmFsdWVzRnJvbUhhc2ggPSByZW1vdmVOdWxsVmFsdWVzRnJvbUhhc2g7XG5jb25zdCBkaWFsZWN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcIm1hcmlhZGJcIiwgXCJteXNxbFwiLCBcInBvc3RncmVzXCIsIFwic3FsaXRlXCIsIFwibXNzcWxcIiwgXCJkYjJcIiwgXCJvcmFjbGVcIl0pO1xuZnVuY3Rpb24gbm93KGRpYWxlY3QpIHtcbiAgY29uc3QgZCA9IG5ldyBEYXRlKCk7XG4gIGlmICghZGlhbGVjdHMuaGFzKGRpYWxlY3QpKSB7XG4gICAgZC5zZXRNaWxsaXNlY29uZHMoMCk7XG4gIH1cbiAgcmV0dXJuIGQ7XG59XG5leHBvcnRzLm5vdyA9IG5vdztcbmNvbnN0IFRJQ0tfQ0hBUiA9IFwiYFwiO1xuZXhwb3J0cy5USUNLX0NIQVIgPSBUSUNLX0NIQVI7XG5mdW5jdGlvbiBhZGRUaWNrcyhzLCB0aWNrQ2hhcikge1xuICB0aWNrQ2hhciA9IHRpY2tDaGFyIHx8IFRJQ0tfQ0hBUjtcbiAgcmV0dXJuIHRpY2tDaGFyICsgcmVtb3ZlVGlja3MocywgdGlja0NoYXIpICsgdGlja0NoYXI7XG59XG5leHBvcnRzLmFkZFRpY2tzID0gYWRkVGlja3M7XG5mdW5jdGlvbiByZW1vdmVUaWNrcyhzLCB0aWNrQ2hhcikge1xuICB0aWNrQ2hhciA9IHRpY2tDaGFyIHx8IFRJQ0tfQ0hBUjtcbiAgcmV0dXJuIHMucmVwbGFjZShuZXcgUmVnRXhwKHRpY2tDaGFyLCBcImdcIiksIFwiXCIpO1xufVxuZXhwb3J0cy5yZW1vdmVUaWNrcyA9IHJlbW92ZVRpY2tzO1xuZnVuY3Rpb24gZmxhdHRlbk9iamVjdERlZXAodmFsdWUpIHtcbiAgaWYgKCFfLmlzUGxhaW5PYmplY3QodmFsdWUpKVxuICAgIHJldHVybiB2YWx1ZTtcbiAgY29uc3QgZmxhdHRlbmVkT2JqID0ge307XG4gIGZ1bmN0aW9uIGZsYXR0ZW5PYmplY3Qob2JqLCBzdWJQYXRoKSB7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IHBhdGhUb1Byb3BlcnR5ID0gc3ViUGF0aCA/IGAke3N1YlBhdGh9LiR7a2V5fWAgOiBrZXk7XG4gICAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSBcIm9iamVjdFwiICYmIG9ialtrZXldICE9PSBudWxsKSB7XG4gICAgICAgIGZsYXR0ZW5PYmplY3Qob2JqW2tleV0sIHBhdGhUb1Byb3BlcnR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsYXR0ZW5lZE9ialtwYXRoVG9Qcm9wZXJ0eV0gPSBfLmdldChvYmosIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZsYXR0ZW5lZE9iajtcbiAgfVxuICByZXR1cm4gZmxhdHRlbk9iamVjdCh2YWx1ZSwgdm9pZCAwKTtcbn1cbmV4cG9ydHMuZmxhdHRlbk9iamVjdERlZXAgPSBmbGF0dGVuT2JqZWN0RGVlcDtcbmNsYXNzIFNlcXVlbGl6ZU1ldGhvZCB7XG59XG5leHBvcnRzLlNlcXVlbGl6ZU1ldGhvZCA9IFNlcXVlbGl6ZU1ldGhvZDtcbmNsYXNzIEZuIGV4dGVuZHMgU2VxdWVsaXplTWV0aG9kIHtcbiAgY29uc3RydWN0b3IoZm4sIGFyZ3MpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZm4gPSBmbjtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgRm4odGhpcy5mbiwgdGhpcy5hcmdzKTtcbiAgfVxufVxuZXhwb3J0cy5GbiA9IEZuO1xuY2xhc3MgQ29sIGV4dGVuZHMgU2VxdWVsaXplTWV0aG9kIHtcbiAgY29uc3RydWN0b3IoY29sLCAuLi5hcmdzKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICBjb2wgPSBhcmdzO1xuICAgIH1cbiAgICB0aGlzLmNvbCA9IGNvbDtcbiAgfVxufVxuZXhwb3J0cy5Db2wgPSBDb2w7XG5jbGFzcyBDYXN0IGV4dGVuZHMgU2VxdWVsaXplTWV0aG9kIHtcbiAgY29uc3RydWN0b3IodmFsLCB0eXBlLCBqc29uKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICB0aGlzLnR5cGUgPSAodHlwZSB8fCBcIlwiKS50cmltKCk7XG4gICAgdGhpcy5qc29uID0ganNvbiB8fCBmYWxzZTtcbiAgfVxufVxuZXhwb3J0cy5DYXN0ID0gQ2FzdDtcbmNsYXNzIExpdGVyYWwgZXh0ZW5kcyBTZXF1ZWxpemVNZXRob2Qge1xuICBjb25zdHJ1Y3Rvcih2YWwpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudmFsID0gdmFsO1xuICB9XG59XG5leHBvcnRzLkxpdGVyYWwgPSBMaXRlcmFsO1xuY2xhc3MgSnNvbiBleHRlbmRzIFNlcXVlbGl6ZU1ldGhvZCB7XG4gIGNvbnN0cnVjdG9yKGNvbmRpdGlvbnNPclBhdGgsIHZhbHVlKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAoXy5pc09iamVjdChjb25kaXRpb25zT3JQYXRoKSkge1xuICAgICAgdGhpcy5jb25kaXRpb25zID0gY29uZGl0aW9uc09yUGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXRoID0gY29uZGl0aW9uc09yUGF0aDtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5leHBvcnRzLkpzb24gPSBKc29uO1xuY2xhc3MgV2hlcmUgZXh0ZW5kcyBTZXF1ZWxpemVNZXRob2Qge1xuICBjb25zdHJ1Y3RvcihhdHRyaWJ1dGUsIGNvbXBhcmF0b3IsIGxvZ2ljKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAobG9naWMgPT09IHZvaWQgMCkge1xuICAgICAgbG9naWMgPSBjb21wYXJhdG9yO1xuICAgICAgY29tcGFyYXRvciA9IFwiPVwiO1xuICAgIH1cbiAgICB0aGlzLmF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcbiAgICB0aGlzLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xuICAgIHRoaXMubG9naWMgPSBsb2dpYztcbiAgfVxufVxuZXhwb3J0cy5XaGVyZSA9IFdoZXJlO1xuZnVuY3Rpb24gZ2V0T3BlcmF0b3JzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopLmZpbHRlcigocykgPT4gb3BlcmF0b3JzU2V0LmhhcyhzKSk7XG59XG5leHBvcnRzLmdldE9wZXJhdG9ycyA9IGdldE9wZXJhdG9ycztcbmZ1bmN0aW9uIGdldENvbXBsZXhLZXlzKG9iaikge1xuICByZXR1cm4gZ2V0T3BlcmF0b3JzKG9iaikuY29uY2F0KE9iamVjdC5rZXlzKG9iaikpO1xufVxuZXhwb3J0cy5nZXRDb21wbGV4S2V5cyA9IGdldENvbXBsZXhLZXlzO1xuZnVuY3Rpb24gZ2V0Q29tcGxleFNpemUob2JqKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG9iaikgPyBvYmoubGVuZ3RoIDogZ2V0Q29tcGxleEtleXMob2JqKS5sZW5ndGg7XG59XG5leHBvcnRzLmdldENvbXBsZXhTaXplID0gZ2V0Q29tcGxleFNpemU7XG5mdW5jdGlvbiBpc1doZXJlRW1wdHkob2JqKSB7XG4gIHJldHVybiAhIW9iaiAmJiBfLmlzRW1wdHkob2JqKSAmJiBnZXRPcGVyYXRvcnMob2JqKS5sZW5ndGggPT09IDA7XG59XG5leHBvcnRzLmlzV2hlcmVFbXB0eSA9IGlzV2hlcmVFbXB0eTtcbmZ1bmN0aW9uIGdlbmVyYXRlRW51bU5hbWUodGFibGVOYW1lLCBjb2x1bW5OYW1lKSB7XG4gIHJldHVybiBgZW51bV8ke3RhYmxlTmFtZX1fJHtjb2x1bW5OYW1lfWA7XG59XG5leHBvcnRzLmdlbmVyYXRlRW51bU5hbWUgPSBnZW5lcmF0ZUVudW1OYW1lO1xuZnVuY3Rpb24gY2FtZWxpemVPYmplY3RLZXlzKG9iaikge1xuICBjb25zdCBuZXdPYmogPSBuZXcgT2JqZWN0KCk7XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgbmV3T2JqW2NhbWVsaXplKGtleSldID0gb2JqW2tleV07XG4gIH0pO1xuICByZXR1cm4gbmV3T2JqO1xufVxuZXhwb3J0cy5jYW1lbGl6ZU9iamVjdEtleXMgPSBjYW1lbGl6ZU9iamVjdEtleXM7XG5mdW5jdGlvbiBkZWZhdWx0cyhvYmplY3QsIC4uLnNvdXJjZXMpIHtcbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHNvdXJjZXMuZm9yRWFjaCgoc291cmNlKSA9PiB7XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgc291cmNlID0gT2JqZWN0KHNvdXJjZSk7XG4gICAgICBnZXRDb21wbGV4S2V5cyhzb3VyY2UpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCB8fCBfLmVxKHZhbHVlLCBPYmplY3QucHJvdG90eXBlW2tleV0pICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG9iamVjdDtcbn1cbmV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbmZ1bmN0aW9uIG5hbWVJbmRleChpbmRleCwgdGFibGVOYW1lKSB7XG4gIGlmICh0YWJsZU5hbWUudGFibGVOYW1lKVxuICAgIHRhYmxlTmFtZSA9IHRhYmxlTmFtZS50YWJsZU5hbWU7XG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGluZGV4LCBcIm5hbWVcIikpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBpbmRleC5maWVsZHMubWFwKChmaWVsZCkgPT4gdHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiID8gZmllbGQgOiBmaWVsZC5uYW1lIHx8IGZpZWxkLmF0dHJpYnV0ZSk7XG4gICAgaW5kZXgubmFtZSA9IHVuZGVyc2NvcmUoYCR7dGFibGVOYW1lfV8ke2ZpZWxkcy5qb2luKFwiX1wiKX1gKTtcbiAgfVxuICByZXR1cm4gaW5kZXg7XG59XG5leHBvcnRzLm5hbWVJbmRleCA9IG5hbWVJbmRleDtcbmZ1bmN0aW9uIGludGVyc2VjdHMoYXJyMSwgYXJyMikge1xuICByZXR1cm4gYXJyMS5zb21lKCh2KSA9PiBhcnIyLmluY2x1ZGVzKHYpKTtcbn1cbmV4cG9ydHMuaW50ZXJzZWN0cyA9IGludGVyc2VjdHM7XG5mdW5jdGlvbiBzYWZlU3RyaW5naWZ5SnNvbih2YWx1ZSkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIChrZXksIHZhbHVlMikgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUyID09PSBcImJpZ2ludFwiKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKHZhbHVlMik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTI7XG4gIH0pO1xufVxuZXhwb3J0cy5zYWZlU3RyaW5naWZ5SnNvbiA9IHNhZmVTdHJpbmdpZnlKc29uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/utils.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/utils/class-to-invokable.js":
/*!*****************************************************************!*\
  !*** ../node_modules/sequelize/lib/utils/class-to-invokable.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("var __defProp = Object.defineProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  classToInvokable: () => classToInvokable\n});\nfunction classToInvokable(Class) {\n  return new Proxy(Class, {\n    apply(_target, _thisArg, args) {\n      return new Class(...args);\n    },\n    construct(_target, args) {\n      return new Class(...args);\n    }\n  });\n}\n//# sourceMappingURL=class-to-invokable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy9jbGFzcy10by1pbnZva2FibGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy9jbGFzcy10by1pbnZva2FibGUuanM/MzcxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGNsYXNzVG9JbnZva2FibGU6ICgpID0+IGNsYXNzVG9JbnZva2FibGVcbn0pO1xuZnVuY3Rpb24gY2xhc3NUb0ludm9rYWJsZShDbGFzcykge1xuICByZXR1cm4gbmV3IFByb3h5KENsYXNzLCB7XG4gICAgYXBwbHkoX3RhcmdldCwgX3RoaXNBcmcsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBuZXcgQ2xhc3MoLi4uYXJncyk7XG4gICAgfSxcbiAgICBjb25zdHJ1Y3QoX3RhcmdldCwgYXJncykge1xuICAgICAgcmV0dXJuIG5ldyBDbGFzcyguLi5hcmdzKTtcbiAgICB9XG4gIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xhc3MtdG8taW52b2thYmxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/utils/class-to-invokable.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/utils/deprecations.js":
/*!***********************************************************!*\
  !*** ../node_modules/sequelize/lib/utils/deprecations.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  noBoolOperatorAliases: () => noBoolOperatorAliases,\n  noDoubleNestedGroup: () => noDoubleNestedGroup,\n  noStringOperators: () => noStringOperators,\n  noTrueLogging: () => noTrueLogging,\n  unsupportedEngine: () => unsupportedEngine\n});\nvar import_util = __toModule(__webpack_require__(/*! util */ \"util\"));\nconst noop = () => {\n};\nconst noTrueLogging = (0, import_util.deprecate)(noop, \"The logging-option should be either a function or false. Default: console.log\", \"SEQUELIZE0002\");\nconst noStringOperators = (0, import_util.deprecate)(noop, \"String based operators are deprecated. Please use Symbol based operators for better security, read more at https://sequelize.org/master/manual/querying.html#operators\", \"SEQUELIZE0003\");\nconst noBoolOperatorAliases = (0, import_util.deprecate)(noop, \"A boolean value was passed to options.operatorsAliases. This is a no-op with v5 and should be removed.\", \"SEQUELIZE0004\");\nconst noDoubleNestedGroup = (0, import_util.deprecate)(noop, \"Passing a double nested nested array to `group` is unsupported and will be removed in v6.\", \"SEQUELIZE0005\");\nconst unsupportedEngine = (0, import_util.deprecate)(noop, \"This database engine version is not supported, please update your database server. More information https://github.com/sequelize/sequelize/blob/main/ENGINE.md\", \"SEQUELIZE0006\");\n//# sourceMappingURL=deprecations.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy9kZXByZWNhdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDZCQUE2QixtQkFBTyxDQUFDLGtCQUFNO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvdXRpbHMvZGVwcmVjYXRpb25zLmpzPzYyMGEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIG5vQm9vbE9wZXJhdG9yQWxpYXNlczogKCkgPT4gbm9Cb29sT3BlcmF0b3JBbGlhc2VzLFxuICBub0RvdWJsZU5lc3RlZEdyb3VwOiAoKSA9PiBub0RvdWJsZU5lc3RlZEdyb3VwLFxuICBub1N0cmluZ09wZXJhdG9yczogKCkgPT4gbm9TdHJpbmdPcGVyYXRvcnMsXG4gIG5vVHJ1ZUxvZ2dpbmc6ICgpID0+IG5vVHJ1ZUxvZ2dpbmcsXG4gIHVuc3VwcG9ydGVkRW5naW5lOiAoKSA9PiB1bnN1cHBvcnRlZEVuZ2luZVxufSk7XG52YXIgaW1wb3J0X3V0aWwgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJ1dGlsXCIpKTtcbmNvbnN0IG5vb3AgPSAoKSA9PiB7XG59O1xuY29uc3Qgbm9UcnVlTG9nZ2luZyA9ICgwLCBpbXBvcnRfdXRpbC5kZXByZWNhdGUpKG5vb3AsIFwiVGhlIGxvZ2dpbmctb3B0aW9uIHNob3VsZCBiZSBlaXRoZXIgYSBmdW5jdGlvbiBvciBmYWxzZS4gRGVmYXVsdDogY29uc29sZS5sb2dcIiwgXCJTRVFVRUxJWkUwMDAyXCIpO1xuY29uc3Qgbm9TdHJpbmdPcGVyYXRvcnMgPSAoMCwgaW1wb3J0X3V0aWwuZGVwcmVjYXRlKShub29wLCBcIlN0cmluZyBiYXNlZCBvcGVyYXRvcnMgYXJlIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgU3ltYm9sIGJhc2VkIG9wZXJhdG9ycyBmb3IgYmV0dGVyIHNlY3VyaXR5LCByZWFkIG1vcmUgYXQgaHR0cHM6Ly9zZXF1ZWxpemUub3JnL21hc3Rlci9tYW51YWwvcXVlcnlpbmcuaHRtbCNvcGVyYXRvcnNcIiwgXCJTRVFVRUxJWkUwMDAzXCIpO1xuY29uc3Qgbm9Cb29sT3BlcmF0b3JBbGlhc2VzID0gKDAsIGltcG9ydF91dGlsLmRlcHJlY2F0ZSkobm9vcCwgXCJBIGJvb2xlYW4gdmFsdWUgd2FzIHBhc3NlZCB0byBvcHRpb25zLm9wZXJhdG9yc0FsaWFzZXMuIFRoaXMgaXMgYSBuby1vcCB3aXRoIHY1IGFuZCBzaG91bGQgYmUgcmVtb3ZlZC5cIiwgXCJTRVFVRUxJWkUwMDA0XCIpO1xuY29uc3Qgbm9Eb3VibGVOZXN0ZWRHcm91cCA9ICgwLCBpbXBvcnRfdXRpbC5kZXByZWNhdGUpKG5vb3AsIFwiUGFzc2luZyBhIGRvdWJsZSBuZXN0ZWQgbmVzdGVkIGFycmF5IHRvIGBncm91cGAgaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2Ni5cIiwgXCJTRVFVRUxJWkUwMDA1XCIpO1xuY29uc3QgdW5zdXBwb3J0ZWRFbmdpbmUgPSAoMCwgaW1wb3J0X3V0aWwuZGVwcmVjYXRlKShub29wLCBcIlRoaXMgZGF0YWJhc2UgZW5naW5lIHZlcnNpb24gaXMgbm90IHN1cHBvcnRlZCwgcGxlYXNlIHVwZGF0ZSB5b3VyIGRhdGFiYXNlIHNlcnZlci4gTW9yZSBpbmZvcm1hdGlvbiBodHRwczovL2dpdGh1Yi5jb20vc2VxdWVsaXplL3NlcXVlbGl6ZS9ibG9iL21haW4vRU5HSU5FLm1kXCIsIFwiU0VRVUVMSVpFMDAwNlwiKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlcHJlY2F0aW9ucy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/utils/deprecations.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/utils/join-sql-fragments.js":
/*!*****************************************************************!*\
  !*** ../node_modules/sequelize/lib/utils/join-sql-fragments.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  JoinSQLFragmentsError: () => JoinSQLFragmentsError,\n  joinSQLFragments: () => joinSQLFragments\n});\nfunction doesNotWantLeadingSpace(str) {\n  return /^[;,)]/.test(str);\n}\nfunction doesNotWantTrailingSpace(str) {\n  return /\\($/.test(str);\n}\nfunction singleSpaceJoinHelper(parts) {\n  return parts.reduce(({ skipNextLeadingSpace, result }, part) => {\n    if (skipNextLeadingSpace || doesNotWantLeadingSpace(part)) {\n      result += part.trim();\n    } else {\n      result += ` ${part.trim()}`;\n    }\n    return {\n      skipNextLeadingSpace: doesNotWantTrailingSpace(part),\n      result\n    };\n  }, {\n    skipNextLeadingSpace: true,\n    result: \"\"\n  }).result;\n}\nfunction joinSQLFragments(array) {\n  if (array.length === 0)\n    return \"\";\n  const truthyArray = array.filter((x) => !!x);\n  const flattenedArray = truthyArray.map((fragment) => {\n    if (Array.isArray(fragment)) {\n      return joinSQLFragments(fragment);\n    }\n    return fragment;\n  });\n  for (const fragment of flattenedArray) {\n    if (fragment && typeof fragment !== \"string\") {\n      throw new JoinSQLFragmentsError(flattenedArray, fragment, `Tried to construct a SQL string with a non-string, non-falsy fragment (${fragment}).`);\n    }\n  }\n  const trimmedArray = flattenedArray.map((x) => x.trim());\n  const nonEmptyStringArray = trimmedArray.filter((x) => x !== \"\");\n  return singleSpaceJoinHelper(nonEmptyStringArray);\n}\nclass JoinSQLFragmentsError extends TypeError {\n  constructor(args, fragment, message) {\n    super(message);\n    __publicField(this, \"args\");\n    __publicField(this, \"fragment\");\n    this.args = args;\n    this.fragment = fragment;\n    this.name = \"JoinSQLFragmentsError\";\n  }\n}\n//# sourceMappingURL=join-sql-fragments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy9qb2luLXNxbC1mcmFnbWVudHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhCQUE4QjtBQUN2RDtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMElBQTBJLFNBQVM7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy9qb2luLXNxbC1mcmFnbWVudHMuanM/NTgyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgSm9pblNRTEZyYWdtZW50c0Vycm9yOiAoKSA9PiBKb2luU1FMRnJhZ21lbnRzRXJyb3IsXG4gIGpvaW5TUUxGcmFnbWVudHM6ICgpID0+IGpvaW5TUUxGcmFnbWVudHNcbn0pO1xuZnVuY3Rpb24gZG9lc05vdFdhbnRMZWFkaW5nU3BhY2Uoc3RyKSB7XG4gIHJldHVybiAvXls7LCldLy50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBkb2VzTm90V2FudFRyYWlsaW5nU3BhY2Uoc3RyKSB7XG4gIHJldHVybiAvXFwoJC8udGVzdChzdHIpO1xufVxuZnVuY3Rpb24gc2luZ2xlU3BhY2VKb2luSGVscGVyKHBhcnRzKSB7XG4gIHJldHVybiBwYXJ0cy5yZWR1Y2UoKHsgc2tpcE5leHRMZWFkaW5nU3BhY2UsIHJlc3VsdCB9LCBwYXJ0KSA9PiB7XG4gICAgaWYgKHNraXBOZXh0TGVhZGluZ1NwYWNlIHx8IGRvZXNOb3RXYW50TGVhZGluZ1NwYWNlKHBhcnQpKSB7XG4gICAgICByZXN1bHQgKz0gcGFydC50cmltKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSBgICR7cGFydC50cmltKCl9YDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNraXBOZXh0TGVhZGluZ1NwYWNlOiBkb2VzTm90V2FudFRyYWlsaW5nU3BhY2UocGFydCksXG4gICAgICByZXN1bHRcbiAgICB9O1xuICB9LCB7XG4gICAgc2tpcE5leHRMZWFkaW5nU3BhY2U6IHRydWUsXG4gICAgcmVzdWx0OiBcIlwiXG4gIH0pLnJlc3VsdDtcbn1cbmZ1bmN0aW9uIGpvaW5TUUxGcmFnbWVudHMoYXJyYXkpIHtcbiAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gXCJcIjtcbiAgY29uc3QgdHJ1dGh5QXJyYXkgPSBhcnJheS5maWx0ZXIoKHgpID0+ICEheCk7XG4gIGNvbnN0IGZsYXR0ZW5lZEFycmF5ID0gdHJ1dGh5QXJyYXkubWFwKChmcmFnbWVudCkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZyYWdtZW50KSkge1xuICAgICAgcmV0dXJuIGpvaW5TUUxGcmFnbWVudHMoZnJhZ21lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH0pO1xuICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIGZsYXR0ZW5lZEFycmF5KSB7XG4gICAgaWYgKGZyYWdtZW50ICYmIHR5cGVvZiBmcmFnbWVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEpvaW5TUUxGcmFnbWVudHNFcnJvcihmbGF0dGVuZWRBcnJheSwgZnJhZ21lbnQsIGBUcmllZCB0byBjb25zdHJ1Y3QgYSBTUUwgc3RyaW5nIHdpdGggYSBub24tc3RyaW5nLCBub24tZmFsc3kgZnJhZ21lbnQgKCR7ZnJhZ21lbnR9KS5gKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdHJpbW1lZEFycmF5ID0gZmxhdHRlbmVkQXJyYXkubWFwKCh4KSA9PiB4LnRyaW0oKSk7XG4gIGNvbnN0IG5vbkVtcHR5U3RyaW5nQXJyYXkgPSB0cmltbWVkQXJyYXkuZmlsdGVyKCh4KSA9PiB4ICE9PSBcIlwiKTtcbiAgcmV0dXJuIHNpbmdsZVNwYWNlSm9pbkhlbHBlcihub25FbXB0eVN0cmluZ0FycmF5KTtcbn1cbmNsYXNzIEpvaW5TUUxGcmFnbWVudHNFcnJvciBleHRlbmRzIFR5cGVFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MsIGZyYWdtZW50LCBtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFyZ3NcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZyYWdtZW50XCIpO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgdGhpcy5mcmFnbWVudCA9IGZyYWdtZW50O1xuICAgIHRoaXMubmFtZSA9IFwiSm9pblNRTEZyYWdtZW50c0Vycm9yXCI7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpvaW4tc3FsLWZyYWdtZW50cy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/utils/join-sql-fragments.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/utils/logger.js":
/*!*****************************************************!*\
  !*** ../node_modules/sequelize/lib/utils/logger.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  Logger: () => Logger,\n  logger: () => logger\n});\nvar import_debug = __toModule(__webpack_require__(/*! debug */ \"(action-browser)/../node_modules/debug/src/index.js\"));\nvar import_util = __toModule(__webpack_require__(/*! util */ \"util\"));\nclass Logger {\n  constructor(_a = {}) {\n    __publicField(this, \"config\");\n    var _b = _a, { context = \"sequelize\" } = _b, rest = __objRest(_b, [\"context\"]);\n    this.config = __spreadValues({\n      context\n    }, rest);\n  }\n  warn(message) {\n    console.warn(`(${this.config.context}) Warning: ${message}`);\n  }\n  inspect(value) {\n    return import_util.default.inspect(value, {\n      showHidden: false,\n      depth: 1\n    });\n  }\n  debugContext(name) {\n    return (0, import_debug.default)(`${this.config.context}:${name}`);\n  }\n}\nconst logger = new Logger();\n//# sourceMappingURL=logger.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy9sb2dnZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOEJBQThCLG1CQUFPLENBQUMsa0VBQU87QUFDN0MsNkJBQTZCLG1CQUFPLENBQUMsa0JBQU07QUFDM0M7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0IsYUFBYSxRQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdDQUF3QyxvQkFBb0IsR0FBRyxLQUFLO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzL2xvZ2dlci5qcz8xOGVhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX29ialJlc3QgPSAoc291cmNlLCBleGNsdWRlKSA9PiB7XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkgJiYgZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMClcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgaWYgKHNvdXJjZSAhPSBudWxsICYmIF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKHNvdXJjZSkpIHtcbiAgICAgIGlmIChleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwICYmIF9fcHJvcElzRW51bS5jYWxsKHNvdXJjZSwgcHJvcCkpXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgTG9nZ2VyOiAoKSA9PiBMb2dnZXIsXG4gIGxvZ2dlcjogKCkgPT4gbG9nZ2VyXG59KTtcbnZhciBpbXBvcnRfZGVidWcgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG52YXIgaW1wb3J0X3V0aWwgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJ1dGlsXCIpKTtcbmNsYXNzIExvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKF9hID0ge30pIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29uZmlnXCIpO1xuICAgIHZhciBfYiA9IF9hLCB7IGNvbnRleHQgPSBcInNlcXVlbGl6ZVwiIH0gPSBfYiwgcmVzdCA9IF9fb2JqUmVzdChfYiwgW1wiY29udGV4dFwiXSk7XG4gICAgdGhpcy5jb25maWcgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBjb250ZXh0XG4gICAgfSwgcmVzdCk7XG4gIH1cbiAgd2FybihtZXNzYWdlKSB7XG4gICAgY29uc29sZS53YXJuKGAoJHt0aGlzLmNvbmZpZy5jb250ZXh0fSkgV2FybmluZzogJHttZXNzYWdlfWApO1xuICB9XG4gIGluc3BlY3QodmFsdWUpIHtcbiAgICByZXR1cm4gaW1wb3J0X3V0aWwuZGVmYXVsdC5pbnNwZWN0KHZhbHVlLCB7XG4gICAgICBzaG93SGlkZGVuOiBmYWxzZSxcbiAgICAgIGRlcHRoOiAxXG4gICAgfSk7XG4gIH1cbiAgZGVidWdDb250ZXh0KG5hbWUpIHtcbiAgICByZXR1cm4gKDAsIGltcG9ydF9kZWJ1Zy5kZWZhdWx0KShgJHt0aGlzLmNvbmZpZy5jb250ZXh0fToke25hbWV9YCk7XG4gIH1cbn1cbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/utils/logger.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/utils/sql.js":
/*!**************************************************!*\
  !*** ../node_modules/sequelize/lib/utils/sql.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  injectReplacements: () => injectReplacements\n});\nvar import_isPlainObject = __toModule(__webpack_require__(/*! lodash/isPlainObject */ \"(action-browser)/../node_modules/lodash/isPlainObject.js\"));\nvar import_sql_string = __toModule(__webpack_require__(/*! ../sql-string */ \"(action-browser)/../node_modules/sequelize/lib/sql-string.js\"));\nfunction injectReplacements(sqlString, dialect, replacements) {\n  var _a, _b, _c, _d;\n  if (replacements == null) {\n    return sqlString;\n  }\n  if (!Array.isArray(replacements) && !(0, import_isPlainObject.default)(replacements)) {\n    throw new TypeError(`\"replacements\" must be an array or a plain object, but received ${JSON.stringify(replacements)} instead.`);\n  }\n  const isNamedReplacements = (0, import_isPlainObject.default)(replacements);\n  const isPositionalReplacements = Array.isArray(replacements);\n  let lastConsumedPositionalReplacementIndex = -1;\n  let output = \"\";\n  let currentDollarStringTagName = null;\n  let isString = false;\n  let isColumn = false;\n  let previousSliceEnd = 0;\n  let isSingleLineComment = false;\n  let isCommentBlock = false;\n  let stringIsBackslashEscapable = false;\n  for (let i = 0; i < sqlString.length; i++) {\n    const char = sqlString[i];\n    if (isColumn) {\n      if (char === dialect.TICK_CHAR_RIGHT) {\n        isColumn = false;\n      }\n      continue;\n    }\n    if (isString) {\n      if (char === \"'\" && (!stringIsBackslashEscapable || !isBackslashEscaped(sqlString, i - 1))) {\n        isString = false;\n        stringIsBackslashEscapable = false;\n      }\n      continue;\n    }\n    if (currentDollarStringTagName !== null) {\n      if (char !== \"$\") {\n        continue;\n      }\n      const remainingString = sqlString.slice(i, sqlString.length);\n      const dollarStringStartMatch = remainingString.match(/^\\$(?<name>[a-z_][0-9a-z_]*)?(\\$)/i);\n      const tagName = ((_a = dollarStringStartMatch == null ? void 0 : dollarStringStartMatch.groups) == null ? void 0 : _a.name) || \"\";\n      if (currentDollarStringTagName === tagName) {\n        currentDollarStringTagName = null;\n      }\n      continue;\n    }\n    if (isSingleLineComment) {\n      if (char === \"\\n\") {\n        isSingleLineComment = false;\n      }\n      continue;\n    }\n    if (isCommentBlock) {\n      if (char === \"*\" && sqlString[i + 1] === \"/\") {\n        isCommentBlock = false;\n      }\n      continue;\n    }\n    if (char === dialect.TICK_CHAR_LEFT) {\n      isColumn = true;\n      continue;\n    }\n    if (char === \"'\") {\n      isString = true;\n      stringIsBackslashEscapable = dialect.canBackslashEscape() || dialect.supports.escapeStringConstants && (sqlString[i - 1] === \"E\" || sqlString[i - 1] === \"e\") && canPrecedeNewToken(sqlString[i - 2]);\n      continue;\n    }\n    if (char === \"-\" && sqlString.slice(i, i + 3) === \"-- \") {\n      isSingleLineComment = true;\n      continue;\n    }\n    if (char === \"/\" && sqlString.slice(i, i + 2) === \"/*\") {\n      isCommentBlock = true;\n      continue;\n    }\n    if (char === \"$\") {\n      const previousChar = sqlString[i - 1];\n      if (/[0-9a-z_]/i.test(previousChar)) {\n        continue;\n      }\n      const remainingString = sqlString.slice(i, sqlString.length);\n      const dollarStringStartMatch = remainingString.match(/^\\$(?<name>[a-z_][0-9a-z_]*)?(\\$)/i);\n      if (dollarStringStartMatch) {\n        currentDollarStringTagName = (_c = (_b = dollarStringStartMatch.groups) == null ? void 0 : _b.name) != null ? _c : \"\";\n        i += dollarStringStartMatch[0].length - 1;\n        continue;\n      }\n      continue;\n    }\n    if (isNamedReplacements && char === \":\") {\n      const previousChar = sqlString[i - 1];\n      if (!canPrecedeNewToken(previousChar) && previousChar !== \"[\") {\n        continue;\n      }\n      const remainingString = sqlString.slice(i, sqlString.length);\n      const match = remainingString.match(/^:(?<name>[a-z_][0-9a-z_]*)(?:\\)|,|$|\\s|::|;|])/i);\n      const replacementName = (_d = match == null ? void 0 : match.groups) == null ? void 0 : _d.name;\n      if (!replacementName) {\n        continue;\n      }\n      const replacementValue = replacements[replacementName];\n      if (!Object.prototype.hasOwnProperty.call(replacements, replacementName) || replacementValue === void 0) {\n        throw new Error(`Named replacement \":${replacementName}\" has no entry in the replacement map.`);\n      }\n      const escapedReplacement = (0, import_sql_string.escape)(replacementValue, void 0, dialect.name, true);\n      output += sqlString.slice(previousSliceEnd, i);\n      previousSliceEnd = i + replacementName.length + 1;\n      output += escapedReplacement;\n      continue;\n    }\n    if (isPositionalReplacements && char === \"?\") {\n      const previousChar = sqlString[i - 1];\n      if (!canPrecedeNewToken(previousChar) && previousChar !== \"[\") {\n        continue;\n      }\n      const nextChar = sqlString[i + 1];\n      if (nextChar === \"|\" || nextChar === \"&\") {\n        continue;\n      }\n      const replacementIndex = ++lastConsumedPositionalReplacementIndex;\n      const replacementValue = replacements[lastConsumedPositionalReplacementIndex];\n      if (replacementValue === void 0) {\n        throw new Error(`Positional replacement (?) ${replacementIndex} has no entry in the replacement map (replacements[${replacementIndex}] is undefined).`);\n      }\n      const escapedReplacement = (0, import_sql_string.escape)(replacementValue, void 0, dialect.name, true);\n      output += sqlString.slice(previousSliceEnd, i);\n      previousSliceEnd = i + 1;\n      output += escapedReplacement;\n    }\n  }\n  if (isString) {\n    throw new Error(`The following SQL query includes an unterminated string literal:\n${sqlString}`);\n  }\n  output += sqlString.slice(previousSliceEnd, sqlString.length);\n  return output;\n}\nfunction canPrecedeNewToken(char) {\n  return char === void 0 || /[\\s(>,=]/.test(char);\n}\nfunction isBackslashEscaped(string, pos) {\n  let escaped = false;\n  for (let i = pos; i >= 0; i--) {\n    const char = string[i];\n    if (char !== \"\\\\\") {\n      break;\n    }\n    escaped = !escaped;\n  }\n  return escaped;\n}\n//# sourceMappingURL=sql.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy9zcWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxzQ0FBc0MsbUJBQU8sQ0FBQyxzRkFBc0I7QUFDcEUsbUNBQW1DLG1CQUFPLENBQUMsbUZBQWU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLDhCQUE4QjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGtCQUFrQixvREFBb0QsaUJBQWlCO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsVUFBVTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy9zcWwuanM/MjY3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgaW5qZWN0UmVwbGFjZW1lbnRzOiAoKSA9PiBpbmplY3RSZXBsYWNlbWVudHNcbn0pO1xudmFyIGltcG9ydF9pc1BsYWluT2JqZWN0ID0gX190b01vZHVsZShyZXF1aXJlKFwibG9kYXNoL2lzUGxhaW5PYmplY3RcIikpO1xudmFyIGltcG9ydF9zcWxfc3RyaW5nID0gX190b01vZHVsZShyZXF1aXJlKFwiLi4vc3FsLXN0cmluZ1wiKSk7XG5mdW5jdGlvbiBpbmplY3RSZXBsYWNlbWVudHMoc3FsU3RyaW5nLCBkaWFsZWN0LCByZXBsYWNlbWVudHMpIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICBpZiAocmVwbGFjZW1lbnRzID09IG51bGwpIHtcbiAgICByZXR1cm4gc3FsU3RyaW5nO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShyZXBsYWNlbWVudHMpICYmICEoMCwgaW1wb3J0X2lzUGxhaW5PYmplY3QuZGVmYXVsdCkocmVwbGFjZW1lbnRzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwicmVwbGFjZW1lbnRzXCIgbXVzdCBiZSBhbiBhcnJheSBvciBhIHBsYWluIG9iamVjdCwgYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkocmVwbGFjZW1lbnRzKX0gaW5zdGVhZC5gKTtcbiAgfVxuICBjb25zdCBpc05hbWVkUmVwbGFjZW1lbnRzID0gKDAsIGltcG9ydF9pc1BsYWluT2JqZWN0LmRlZmF1bHQpKHJlcGxhY2VtZW50cyk7XG4gIGNvbnN0IGlzUG9zaXRpb25hbFJlcGxhY2VtZW50cyA9IEFycmF5LmlzQXJyYXkocmVwbGFjZW1lbnRzKTtcbiAgbGV0IGxhc3RDb25zdW1lZFBvc2l0aW9uYWxSZXBsYWNlbWVudEluZGV4ID0gLTE7XG4gIGxldCBvdXRwdXQgPSBcIlwiO1xuICBsZXQgY3VycmVudERvbGxhclN0cmluZ1RhZ05hbWUgPSBudWxsO1xuICBsZXQgaXNTdHJpbmcgPSBmYWxzZTtcbiAgbGV0IGlzQ29sdW1uID0gZmFsc2U7XG4gIGxldCBwcmV2aW91c1NsaWNlRW5kID0gMDtcbiAgbGV0IGlzU2luZ2xlTGluZUNvbW1lbnQgPSBmYWxzZTtcbiAgbGV0IGlzQ29tbWVudEJsb2NrID0gZmFsc2U7XG4gIGxldCBzdHJpbmdJc0JhY2tzbGFzaEVzY2FwYWJsZSA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNxbFN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBzcWxTdHJpbmdbaV07XG4gICAgaWYgKGlzQ29sdW1uKSB7XG4gICAgICBpZiAoY2hhciA9PT0gZGlhbGVjdC5USUNLX0NIQVJfUklHSFQpIHtcbiAgICAgICAgaXNDb2x1bW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIGlmIChjaGFyID09PSBcIidcIiAmJiAoIXN0cmluZ0lzQmFja3NsYXNoRXNjYXBhYmxlIHx8ICFpc0JhY2tzbGFzaEVzY2FwZWQoc3FsU3RyaW5nLCBpIC0gMSkpKSB7XG4gICAgICAgIGlzU3RyaW5nID0gZmFsc2U7XG4gICAgICAgIHN0cmluZ0lzQmFja3NsYXNoRXNjYXBhYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnREb2xsYXJTdHJpbmdUYWdOYW1lICE9PSBudWxsKSB7XG4gICAgICBpZiAoY2hhciAhPT0gXCIkXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZW1haW5pbmdTdHJpbmcgPSBzcWxTdHJpbmcuc2xpY2UoaSwgc3FsU3RyaW5nLmxlbmd0aCk7XG4gICAgICBjb25zdCBkb2xsYXJTdHJpbmdTdGFydE1hdGNoID0gcmVtYWluaW5nU3RyaW5nLm1hdGNoKC9eXFwkKD88bmFtZT5bYS16X11bMC05YS16X10qKT8oXFwkKS9pKTtcbiAgICAgIGNvbnN0IHRhZ05hbWUgPSAoKF9hID0gZG9sbGFyU3RyaW5nU3RhcnRNYXRjaCA9PSBudWxsID8gdm9pZCAwIDogZG9sbGFyU3RyaW5nU3RhcnRNYXRjaC5ncm91cHMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5uYW1lKSB8fCBcIlwiO1xuICAgICAgaWYgKGN1cnJlbnREb2xsYXJTdHJpbmdUYWdOYW1lID09PSB0YWdOYW1lKSB7XG4gICAgICAgIGN1cnJlbnREb2xsYXJTdHJpbmdUYWdOYW1lID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaXNTaW5nbGVMaW5lQ29tbWVudCkge1xuICAgICAgaWYgKGNoYXIgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgaXNTaW5nbGVMaW5lQ29tbWVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpc0NvbW1lbnRCbG9jaykge1xuICAgICAgaWYgKGNoYXIgPT09IFwiKlwiICYmIHNxbFN0cmluZ1tpICsgMV0gPT09IFwiL1wiKSB7XG4gICAgICAgIGlzQ29tbWVudEJsb2NrID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNoYXIgPT09IGRpYWxlY3QuVElDS19DSEFSX0xFRlQpIHtcbiAgICAgIGlzQ29sdW1uID0gdHJ1ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY2hhciA9PT0gXCInXCIpIHtcbiAgICAgIGlzU3RyaW5nID0gdHJ1ZTtcbiAgICAgIHN0cmluZ0lzQmFja3NsYXNoRXNjYXBhYmxlID0gZGlhbGVjdC5jYW5CYWNrc2xhc2hFc2NhcGUoKSB8fCBkaWFsZWN0LnN1cHBvcnRzLmVzY2FwZVN0cmluZ0NvbnN0YW50cyAmJiAoc3FsU3RyaW5nW2kgLSAxXSA9PT0gXCJFXCIgfHwgc3FsU3RyaW5nW2kgLSAxXSA9PT0gXCJlXCIpICYmIGNhblByZWNlZGVOZXdUb2tlbihzcWxTdHJpbmdbaSAtIDJdKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY2hhciA9PT0gXCItXCIgJiYgc3FsU3RyaW5nLnNsaWNlKGksIGkgKyAzKSA9PT0gXCItLSBcIikge1xuICAgICAgaXNTaW5nbGVMaW5lQ29tbWVudCA9IHRydWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNoYXIgPT09IFwiL1wiICYmIHNxbFN0cmluZy5zbGljZShpLCBpICsgMikgPT09IFwiLypcIikge1xuICAgICAgaXNDb21tZW50QmxvY2sgPSB0cnVlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjaGFyID09PSBcIiRcIikge1xuICAgICAgY29uc3QgcHJldmlvdXNDaGFyID0gc3FsU3RyaW5nW2kgLSAxXTtcbiAgICAgIGlmICgvWzAtOWEtel9dL2kudGVzdChwcmV2aW91c0NoYXIpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVtYWluaW5nU3RyaW5nID0gc3FsU3RyaW5nLnNsaWNlKGksIHNxbFN0cmluZy5sZW5ndGgpO1xuICAgICAgY29uc3QgZG9sbGFyU3RyaW5nU3RhcnRNYXRjaCA9IHJlbWFpbmluZ1N0cmluZy5tYXRjaCgvXlxcJCg/PG5hbWU+W2Etel9dWzAtOWEtel9dKik/KFxcJCkvaSk7XG4gICAgICBpZiAoZG9sbGFyU3RyaW5nU3RhcnRNYXRjaCkge1xuICAgICAgICBjdXJyZW50RG9sbGFyU3RyaW5nVGFnTmFtZSA9IChfYyA9IChfYiA9IGRvbGxhclN0cmluZ1N0YXJ0TWF0Y2guZ3JvdXBzKSA9PSBudWxsID8gdm9pZCAwIDogX2IubmFtZSkgIT0gbnVsbCA/IF9jIDogXCJcIjtcbiAgICAgICAgaSArPSBkb2xsYXJTdHJpbmdTdGFydE1hdGNoWzBdLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpc05hbWVkUmVwbGFjZW1lbnRzICYmIGNoYXIgPT09IFwiOlwiKSB7XG4gICAgICBjb25zdCBwcmV2aW91c0NoYXIgPSBzcWxTdHJpbmdbaSAtIDFdO1xuICAgICAgaWYgKCFjYW5QcmVjZWRlTmV3VG9rZW4ocHJldmlvdXNDaGFyKSAmJiBwcmV2aW91c0NoYXIgIT09IFwiW1wiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVtYWluaW5nU3RyaW5nID0gc3FsU3RyaW5nLnNsaWNlKGksIHNxbFN0cmluZy5sZW5ndGgpO1xuICAgICAgY29uc3QgbWF0Y2ggPSByZW1haW5pbmdTdHJpbmcubWF0Y2goL146KD88bmFtZT5bYS16X11bMC05YS16X10qKSg/OlxcKXwsfCR8XFxzfDo6fDt8XSkvaSk7XG4gICAgICBjb25zdCByZXBsYWNlbWVudE5hbWUgPSAoX2QgPSBtYXRjaCA9PSBudWxsID8gdm9pZCAwIDogbWF0Y2guZ3JvdXBzKSA9PSBudWxsID8gdm9pZCAwIDogX2QubmFtZTtcbiAgICAgIGlmICghcmVwbGFjZW1lbnROYW1lKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVwbGFjZW1lbnRWYWx1ZSA9IHJlcGxhY2VtZW50c1tyZXBsYWNlbWVudE5hbWVdO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVwbGFjZW1lbnRzLCByZXBsYWNlbWVudE5hbWUpIHx8IHJlcGxhY2VtZW50VmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5hbWVkIHJlcGxhY2VtZW50IFwiOiR7cmVwbGFjZW1lbnROYW1lfVwiIGhhcyBubyBlbnRyeSBpbiB0aGUgcmVwbGFjZW1lbnQgbWFwLmApO1xuICAgICAgfVxuICAgICAgY29uc3QgZXNjYXBlZFJlcGxhY2VtZW50ID0gKDAsIGltcG9ydF9zcWxfc3RyaW5nLmVzY2FwZSkocmVwbGFjZW1lbnRWYWx1ZSwgdm9pZCAwLCBkaWFsZWN0Lm5hbWUsIHRydWUpO1xuICAgICAgb3V0cHV0ICs9IHNxbFN0cmluZy5zbGljZShwcmV2aW91c1NsaWNlRW5kLCBpKTtcbiAgICAgIHByZXZpb3VzU2xpY2VFbmQgPSBpICsgcmVwbGFjZW1lbnROYW1lLmxlbmd0aCArIDE7XG4gICAgICBvdXRwdXQgKz0gZXNjYXBlZFJlcGxhY2VtZW50O1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpc1Bvc2l0aW9uYWxSZXBsYWNlbWVudHMgJiYgY2hhciA9PT0gXCI/XCIpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzQ2hhciA9IHNxbFN0cmluZ1tpIC0gMV07XG4gICAgICBpZiAoIWNhblByZWNlZGVOZXdUb2tlbihwcmV2aW91c0NoYXIpICYmIHByZXZpb3VzQ2hhciAhPT0gXCJbXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0Q2hhciA9IHNxbFN0cmluZ1tpICsgMV07XG4gICAgICBpZiAobmV4dENoYXIgPT09IFwifFwiIHx8IG5leHRDaGFyID09PSBcIiZcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50SW5kZXggPSArK2xhc3RDb25zdW1lZFBvc2l0aW9uYWxSZXBsYWNlbWVudEluZGV4O1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnRWYWx1ZSA9IHJlcGxhY2VtZW50c1tsYXN0Q29uc3VtZWRQb3NpdGlvbmFsUmVwbGFjZW1lbnRJbmRleF07XG4gICAgICBpZiAocmVwbGFjZW1lbnRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zaXRpb25hbCByZXBsYWNlbWVudCAoPykgJHtyZXBsYWNlbWVudEluZGV4fSBoYXMgbm8gZW50cnkgaW4gdGhlIHJlcGxhY2VtZW50IG1hcCAocmVwbGFjZW1lbnRzWyR7cmVwbGFjZW1lbnRJbmRleH1dIGlzIHVuZGVmaW5lZCkuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBlc2NhcGVkUmVwbGFjZW1lbnQgPSAoMCwgaW1wb3J0X3NxbF9zdHJpbmcuZXNjYXBlKShyZXBsYWNlbWVudFZhbHVlLCB2b2lkIDAsIGRpYWxlY3QubmFtZSwgdHJ1ZSk7XG4gICAgICBvdXRwdXQgKz0gc3FsU3RyaW5nLnNsaWNlKHByZXZpb3VzU2xpY2VFbmQsIGkpO1xuICAgICAgcHJldmlvdXNTbGljZUVuZCA9IGkgKyAxO1xuICAgICAgb3V0cHV0ICs9IGVzY2FwZWRSZXBsYWNlbWVudDtcbiAgICB9XG4gIH1cbiAgaWYgKGlzU3RyaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZm9sbG93aW5nIFNRTCBxdWVyeSBpbmNsdWRlcyBhbiB1bnRlcm1pbmF0ZWQgc3RyaW5nIGxpdGVyYWw6XG4ke3NxbFN0cmluZ31gKTtcbiAgfVxuICBvdXRwdXQgKz0gc3FsU3RyaW5nLnNsaWNlKHByZXZpb3VzU2xpY2VFbmQsIHNxbFN0cmluZy5sZW5ndGgpO1xuICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gY2FuUHJlY2VkZU5ld1Rva2VuKGNoYXIpIHtcbiAgcmV0dXJuIGNoYXIgPT09IHZvaWQgMCB8fCAvW1xccyg+LD1dLy50ZXN0KGNoYXIpO1xufVxuZnVuY3Rpb24gaXNCYWNrc2xhc2hFc2NhcGVkKHN0cmluZywgcG9zKSB7XG4gIGxldCBlc2NhcGVkID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSBwb3M7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgY2hhciA9IHN0cmluZ1tpXTtcbiAgICBpZiAoY2hhciAhPT0gXCJcXFxcXCIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gIH1cbiAgcmV0dXJuIGVzY2FwZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcWwuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/utils/sql.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/utils/validator-extras.js":
/*!***************************************************************!*\
  !*** ../node_modules/sequelize/lib/utils/validator-extras.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../node_modules/lodash/lodash.js\");\nconst validator = _.cloneDeep(__webpack_require__(/*! validator */ \"(action-browser)/../node_modules/validator/index.js\"));\nconst moment = __webpack_require__(/*! moment */ \"(action-browser)/../node_modules/moment/moment.js\");\nconst extensions = {\n  extend(name, fn) {\n    this[name] = fn;\n    return this;\n  },\n  notEmpty(str) {\n    return !str.match(/^[\\s\\t\\r\\n]*$/);\n  },\n  len(str, min, max) {\n    return this.isLength(str, min, max);\n  },\n  isUrl(str) {\n    return this.isURL(str);\n  },\n  isIPv6(str) {\n    return this.isIP(str, 6);\n  },\n  isIPv4(str) {\n    return this.isIP(str, 4);\n  },\n  notIn(str, values) {\n    return !this.isIn(str, values);\n  },\n  regex(str, pattern, modifiers) {\n    str += \"\";\n    if (Object.prototype.toString.call(pattern).slice(8, -1) !== \"RegExp\") {\n      pattern = new RegExp(pattern, modifiers);\n    }\n    return str.match(pattern);\n  },\n  notRegex(str, pattern, modifiers) {\n    return !this.regex(str, pattern, modifiers);\n  },\n  isDecimal(str) {\n    return str !== \"\" && !!str.match(/^(?:-?(?:[0-9]+))?(?:\\.[0-9]*)?(?:[eE][+-]?(?:[0-9]+))?$/);\n  },\n  min(str, val) {\n    const number = parseFloat(str);\n    return isNaN(number) || number >= val;\n  },\n  max(str, val) {\n    const number = parseFloat(str);\n    return isNaN(number) || number <= val;\n  },\n  not(str, pattern, modifiers) {\n    return this.notRegex(str, pattern, modifiers);\n  },\n  contains(str, elem) {\n    return !!elem && str.includes(elem);\n  },\n  notContains(str, elem) {\n    return !this.contains(str, elem);\n  },\n  is(str, pattern, modifiers) {\n    return this.regex(str, pattern, modifiers);\n  }\n};\nexports.extensions = extensions;\nvalidator.isImmutable = function(value, validatorArgs, field, modelInstance) {\n  return modelInstance.isNewRecord || modelInstance.dataValues[field] === modelInstance._previousDataValues[field];\n};\nvalidator.notNull = function(val) {\n  return val !== null && val !== void 0;\n};\n_.forEach(extensions, (extend, key) => {\n  validator[key] = extend;\n});\nvalidator.isNull = validator.isEmpty;\nvalidator.isDate = function(dateString) {\n  const parsed = Date.parse(dateString);\n  if (isNaN(parsed)) {\n    return false;\n  }\n  const date = new Date(parsed);\n  return moment(date.toISOString()).isValid();\n};\nexports.validator = validator;\n//# sourceMappingURL=validator-extras.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy92YWxpZGF0b3ItZXh0cmFzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsVUFBVSxtQkFBTyxDQUFDLGlFQUFRO0FBQzFCLDhCQUE4QixtQkFBTyxDQUFDLHNFQUFXO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvdXRpbHMvdmFsaWRhdG9yLWV4dHJhcy5qcz8wNzQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCB2YWxpZGF0b3IgPSBfLmNsb25lRGVlcChyZXF1aXJlKFwidmFsaWRhdG9yXCIpKTtcbmNvbnN0IG1vbWVudCA9IHJlcXVpcmUoXCJtb21lbnRcIik7XG5jb25zdCBleHRlbnNpb25zID0ge1xuICBleHRlbmQobmFtZSwgZm4pIHtcbiAgICB0aGlzW25hbWVdID0gZm47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG5vdEVtcHR5KHN0cikge1xuICAgIHJldHVybiAhc3RyLm1hdGNoKC9eW1xcc1xcdFxcclxcbl0qJC8pO1xuICB9LFxuICBsZW4oc3RyLCBtaW4sIG1heCkge1xuICAgIHJldHVybiB0aGlzLmlzTGVuZ3RoKHN0ciwgbWluLCBtYXgpO1xuICB9LFxuICBpc1VybChzdHIpIHtcbiAgICByZXR1cm4gdGhpcy5pc1VSTChzdHIpO1xuICB9LFxuICBpc0lQdjYoc3RyKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNJUChzdHIsIDYpO1xuICB9LFxuICBpc0lQdjQoc3RyKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNJUChzdHIsIDQpO1xuICB9LFxuICBub3RJbihzdHIsIHZhbHVlcykge1xuICAgIHJldHVybiAhdGhpcy5pc0luKHN0ciwgdmFsdWVzKTtcbiAgfSxcbiAgcmVnZXgoc3RyLCBwYXR0ZXJuLCBtb2RpZmllcnMpIHtcbiAgICBzdHIgKz0gXCJcIjtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHBhdHRlcm4pLnNsaWNlKDgsIC0xKSAhPT0gXCJSZWdFeHBcIikge1xuICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybiwgbW9kaWZpZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5tYXRjaChwYXR0ZXJuKTtcbiAgfSxcbiAgbm90UmVnZXgoc3RyLCBwYXR0ZXJuLCBtb2RpZmllcnMpIHtcbiAgICByZXR1cm4gIXRoaXMucmVnZXgoc3RyLCBwYXR0ZXJuLCBtb2RpZmllcnMpO1xuICB9LFxuICBpc0RlY2ltYWwoc3RyKSB7XG4gICAgcmV0dXJuIHN0ciAhPT0gXCJcIiAmJiAhIXN0ci5tYXRjaCgvXig/Oi0/KD86WzAtOV0rKSk/KD86XFwuWzAtOV0qKT8oPzpbZUVdWystXT8oPzpbMC05XSspKT8kLyk7XG4gIH0sXG4gIG1pbihzdHIsIHZhbCkge1xuICAgIGNvbnN0IG51bWJlciA9IHBhcnNlRmxvYXQoc3RyKTtcbiAgICByZXR1cm4gaXNOYU4obnVtYmVyKSB8fCBudW1iZXIgPj0gdmFsO1xuICB9LFxuICBtYXgoc3RyLCB2YWwpIHtcbiAgICBjb25zdCBudW1iZXIgPSBwYXJzZUZsb2F0KHN0cik7XG4gICAgcmV0dXJuIGlzTmFOKG51bWJlcikgfHwgbnVtYmVyIDw9IHZhbDtcbiAgfSxcbiAgbm90KHN0ciwgcGF0dGVybiwgbW9kaWZpZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMubm90UmVnZXgoc3RyLCBwYXR0ZXJuLCBtb2RpZmllcnMpO1xuICB9LFxuICBjb250YWlucyhzdHIsIGVsZW0pIHtcbiAgICByZXR1cm4gISFlbGVtICYmIHN0ci5pbmNsdWRlcyhlbGVtKTtcbiAgfSxcbiAgbm90Q29udGFpbnMoc3RyLCBlbGVtKSB7XG4gICAgcmV0dXJuICF0aGlzLmNvbnRhaW5zKHN0ciwgZWxlbSk7XG4gIH0sXG4gIGlzKHN0ciwgcGF0dGVybiwgbW9kaWZpZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnZXgoc3RyLCBwYXR0ZXJuLCBtb2RpZmllcnMpO1xuICB9XG59O1xuZXhwb3J0cy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbnZhbGlkYXRvci5pc0ltbXV0YWJsZSA9IGZ1bmN0aW9uKHZhbHVlLCB2YWxpZGF0b3JBcmdzLCBmaWVsZCwgbW9kZWxJbnN0YW5jZSkge1xuICByZXR1cm4gbW9kZWxJbnN0YW5jZS5pc05ld1JlY29yZCB8fCBtb2RlbEluc3RhbmNlLmRhdGFWYWx1ZXNbZmllbGRdID09PSBtb2RlbEluc3RhbmNlLl9wcmV2aW91c0RhdGFWYWx1ZXNbZmllbGRdO1xufTtcbnZhbGlkYXRvci5ub3ROdWxsID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdmFsICE9PSB2b2lkIDA7XG59O1xuXy5mb3JFYWNoKGV4dGVuc2lvbnMsIChleHRlbmQsIGtleSkgPT4ge1xuICB2YWxpZGF0b3Jba2V5XSA9IGV4dGVuZDtcbn0pO1xudmFsaWRhdG9yLmlzTnVsbCA9IHZhbGlkYXRvci5pc0VtcHR5O1xudmFsaWRhdG9yLmlzRGF0ZSA9IGZ1bmN0aW9uKGRhdGVTdHJpbmcpIHtcbiAgY29uc3QgcGFyc2VkID0gRGF0ZS5wYXJzZShkYXRlU3RyaW5nKTtcbiAgaWYgKGlzTmFOKHBhcnNlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHBhcnNlZCk7XG4gIHJldHVybiBtb21lbnQoZGF0ZS50b0lTT1N0cmluZygpKS5pc1ZhbGlkKCk7XG59O1xuZXhwb3J0cy52YWxpZGF0b3IgPSB2YWxpZGF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0b3ItZXh0cmFzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/utils/validator-extras.js\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/lib/index.mjs":
/*!***********************************************!*\
  !*** ../node_modules/sequelize/lib/index.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ABSTRACT: () => (/* binding */ ABSTRACT),\n/* harmony export */   ARRAY: () => (/* binding */ ARRAY),\n/* harmony export */   AccessDeniedError: () => (/* binding */ AccessDeniedError),\n/* harmony export */   AggregateError: () => (/* binding */ AggregateError),\n/* harmony export */   Association: () => (/* binding */ Association),\n/* harmony export */   AssociationError: () => (/* binding */ AssociationError),\n/* harmony export */   AsyncQueueError: () => (/* binding */ AsyncQueueError),\n/* harmony export */   BIGINT: () => (/* binding */ BIGINT),\n/* harmony export */   BLOB: () => (/* binding */ BLOB),\n/* harmony export */   BOOLEAN: () => (/* binding */ BOOLEAN),\n/* harmony export */   BaseError: () => (/* binding */ BaseError),\n/* harmony export */   BelongsTo: () => (/* binding */ BelongsTo),\n/* harmony export */   BelongsToMany: () => (/* binding */ BelongsToMany),\n/* harmony export */   BulkRecordError: () => (/* binding */ BulkRecordError),\n/* harmony export */   CHAR: () => (/* binding */ CHAR),\n/* harmony export */   CIDR: () => (/* binding */ CIDR),\n/* harmony export */   CITEXT: () => (/* binding */ CITEXT),\n/* harmony export */   ConnectionAcquireTimeoutError: () => (/* binding */ ConnectionAcquireTimeoutError),\n/* harmony export */   ConnectionError: () => (/* binding */ ConnectionError),\n/* harmony export */   ConnectionRefusedError: () => (/* binding */ ConnectionRefusedError),\n/* harmony export */   ConnectionTimedOutError: () => (/* binding */ ConnectionTimedOutError),\n/* harmony export */   DATE: () => (/* binding */ DATE),\n/* harmony export */   DATEONLY: () => (/* binding */ DATEONLY),\n/* harmony export */   DECIMAL: () => (/* binding */ DECIMAL),\n/* harmony export */   DOUBLE: () => (/* binding */ DOUBLE),\n/* harmony export */   DataTypes: () => (/* binding */ DataTypes),\n/* harmony export */   DatabaseError: () => (/* binding */ DatabaseError),\n/* harmony export */   Deferrable: () => (/* binding */ Deferrable),\n/* harmony export */   ENUM: () => (/* binding */ ENUM),\n/* harmony export */   EagerLoadingError: () => (/* binding */ EagerLoadingError),\n/* harmony export */   EmptyResultError: () => (/* binding */ EmptyResultError),\n/* harmony export */   Error: () => (/* binding */ Error),\n/* harmony export */   ExclusionConstraintError: () => (/* binding */ ExclusionConstraintError),\n/* harmony export */   FLOAT: () => (/* binding */ FLOAT),\n/* harmony export */   ForeignKeyConstraintError: () => (/* binding */ ForeignKeyConstraintError),\n/* harmony export */   GEOGRAPHY: () => (/* binding */ GEOGRAPHY),\n/* harmony export */   GEOMETRY: () => (/* binding */ GEOMETRY),\n/* harmony export */   HSTORE: () => (/* binding */ HSTORE),\n/* harmony export */   HasMany: () => (/* binding */ HasMany),\n/* harmony export */   HasOne: () => (/* binding */ HasOne),\n/* harmony export */   HostNotFoundError: () => (/* binding */ HostNotFoundError),\n/* harmony export */   HostNotReachableError: () => (/* binding */ HostNotReachableError),\n/* harmony export */   INET: () => (/* binding */ INET),\n/* harmony export */   INTEGER: () => (/* binding */ INTEGER),\n/* harmony export */   IndexHints: () => (/* binding */ IndexHints),\n/* harmony export */   InstanceError: () => (/* binding */ InstanceError),\n/* harmony export */   InvalidConnectionError: () => (/* binding */ InvalidConnectionError),\n/* harmony export */   JSON: () => (/* binding */ JSON),\n/* harmony export */   JSONB: () => (/* binding */ JSONB),\n/* harmony export */   MACADDR: () => (/* binding */ MACADDR),\n/* harmony export */   MEDIUMINT: () => (/* binding */ MEDIUMINT),\n/* harmony export */   Model: () => (/* binding */ Model),\n/* harmony export */   NOW: () => (/* binding */ NOW),\n/* harmony export */   NUMBER: () => (/* binding */ NUMBER),\n/* harmony export */   NUMERIC: () => (/* binding */ NUMERIC),\n/* harmony export */   Op: () => (/* binding */ Op),\n/* harmony export */   OptimisticLockError: () => (/* binding */ OptimisticLockError),\n/* harmony export */   QueryError: () => (/* binding */ QueryError),\n/* harmony export */   QueryInterface: () => (/* binding */ QueryInterface),\n/* harmony export */   QueryTypes: () => (/* binding */ QueryTypes),\n/* harmony export */   RANGE: () => (/* binding */ RANGE),\n/* harmony export */   REAL: () => (/* binding */ REAL),\n/* harmony export */   SMALLINT: () => (/* binding */ SMALLINT),\n/* harmony export */   STRING: () => (/* binding */ STRING),\n/* harmony export */   Sequelize: () => (/* binding */ Sequelize),\n/* harmony export */   SequelizeScopeError: () => (/* binding */ SequelizeScopeError),\n/* harmony export */   TEXT: () => (/* binding */ TEXT),\n/* harmony export */   TIME: () => (/* binding */ TIME),\n/* harmony export */   TINYINT: () => (/* binding */ TINYINT),\n/* harmony export */   TSVECTOR: () => (/* binding */ TSVECTOR),\n/* harmony export */   TableHints: () => (/* binding */ TableHints),\n/* harmony export */   TimeoutError: () => (/* binding */ TimeoutError),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   UUID: () => (/* binding */ UUID),\n/* harmony export */   UUIDV1: () => (/* binding */ UUIDV1),\n/* harmony export */   UUIDV4: () => (/* binding */ UUIDV4),\n/* harmony export */   UniqueConstraintError: () => (/* binding */ UniqueConstraintError),\n/* harmony export */   UnknownConstraintError: () => (/* binding */ UnknownConstraintError),\n/* harmony export */   Utils: () => (/* binding */ Utils),\n/* harmony export */   VIRTUAL: () => (/* binding */ VIRTUAL),\n/* harmony export */   ValidationError: () => (/* binding */ ValidationError),\n/* harmony export */   ValidationErrorItem: () => (/* binding */ ValidationErrorItem),\n/* harmony export */   ValidationErrorItemOrigin: () => (/* binding */ ValidationErrorItemOrigin),\n/* harmony export */   ValidationErrorItemType: () => (/* binding */ ValidationErrorItemType),\n/* harmony export */   Validator: () => (/* binding */ Validator),\n/* harmony export */   and: () => (/* binding */ and),\n/* harmony export */   cast: () => (/* binding */ cast),\n/* harmony export */   col: () => (/* binding */ col),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fn: () => (/* binding */ fn),\n/* harmony export */   json: () => (/* binding */ json),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   or: () => (/* binding */ or),\n/* harmony export */   useInflection: () => (/* binding */ useInflection),\n/* harmony export */   where: () => (/* binding */ where)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"(action-browser)/../node_modules/sequelize/lib/index.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_index_js__WEBPACK_IMPORTED_MODULE_0__);\n\n// export * from './lib/sequelize';\nconst Sequelize = _index_js__WEBPACK_IMPORTED_MODULE_0__.Sequelize;\nconst fn = _index_js__WEBPACK_IMPORTED_MODULE_0__.fn;\nconst col = _index_js__WEBPACK_IMPORTED_MODULE_0__.col;\nconst cast = _index_js__WEBPACK_IMPORTED_MODULE_0__.cast;\nconst literal = _index_js__WEBPACK_IMPORTED_MODULE_0__.literal;\nconst and = _index_js__WEBPACK_IMPORTED_MODULE_0__.and;\nconst or = _index_js__WEBPACK_IMPORTED_MODULE_0__.or;\nconst json = _index_js__WEBPACK_IMPORTED_MODULE_0__.json;\nconst where = _index_js__WEBPACK_IMPORTED_MODULE_0__.where;\n\n// export * from './lib/query-interface';\nconst QueryInterface = _index_js__WEBPACK_IMPORTED_MODULE_0__.QueryInterface;\n\n// export * from './lib/data-types';\n// 'DOUBLE PRECISION' is missing because its name is not a valid export identifier.\nconst ABSTRACT = _index_js__WEBPACK_IMPORTED_MODULE_0__.ABSTRACT;\nconst STRING = _index_js__WEBPACK_IMPORTED_MODULE_0__.STRING;\nconst CHAR = _index_js__WEBPACK_IMPORTED_MODULE_0__.CHAR;\nconst TEXT = _index_js__WEBPACK_IMPORTED_MODULE_0__.TEXT;\nconst NUMBER = _index_js__WEBPACK_IMPORTED_MODULE_0__.NUMBER;\nconst TINYINT = _index_js__WEBPACK_IMPORTED_MODULE_0__.TINYINT;\nconst SMALLINT = _index_js__WEBPACK_IMPORTED_MODULE_0__.SMALLINT;\nconst MEDIUMINT = _index_js__WEBPACK_IMPORTED_MODULE_0__.MEDIUMINT;\nconst INTEGER = _index_js__WEBPACK_IMPORTED_MODULE_0__.INTEGER;\nconst BIGINT = _index_js__WEBPACK_IMPORTED_MODULE_0__.BIGINT;\nconst FLOAT = _index_js__WEBPACK_IMPORTED_MODULE_0__.FLOAT;\nconst TIME = _index_js__WEBPACK_IMPORTED_MODULE_0__.TIME;\nconst DATE = _index_js__WEBPACK_IMPORTED_MODULE_0__.DATE;\nconst DATEONLY = _index_js__WEBPACK_IMPORTED_MODULE_0__.DATEONLY;\nconst BOOLEAN = _index_js__WEBPACK_IMPORTED_MODULE_0__.BOOLEAN;\nconst NOW = _index_js__WEBPACK_IMPORTED_MODULE_0__.NOW;\nconst BLOB = _index_js__WEBPACK_IMPORTED_MODULE_0__.BLOB;\nconst DECIMAL = _index_js__WEBPACK_IMPORTED_MODULE_0__.DECIMAL;\nconst NUMERIC = _index_js__WEBPACK_IMPORTED_MODULE_0__.NUMERIC;\nconst UUID = _index_js__WEBPACK_IMPORTED_MODULE_0__.UUID;\nconst UUIDV1 = _index_js__WEBPACK_IMPORTED_MODULE_0__.UUIDV1;\nconst UUIDV4 = _index_js__WEBPACK_IMPORTED_MODULE_0__.UUIDV4;\nconst HSTORE = _index_js__WEBPACK_IMPORTED_MODULE_0__.HSTORE;\nconst JSON = _index_js__WEBPACK_IMPORTED_MODULE_0__.JSON;\nconst JSONB = _index_js__WEBPACK_IMPORTED_MODULE_0__.JSONB;\nconst VIRTUAL = _index_js__WEBPACK_IMPORTED_MODULE_0__.VIRTUAL;\nconst ARRAY = _index_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY;\nconst ENUM = _index_js__WEBPACK_IMPORTED_MODULE_0__.ENUM;\nconst RANGE = _index_js__WEBPACK_IMPORTED_MODULE_0__.RANGE;\nconst REAL = _index_js__WEBPACK_IMPORTED_MODULE_0__.REAL;\nconst DOUBLE = _index_js__WEBPACK_IMPORTED_MODULE_0__.DOUBLE;\nconst GEOMETRY = _index_js__WEBPACK_IMPORTED_MODULE_0__.GEOMETRY;\nconst GEOGRAPHY = _index_js__WEBPACK_IMPORTED_MODULE_0__.GEOGRAPHY;\nconst CIDR = _index_js__WEBPACK_IMPORTED_MODULE_0__.CIDR;\nconst INET = _index_js__WEBPACK_IMPORTED_MODULE_0__.INET;\nconst MACADDR = _index_js__WEBPACK_IMPORTED_MODULE_0__.MACADDR;\nconst CITEXT = _index_js__WEBPACK_IMPORTED_MODULE_0__.CITEXT;\nconst TSVECTOR = _index_js__WEBPACK_IMPORTED_MODULE_0__.TSVECTOR;\n\n// export * from './lib/model';\nconst Model = _index_js__WEBPACK_IMPORTED_MODULE_0__.Model;\n\n// export * from './lib/transaction';\nconst Transaction = _index_js__WEBPACK_IMPORTED_MODULE_0__.Transaction;\n\n// export * from './lib/associations/index';\nconst Association = _index_js__WEBPACK_IMPORTED_MODULE_0__.Association;\nconst BelongsTo = _index_js__WEBPACK_IMPORTED_MODULE_0__.BelongsTo;\nconst HasOne = _index_js__WEBPACK_IMPORTED_MODULE_0__.HasOne;\nconst HasMany = _index_js__WEBPACK_IMPORTED_MODULE_0__.HasMany;\nconst BelongsToMany = _index_js__WEBPACK_IMPORTED_MODULE_0__.BelongsToMany;\n\n// export * from './lib/errors';\nconst BaseError = _index_js__WEBPACK_IMPORTED_MODULE_0__.BaseError;\n\nconst AggregateError = _index_js__WEBPACK_IMPORTED_MODULE_0__.AggregateError;\nconst AsyncQueueError = _index_js__WEBPACK_IMPORTED_MODULE_0__.AsyncQueueError;\nconst AssociationError = _index_js__WEBPACK_IMPORTED_MODULE_0__.AssociationError;\nconst BulkRecordError = _index_js__WEBPACK_IMPORTED_MODULE_0__.BulkRecordError;\nconst ConnectionError = _index_js__WEBPACK_IMPORTED_MODULE_0__.ConnectionError;\nconst DatabaseError = _index_js__WEBPACK_IMPORTED_MODULE_0__.DatabaseError;\nconst EagerLoadingError = _index_js__WEBPACK_IMPORTED_MODULE_0__.EagerLoadingError;\nconst EmptyResultError = _index_js__WEBPACK_IMPORTED_MODULE_0__.EmptyResultError;\nconst InstanceError = _index_js__WEBPACK_IMPORTED_MODULE_0__.InstanceError;\nconst OptimisticLockError = _index_js__WEBPACK_IMPORTED_MODULE_0__.OptimisticLockError;\nconst QueryError = _index_js__WEBPACK_IMPORTED_MODULE_0__.QueryError;\nconst SequelizeScopeError = _index_js__WEBPACK_IMPORTED_MODULE_0__.SequelizeScopeError;\nconst ValidationError = _index_js__WEBPACK_IMPORTED_MODULE_0__.ValidationError;\nconst ValidationErrorItem = _index_js__WEBPACK_IMPORTED_MODULE_0__.ValidationErrorItem;\n\nconst AccessDeniedError = _index_js__WEBPACK_IMPORTED_MODULE_0__.AccessDeniedError;\nconst ConnectionAcquireTimeoutError = _index_js__WEBPACK_IMPORTED_MODULE_0__.ConnectionAcquireTimeoutError;\nconst ConnectionRefusedError = _index_js__WEBPACK_IMPORTED_MODULE_0__.ConnectionRefusedError;\nconst ConnectionTimedOutError = _index_js__WEBPACK_IMPORTED_MODULE_0__.ConnectionTimedOutError;\nconst HostNotFoundError = _index_js__WEBPACK_IMPORTED_MODULE_0__.HostNotFoundError;\nconst HostNotReachableError = _index_js__WEBPACK_IMPORTED_MODULE_0__.HostNotReachableError;\nconst InvalidConnectionError = _index_js__WEBPACK_IMPORTED_MODULE_0__.InvalidConnectionError;\n\nconst ExclusionConstraintError = _index_js__WEBPACK_IMPORTED_MODULE_0__.ExclusionConstraintError;\nconst ForeignKeyConstraintError = _index_js__WEBPACK_IMPORTED_MODULE_0__.ForeignKeyConstraintError;\nconst TimeoutError = _index_js__WEBPACK_IMPORTED_MODULE_0__.TimeoutError;\nconst UnknownConstraintError = _index_js__WEBPACK_IMPORTED_MODULE_0__.UnknownConstraintError;\n\nconst UniqueConstraintError = _index_js__WEBPACK_IMPORTED_MODULE_0__.UniqueConstraintError;\n\n// export { BaseError as Error } from './lib/errors';\nconst Error = _index_js__WEBPACK_IMPORTED_MODULE_0__.Error;\n\n// export { useInflection } from './lib/utils';\nconst useInflection = _index_js__WEBPACK_IMPORTED_MODULE_0__.useInflection;\n\n// export { Utils, QueryTypes, Op, TableHints, IndexHints, DataTypes, Deferrable };\nconst Utils = _index_js__WEBPACK_IMPORTED_MODULE_0__.Utils;\nconst QueryTypes = _index_js__WEBPACK_IMPORTED_MODULE_0__.QueryTypes;\nconst Op = _index_js__WEBPACK_IMPORTED_MODULE_0__.Op;\nconst TableHints = _index_js__WEBPACK_IMPORTED_MODULE_0__.TableHints;\nconst IndexHints = _index_js__WEBPACK_IMPORTED_MODULE_0__.IndexHints;\nconst DataTypes = _index_js__WEBPACK_IMPORTED_MODULE_0__.DataTypes;\nconst Deferrable = _index_js__WEBPACK_IMPORTED_MODULE_0__.Deferrable;\n\n// export { Validator as validator } from './lib/utils/validator-extras';\nconst Validator = _index_js__WEBPACK_IMPORTED_MODULE_0__.Validator;\n\nconst ValidationErrorItemOrigin = _index_js__WEBPACK_IMPORTED_MODULE_0__.ValidationErrorItemOrigin;\nconst ValidationErrorItemType = _index_js__WEBPACK_IMPORTED_MODULE_0__.ValidationErrorItemType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZCOztBQUU3QixpRUFBZSxzQ0FBRyxFQUFDOztBQUVuQjtBQUNPLGtCQUFrQixnREFBYTtBQUMvQixXQUFXLHlDQUFNO0FBQ2pCLFlBQVksMENBQU87QUFDbkIsYUFBYSwyQ0FBUTtBQUNyQixnQkFBZ0IsOENBQVc7QUFDM0IsWUFBWSwwQ0FBTztBQUNuQixXQUFXLHlDQUFNO0FBQ2pCLGFBQWEsMkNBQVE7QUFDckIsY0FBYyw0Q0FBUzs7QUFFOUI7QUFDTyx1QkFBdUIscURBQWtCOztBQUVoRDtBQUNBO0FBQ08saUJBQWlCLCtDQUFZO0FBQzdCLGVBQWUsNkNBQVU7QUFDekIsYUFBYSwyQ0FBUTtBQUNyQixhQUFhLDJDQUFRO0FBQ3JCLGVBQWUsNkNBQVU7QUFDekIsZ0JBQWdCLDhDQUFXO0FBQzNCLGlCQUFpQiwrQ0FBWTtBQUM3QixrQkFBa0IsZ0RBQWE7QUFDL0IsZ0JBQWdCLDhDQUFXO0FBQzNCLGVBQWUsNkNBQVU7QUFDekIsY0FBYyw0Q0FBUztBQUN2QixhQUFhLDJDQUFRO0FBQ3JCLGFBQWEsMkNBQVE7QUFDckIsaUJBQWlCLCtDQUFZO0FBQzdCLGdCQUFnQiw4Q0FBVztBQUMzQixZQUFZLDBDQUFPO0FBQ25CLGFBQWEsMkNBQVE7QUFDckIsZ0JBQWdCLDhDQUFXO0FBQzNCLGdCQUFnQiw4Q0FBVztBQUMzQixhQUFhLDJDQUFRO0FBQ3JCLGVBQWUsNkNBQVU7QUFDekIsZUFBZSw2Q0FBVTtBQUN6QixlQUFlLDZDQUFVO0FBQ3pCLGFBQWEsMkNBQVE7QUFDckIsY0FBYyw0Q0FBUztBQUN2QixnQkFBZ0IsOENBQVc7QUFDM0IsY0FBYyw0Q0FBUztBQUN2QixhQUFhLDJDQUFRO0FBQ3JCLGNBQWMsNENBQVM7QUFDdkIsYUFBYSwyQ0FBUTtBQUNyQixlQUFlLDZDQUFVO0FBQ3pCLGlCQUFpQiwrQ0FBWTtBQUM3QixrQkFBa0IsZ0RBQWE7QUFDL0IsYUFBYSwyQ0FBUTtBQUNyQixhQUFhLDJDQUFRO0FBQ3JCLGdCQUFnQiw4Q0FBVztBQUMzQixlQUFlLDZDQUFVO0FBQ3pCLGlCQUFpQiwrQ0FBWTs7QUFFcEM7QUFDTyxjQUFjLDRDQUFTOztBQUU5QjtBQUNPLG9CQUFvQixrREFBZTs7QUFFMUM7QUFDTyxvQkFBb0Isa0RBQWU7QUFDbkMsa0JBQWtCLGdEQUFhO0FBQy9CLGVBQWUsNkNBQVU7QUFDekIsZ0JBQWdCLDhDQUFXO0FBQzNCLHNCQUFzQixvREFBaUI7O0FBRTlDO0FBQ08sa0JBQWtCLGdEQUFhOztBQUUvQix1QkFBdUIscURBQWtCO0FBQ3pDLHdCQUF3QixzREFBbUI7QUFDM0MseUJBQXlCLHVEQUFvQjtBQUM3Qyx3QkFBd0Isc0RBQW1CO0FBQzNDLHdCQUF3QixzREFBbUI7QUFDM0Msc0JBQXNCLG9EQUFpQjtBQUN2QywwQkFBMEIsd0RBQXFCO0FBQy9DLHlCQUF5Qix1REFBb0I7QUFDN0Msc0JBQXNCLG9EQUFpQjtBQUN2Qyw0QkFBNEIsMERBQXVCO0FBQ25ELG1CQUFtQixpREFBYztBQUNqQyw0QkFBNEIsMERBQXVCO0FBQ25ELHdCQUF3QixzREFBbUI7QUFDM0MsNEJBQTRCLDBEQUF1Qjs7QUFFbkQsMEJBQTBCLHdEQUFxQjtBQUMvQyxzQ0FBc0Msb0VBQWlDO0FBQ3ZFLCtCQUErQiw2REFBMEI7QUFDekQsZ0NBQWdDLDhEQUEyQjtBQUMzRCwwQkFBMEIsd0RBQXFCO0FBQy9DLDhCQUE4Qiw0REFBeUI7QUFDdkQsK0JBQStCLDZEQUEwQjs7QUFFekQsaUNBQWlDLCtEQUE0QjtBQUM3RCxrQ0FBa0MsZ0VBQTZCO0FBQy9ELHFCQUFxQixtREFBZ0I7QUFDckMsK0JBQStCLDZEQUEwQjs7QUFFekQsOEJBQThCLDREQUF5Qjs7QUFFOUQsWUFBWSxxQkFBcUI7QUFDMUIsY0FBYyw0Q0FBUzs7QUFFOUIsWUFBWSxnQkFBZ0I7QUFDckIsc0JBQXNCLG9EQUFpQjs7QUFFOUMsWUFBWTtBQUNMLGNBQWMsNENBQVM7QUFDdkIsbUJBQW1CLGlEQUFjO0FBQ2pDLFdBQVcseUNBQU07QUFDakIsbUJBQW1CLGlEQUFjO0FBQ2pDLG1CQUFtQixpREFBYztBQUNqQyxrQkFBa0IsZ0RBQWE7QUFDL0IsbUJBQW1CLGlEQUFjOztBQUV4QyxZQUFZLHlCQUF5QjtBQUM5QixrQkFBa0IsZ0RBQWE7O0FBRS9CLGtDQUFrQyxnRUFBNkI7QUFDL0QsZ0NBQWdDLDhEQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9pbmRleC5tanM/NmU1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUGtnIGZyb20gJy4vaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBQa2c7XG5cbi8vIGV4cG9ydCAqIGZyb20gJy4vbGliL3NlcXVlbGl6ZSc7XG5leHBvcnQgY29uc3QgU2VxdWVsaXplID0gUGtnLlNlcXVlbGl6ZTtcbmV4cG9ydCBjb25zdCBmbiA9IFBrZy5mbjtcbmV4cG9ydCBjb25zdCBjb2wgPSBQa2cuY29sO1xuZXhwb3J0IGNvbnN0IGNhc3QgPSBQa2cuY2FzdDtcbmV4cG9ydCBjb25zdCBsaXRlcmFsID0gUGtnLmxpdGVyYWw7XG5leHBvcnQgY29uc3QgYW5kID0gUGtnLmFuZDtcbmV4cG9ydCBjb25zdCBvciA9IFBrZy5vcjtcbmV4cG9ydCBjb25zdCBqc29uID0gUGtnLmpzb247XG5leHBvcnQgY29uc3Qgd2hlcmUgPSBQa2cud2hlcmU7XG5cbi8vIGV4cG9ydCAqIGZyb20gJy4vbGliL3F1ZXJ5LWludGVyZmFjZSc7XG5leHBvcnQgY29uc3QgUXVlcnlJbnRlcmZhY2UgPSBQa2cuUXVlcnlJbnRlcmZhY2U7XG5cbi8vIGV4cG9ydCAqIGZyb20gJy4vbGliL2RhdGEtdHlwZXMnO1xuLy8gJ0RPVUJMRSBQUkVDSVNJT04nIGlzIG1pc3NpbmcgYmVjYXVzZSBpdHMgbmFtZSBpcyBub3QgYSB2YWxpZCBleHBvcnQgaWRlbnRpZmllci5cbmV4cG9ydCBjb25zdCBBQlNUUkFDVCA9IFBrZy5BQlNUUkFDVDtcbmV4cG9ydCBjb25zdCBTVFJJTkcgPSBQa2cuU1RSSU5HO1xuZXhwb3J0IGNvbnN0IENIQVIgPSBQa2cuQ0hBUjtcbmV4cG9ydCBjb25zdCBURVhUID0gUGtnLlRFWFQ7XG5leHBvcnQgY29uc3QgTlVNQkVSID0gUGtnLk5VTUJFUjtcbmV4cG9ydCBjb25zdCBUSU5ZSU5UID0gUGtnLlRJTllJTlQ7XG5leHBvcnQgY29uc3QgU01BTExJTlQgPSBQa2cuU01BTExJTlQ7XG5leHBvcnQgY29uc3QgTUVESVVNSU5UID0gUGtnLk1FRElVTUlOVDtcbmV4cG9ydCBjb25zdCBJTlRFR0VSID0gUGtnLklOVEVHRVI7XG5leHBvcnQgY29uc3QgQklHSU5UID0gUGtnLkJJR0lOVDtcbmV4cG9ydCBjb25zdCBGTE9BVCA9IFBrZy5GTE9BVDtcbmV4cG9ydCBjb25zdCBUSU1FID0gUGtnLlRJTUU7XG5leHBvcnQgY29uc3QgREFURSA9IFBrZy5EQVRFO1xuZXhwb3J0IGNvbnN0IERBVEVPTkxZID0gUGtnLkRBVEVPTkxZO1xuZXhwb3J0IGNvbnN0IEJPT0xFQU4gPSBQa2cuQk9PTEVBTjtcbmV4cG9ydCBjb25zdCBOT1cgPSBQa2cuTk9XO1xuZXhwb3J0IGNvbnN0IEJMT0IgPSBQa2cuQkxPQjtcbmV4cG9ydCBjb25zdCBERUNJTUFMID0gUGtnLkRFQ0lNQUw7XG5leHBvcnQgY29uc3QgTlVNRVJJQyA9IFBrZy5OVU1FUklDO1xuZXhwb3J0IGNvbnN0IFVVSUQgPSBQa2cuVVVJRDtcbmV4cG9ydCBjb25zdCBVVUlEVjEgPSBQa2cuVVVJRFYxO1xuZXhwb3J0IGNvbnN0IFVVSURWNCA9IFBrZy5VVUlEVjQ7XG5leHBvcnQgY29uc3QgSFNUT1JFID0gUGtnLkhTVE9SRTtcbmV4cG9ydCBjb25zdCBKU09OID0gUGtnLkpTT047XG5leHBvcnQgY29uc3QgSlNPTkIgPSBQa2cuSlNPTkI7XG5leHBvcnQgY29uc3QgVklSVFVBTCA9IFBrZy5WSVJUVUFMO1xuZXhwb3J0IGNvbnN0IEFSUkFZID0gUGtnLkFSUkFZO1xuZXhwb3J0IGNvbnN0IEVOVU0gPSBQa2cuRU5VTTtcbmV4cG9ydCBjb25zdCBSQU5HRSA9IFBrZy5SQU5HRTtcbmV4cG9ydCBjb25zdCBSRUFMID0gUGtnLlJFQUw7XG5leHBvcnQgY29uc3QgRE9VQkxFID0gUGtnLkRPVUJMRTtcbmV4cG9ydCBjb25zdCBHRU9NRVRSWSA9IFBrZy5HRU9NRVRSWTtcbmV4cG9ydCBjb25zdCBHRU9HUkFQSFkgPSBQa2cuR0VPR1JBUEhZO1xuZXhwb3J0IGNvbnN0IENJRFIgPSBQa2cuQ0lEUjtcbmV4cG9ydCBjb25zdCBJTkVUID0gUGtnLklORVQ7XG5leHBvcnQgY29uc3QgTUFDQUREUiA9IFBrZy5NQUNBRERSO1xuZXhwb3J0IGNvbnN0IENJVEVYVCA9IFBrZy5DSVRFWFQ7XG5leHBvcnQgY29uc3QgVFNWRUNUT1IgPSBQa2cuVFNWRUNUT1I7XG5cbi8vIGV4cG9ydCAqIGZyb20gJy4vbGliL21vZGVsJztcbmV4cG9ydCBjb25zdCBNb2RlbCA9IFBrZy5Nb2RlbDtcblxuLy8gZXhwb3J0ICogZnJvbSAnLi9saWIvdHJhbnNhY3Rpb24nO1xuZXhwb3J0IGNvbnN0IFRyYW5zYWN0aW9uID0gUGtnLlRyYW5zYWN0aW9uO1xuXG4vLyBleHBvcnQgKiBmcm9tICcuL2xpYi9hc3NvY2lhdGlvbnMvaW5kZXgnO1xuZXhwb3J0IGNvbnN0IEFzc29jaWF0aW9uID0gUGtnLkFzc29jaWF0aW9uO1xuZXhwb3J0IGNvbnN0IEJlbG9uZ3NUbyA9IFBrZy5CZWxvbmdzVG87XG5leHBvcnQgY29uc3QgSGFzT25lID0gUGtnLkhhc09uZTtcbmV4cG9ydCBjb25zdCBIYXNNYW55ID0gUGtnLkhhc01hbnk7XG5leHBvcnQgY29uc3QgQmVsb25nc1RvTWFueSA9IFBrZy5CZWxvbmdzVG9NYW55O1xuXG4vLyBleHBvcnQgKiBmcm9tICcuL2xpYi9lcnJvcnMnO1xuZXhwb3J0IGNvbnN0IEJhc2VFcnJvciA9IFBrZy5CYXNlRXJyb3I7XG5cbmV4cG9ydCBjb25zdCBBZ2dyZWdhdGVFcnJvciA9IFBrZy5BZ2dyZWdhdGVFcnJvcjtcbmV4cG9ydCBjb25zdCBBc3luY1F1ZXVlRXJyb3IgPSBQa2cuQXN5bmNRdWV1ZUVycm9yO1xuZXhwb3J0IGNvbnN0IEFzc29jaWF0aW9uRXJyb3IgPSBQa2cuQXNzb2NpYXRpb25FcnJvcjtcbmV4cG9ydCBjb25zdCBCdWxrUmVjb3JkRXJyb3IgPSBQa2cuQnVsa1JlY29yZEVycm9yO1xuZXhwb3J0IGNvbnN0IENvbm5lY3Rpb25FcnJvciA9IFBrZy5Db25uZWN0aW9uRXJyb3I7XG5leHBvcnQgY29uc3QgRGF0YWJhc2VFcnJvciA9IFBrZy5EYXRhYmFzZUVycm9yO1xuZXhwb3J0IGNvbnN0IEVhZ2VyTG9hZGluZ0Vycm9yID0gUGtnLkVhZ2VyTG9hZGluZ0Vycm9yO1xuZXhwb3J0IGNvbnN0IEVtcHR5UmVzdWx0RXJyb3IgPSBQa2cuRW1wdHlSZXN1bHRFcnJvcjtcbmV4cG9ydCBjb25zdCBJbnN0YW5jZUVycm9yID0gUGtnLkluc3RhbmNlRXJyb3I7XG5leHBvcnQgY29uc3QgT3B0aW1pc3RpY0xvY2tFcnJvciA9IFBrZy5PcHRpbWlzdGljTG9ja0Vycm9yO1xuZXhwb3J0IGNvbnN0IFF1ZXJ5RXJyb3IgPSBQa2cuUXVlcnlFcnJvcjtcbmV4cG9ydCBjb25zdCBTZXF1ZWxpemVTY29wZUVycm9yID0gUGtnLlNlcXVlbGl6ZVNjb3BlRXJyb3I7XG5leHBvcnQgY29uc3QgVmFsaWRhdGlvbkVycm9yID0gUGtnLlZhbGlkYXRpb25FcnJvcjtcbmV4cG9ydCBjb25zdCBWYWxpZGF0aW9uRXJyb3JJdGVtID0gUGtnLlZhbGlkYXRpb25FcnJvckl0ZW07XG5cbmV4cG9ydCBjb25zdCBBY2Nlc3NEZW5pZWRFcnJvciA9IFBrZy5BY2Nlc3NEZW5pZWRFcnJvcjtcbmV4cG9ydCBjb25zdCBDb25uZWN0aW9uQWNxdWlyZVRpbWVvdXRFcnJvciA9IFBrZy5Db25uZWN0aW9uQWNxdWlyZVRpbWVvdXRFcnJvcjtcbmV4cG9ydCBjb25zdCBDb25uZWN0aW9uUmVmdXNlZEVycm9yID0gUGtnLkNvbm5lY3Rpb25SZWZ1c2VkRXJyb3I7XG5leHBvcnQgY29uc3QgQ29ubmVjdGlvblRpbWVkT3V0RXJyb3IgPSBQa2cuQ29ubmVjdGlvblRpbWVkT3V0RXJyb3I7XG5leHBvcnQgY29uc3QgSG9zdE5vdEZvdW5kRXJyb3IgPSBQa2cuSG9zdE5vdEZvdW5kRXJyb3I7XG5leHBvcnQgY29uc3QgSG9zdE5vdFJlYWNoYWJsZUVycm9yID0gUGtnLkhvc3ROb3RSZWFjaGFibGVFcnJvcjtcbmV4cG9ydCBjb25zdCBJbnZhbGlkQ29ubmVjdGlvbkVycm9yID0gUGtnLkludmFsaWRDb25uZWN0aW9uRXJyb3I7XG5cbmV4cG9ydCBjb25zdCBFeGNsdXNpb25Db25zdHJhaW50RXJyb3IgPSBQa2cuRXhjbHVzaW9uQ29uc3RyYWludEVycm9yO1xuZXhwb3J0IGNvbnN0IEZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3IgPSBQa2cuRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvcjtcbmV4cG9ydCBjb25zdCBUaW1lb3V0RXJyb3IgPSBQa2cuVGltZW91dEVycm9yO1xuZXhwb3J0IGNvbnN0IFVua25vd25Db25zdHJhaW50RXJyb3IgPSBQa2cuVW5rbm93bkNvbnN0cmFpbnRFcnJvcjtcblxuZXhwb3J0IGNvbnN0IFVuaXF1ZUNvbnN0cmFpbnRFcnJvciA9IFBrZy5VbmlxdWVDb25zdHJhaW50RXJyb3I7XG5cbi8vIGV4cG9ydCB7IEJhc2VFcnJvciBhcyBFcnJvciB9IGZyb20gJy4vbGliL2Vycm9ycyc7XG5leHBvcnQgY29uc3QgRXJyb3IgPSBQa2cuRXJyb3I7XG5cbi8vIGV4cG9ydCB7IHVzZUluZmxlY3Rpb24gfSBmcm9tICcuL2xpYi91dGlscyc7XG5leHBvcnQgY29uc3QgdXNlSW5mbGVjdGlvbiA9IFBrZy51c2VJbmZsZWN0aW9uO1xuXG4vLyBleHBvcnQgeyBVdGlscywgUXVlcnlUeXBlcywgT3AsIFRhYmxlSGludHMsIEluZGV4SGludHMsIERhdGFUeXBlcywgRGVmZXJyYWJsZSB9O1xuZXhwb3J0IGNvbnN0IFV0aWxzID0gUGtnLlV0aWxzO1xuZXhwb3J0IGNvbnN0IFF1ZXJ5VHlwZXMgPSBQa2cuUXVlcnlUeXBlcztcbmV4cG9ydCBjb25zdCBPcCA9IFBrZy5PcDtcbmV4cG9ydCBjb25zdCBUYWJsZUhpbnRzID0gUGtnLlRhYmxlSGludHM7XG5leHBvcnQgY29uc3QgSW5kZXhIaW50cyA9IFBrZy5JbmRleEhpbnRzO1xuZXhwb3J0IGNvbnN0IERhdGFUeXBlcyA9IFBrZy5EYXRhVHlwZXM7XG5leHBvcnQgY29uc3QgRGVmZXJyYWJsZSA9IFBrZy5EZWZlcnJhYmxlO1xuXG4vLyBleHBvcnQgeyBWYWxpZGF0b3IgYXMgdmFsaWRhdG9yIH0gZnJvbSAnLi9saWIvdXRpbHMvdmFsaWRhdG9yLWV4dHJhcyc7XG5leHBvcnQgY29uc3QgVmFsaWRhdG9yID0gUGtnLlZhbGlkYXRvcjtcblxuZXhwb3J0IGNvbnN0IFZhbGlkYXRpb25FcnJvckl0ZW1PcmlnaW4gPSBQa2cuVmFsaWRhdGlvbkVycm9ySXRlbU9yaWdpbjtcbmV4cG9ydCBjb25zdCBWYWxpZGF0aW9uRXJyb3JJdGVtVHlwZSA9IFBrZy5WYWxpZGF0aW9uRXJyb3JJdGVtVHlwZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../node_modules/sequelize/lib/index.mjs\n");

/***/ }),

/***/ "(action-browser)/../node_modules/sequelize/package.json":
/*!**********************************************!*\
  !*** ../node_modules/sequelize/package.json ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"sequelize","description":"Sequelize is a promise-based Node.js ORM tool for Postgres, MySQL, MariaDB, SQLite, Microsoft SQL Server, Amazon Redshift and Snowflakes Data Cloud. It features solid transaction support, relations, eager and lazy loading, read replication and more.","version":"6.37.5","funding":[{"type":"opencollective","url":"https://opencollective.com/sequelize"}],"repository":{"type":"git","url":"https://github.com/sequelize/sequelize.git"},"bugs":{"url":"https://github.com/sequelize/sequelize/issues"},"homepage":"https://sequelize.org/","main":"./lib/index.js","types":"./types/index.d.ts","type":"commonjs","exports":{".":{"types":"./types/index.d.ts","import":"./lib/index.mjs","require":"./lib/index.js"},"./lib/*":{"types":"./types/*.d.ts","default":"./lib/*.js"},"./lib/errors":{"types":"./types/errors/index.d.ts","default":"./lib/errors/index.js"},"./package.json":"./package.json","./types/*":{"types":"./types/*.d.ts"}},"engines":{"node":">=10.0.0"},"files":["lib","types","index.js"],"license":"MIT","dependencies":{"@types/debug":"^4.1.8","@types/validator":"^13.7.17","debug":"^4.3.4","dottie":"^2.0.6","inflection":"^1.13.4","lodash":"^4.17.21","moment":"^2.29.4","moment-timezone":"^0.5.43","pg-connection-string":"^2.6.1","retry-as-promised":"^7.0.4","semver":"^7.5.4","sequelize-pool":"^7.1.0","toposort-class":"^1.0.1","uuid":"^8.3.2","validator":"^13.9.0","wkx":"^0.5.0"},"devDependencies":{"@commitlint/cli":"^15.0.0","@commitlint/config-angular":"^15.0.0","@octokit/rest":"^18.12.0","@octokit/types":"^6.34.0","@types/chai":"^4.3.0","@types/lodash":"4.14.197","@types/mocha":"^9.0.0","@types/node":"^16.11.17","@types/sinon":"^10.0.6","@typescript-eslint/eslint-plugin":"^5.8.1","@typescript-eslint/parser":"^5.8.1","acorn":"^8.7.0","chai":"^4.3.7","chai-as-promised":"^7.1.1","chai-datetime":"^1.8.0","cheerio":"^1.0.0-rc.10","cls-hooked":"^4.2.2","copyfiles":"^2.4.1","cross-env":"^7.0.3","delay":"^5.0.0","esbuild":"0.14.3","esdoc":"^1.1.0","esdoc-ecmascript-proposal-plugin":"^1.0.0","esdoc-inject-style-plugin":"^1.0.0","esdoc-standard-plugin":"^1.0.0","eslint":"^8.5.0","eslint-plugin-jsdoc":"^37.4.0","eslint-plugin-mocha":"^9.0.0","expect-type":"^0.12.0","fast-glob":"^3.2.7","fs-jetpack":"^4.3.0","husky":"^7.0.4","ibm_db":"^2.8.1","js-combinatorics":"^0.6.1","lcov-result-merger":"^3.1.0","lint-staged":"^12.1.4","mariadb":"^2.5.5","markdownlint-cli":"^0.30.0","mocha":"^7.2.0","module-alias":"^2.2.2","mysql2":"^2.3.3","node-hook":"^1.0.0","nyc":"^15.1.0","oracledb":"^5.5.0","p-map":"^4.0.0","p-props":"^4.0.0","p-settle":"^4.1.1","p-timeout":"^4.0.0","pg":"^8.7.1","pg-hstore":"^2.3.4","rimraf":"^3.0.2","semantic-release":"^18.0.1","semantic-release-fail-on-major-bump":"^1.0.0","sinon":"^12.0.1","sinon-chai":"^3.7.0","snowflake-sdk":"^1.6.6","source-map-support":"^0.5.21","sqlite3":"^5.1.6","tedious":"8.3.0","typescript":"^4.5.4"},"peerDependenciesMeta":{"pg":{"optional":true},"pg-hstore":{"optional":true},"mysql2":{"optional":true},"ibm_db":{"optional":true},"snowflake-sdk":{"optional":true},"mariadb":{"optional":true},"sqlite3":{"optional":true},"tedious":{"optional":true},"oracledb":{"optional":true}},"keywords":["mysql","mariadb","sqlite","postgresql","postgres","pg","mssql","db2","ibm_db","sql","oracledb","sqlserver","snowflake","orm","nodejs","object relational mapper","database","db"],"commitlint":{"extends":["@commitlint/config-angular"],"rules":{"type-enum":[2,"always",["build","ci","docs","feat","fix","perf","refactor","revert","style","test","meta"]]}},"lint-staged":{"*!(d).[tj]s":"eslint"},"release":{"plugins":["@semantic-release/commit-analyzer","semantic-release-fail-on-major-bump","@semantic-release/release-notes-generator","@semantic-release/npm","@semantic-release/github"],"branches":["v6",{"name":"v6-beta","prerelease":"beta"}]},"publishConfig":{"tag":"latest"},"scripts":{"----------------------------------------- static analysis -----------------------------------------":"","lint":"eslint src test --quiet --fix","lint-docs":"markdownlint docs","test-typings":"tsc --noEmit --emitDeclarationOnly false && tsc -b test/tsconfig.json","----------------------------------------- documentation -------------------------------------------":"","docs":"sh docs.sh","----------------------------------------- tests ---------------------------------------------------":"","mocha":"mocha -r ./test/registerEsbuild","test-unit":"yarn mocha \\"test/unit/**/*.test.[tj]s\\"","test-integration":"yarn mocha \\"test/integration/**/*.test.[tj]s\\"","teaser":"node test/teaser.js","test":"npm run prepare && npm run test-typings && npm run teaser && npm run test-unit && npm run test-integration","----------------------------------------- coverage ------------------------------------------------":"","cover":"rimraf coverage && npm run teaser && npm run cover-integration && npm run cover-unit && npm run merge-coverage","cover-integration":"cross-env COVERAGE=true nyc --reporter=lcovonly yarn mocha \\"test/integration/**/*.test.[tj]s\\" && node -e \\"require(\'fs\').renameSync(\'coverage/lcov.info\', \'coverage/integration.info\')\\"","cover-unit":"cross-env COVERAGE=true nyc --reporter=lcovonly yarn mocha \\"test/unit/**/*.test.[tj]s\\" && node -e \\"require(\'fs\').renameSync(\'coverage/lcov.info\', \'coverage/unit.info\')\\"","merge-coverage":"lcov-result-merger \\"coverage/*.info\\" \\"coverage/lcov.info\\"","----------------------------------------- local test dbs ------------------------------------------":"","start-mariadb":"bash dev/mariadb/10.3/start.sh","start-mysql":"bash dev/mysql/5.7/start.sh","start-mysql-8":"bash dev/mysql/8.0/start.sh","start-postgres":"bash dev/postgres/10/start.sh","start-mssql":"bash dev/mssql/2019/start.sh","start-db2":"bash dev/db2/11.5/start.sh","start-oracle-oldest":"bash dev/oracle/18-slim/start.sh","start-oracle-latest":"bash dev/oracle/23-slim/start.sh","stop-mariadb":"bash dev/mariadb/10.3/stop.sh","stop-mysql":"bash dev/mysql/5.7/stop.sh","stop-mysql-8":"bash dev/mysql/8.0/stop.sh","stop-postgres":"bash dev/postgres/10/stop.sh","stop-mssql":"bash dev/mssql/2019/stop.sh","stop-db2":"bash dev/db2/11.5/stop.sh","stop-oracle-oldest":"bash dev/oracle/18-slim/stop.sh","stop-oracle-latest":"bash dev/oracle/23-slim/stop.sh","restart-mariadb":"npm run start-mariadb","restart-mysql":"npm run start-mysql","restart-postgres":"npm run start-postgres","restart-mssql":"npm run start-mssql","restart-db2":"npm run start-db2","restart-oracle-oldest":"npm run start-oracle-oldest","restart-oracle-latest":"npm run start-oracle-latest","----------------------------------------- local tests ---------------------------------------------":"","test-unit-mariadb":"cross-env DIALECT=mariadb npm run test-unit","test-unit-mysql":"cross-env DIALECT=mysql npm run test-unit","test-unit-postgres":"cross-env DIALECT=postgres npm run test-unit","test-unit-postgres-native":"cross-env DIALECT=postgres-native npm run test-unit","test-unit-sqlite":"cross-env DIALECT=sqlite npm run test-unit","test-unit-mssql":"cross-env DIALECT=mssql npm run test-unit","test-unit-db2":"cross-env DIALECT=db2 npm run test-unit","test-unit-snowflake":"cross-env DIALECT=snowflake npm run test-unit","test-unit-oracle":"cross-env DIALECT=oracle npm run test-unit","test-unit-all":"npm run test-unit-mariadb && npm run test-unit-mysql && npm run test-unit-postgres && npm run test-unit-postgres-native && npm run test-unit-mssql && npm run test-unit-sqlite && npm run test-unit-snowflake && npm run test-unit-db2 && npm run test-unit-oracle","test-integration-mariadb":"cross-env DIALECT=mariadb npm run test-integration","test-integration-mysql":"cross-env DIALECT=mysql npm run test-integration","test-integration-postgres":"cross-env DIALECT=postgres npm run test-integration","test-integration-postgres-native":"cross-env DIALECT=postgres-native npm run test-integration","test-integration-sqlite":"cross-env DIALECT=sqlite npm run test-integration","test-integration-mssql":"cross-env DIALECT=mssql npm run test-integration","test-integration-db2":"cross-env DIALECT=db2 npm run test-integration","test-integration-snowflake":"cross-env DIALECT=snowflake npm run test-integration","test-integration-oracle":"cross-env LD_LIBRARY_PATH=\\"$PWD/.oracle/instantclient/\\" DIALECT=oracle UV_THREADPOOL_SIZE=128 npm run test-integration","test-mariadb":"cross-env DIALECT=mariadb npm test","test-mysql":"cross-env DIALECT=mysql npm test","test-sqlite":"cross-env DIALECT=sqlite npm test","test-postgres":"cross-env DIALECT=postgres npm test","test-postgres-native":"cross-env DIALECT=postgres-native npm test","test-mssql":"cross-env DIALECT=mssql npm test","test-db2":"cross-env DIALECT=db2 npm test","test-oracle":"cross-env LD_LIBRARY_PATH=\\"$PWD/.oracle/instantclient/\\" DIALECT=oracle UV_THREADPOOL_SIZE=128 npm test","----------------------------------------- development ---------------------------------------------":"","sscce":"node sscce.js","sscce-mariadb":"cross-env DIALECT=mariadb node sscce.js","sscce-mysql":"cross-env DIALECT=mysql node sscce.js","sscce-postgres":"cross-env DIALECT=postgres node sscce.js","sscce-postgres-native":"cross-env DIALECT=postgres-native node sscce.js","sscce-sqlite":"cross-env DIALECT=sqlite node sscce.js","sscce-mssql":"cross-env DIALECT=mssql node sscce.js","sscce-db2":"cross-env DIALECT=db2 node sscce.js","sscce-oracle":"cross-env LD_LIBRARY_PATH=\\"$PWD/.oracle/instantclient/\\" DIALECT=oracle UV_THREADPOOL_SIZE=128 node sscce.js","prepare":"npm run build && husky install","build":"node ./build.js","---------------------------------------------------------------------------------------------------":""},"support":true}');

/***/ })

};
;